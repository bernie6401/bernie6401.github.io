<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>SBK Site</title><link>https://bernie6401.github.io/docs/data-structure/</link><description>Recent content on SBK Site</description><generator>Hugo</generator><language>en-us</language><atom:link href="https://bernie6401.github.io/docs/data-structure/index.xml" rel="self" type="application/rss+xml"/><item><title>Data Structure</title><link>https://bernie6401.github.io/docs/data-structure/data-structure/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/docs/data-structure/data-structure/</guid><description>&lt;h1 id="data-structure">
 Data Structure
 &lt;a class="anchor" href="#data-structure">#&lt;/a>
&lt;/h1>
&lt;h6 id="tags-data-structure-nycu">
 tags: &lt;code>Data Structure&lt;/code> &lt;code>NYCU&lt;/code>
 &lt;a class="anchor" href="#tags-data-structure-nycu">#&lt;/a>
&lt;/h6>
&lt;ul>
&lt;li>&lt;a href="https://bernie6401.github.io/@S7deXzLKQkGUhZX374ALMg/HyyY4lwk2">Lecture 1&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://bernie6401.github.io/@UHzVfhAITliOM3mFSo6mfA/rkpbVewk2">Lecture 2&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://bernie6401.github.io/@S7deXzLKQkGUhZX374ALMg/rymPPeCmh">Lecture 3&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://hackmd.io/@SBK6401/HkkqlHIm2">Lecture 4&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://bernie6401.github.io/@S7deXzLKQkGUhZX374ALMg/HkiadlBN3">Lecture 5&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://hackmd.io/@SBK6401/rJloxgM4h">Lecture 6&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://bernie6401.github.io/@S7deXzLKQkGUhZX374ALMg/Hkl511BBn">Lecture 7&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://hackmd.io/@SBK6401/SJpGh4mSh">Lecture 8&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://hackmd.io/@SBK6401/rkNBMLk83">Lecture 10&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>Lecture 10</title><link>https://bernie6401.github.io/docs/data-structure/lecture-10/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/docs/data-structure/lecture-10/</guid><description>&lt;h1 id="lecture-10">
 Lecture 10
 &lt;a class="anchor" href="#lecture-10">#&lt;/a>
&lt;/h1>
&lt;h6 id="tags-data-structure-nycu">
 tags: &lt;code>Data Structure&lt;/code> &lt;code>NYCU&lt;/code>
 &lt;a class="anchor" href="#tags-data-structure-nycu">#&lt;/a>
&lt;/h6>
&lt;h2 id="reference">
 Reference
 &lt;a class="anchor" href="#reference">#&lt;/a>
&lt;/h2>
&lt;p>&lt;a href="https://youtu.be/zLuuRC56uvI">Lec10 資料結構 第六週課程&lt;/a>&lt;/p>
&lt;h2 id="rewind">
 Rewind
 &lt;a class="anchor" href="#rewind">#&lt;/a>
&lt;/h2>
&lt;ul>
&lt;li>Stack / Queue也可以用link-list實作，所以兩者不能和array畫上等號，只能說兩者都是一種data structure，只是用不同方式implement而已
:::spoiler Implementation Example
&lt;img src="https://hackmd.io/_uploads/HkkCaFyUn.png" alt="" />
:::&lt;/li>
&lt;li>之前提到的多項式也可以用link-list實作，同樣也可以解決sparse的問題
:::spoiler Implementation Example
&lt;img src="https://hackmd.io/_uploads/r15haYyL2.png" alt="" />
:::&lt;/li>
&lt;li>Free pool的概念就是像glibc中那樣的回收場(Fast bin/Small bin/Large bin/Unsorted bin)&lt;/li>
&lt;/ul>
&lt;h3 id="equivalence-relations">
 Equivalence Relations
 &lt;a class="anchor" href="#equivalence-relations">#&lt;/a>
&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>A relation over a set, S, is said to be an equivalence relations over S iff it is symmetric, reflexive, and transitive over S.&lt;/p>
&lt;ul>
&lt;li>reflexive, x=x&lt;/li>
&lt;li>symmetric, if x=y, then y=x&lt;/li>
&lt;li>transitive, if x=y and y=z, then x=z&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>Example&lt;/p></description></item><item><title>Lecture 2</title><link>https://bernie6401.github.io/docs/data-structure/lecture-2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/docs/data-structure/lecture-2/</guid><description>&lt;h1 id="lecture-2">
 Lecture 2
 &lt;a class="anchor" href="#lecture-2">#&lt;/a>
&lt;/h1>
&lt;h6 id="tags-data-structure-nycu">
 tags: &lt;code>Data Structure&lt;/code> &lt;code>NYCU&lt;/code>
 &lt;a class="anchor" href="#tags-data-structure-nycu">#&lt;/a>
&lt;/h6>
&lt;p>[TOC]&lt;/p>
&lt;h2 id="reference">
 Reference
 &lt;a class="anchor" href="#reference">#&lt;/a>
&lt;/h2>
&lt;p>&lt;a href="https://youtu.be/0J2eLvkuF8k">Lec02 資料結構 第二週課程&lt;/a>&lt;/p>
&lt;h2 id="note">
 Note
 &lt;a class="anchor" href="#note">#&lt;/a>
&lt;/h2>
&lt;h3 id="recursive-algorithms">
 Recursive Algorithms
 &lt;a class="anchor" href="#recursive-algorithms">#&lt;/a>
&lt;/h3>
&lt;h4 id="type">
 Type
 &lt;a class="anchor" href="#type">#&lt;/a>
&lt;/h4>
&lt;ul>
&lt;li>Direct Recursion: 簡單來說就是自己呼叫自己&lt;/li>
&lt;li>Indirect Recursion: A calls B $\to$ B calls itself&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h4 id="boundary-condition">
 Boundary Condition
 &lt;a class="anchor" href="#boundary-condition">#&lt;/a>
&lt;/h4>
&lt;p>Recursive algorithm是會停止的，如果他能夠寫出一個完整的通式或過程，就代表有上限，當達到這個上限時就會停止
:::spoiler Example
&lt;img src="https://i.imgur.com/5fDAGfc.png" alt="" />
:::&lt;/p>
&lt;hr>
&lt;h4 id="application-of-recursive-function">
 Application of Recursive Function
 &lt;a class="anchor" href="#application-of-recursive-function">#&lt;/a>
&lt;/h4>
&lt;ul>
&lt;li>
&lt;p>Permutation
Detailed description can browse the &lt;a href="https://youtu.be/0J2eLvkuF8k">original video&lt;/a>
如果不用Recursive解決Permutation的問題，可以考慮用For-Loop但是要考慮重複出現的問題
:::spoiler Example
&lt;img src="https://i.imgur.com/hGNBo0t.png" alt="" />&lt;/p>
&lt;p>&lt;img src="https://i.imgur.com/oU1sF0H.png" alt="" />
在這個例子中boundary condition就是只剩下一個字元需要做排列的時候
:::&lt;/p></description></item><item><title>Lecture 4</title><link>https://bernie6401.github.io/docs/data-structure/lecture-4/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/docs/data-structure/lecture-4/</guid><description>&lt;h1 id="lecture-4">
 Lecture 4
 &lt;a class="anchor" href="#lecture-4">#&lt;/a>
&lt;/h1>
&lt;h6 id="tags-data-structure-nycu">
 tags: &lt;code>Data Structure&lt;/code> &lt;code>NYCU&lt;/code>
 &lt;a class="anchor" href="#tags-data-structure-nycu">#&lt;/a>
&lt;/h6>
&lt;h2 id="reference">
 Reference
 &lt;a class="anchor" href="#reference">#&lt;/a>
&lt;/h2>
&lt;p>&lt;a href="https://youtu.be/x72xBomc-XE">Lec04 資料結構 第三週課程&lt;/a>&lt;/p>
&lt;h2 id="note">
 Note
 &lt;a class="anchor" href="#note">#&lt;/a>
&lt;/h2>
&lt;h3 id="array">
 Array
 &lt;a class="anchor" href="#array">#&lt;/a>
&lt;/h3>
&lt;p>用array表達一個多項式 $\to$ e.g.:
$$
A(X)=3X^{20}+2X^{5}+4\
B(X)=X^{4}+10X^{3}+1
$$&lt;/p>
&lt;h4 id="type-1">
 Type 1
 &lt;a class="anchor" href="#type-1">#&lt;/a>
&lt;/h4>
&lt;p>多項式的係數就是Array中存放的element，而指數代表Array的index
&lt;img src="https://i.imgur.com/Wy5X9bx.png" alt="" />&lt;/p>
&lt;ul>
&lt;li>缺點：
如下圖的$A(X)$，如果有一個sparse的array，這樣開的空間就只會有兩個index有存放數值，其他就會被浪費掉
&lt;img src="https://i.imgur.com/SjZreKb.png" alt="" />&lt;/li>
&lt;/ul>
&lt;h4 id="type-2">
 Type 2
 &lt;a class="anchor" href="#type-2">#&lt;/a>
&lt;/h4>
&lt;blockquote>
&lt;p>老師表示回家自己看書&lt;/p>&lt;/blockquote>
&lt;h4 id="type-3">
 Type 3
 &lt;a class="anchor" href="#type-3">#&lt;/a>
&lt;/h4>
&lt;p>用一個global array存放所有的多項式，以上圖為例，global array存放$A(X)$和$B(X)$，存放index和相對應的coefficient
:::info
How to implement? Refer to original video at timestamp &lt;code>5:30&lt;/code>
:::
:::danger
如果Global Array滿了怎麼辦?最簡單的作法是看前面有無可回收的多項式(寫在Descrutor)
:::&lt;/p>
&lt;hr>
&lt;h3 id="matrix">
 Matrix
 &lt;a class="anchor" href="#matrix">#&lt;/a>
&lt;/h3>
&lt;p>最簡單的就是直接declare一個2-dim的陣列，存放矩陣的element，缺點也和上面提到的sparse array一樣會有sparse matrix，如果太多index沒有存放東西，就會很浪費&lt;/p></description></item><item><title>Lecture 6</title><link>https://bernie6401.github.io/docs/data-structure/lecture-6/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/docs/data-structure/lecture-6/</guid><description>&lt;h1 id="lecture-6">
 Lecture 6
 &lt;a class="anchor" href="#lecture-6">#&lt;/a>
&lt;/h1>
&lt;h6 id="tags-data-structure-nycu">
 tags: &lt;code>Data Structure&lt;/code> &lt;code>NYCU&lt;/code>
 &lt;a class="anchor" href="#tags-data-structure-nycu">#&lt;/a>
&lt;/h6>
&lt;p>[TOC]&lt;/p>
&lt;h2 id="reference">
 Reference
 &lt;a class="anchor" href="#reference">#&lt;/a>
&lt;/h2>
&lt;p>&lt;a href="https://youtu.be/5HBMYNYYGZU">Lec06 資料結構 第四週課程&lt;/a>
&lt;a href="https://gist.github.com/LeeKLTW/e5004f2d7046d43676d0891af8a13ef7">[C/C++] C/C++ 箭頭(-&amp;gt;) 、點(.)、雙冒號(::) 用法&lt;/a>&lt;/p>
&lt;h2 id="rewind">
 Rewind
 &lt;a class="anchor" href="#rewind">#&lt;/a>
&lt;/h2>
&lt;h3 id="string-matching-task">
 String Matching Task
 &lt;a class="anchor" href="#string-matching-task">#&lt;/a>
&lt;/h3>
&lt;p>最笨的作法是一個字元依依比對
&lt;img src="https://i.imgur.com/qwCSoNe.png" alt="" />&lt;/p>
&lt;hr>
&lt;h3 id="kmp-algorithm">
 KMP Algorithm
 &lt;a class="anchor" href="#kmp-algorithm">#&lt;/a>
&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>有沒有可能一次不要只移動一個字元，
&lt;img src="https://i.imgur.com/zNhwzCt.png" alt="" />&lt;/p>
&lt;/li>
&lt;li>
&lt;p>又充分利用已經比對過的資訊進行位移
&lt;img src="https://i.imgur.com/7uvOfzP.png" alt="" />&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="原理">
 原理
 &lt;a class="anchor" href="#%e5%8e%9f%e7%90%86">#&lt;/a>
&lt;/h3>
&lt;p>運用到的就是建立一個Failure Function，如下圖為例，在index=5的地方failure function是3，代表從index=5往回看3個字元，會和整個字串的開頭往後看3個字元會相等
&lt;img src="https://i.imgur.com/k8auhgP.png" alt="" />&lt;/p>
&lt;p>這樣的話就可以快速的移動比對的字串，例如下圖，index i和j不相等，則可以往回看j-1的failure function儲存的相等字元有多少，如果是3代表可以直接移動到P到相等字元的地方(也就是p[3+1]的地方開始比對)，也就是粉紅色的地方對齊，這樣的話就可以移動不只一個字元
&lt;img src="https://i.imgur.com/vrO4YnO.png" alt="" />&lt;/p>
&lt;h3 id="implementation">
 Implementation
 &lt;a class="anchor" href="#implementation">#&lt;/a>
&lt;/h3>
&lt;p>:::info
Prefix (Failure) Function can refer to &lt;code>1:05:00&lt;/code>
KMP Matcher can refer to orignal video at timestamp &lt;code>1:14:00&lt;/code>
實際操作：&lt;code>1:14:10&lt;/code>
:::&lt;/p></description></item><item><title>Lecture 8</title><link>https://bernie6401.github.io/docs/data-structure/lecture-8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/docs/data-structure/lecture-8/</guid><description>&lt;h1 id="lecture-8">
 Lecture 8
 &lt;a class="anchor" href="#lecture-8">#&lt;/a>
&lt;/h1>
&lt;h6 id="tags-data-structure-nycu">
 tags: &lt;code>Data Structure&lt;/code> &lt;code>NYCU&lt;/code>
 &lt;a class="anchor" href="#tags-data-structure-nycu">#&lt;/a>
&lt;/h6>
&lt;h2 id="reference--background">
 Reference &amp;amp; Background
 &lt;a class="anchor" href="#reference--background">#&lt;/a>
&lt;/h2>
&lt;p>&lt;a href="https://youtu.be/lhXHk8IuFeQ">Lec08 資料結構 第五週課程&lt;/a>
&lt;a href="https://kopu.chat/c%E8%AA%9E%E8%A8%80-%E8%B6%85%E5%A5%BD%E6%87%82%E7%9A%84%E6%8C%87%E6%A8%99%EF%BC%8C%E5%88%9D%E5%AD%B8%E8%80%85%E8%AB%8B%E9%80%B2%EF%BD%9E/">C語言: 超好懂的指標，初學者請進～&lt;/a>&lt;/p>
&lt;h2 id="note">
 Note
 &lt;a class="anchor" href="#note">#&lt;/a>
&lt;/h2>
&lt;h3 id="rewind">
 Rewind
 &lt;a class="anchor" href="#rewind">#&lt;/a>
&lt;/h3>
&lt;ul>
&lt;li>Array
之前提到Array的結構，其缺點是大小是固定的，但有時候需要儲存的東西可能是動態改變的，且沒有用到的空間就會變成一種浪費&lt;/li>
&lt;li>Solution
此時就可能可以考慮用Link-List的結構處理這樣的資料&lt;/li>
&lt;/ul>
&lt;h3 id="link-list">
 Link-List
 &lt;a class="anchor" href="#link-list">#&lt;/a>
&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>主要結構
每一個Element都會有兩個儲存單位，一個是儲存資料本體，另一個是儲存pointer，指向下一個Element的位置
&lt;img src="https://hackmd.io/_uploads/SJ0yRNXH3.png" alt="" />&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Insert &lt;code>GAT&lt;/code>
Create新的node，儲存&lt;code>GAT&lt;/code>，並改變前後的指標，原本&lt;code>FAT&lt;/code>的指標要assign給&lt;code>GAT&lt;/code>的pointer，然後&lt;code>GAT&lt;/code>的位址也要assign給&lt;code>FAT&lt;/code>
&lt;img src="https://hackmd.io/_uploads/H1JrREXBh.png" alt="" />&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Delete &lt;code>GAT&lt;/code>
把&lt;code>HAT&lt;/code>的位址assign給&lt;code>FAT&lt;/code>
&lt;img src="https://hackmd.io/_uploads/SJ2zkr7B3.png" alt="" />&lt;/p>
&lt;ul>
&lt;li>缺點：如果要delete某一個Element就需要&amp;quot;先找到該Element的位置在哪裡&amp;quot;，如果Link-List 很長，則要做到這件事情的Overhead就會很高&lt;/li>
&lt;li>Solution: Double-Link-List，可以從前後同時找要刪除的Element，這樣的話就會比較快&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h4 id="implement">
 Implement
 &lt;a class="anchor" href="#implement">#&lt;/a>
&lt;/h4>
&lt;p>:::spoiler Source Code - Composite Classes&lt;/p>
&lt;pre tabindex="0">&lt;code class="language-cpp!" data-lang="cpp!">class ThreeLetterList; // forward delcanon 
class ThreeLetterNode {
 friend class ThreeLetterList; 
 private 
 char data[3]; // 每一個Elment就是只有儲存三個字元
 ThreeLetterNode *link;
};

class ThreeLetterList{ 
 public: 
 // List Manipulat10n operabons 
 private:
 ThreeLetterNode *first;
};
&lt;/code>&lt;/pre>&lt;p>:::&lt;/p></description></item></channel></rss>