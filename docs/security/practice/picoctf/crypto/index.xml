<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>SBK Hugo Site</title><link>https://bernie6401.github.io/docs/security/practice/picoctf/crypto/</link><description>Recent content on SBK Hugo Site</description><generator>Hugo</generator><language>en-us</language><atom:link href="https://bernie6401.github.io/docs/security/practice/picoctf/crypto/index.xml" rel="self" type="application/rss+xml"/><item><title>PicoCTF - Compress and Attack</title><link>https://bernie6401.github.io/docs/security/practice/picoctf/crypto/picoctf---compress-and-attack/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/docs/security/practice/picoctf/crypto/picoctf---compress-and-attack/</guid><description>&lt;h1 id="picoctf---compress-and-attack">
 PicoCTF - Compress and Attack
 &lt;a class="anchor" href="#picoctf---compress-and-attack">#&lt;/a>
&lt;/h1>
&lt;h6 id="tags-picoctf-ctf-crypto">
 tags: &lt;code>PicoCTF&lt;/code> &lt;code>CTF&lt;/code> &lt;code>Crypto&lt;/code>
 &lt;a class="anchor" href="#tags-picoctf-ctf-crypto">#&lt;/a>
&lt;/h6>
&lt;h2 id="background">
 Background
 &lt;a class="anchor" href="#background">#&lt;/a>
&lt;/h2>
&lt;ul>
&lt;li>zlib compression property
詳細說明一下zlib的壓縮特性是當壓縮的內容出現重複字元的時候，壓縮過後的長度會不變&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&amp;gt;&amp;gt;&amp;gt; import zlib
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&amp;gt;&amp;gt;&amp;gt; enc &lt;span style="color:#f92672">=&lt;/span> zlib.compress&lt;span style="color:#f92672">(&lt;/span>bytes&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#e6db74">&amp;#34;picoCTF{picoCTF{testing_123456}&amp;#34;&lt;/span>.encode&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#e6db74">&amp;#34;utf-8&amp;#34;&lt;/span>&lt;span style="color:#f92672">)))&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&amp;gt;&amp;gt;&amp;gt; len&lt;span style="color:#f92672">(&lt;/span>enc&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">33&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&amp;gt;&amp;gt;&amp;gt; enc &lt;span style="color:#f92672">=&lt;/span> zlib.compress&lt;span style="color:#f92672">(&lt;/span>bytes&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#e6db74">&amp;#34;picoCTF{tepicoCTF{testing_123456}&amp;#34;&lt;/span>.encode&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#e6db74">&amp;#34;utf-8&amp;#34;&lt;/span>&lt;span style="color:#f92672">)))&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&amp;gt;&amp;gt;&amp;gt; len&lt;span style="color:#f92672">(&lt;/span>enc&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">33&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&amp;gt;&amp;gt;&amp;gt; enc &lt;span style="color:#f92672">=&lt;/span> zlib.compress&lt;span style="color:#f92672">(&lt;/span>bytes&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#e6db74">&amp;#34;picoCTF{tekpicoCTF{testing_123456}&amp;#34;&lt;/span>.encode&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#e6db74">&amp;#34;utf-8&amp;#34;&lt;/span>&lt;span style="color:#f92672">)))&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&amp;gt;&amp;gt;&amp;gt; len&lt;span style="color:#f92672">(&lt;/span>enc&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">34&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>此時重複的部分就是&lt;code>picoCTF{&lt;/code>，若是繼續增加重複的部分(例如：&lt;code>picoCTF{te&lt;/code>)，壓縮後的長度也不會變，這樣就可以當作一個oracle，也就是利用長度來判斷增加的字元是不是flag重複的一部分&lt;/p>
&lt;h2 id="source-code">
 Source code
 &lt;a class="anchor" href="#source-code">#&lt;/a>
&lt;/h2>
&lt;p>:::spoiler&lt;/p>
&lt;pre tabindex="0">&lt;code class="language-python=" data-lang="python=">#!/usr/bin/python3 -u

import zlib
from random import randint
import os
from Crypto.Cipher import Salsa20

flag = open(&amp;#34;./flag&amp;#34;).read()


def compress(text):
 return zlib.compress(bytes(text.encode(&amp;#34;utf-8&amp;#34;)))

def encrypt(plaintext):
 secret = os.urandom(32)
 cipher = Salsa20.new(key=secret)
 return cipher.nonce + cipher.encrypt(plaintext)

def main():
 while True:
 usr_input = input(&amp;#34;Enter your text to be encrypted: &amp;#34;)
 compressed_text = compress(flag + usr_input)
 encrypted = encrypt(compressed_text)
 
 nonce = encrypted[:8]
 encrypted_text = encrypted[8:]
 print(nonce)
 print(encrypted_text)
 print(len(encrypted_text))

if __name__ == &amp;#39;__main__&amp;#39;:
 main()
&lt;/code>&lt;/pre>&lt;p>:::&lt;/p></description></item></channel></rss>