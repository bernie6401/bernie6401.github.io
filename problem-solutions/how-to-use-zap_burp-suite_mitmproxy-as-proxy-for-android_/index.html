<!doctype html><html lang=en-us dir=ltr><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content='
  How to use ZAP as Proxy?
  #



根據1我大概知道怎麼使用，我們通常會使用zap的command line形式進行操作，詳細的參數可以參考Official Document，另外我看ZAP如果要當作Proxy的角色會需要用到ROOT CA憑證，所以如果單純用之前的教學文章會不知到在哪裡產生憑證，他已經移動到Network底下了
![image](https://hackmd.io/_uploads/B11DaMnpT.png =400x)


目前我把Proxy架好了，看的是這篇教學文章-OWASP ZAP操作手冊，講的非常詳細

在Firefox中搜尋憑證或是cert，直接安裝在ZAP產生的憑證檔案
在Firefox的setting中搜尋Proxy
![圖片](https://hackmd.io/_uploads/HJ4NI5Aap.png =400x)
設定成如下
![圖片](https://hackmd.io/_uploads/HJoGB9CTa.png =400x)
只要ZAP有打開，就可以連線出去，但如果Proxy已經setup，卻沒有打開ZAP會通不到外面喔




  補充
  #


如果上述的步驟已經執行完但Proxy只能攔截到GET Method的封包，就代表憑證爛掉了，和在手機上一樣，但手機會出現這個問題還有可能是SSL Pinning，網頁端只需要重新安裝ZAP Generate的新憑證就好
如果設定Firefox的Proxy時，是設定成使用系統Proxy設定，那就要在電腦的設定中，更改Proxy的config
![圖片](https://hackmd.io/_uploads/HJ6STMP1R.png =400x)
這樣的話ZAP也可以正常運作，但是就不會出現ZAP特定的畫面(功能)
![圖片](https://hackmd.io/_uploads/ByAxAfPyA.png =400x)
只有設定成手動設定Proxy才會出現，否則會變成連線不上的畫面



  How to use Burp Suite as Proxy?
  #

這個完全是翻譯並且按照 Intercepting Android App Traffic with BurpSuite 的影片教學

  Prepare
  #


  (有取得Root實機的情況下)
  #

如果要保險一點零失敗的達成目標，按照影片的步驟和環境比較好，如果是已經有一台取得Root的實機，就可以忽略用VMware開的Emulator

取得Burp Suite Cert(在開啟Burp Suite的前提下)
有關於DER和PEM的背景知識可以參考[背景知識] 憑證的格式 PEM 與 DER | 自然人憑證開發筆記
$ curl localhost:8080/cert -o cert.der

# 這一段是強制把der檔案轉換成pem檔案
$ openssl x509 -inform der -in cert.der -out cert.pem

丟到手機端後直接在手機安裝憑證
接著就要參考How to Root Android Phone & Install AlwaysTrustUserCert.zip Module?這篇文章下面註解的地方重新安裝AlwaysTrustUserCert.zip這個plugin，最保險的做法是
先把之前所有安裝的憑證刪除→
重新啟動→
重新安裝"所有"的憑證→
重新安裝Magisk模組→
Reboot
接著就直接跳到下一段(實際攔截前)


  (利用VMware開Emulator)
  #


VMware 記得啟動 Virtualization
安裝Genymotion, virtualbox, adb
安裝前先到Genymotion官網註冊帳號
$ wget https://dl.genymotion.com/releases/genymotion-3.6.0/genymotion-3.6.0-linux_x64.bin
$ chmod +x genymotion-3.6.0-linux_x64.bin
$ ./genymotion-3.6.0-linux_x64.bin
$ sudo apt install virtualbox adb -y
$ cd genymotion
$ ./genymotion # login to genymotion

選擇Emulator的手機型號就可以開啟一個全新的Emulator
取得Burp Suite Cert(在開啟Burp Suite的前提下)
有關於DER和PEM的背景知識可以參考[背景知識] 憑證的格式 PEM 與 DER | 自然人憑證開發筆記
$ curl localhost:8080/cert -o cert.der

# 這一段是強制把der檔案轉換成pem檔案
$ openssl x509 -inform der -in cert.der -out cert.pem

# 這一段是顯示cert.pem這個檔案Subject的MD5 Hash Value，至於他怎麼做hash的，可以參考https://github.com/spacemonkeygo/openssl/issues/112#issuecomment-443313713，他解釋該hash的標的為哪些，並不是針對這整個file做hash
$ openssl x509 -inform PEM -subject_hash_old -in cert.pem
9a5ba575
-----BEGIN CERTIFICATE-----
MIIDpzCCAo+gAwIBAgIEdz+xgjANBgkqhkiG9w0BAQsFADCBijEUMBIGA1UEBhML
UG9ydFN3aWdnZXIxFDASBgNVBAgTC1BvcnRTd2lnZ2VyMRQwEgYDVQQHEwtQb3J0
U3dpZ2dlcjEUMBIGA1UEChMLUG9ydFN3aWdnZXIxFzAVBgNVBAsTDlBvcnRTd2ln
Z2VyIENBMRcwFQYDVQQDEw5Qb3J0U3dpZ2dlciBDQTAeFw0xNDA4MjgxMzUxMzda
Fw0zMzA4MjgxMzUxMzdaMIGKMRQwEgYDVQQGEwtQb3J0U3dpZ2dlcjEUMBIGA1UE
CBMLUG9ydFN3aWdnZXIxFDASBgNVBAcTC1BvcnRTd2lnZ2VyMRQwEgYDVQQKEwtQ
b3J0U3dpZ2dlcjEXMBUGA1UECxMOUG9ydFN3aWdnZXIgQ0ExFzAVBgNVBAMTDlBv
cnRTd2lnZ2VyIENBMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAwCM2
OEX9sby5W3ck1djqnohtIpNKIkBWw0qvwDfi17Hvyc0YIUPzQE+6o/a1KRgCS6Ni
2SgcJ/soKcRkMn5nmI5Mh+6w0NGEd13VmIcSkd97RghpeNivd5u0LOHW4KVYmxh9
0pDlt+6DD2zQIShM0hxUTGpaaPaRk9S9z0kWHNyJ9cfy627IWDSl1oNrQvNYTWU4
DhjBa0AOQUjCrTqkCALwCEAErZRGgjeonkola117DFG8twdjdA+55Iegw2Bd8ogd
JafibIUutXwGFiaAxx/ckapkqUKFnjBbXwyfoFmeiuiHqB3oy8Y8tduSh1e9lJNq
bMWW+UDG/4H5kXNOgwIDAQABoxMwETAPBgNVHRMBAf8EBTADAQH/MA0GCSqGSIb3
DQEBCwUAA4IBAQAn4BB23JUP0EThzsQY/299zJW0Z1AquMwYRYtWhhno+OoQ8gHu
zKNQHdV2RHr/Ns4z7tP7aNyWiCgSmmOwJ/0l7pY74NjxbZPdqVnHMy5Vg6ehggOH
ShKk6N561W4856G2AaiOqtY1a84wj1l5GtAtSbfVJtu3SdOvdiR2oD8C8IWx71VN
EGjEuIkbWdyysVQkhXkn1GAl8E3CRPqDrqJL4HA9CSAPEvvhbpUvJ/j+dqp+bH68
kPBVOVVKdzUBbngYeRpSwGm2WlbZ8RiWoeodsixPKiK2tSqtGG+D1H/bOKH/aq8x
PVGwpBZqfagUIDw+E1x1zmbtUkpY5nHCAcEo
-----END CERTIFICATE-----

# 複製cert.pem並改名成9a5ba575.0，會改成這樣是因為手機當中儲存憑證的方式就是這樣
$ cp cert.pem 9a5ba575.0

# 這一段是print出9a5ba575.0的subject，也就是上面做hash的標的就是下面這一串東西，所以只要是PortSwigger的憑證，只要他們沒有改subject，基本上做hash得到的結果都會是9a5ba575
$ openssl x509 -inform PEM -subject -in 9a5ba575.0
subject=C = PortSwigger, ST = PortSwigger, L = PortSwigger, O = PortSwigger, OU = PortSwigger CA, CN = PortSwigger CA

丟到手機端中儲存憑證的絕對位址
如果直接用adb push到該位置，會發現錯誤，原因是該位置是read only的狀態，所以我們要進到su進到root權限改變read only的狀態，再把東西丟進去就完成安裝了
$ adb shell
# su
# mount -o remount,rw /
# exit
# exit
$ adb push 9a5ba575.0 /system/etc/security/cacerts/



  實際攔截前
  #


打開的Burp Suite一定要把Bind to address改成All interfaces
![圖片](https://hackmd.io/_uploads/B1HBnVVPR.png =400x)
設定手機端的網路Proxy
這一部分就跟ZAP當初設定的時候一模一樣，當然也是可以像教學影片那樣用CLI的方式處理
$ adb shell settings put global http_proxy <proxy server ip>:8080 # set phone proxy
$ adb shell settings put global http_proxy :0 # unset phone proxy

接下來就可以實際攔截了


  Bypass SSL Pinning by Frida
  #

還記得之前做的實驗論文筆記中有提到，有一部分的app就算安裝了SSL Unpinning的Plugin還是無法攔截到流量，根據Defeating Android Certificate Pinning with Frida文章的說明，Facebook各式各樣的App所使用的憑證標準和實作方式都是自定義的，而不是用標準API，這樣的話用一般的SSL Unpinning就還是不會成功'><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#343a40"><meta name=color-scheme content="light dark"><meta property="og:url" content="https://bernie6401.github.io/problem-solutions/how-to-use-zap_burp-suite_mitmproxy-as-proxy-for-android_/"><meta property="og:site_name" content="SBK Hugo Site"><meta property="og:title" content="How to use ZAP/Burp Suite/mitmproxy as Proxy for Android?"><meta property="og:description" content='How to use ZAP as Proxy? # 根據1我大概知道怎麼使用，我們通常會使用zap的command line形式進行操作，詳細的參數可以參考Official Document，另外我看ZAP如果要當作Proxy的角色會需要用到ROOT CA憑證，所以如果單純用之前的教學文章會不知到在哪裡產生憑證，他已經移動到Network底下了 ![image](https://hackmd.io/_uploads/B11DaMnpT.png =400x)
目前我把Proxy架好了，看的是這篇教學文章-OWASP ZAP操作手冊，講的非常詳細
在Firefox中搜尋憑證或是cert，直接安裝在ZAP產生的憑證檔案 在Firefox的setting中搜尋Proxy ![圖片](https://hackmd.io/_uploads/HJ4NI5Aap.png =400x) 設定成如下 ![圖片](https://hackmd.io/_uploads/HJoGB9CTa.png =400x) 只要ZAP有打開，就可以連線出去，但如果Proxy已經setup，卻沒有打開ZAP會通不到外面喔 補充 # 如果上述的步驟已經執行完但Proxy只能攔截到GET Method的封包，就代表憑證爛掉了，和在手機上一樣，但手機會出現這個問題還有可能是SSL Pinning，網頁端只需要重新安裝ZAP Generate的新憑證就好 如果設定Firefox的Proxy時，是設定成使用系統Proxy設定，那就要在電腦的設定中，更改Proxy的config ![圖片](https://hackmd.io/_uploads/HJ6STMP1R.png =400x) 這樣的話ZAP也可以正常運作，但是就不會出現ZAP特定的畫面(功能) ![圖片](https://hackmd.io/_uploads/ByAxAfPyA.png =400x) 只有設定成手動設定Proxy才會出現，否則會變成連線不上的畫面 How to use Burp Suite as Proxy? # 這個完全是翻譯並且按照 Intercepting Android App Traffic with BurpSuite 的影片教學
Prepare # (有取得Root實機的情況下) # 如果要保險一點零失敗的達成目標，按照影片的步驟和環境比較好，如果是已經有一台取得Root的實機，就可以忽略用VMware開的Emulator
取得Burp Suite Cert(在開啟Burp Suite的前提下) 有關於DER和PEM的背景知識可以參考[背景知識] 憑證的格式 PEM 與 DER | 自然人憑證開發筆記 $ curl localhost:8080/cert -o cert.der # 這一段是強制把der檔案轉換成pem檔案 $ openssl x509 -inform der -in cert.der -out cert.pem 丟到手機端後直接在手機安裝憑證 接著就要參考How to Root Android Phone & Install AlwaysTrustUserCert.zip Module?這篇文章下面註解的地方重新安裝AlwaysTrustUserCert.zip這個plugin，最保險的做法是 先把之前所有安裝的憑證刪除→ 重新啟動→ 重新安裝"所有"的憑證→ 重新安裝Magisk模組→ Reboot 接著就直接跳到下一段(實際攔截前) (利用VMware開Emulator) # VMware 記得啟動 Virtualization 安裝Genymotion, virtualbox, adb 安裝前先到Genymotion官網註冊帳號 $ wget https://dl.genymotion.com/releases/genymotion-3.6.0/genymotion-3.6.0-linux_x64.bin $ chmod +x genymotion-3.6.0-linux_x64.bin $ ./genymotion-3.6.0-linux_x64.bin $ sudo apt install virtualbox adb -y $ cd genymotion $ ./genymotion # login to genymotion 選擇Emulator的手機型號就可以開啟一個全新的Emulator 取得Burp Suite Cert(在開啟Burp Suite的前提下) 有關於DER和PEM的背景知識可以參考[背景知識] 憑證的格式 PEM 與 DER | 自然人憑證開發筆記 $ curl localhost:8080/cert -o cert.der # 這一段是強制把der檔案轉換成pem檔案 $ openssl x509 -inform der -in cert.der -out cert.pem # 這一段是顯示cert.pem這個檔案Subject的MD5 Hash Value，至於他怎麼做hash的，可以參考https://github.com/spacemonkeygo/openssl/issues/112#issuecomment-443313713，他解釋該hash的標的為哪些，並不是針對這整個file做hash $ openssl x509 -inform PEM -subject_hash_old -in cert.pem 9a5ba575 -----BEGIN CERTIFICATE----- MIIDpzCCAo+gAwIBAgIEdz+xgjANBgkqhkiG9w0BAQsFADCBijEUMBIGA1UEBhML UG9ydFN3aWdnZXIxFDASBgNVBAgTC1BvcnRTd2lnZ2VyMRQwEgYDVQQHEwtQb3J0 U3dpZ2dlcjEUMBIGA1UEChMLUG9ydFN3aWdnZXIxFzAVBgNVBAsTDlBvcnRTd2ln Z2VyIENBMRcwFQYDVQQDEw5Qb3J0U3dpZ2dlciBDQTAeFw0xNDA4MjgxMzUxMzda Fw0zMzA4MjgxMzUxMzdaMIGKMRQwEgYDVQQGEwtQb3J0U3dpZ2dlcjEUMBIGA1UE CBMLUG9ydFN3aWdnZXIxFDASBgNVBAcTC1BvcnRTd2lnZ2VyMRQwEgYDVQQKEwtQ b3J0U3dpZ2dlcjEXMBUGA1UECxMOUG9ydFN3aWdnZXIgQ0ExFzAVBgNVBAMTDlBv cnRTd2lnZ2VyIENBMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAwCM2 OEX9sby5W3ck1djqnohtIpNKIkBWw0qvwDfi17Hvyc0YIUPzQE+6o/a1KRgCS6Ni 2SgcJ/soKcRkMn5nmI5Mh+6w0NGEd13VmIcSkd97RghpeNivd5u0LOHW4KVYmxh9 0pDlt+6DD2zQIShM0hxUTGpaaPaRk9S9z0kWHNyJ9cfy627IWDSl1oNrQvNYTWU4 DhjBa0AOQUjCrTqkCALwCEAErZRGgjeonkola117DFG8twdjdA+55Iegw2Bd8ogd JafibIUutXwGFiaAxx/ckapkqUKFnjBbXwyfoFmeiuiHqB3oy8Y8tduSh1e9lJNq bMWW+UDG/4H5kXNOgwIDAQABoxMwETAPBgNVHRMBAf8EBTADAQH/MA0GCSqGSIb3 DQEBCwUAA4IBAQAn4BB23JUP0EThzsQY/299zJW0Z1AquMwYRYtWhhno+OoQ8gHu zKNQHdV2RHr/Ns4z7tP7aNyWiCgSmmOwJ/0l7pY74NjxbZPdqVnHMy5Vg6ehggOH ShKk6N561W4856G2AaiOqtY1a84wj1l5GtAtSbfVJtu3SdOvdiR2oD8C8IWx71VN EGjEuIkbWdyysVQkhXkn1GAl8E3CRPqDrqJL4HA9CSAPEvvhbpUvJ/j+dqp+bH68 kPBVOVVKdzUBbngYeRpSwGm2WlbZ8RiWoeodsixPKiK2tSqtGG+D1H/bOKH/aq8x PVGwpBZqfagUIDw+E1x1zmbtUkpY5nHCAcEo -----END CERTIFICATE----- # 複製cert.pem並改名成9a5ba575.0，會改成這樣是因為手機當中儲存憑證的方式就是這樣 $ cp cert.pem 9a5ba575.0 # 這一段是print出9a5ba575.0的subject，也就是上面做hash的標的就是下面這一串東西，所以只要是PortSwigger的憑證，只要他們沒有改subject，基本上做hash得到的結果都會是9a5ba575 $ openssl x509 -inform PEM -subject -in 9a5ba575.0 subject=C = PortSwigger, ST = PortSwigger, L = PortSwigger, O = PortSwigger, OU = PortSwigger CA, CN = PortSwigger CA 丟到手機端中儲存憑證的絕對位址 如果直接用adb push到該位置，會發現錯誤，原因是該位置是read only的狀態，所以我們要進到su進到root權限改變read only的狀態，再把東西丟進去就完成安裝了 $ adb shell # su # mount -o remount,rw / # exit # exit $ adb push 9a5ba575.0 /system/etc/security/cacerts/ 實際攔截前 # 打開的Burp Suite一定要把Bind to address改成All interfaces ![圖片](https://hackmd.io/_uploads/B1HBnVVPR.png =400x) 設定手機端的網路Proxy 這一部分就跟ZAP當初設定的時候一模一樣，當然也是可以像教學影片那樣用CLI的方式處理 $ adb shell settings put global http_proxy <proxy server ip>:8080 # set phone proxy $ adb shell settings put global http_proxy :0 # unset phone proxy 接下來就可以實際攔截了 Bypass SSL Pinning by Frida # 還記得之前做的實驗論文筆記中有提到，有一部分的app就算安裝了SSL Unpinning的Plugin還是無法攔截到流量，根據Defeating Android Certificate Pinning with Frida文章的說明，Facebook各式各樣的App所使用的憑證標準和實作方式都是自定義的，而不是用標準API，這樣的話用一般的SSL Unpinning就還是不會成功'><meta property="og:locale" content="en_us"><meta property="og:type" content="article"><meta property="article:section" content="problem-solutions"><meta property="article:tag" content="Problem Solution"><title>How to use ZAP/Burp Suite/mitmproxy as Proxy for Android? | SBK Hugo Site</title>
<link rel=icon href=/favicon.png><link rel=manifest href=/manifest.json><link rel=canonical href=https://bernie6401.github.io/problem-solutions/how-to-use-zap_burp-suite_mitmproxy-as-proxy-for-android_/><link rel=stylesheet href=/book.min.6c8b9d2a1fc95075ed7da46ca81060b39add8fff6741ac51259f768929281e2c.css integrity="sha256-bIudKh/JUHXtfaRsqBBgs5rdj/9nQaxRJZ92iSkoHiw=" crossorigin=anonymous><script defer src=/fuse.min.js></script><script defer src=/en.search.min.acdc41c8d39e6c69d70d8a23779875e0a3733fefead3e428d5344966bb12f562.js integrity="sha256-rNxByNOebGnXDYojd5h14KNzP+/q0+Qo1TRJZrsS9WI=" crossorigin=anonymous></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/><span>SBK Hugo Site</span></a></h2><div class="book-search hidden"><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><script>document.querySelector(".book-search").classList.remove("hidden")</script></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu></label><h3>How to use ZAP/Burp Suite/mitmproxy as Proxy for Android?</h3><label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#補充>補充</a></li></ul><ul><li><a href=#prepare>Prepare</a><ul><li><a href=#有取得root實機的情況下>(有取得Root實機的情況下)</a></li><li><a href=#利用vmware開emulator>(利用VMware開Emulator)</a></li></ul></li><li><a href=#實際攔截前>實際攔截前</a></li><li><a href=#bypass-ssl-pinning-by-frida>Bypass SSL Pinning by Frida</a></li><li><a href=#對比>對比</a><ul><li><a href=#沒有使用frida的時候>沒有使用Frida的時候</a></li><li><a href=#有使用frida的時候>有使用Frida的時候</a></li></ul></li></ul></nav></aside></header><article class="markdown book-article"><h1 id=how-to-use-zap-as-proxy>How to use ZAP as Proxy?
<a class=anchor href=#how-to-use-zap-as-proxy>#</a></h1><ul><li><p>根據<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup>我大概知道怎麼使用，我們通常會使用zap的command line形式進行操作，詳細的參數可以參考<a href=https://www.zaproxy.org/docs/desktop/cmdline/>Official Document</a>，另外我看ZAP如果要當作Proxy的角色會需要用到ROOT CA憑證，所以如果單純用之前的教學文章會不知到在哪裡產生憑證，他已經移動到Network底下了
![image](<a href=https://hackmd.io/_uploads/B11DaMnpT.png>https://hackmd.io/_uploads/B11DaMnpT.png</a> =400x)</p></li><li><p>目前我把Proxy架好了，看的是<a href=https://hackmd.io/@ZLgd0D1pQcyasZhkkWKG4g/HyFZFPDQu>這篇教學文章-OWASP ZAP操作手冊</a>，講的非常詳細</p><ol><li>在Firefox中搜尋憑證或是cert，直接安裝在ZAP產生的憑證檔案</li><li>在Firefox的setting中搜尋Proxy
![圖片](<a href=https://hackmd.io/_uploads/HJ4NI5Aap.png>https://hackmd.io/_uploads/HJ4NI5Aap.png</a> =400x)</li><li>設定成如下
![圖片](<a href=https://hackmd.io/_uploads/HJoGB9CTa.png>https://hackmd.io/_uploads/HJoGB9CTa.png</a> =400x)
只要ZAP有打開，就可以連線出去，但如果Proxy已經setup，卻沒有打開ZAP會通不到外面喔</li></ol></li></ul><h2 id=補充>補充
<a class=anchor href=#%e8%a3%9c%e5%85%85>#</a></h2><ol><li>如果上述的步驟已經執行完但Proxy只能攔截到GET Method的封包，就代表憑證爛掉了，和在手機上一樣，但手機會出現這個問題還有可能是SSL Pinning，網頁端只需要重新安裝ZAP Generate的新憑證就好</li><li>如果設定Firefox的Proxy時，是設定成<code>使用系統Proxy設定</code>，那就要在電腦的設定中，更改Proxy的config
![圖片](<a href=https://hackmd.io/_uploads/HJ6STMP1R.png>https://hackmd.io/_uploads/HJ6STMP1R.png</a> =400x)
這樣的話ZAP也可以正常運作，但是就不會出現ZAP特定的畫面(功能)
![圖片](<a href=https://hackmd.io/_uploads/ByAxAfPyA.png>https://hackmd.io/_uploads/ByAxAfPyA.png</a> =400x)
只有設定成<code>手動設定Proxy</code>才會出現，否則會變成連線不上的畫面
<img src=https://hackmd.io/_uploads/B1vHRzPJ0.png alt=圖片></li></ol><h1 id=how-to-use-burp-suite-as-proxy>How to use Burp Suite as Proxy?
<a class=anchor href=#how-to-use-burp-suite-as-proxy>#</a></h1><p>這個完全是翻譯並且按照<a href="https://youtu.be/xp8ufidc514?si=4y0JhxW0kbnO1HjF"> Intercepting Android App Traffic with BurpSuite </a>的影片教學</p><h2 id=prepare>Prepare
<a class=anchor href=#prepare>#</a></h2><h3 id=有取得root實機的情況下>(有取得Root實機的情況下)
<a class=anchor href=#%e6%9c%89%e5%8f%96%e5%be%97root%e5%af%a6%e6%a9%9f%e7%9a%84%e6%83%85%e6%b3%81%e4%b8%8b>#</a></h3><p>如果要保險一點零失敗的達成目標，按照影片的步驟和環境比較好，如果是已經有一台取得Root的實機，就可以忽略用VMware開的Emulator</p><ul><li>取得Burp Suite Cert(在開啟Burp Suite的前提下)
有關於DER和PEM的背景知識可以參考<a href=https://medium.com/chouhsiang/%e8%83%8c%e6%99%af%e7%9f%a5%e8%ad%98-pem-%e8%88%87-der-dad659e0a40d>[背景知識] 憑證的格式 PEM 與 DER | 自然人憑證開發筆記</a><pre tabindex=0><code class=language-bash! data-lang=bash!>$ curl localhost:8080/cert -o cert.der

# 這一段是強制把der檔案轉換成pem檔案
$ openssl x509 -inform der -in cert.der -out cert.pem
</code></pre></li><li>丟到手機端後直接在手機安裝憑證</li><li>接著就要參考<a href=https://hackmd.io/nAJIgt13TjSZ5nqLR4-BiQ#Install-AlwaysTrustUserCertzip-Module>How to Root Android Phone & Install AlwaysTrustUserCert.zip Module?</a>這篇文章下面註解的地方重新安裝AlwaysTrustUserCert.zip這個plugin，最保險的做法是
先把之前所有安裝的憑證刪除→
重新啟動→
重新安裝"所有"的憑證→
重新安裝Magisk模組→
Reboot
接著就直接跳到下一段(實際攔截前)</li></ul><h3 id=利用vmware開emulator>(利用VMware開Emulator)
<a class=anchor href=#%e5%88%a9%e7%94%a8vmware%e9%96%8bemulator>#</a></h3><ul><li>VMware 記得啟動 Virtualization</li><li>安裝Genymotion, virtualbox, adb
安裝前先到Genymotion官網註冊帳號<pre tabindex=0><code class=language-bash! data-lang=bash!>$ wget https://dl.genymotion.com/releases/genymotion-3.6.0/genymotion-3.6.0-linux_x64.bin
$ chmod +x genymotion-3.6.0-linux_x64.bin
$ ./genymotion-3.6.0-linux_x64.bin
$ sudo apt install virtualbox adb -y
$ cd genymotion
$ ./genymotion # login to genymotion
</code></pre></li><li>選擇Emulator的手機型號就可以開啟一個全新的Emulator</li><li>取得Burp Suite Cert(在開啟Burp Suite的前提下)
有關於DER和PEM的背景知識可以參考<a href=https://medium.com/chouhsiang/%e8%83%8c%e6%99%af%e7%9f%a5%e8%ad%98-pem-%e8%88%87-der-dad659e0a40d>[背景知識] 憑證的格式 PEM 與 DER | 自然人憑證開發筆記</a><pre tabindex=0><code class=language-bash! data-lang=bash!>$ curl localhost:8080/cert -o cert.der

# 這一段是強制把der檔案轉換成pem檔案
$ openssl x509 -inform der -in cert.der -out cert.pem

# 這一段是顯示cert.pem這個檔案Subject的MD5 Hash Value，至於他怎麼做hash的，可以參考https://github.com/spacemonkeygo/openssl/issues/112#issuecomment-443313713，他解釋該hash的標的為哪些，並不是針對這整個file做hash
$ openssl x509 -inform PEM -subject_hash_old -in cert.pem
9a5ba575
-----BEGIN CERTIFICATE-----
MIIDpzCCAo+gAwIBAgIEdz+xgjANBgkqhkiG9w0BAQsFADCBijEUMBIGA1UEBhML
UG9ydFN3aWdnZXIxFDASBgNVBAgTC1BvcnRTd2lnZ2VyMRQwEgYDVQQHEwtQb3J0
U3dpZ2dlcjEUMBIGA1UEChMLUG9ydFN3aWdnZXIxFzAVBgNVBAsTDlBvcnRTd2ln
Z2VyIENBMRcwFQYDVQQDEw5Qb3J0U3dpZ2dlciBDQTAeFw0xNDA4MjgxMzUxMzda
Fw0zMzA4MjgxMzUxMzdaMIGKMRQwEgYDVQQGEwtQb3J0U3dpZ2dlcjEUMBIGA1UE
CBMLUG9ydFN3aWdnZXIxFDASBgNVBAcTC1BvcnRTd2lnZ2VyMRQwEgYDVQQKEwtQ
b3J0U3dpZ2dlcjEXMBUGA1UECxMOUG9ydFN3aWdnZXIgQ0ExFzAVBgNVBAMTDlBv
cnRTd2lnZ2VyIENBMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAwCM2
OEX9sby5W3ck1djqnohtIpNKIkBWw0qvwDfi17Hvyc0YIUPzQE+6o/a1KRgCS6Ni
2SgcJ/soKcRkMn5nmI5Mh+6w0NGEd13VmIcSkd97RghpeNivd5u0LOHW4KVYmxh9
0pDlt+6DD2zQIShM0hxUTGpaaPaRk9S9z0kWHNyJ9cfy627IWDSl1oNrQvNYTWU4
DhjBa0AOQUjCrTqkCALwCEAErZRGgjeonkola117DFG8twdjdA+55Iegw2Bd8ogd
JafibIUutXwGFiaAxx/ckapkqUKFnjBbXwyfoFmeiuiHqB3oy8Y8tduSh1e9lJNq
bMWW+UDG/4H5kXNOgwIDAQABoxMwETAPBgNVHRMBAf8EBTADAQH/MA0GCSqGSIb3
DQEBCwUAA4IBAQAn4BB23JUP0EThzsQY/299zJW0Z1AquMwYRYtWhhno+OoQ8gHu
zKNQHdV2RHr/Ns4z7tP7aNyWiCgSmmOwJ/0l7pY74NjxbZPdqVnHMy5Vg6ehggOH
ShKk6N561W4856G2AaiOqtY1a84wj1l5GtAtSbfVJtu3SdOvdiR2oD8C8IWx71VN
EGjEuIkbWdyysVQkhXkn1GAl8E3CRPqDrqJL4HA9CSAPEvvhbpUvJ/j+dqp+bH68
kPBVOVVKdzUBbngYeRpSwGm2WlbZ8RiWoeodsixPKiK2tSqtGG+D1H/bOKH/aq8x
PVGwpBZqfagUIDw+E1x1zmbtUkpY5nHCAcEo
-----END CERTIFICATE-----

# 複製cert.pem並改名成9a5ba575.0，會改成這樣是因為手機當中儲存憑證的方式就是這樣
$ cp cert.pem 9a5ba575.0

# 這一段是print出9a5ba575.0的subject，也就是上面做hash的標的就是下面這一串東西，所以只要是PortSwigger的憑證，只要他們沒有改subject，基本上做hash得到的結果都會是9a5ba575
$ openssl x509 -inform PEM -subject -in 9a5ba575.0
subject=C = PortSwigger, ST = PortSwigger, L = PortSwigger, O = PortSwigger, OU = PortSwigger CA, CN = PortSwigger CA
</code></pre></li><li>丟到手機端中儲存憑證的絕對位址
如果直接用adb push到該位置，會發現錯誤，原因是該位置是read only的狀態，所以我們要進到su進到root權限改變read only的狀態，再把東西丟進去就完成安裝了<pre tabindex=0><code class=language-bash! data-lang=bash!>$ adb shell
# su
# mount -o remount,rw /
# exit
# exit
$ adb push 9a5ba575.0 /system/etc/security/cacerts/
</code></pre></li></ul><h2 id=實際攔截前>實際攔截前
<a class=anchor href=#%e5%af%a6%e9%9a%9b%e6%94%94%e6%88%aa%e5%89%8d>#</a></h2><ol><li>打開的Burp Suite一定要把Bind to address改成All interfaces
![圖片](<a href=https://hackmd.io/_uploads/B1HBnVVPR.png>https://hackmd.io/_uploads/B1HBnVVPR.png</a> =400x)</li><li>設定手機端的網路Proxy
這一部分就跟ZAP當初設定的時候一模一樣，當然也是可以像教學影片那樣用CLI的方式處理<pre tabindex=0><code class=language-bash! data-lang=bash!>$ adb shell settings put global http_proxy &lt;proxy server ip&gt;:8080 # set phone proxy
$ adb shell settings put global http_proxy :0 # unset phone proxy
</code></pre></li><li>接下來就可以實際攔截了</li></ol><h2 id=bypass-ssl-pinning-by-frida>Bypass SSL Pinning by Frida
<a class=anchor href=#bypass-ssl-pinning-by-frida>#</a></h2><p>還記得之前做的實驗<a href=https://hackmd.io/@SBK6401/r155hduCT#%e7%84%a1%e6%b3%95%e4%bd%bf%e7%94%a8>論文筆記</a>中有提到，有一部分的app就算安裝了SSL Unpinning的Plugin還是無法攔截到流量，根據<a href=https://httptoolkit.com/blog/frida-certificate-pinning/>Defeating Android Certificate Pinning with Frida</a>文章的說明，Facebook各式各樣的App所使用的憑證標準和實作方式都是自定義的，而不是用標準API，這樣的話用一般的SSL Unpinning就還是不會成功</p><blockquote><p>Notably some apps which will go above and beyond, by implementing their own custom certificate pinning techniques from scratch, to make disabling it as difficult as possible. The prime example of this is the various Facebook apps, which all use their own custom reimplementation of TLS rather than the standard platform APIs.</p><p>It&rsquo;s definitely possible to automatically remove certificate pinning features from that too within the same Frida script in theory (contributions very welcome!), but it&rsquo;s significantly more difficult than mocking out a well-known common library, so I haven&rsquo;t done that yet, and so this script won&rsquo;t work for Facebook, Facebook Messenger, Instagram, or similar.</p></blockquote><p>所以通過上述教學影片，我們可以用Frida搭配特定App的腳本去Hook特定App中的特定Function，讓我們能夠在Proxy中攔截到流量</p><ol><li>安裝Frida-tools和Frida-server<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ conda create --name proxy python<span style=color:#f92672>=</span>3.11 -y
</span></span><span style=display:flex><span>$ pip install frida-tools
</span></span></code></pre></div>接著按照<a href=https://frida.re/docs/android/>官網</a>的說明安裝frida-server<ol><li>先從手機看架構
以我的Google Pixel 6a來說，架構是aarch64<pre tabindex=0><code class=language-bash! data-lang=bash!>$ adb shell uname -a
Linux localhost 5.10.157-android13-4-00001-g914e947b041d-ab10144456 #1 SMP PREEMPT Tue May 16 08:47:42 UTC 2023 aarch64 Toybox
</code></pre></li><li>再到<a href=https://github.com/frida/frida/releases>github releases</a>下載最新的server
此時我要選的版本就是frida-server-{version number}-android-arm64.xz
<img src=https://hackmd.io/_uploads/S1S234ND0.png alt=圖片></li><li>解壓縮後放到手機端上並且啟動這個frida-server<pre tabindex=0><code class=language-bash! data-lang=bash!>$ mv frida-server-16.2.5-android-arm64 frida-server # rename it
$ adb push frida-server /data/local/tmp/
$ adb shell &#34;chmod 755 /data/local/tmp/frida-server&#34;
$ adb shell &#34;/data/local/tmp/frida-server &amp;&#34;
</code></pre></li></ol></li><li>下載Instagram的腳本
同樣根據影片教學，到<a href="https://github.com/Eltion/Instagram-SSL-Pinning-Bypass?tab=readme-ov-file">Eltion/Instagram-SSL-Pinning-Bypass</a>下載最關鍵的.js script，他裡面還有其他的App Script，包含threads和messager之類的<pre tabindex=0><code class=language-bash! data-lang=bash!>$ wget https://raw.githubusercontent.com/Eltion/Instagram-SSL-Pinning-Bypass/main/instagram-ssl-pinning-bypass.js
</code></pre></li><li>啟動Burp Suite和腳本
<strong>Run腳本之前把Instagram的App強制停止</strong><pre tabindex=0><code class=language-bash! data-lang=bash!>$ frida -U -l ./instagram-ssl-pinning-bypass.js -f com.instagram.android
     ____
    / _  |   Frida 16.2.1 - A world-class dynamic instrumentation toolkit
   | (_| |
    &gt; _  |   Commands:
   /_/ |_|       help      -&gt; Displays the help system
   . . . .       object?   -&gt; Display information about &#39;object&#39;
   . . . .       exit/quit -&gt; Exit
   . . . .
   . . . .   More info at https://frida.re/docs/home/
   . . . .
   . . . .   Connected to Pixel 6a (id=24121JEGR04513)
Spawning `com.instagram.android`...
[*][*] Waiting for libliger...
Spawned `com.instagram.android`. Resuming main thread!
[Pixel 6a::com.instagram.android ]-&gt; [*][+] Hooked checkTrustedRecursive
[*][+] Hooked SSLContextInit
[*][+] Found libliger at: 0x76a3404000
[*][+] Hooked function: _ZN8proxygen15SSLVerification17verifyWithMetricsEbP17x509_store_ctx_stRKNSt6__ndk112basic_stringIcNS3_11char_traitsIcEENS3_9allocatorIcEEEEPNS0_31SSLFailureVerificationCallbacksEPNS0_31SSLSuccessVerificationCallbacksERKNS_15TimeUtilGenericINS3_6chrono12steady_clockEEERNS_10TraceEventE
</code></pre><code>-U</code>代表目標是USB連接的Device
<code>-l</code>代表要運行的Script
<code>-f</code>代表腳本的目標為何</li><li>查看Burp Suite
此時如果Burp Suite有開Intercept，並且App有送出一些東西，理論上都會被攔截到</li></ol><h2 id=對比>對比
<a class=anchor href=#%e5%b0%8d%e6%af%94>#</a></h2><h3 id=沒有使用frida的時候>沒有使用Frida的時候
<a class=anchor href=#%e6%b2%92%e6%9c%89%e4%bd%bf%e7%94%a8frida%e7%9a%84%e6%99%82%e5%80%99>#</a></h3><p>會得到以下截圖
![Screenshot_20240523-101015](<a href=https://hackmd.io/_uploads/Bk7aFN37R.png#pic_center>https://hackmd.io/_uploads/Bk7aFN37R.png#pic_center</a> =200x)
並且Burp Suite沒有得到任何關於instagram的封包</p><h3 id=有使用frida的時候>有使用Frida的時候
<a class=anchor href=#%e6%9c%89%e4%bd%bf%e7%94%a8frida%e7%9a%84%e6%99%82%e5%80%99>#</a></h3><p>例如我在前面的登入介面輸入一些東西，可以在封包紀錄中找到我輸入的Username和Password
![Screenshot_20240523-120440](<a href=https://hackmd.io/_uploads/H1-tlBhXR.png>https://hackmd.io/_uploads/H1-tlBhXR.png</a> =200x)
可以在傳輸的封包中找到這個json parameter body，而我輸入的Username: testqqqqqqwwwwww也的確在其中
<img src=https://hackmd.io/_uploads/SygolHnm0.png alt=圖片></p><pre tabindex=0><code class=language-jsonld data-lang=jsonld>{
  &#34;client_input_params&#34;: {
    &#34;device_id&#34;: &#34;android-70ea1739c3d78fb5&#34;,
    &#34;login_attempt_count&#34;: 1,
    &#34;secure_family_device_id&#34;: &#34;&#34;,
    &#34;machine_id&#34;: &#34;Zk6_IgABAAFG881bw25QVFTkQhJH&#34;,
    &#34;accounts_list&#34;: [],
    &#34;auth_secure_device_id&#34;: &#34;&#34;,
    &#34;has_whatsapp_installed&#34;: 0,
    &#34;password&#34;: &#34;#PWD_INSTAGRAM:1:1716436802:ASkUVtbquYjqR+MxW5sAAQJv9IFYeA7RM5r8OEvSkEDf6+0YsJ0oKKAkfx7o9AM5hpZW1TQV6POf1fg8uLC1E+gCgyqCwZiyCHYgqO3XDol2g2HFrwpNMwMn1S15LGjT9i8TEfh+k8hPuNFwGkEpLll6ycMur34gdx2V0vewuHlDOZapFmVetj+odQVW0u4WLwJybvKcFMdGGYWH7BqhmSsMjCFOBPzeflgf5fHQdxV14NWekpCWHED3LVwdISxa/yHvaYoc1EICz/O3wJO56aU3Y2zNQttBxKxuhCeS59sexNwaiz10hFMe9mb/0BD158z5Nn9x+3b5XDy24v3mNNHA4F6jkdiGwy8pAI0a/4X+yiOt5bVOCsinfGbso22kC6YnYq8dbBlUHD5zKTlKow8E&#34;,
    &#34;sso_token_map_json_string&#34;: &#34;&#34;,
    &#34;family_device_id&#34;: &#34;23045e76-6a5c-4886-8eca-0936fdb5f76b&#34;,
    &#34;fb_ig_device_id&#34;: [],
    &#34;device_emails&#34;: [],
    &#34;try_num&#34;: 1,
    &#34;lois_settings&#34;: {
      &#34;lois_token&#34;: &#34;&#34;,
      &#34;lara_override&#34;: &#34;&#34;
    },
    &#34;event_flow&#34;: &#34;login_manual&#34;,
    &#34;event_step&#34;: &#34;home_page&#34;,
    &#34;headers_infra_flow_id&#34;: &#34;&#34;,
    &#34;openid_tokens&#34;: {},
    &#34;client_known_key_hash&#34;: &#34;&#34;,
    &#34;contact_point&#34;: &#34;testqqqqqqwwwwww&#34;,
    &#34;encrypted_msisdn&#34;: &#34;&#34;
  },
  &#34;server_params&#34;: {
    &#34;should_trigger_override_login_2fa_action&#34;: 0,
    &#34;is_from_logged_out&#34;: 0,
    &#34;should_trigger_override_login_success_action&#34;: 0,
    &#34;login_credential_type&#34;: &#34;none&#34;,
    &#34;server_login_source&#34;: &#34;login&#34;,
    &#34;waterfall_id&#34;: null,
    &#34;login_source&#34;: &#34;Login&#34;,
    &#34;is_platform_login&#34;: 0,
    &#34;INTERNAL__latency_qpl_marker_id&#34;: 36707139,
    &#34;offline_experiment_group&#34;: null,
    &#34;is_from_landing_page&#34;: 0,
    &#34;password_text_input_id&#34;: &#34;0:96&#34;,
    &#34;ar_event_source&#34;: &#34;login_home_page&#34;,
    &#34;username_text_input_id&#34;: &#34;0:95&#34;,
    &#34;layered_homepage_experiment_group&#34;: null,
    &#34;should_show_nested_nta_from_aymh&#34;: 1,
    &#34;device_id&#34;: null,
    &#34;INTERNAL__latency_qpl_instance_id&#34;: 217,
    &#34;reg_flow_source&#34;: &#34;cacheable_aymh_screen&#34;,
    &#34;is_caa_perf_enabled&#34;: 1,
    &#34;credential_type&#34;: &#34;password&#34;,
    &#34;caller&#34;: &#34;gslr&#34;,
    &#34;family_device_id&#34;: null,
    &#34;INTERNAL_INFRA_THEME&#34;: &#34;harm_f&#34;,
    &#34;is_from_logged_in_switcher&#34;: 0
  }
}
</code></pre><h1 id=how-to-use-mitmproxy-as-proxy>How to use mitmproxy as Proxy?
<a class=anchor href=#how-to-use-mitmproxy-as-proxy>#</a></h1><p>這有點小複雜，我看網路上的教學有時候都東漏西漏，</p><ol><li>安裝mitmrproxy
我是直接用<code>$ pip install mitmproxy</code>，並且直接run起來，<code>$ mitmweb</code></li><li>下載憑證
如果一開始拿到的手機就是已經Rooted，那就直接下載憑證就好，我是用電腦版下載，首先把電腦上的proxy設定起來
![圖片](<a href=https://hackmd.io/_uploads/HJ5drE4wC.png>https://hackmd.io/_uploads/HJ5drE4wC.png</a> =300x)
並且在瀏覽器上打 <a href=http://mitm.it>http://mitm.it</a> 然後就會看到以下畫面
![圖片](<a href=https://hackmd.io/_uploads/Bk-cINNP0.png>https://hackmd.io/_uploads/Bk-cINNP0.png</a> =300x)
如果沒有先設定電腦上的proxy，他預設並不會走mitmproxy，這時候再瀏覽同一個網站就會出現以下畫面
<img src=https://hackmd.io/_uploads/H1dmI4NPC.png alt=圖片>
這時我們們就可以直接選取android要得憑證</li><li>把憑證放到手機上並且依照<a href=https://hackmd.io/@SBK6401/r1pDCcqCT#%e6%b3%a8%e6%84%8f%e4%ba%8b%e9%a0%85>How to Root Android Phone & Install AlwaysTrustUserCert.zip Module?</a>中最後的注意事項進行安裝，也就是先把之前所有安裝的憑證刪除→重新啟動→重新安裝"所有"的憑證→重新安裝Magisk模組→Reboot，就可以了
此時檢查手機中的的Trusted credentials應該就會發現mitmproxy的憑證已經被信任
![Screenshot_20240704-225258](<a href=https://hackmd.io/_uploads/B1v_PE4vC.png>https://hackmd.io/_uploads/B1v_PE4vC.png</a> =200x)</li><li>設定手機的Proxy IP
我是直接用電腦的hot spot來測試，所以手機就填電腦IP和8080的Port</li><li>攔截流量
此時一切幾乎準備就緒，但有個小問題，如果按照前面的command，會一直出現以下問題
![圖片](<a href=https://hackmd.io/_uploads/r1Huu44PA.png>https://hackmd.io/_uploads/r1Huu44PA.png</a> =400x)
根據<a href=https://stackoverflow.com/questions/52068746/mitmproxy-client-connection-killed-by-block-global>Stackoverflow</a>的說明，我們可以加上set參數<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ mitmweb --set block_global<span style=color:#f92672>=</span>false --set view
</span></span></code></pre></div>就可以順利攔截到流量了
<img src=https://hackmd.io/_uploads/SkYGtVEwA.png alt=圖片></li></ol><h1 id=reference>Reference
<a class=anchor href=#reference>#</a></h1><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p><a href=https://www.tpisoftware.com/tpu/articleDetails/2161>網頁安全性測試：OWASP ZAP使用入門</a>&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#補充>補充</a></li></ul><ul><li><a href=#prepare>Prepare</a><ul><li><a href=#有取得root實機的情況下>(有取得Root實機的情況下)</a></li><li><a href=#利用vmware開emulator>(利用VMware開Emulator)</a></li></ul></li><li><a href=#實際攔截前>實際攔截前</a></li><li><a href=#bypass-ssl-pinning-by-frida>Bypass SSL Pinning by Frida</a></li><li><a href=#對比>對比</a><ul><li><a href=#沒有使用frida的時候>沒有使用Frida的時候</a></li><li><a href=#有使用frida的時候>有使用Frida的時候</a></li></ul></li></ul></nav></div></aside></main></body></html>