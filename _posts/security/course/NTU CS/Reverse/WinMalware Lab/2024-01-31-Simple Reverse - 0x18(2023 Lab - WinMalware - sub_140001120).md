---
title: Simple Reverse - 0x18(2023 Lab - WinMalware - sub_140001120)
tags: [eductf, CTF, Reverse]

category: "Security/Course/NTU CS/Reverse/WinMalware Lab"
---

# Simple Reverse - 0x18(2023 Lab - WinMalware - sub_140001120)
<!-- more -->

## Description
> 分析 eductf-lab.exe 中的 function sub_140001120 在做什麼，並找出其所建立的 Mutex 的名稱。
> Flag format: FLAG{mutex_name}

## Background
* [CreateMutexA](https://learn.microsoft.com/zh-tw/windows/win32/api/synchapi/nf-synchapi-createmutexa)
* [GetLastError](https://learn.microsoft.com/zh-tw/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror)
* [使用 Mutex 物件](https://learn.microsoft.com/zh-tw/windows/win32/sync/using-mutex-objects)
    > 可以使用 mutex 物件 來保護共用資源，避免多個執行緒或進程同時存取。 每個執行緒都必須等候 mutex 的擁有權，才能執行可存取共用資源的程式碼。 例如，如果數個執行緒共用資料庫的存取權，執行緒可以使用 mutex 物件一次只允許一個執行緒寫入資料庫。
* [系統錯誤碼 (0-499)](https://learn.microsoft.com/zh-tw/windows/win32/debug/system-error-codes--0-499-)
    > ERROR_ALREADY_EXISTS
    > 183 (0xB7)
    > 無法建立檔案，該檔案已存在。

## Source code
* sub_140001120
    :::spoiler IDA Source Code
    ```cpp
    int sub_140001120()
    {    
      HANDLE MutexA; // rax
      int i; // [rsp+20h] [rbp-78h]
      int v3[2]; // [rsp+30h] [rbp-68h]
      CHAR Name[32]; // [rsp+38h] [rbp-60h] BYREF
      char v5[32]; // [rsp+58h] [rbp-40h] BYREF

      v3[0] = 1684234874;
      qmemcpy(v5, &unk_140003348, 0x1Dui64);
      for ( i = 0; i < 28; ++i )
        Name[i] = *(v3 + i % 4) ^ v5[i];
      MutexA = CreateMutexA(0i64, 1, Name);
      if ( MutexA )
      {
        LODWORD(MutexA) = GetLastError();
        if ( MutexA == 183 )
          exit(0);
      }
      return MutexA;
    }
    ```
    :::

## Recon
這一題有個小地方要注意，雖然觀察過source code是非常簡單的建立mutex的操作，題目想要知道的mutex name也非常簡單，只是個xor就知道的東西，不過在實作上需要注意endian的問題，一開始我是直接按照`0x64, 0x63, 0x62, 0x7A`的順序，但結果輸出一些ascii的字元，其實他是從後面讀進來再開始操作xor

* Malware使用Mutex的用途
    * 與一般程式相同，用於跨 process / thread 間的 synchronization
    * 避免重複感染、勒索 (LockBit 3.0、RedLine Stealer)

## Exploit
```python
f = [0x0E, 0x0A, 0x52, 0x51, 0x25, 0x2B, 0x57, 0x3B, 0x4E, 0x3D, 0x0E, 0x11, 0x0E, 0x51, 0x1B, 0x3B, 0x11, 0x53, 0x2F, 0x28, 0x25, 0x31, 0x14, 0x0D, 0x0E, 0x01, 0x2B, 0x64]
# v3 = [0x64, 0x63, 0x62, 0x7A]
key = [0X7A, 0X62, 0X63, 0X64]

Name = []
for i in range(len(f)):
    Name.append(chr(key[i % 4] ^ f[i]))

print("Flag: FLAG{" + "".join(Name) + "}")
```

Flag: `FLAG{th15_I4_4_mut3x_k1LL_SwitcH}`