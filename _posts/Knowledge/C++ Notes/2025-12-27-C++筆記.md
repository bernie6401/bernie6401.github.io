---
layout: post
title: "C++筆記"
date: 2025-12-27
category: "Knowledge｜C++ Notes"
tags: []
draft: false
toc: true
comments: true
---

# C++筆記
<!-- more -->

## 語法
### 基本
* Basic Class
    ```c++
    # include <iostream>
    using namespace std;

    class GradeBook
    {
        public:
            void displayMessage()
            {
                cout << "Welcome to the Grade Book!" << endl;
            }
    };

    int main()
    {
        GradeBook myGradeBook;
        myGradeBook.displayMessage();
    }
    ```
* if(Conditional Operator): `cout << (grade >= 60 ? "Passed" : "Failed")`
* For Loop
    ```c++
    for (int counter = 1; counter <= 10; counter++>)
        count << counter << endl;
    ```
* Reference: 和Pointer不一樣，是完全兩個不同的東西，所以`&`不是取位址，以下例子代表<span style="background-color: yellow">y永遠參考(綁定)x</span>，所以改y就會改道x，因為實際的記憶體中只有一份data，y也不是一個獨立的空間。使用refernce之前要初始化
    ```c++
    int &y = x;
    ```
    ```c++
    int squareByValue(int num){
        return num *= num;
    }

    void squareByRefernce(int &numRef){
        numRef *= numRef;
    }

    int main(){
        int x = 2, z = 4;

        cout << x << endl; // 2
        cout << squareByValue(x) << endl; // 4
        cout << x << endl; // 2

        cout << z << endl; // 4
        cout << squareByRefernce(z) << endl; // 16
        cout << z << endl; // 16->已經改變了
    }
    ```
* Array: `type arrayName[ arraySize ];`，代表array中所有的element都是同樣的data type，如果想要什麼type都能放，要用vector搭配Variant
    ```c++
    # include <Variant>
    # include <vector>
    using Var = std::variant<int, double, std::string>;

    std::vector<Var> v;
    v.push_back(10);
    v.push_back(3.14);
    v.push_back("hello");

    // 如果要存取
    for(auto& x:v){
        std::visit([](auto&& value){
            std::cout<< value << "\n";
        }, x);
    }
    ```
    另外，array也可以當作argument傳入function`void modifyArray(int b[], int sizeOfArray){for (int k = 0; k < sizeOfArray; k++)b[k] *= 2;}`

    多維的表示方式: `int a[2][3];`

* `vector`: 是一種class template，所以要使用template notation的寫法
    ```c++
    # include
    ```

* Function
    ArgumentName前面可以加static/const/static const，也可以用在object，但不能用在class之前；另外，member function 和data member都可以加static/const/static const
    ```c++
    // Function that take no argument
    dataType functionName();

    // Inline function
    inline dataType functionName( dataType argumentName )

    // Pass by reference
    dataType functionName( dataType &argumentName ){
    argumentName.classMemberFumction(); // 假設argumentName是一個object，想要使用/存取其中的member要用句點
    }

    // Function with default argument
    dataType functionName( dataType argumentName = value )

    // Function Template
    template<class T>
    T className( T argumentName ){
    T variableName = value;
    }

    // Array argument
    dataType functionName( dataType argumentName[] )

    // Vector as argument
    dataType functionName( vector<dataType> argumentName & )

    // Pass by reference with pointer
    dataType functionName( dataType *argumentName ){
    argumentName->classMemberFumction(); // 假設argumentName是一個object，想要使用/存取其中的member要用箭頭
    }

    dataType functionName( const dataType *argumentName ) // 代表*argumentName指的對象不能改，但argumentName本身可以改指其他memory

    dataType functionName( dataType * const argumentName ) // 代表argumentName本身不能改，但是指到的對象可以

    // Function pointer
    dataType functionName( FunctionDataType (*) (ArgumentDataType) ) // 看Argument有多少就要有幾個
    ```
* Class
    ```c++
    class className{
    public:
    // Constructor w/ default argument
    className( dataType = value );

    // deconstructor
    ~className ();

    // Const member function(保護return value不能改，在cpp的實作也要加const)
    dataType functionName() const;
    }


    // Constructor initializer for data member (初始化data member)
    // A.h
    class A{
    friend dataType outsideFunctionName( A &); // Class A授權外部function可以使用class A中的成員

    public:
    A( int c = 0, int i = 1, const x & ); // constructor
    A& e( dataType ); // 代表可以做到Cascaded member function / method chaining

    private:
    int a;
    const int b;
    const x y; // x是另外一個class，y是x的object
    };

    // A.cpp
    #include "A.h"
    using namespace std;

    A::A( int c, int d, const x &z ): a(c), b(d), y(z){} // 會這樣設計是因為這樣也可以初始化const member，同樣的概念也可以用來初始化object

    dataType outsideFunctionName ( A &B ){ cout << B.a;}

    A &A::e( dataType ) {return *this;} // 回傳物件本身，實現cascaded function / method chaining -> a.e(f).e(g)
    ```

* new例子
    ```c++
    dataType variableName = new (class object/array/dataType(value))
    Time *timePtr = new Time;
    delete timePtr;
    double *ptr = new double(3.14);
    int *gradeArray = new int[10];
    int gradeArray[] = new int[10];
    delete [] gradeArray;
    ```

## 開發注意事項
### Header 可以寫什麼
* `class`/`struct`的宣告
    ```c++
    // foo.h
    class Foo {
    public:
        Foo();          // 建構子宣告
        void bar();     // member function 宣告

    private:
        int x;
    };
    ```
* 常數、型別定義
    ```c++
    // config.h
    constexpr int MAX_SIZE = 100;

    using ID = unsigned int;
    typedef unsigned long ulong;
    ```
* Template: 實作也要寫在header file中，和一般的class不一樣
    ```c++
    // max.h
    template<typename T>
    T max(T a, T b) {
        return a > b ? a : b;
    }
    ```

### Header 和 CPP要分開
* header 負責「說有什麼」，source 負責「怎麼做」，也就是前者只負責宣告 Member Variable 和Member Functions，但把實作寫在後者，
* 因為假設把兩者都寫在同一個cpp，那麼其他cpp需要用到某個function就無法使用，也不可以把實作直接寫在header file中

否則:
1. 增加編譯時間
    一般來說使用者會拿到`.h` + (`.dll` or `a`)，前者類似給使用者的說明書，讓他知道可以用什麼以及怎麼用，然後include之後實際使用的program則是會放在`.dll`或`.a`中，編譯的時候會直接link過去，好處是可以把實作的細節褒裝起來不讓其他人輕易看到，以及要修改header file的實作細節時，所有include的cpp不需要再重新編譯
2. 破壞封裝（Encapsulation）
    封裝的核心是：用的人只知道「能做什麼」，不知道「怎麼做到」，如果 header 暴露實作：
    * 私有資料結構被看見
    * 未來很難改內部實作
    * 使用者可能「依賴細節」
3. 降低可維護性與可讀性: 實作混進來後： Header 又長又亂、找介面變困難、新人難上手

### ++a VS a++
前者是先+1再往後使用，後者則是相反
```c++
c = 5;
cout << c++ << endl; // 5
cout << c << endl; // 6

c = 5;
cout << ++c << endl; // 6
cout << c << endl; // 6
```

### Function Overloading
可以定義名稱相同的function，只要return/argument的 data type不同，signature就會不一樣，那compiler就會視為不同的東西

### Function Template
是Function Overloading的推演，既然所有logic都一樣，只有data type不同，那就設計一個邏輯通用的template，讓compiler自行推導該用什麼data type(實際使用的時候)
```c++
template < class T >
T maximum( T value1, T value2, T value3){
    T maximumValue = value1;
    if (value2 > maximumValue) maximumValue = value2;

    if (value3 > maximumValue) maximumValue = value3;

    return maximumValue;
}
```
T可以帶入`int`, `double`, `float`, `char`之類的

### Recusive VS. Iterative Function
前者是重複動作並呼叫自己的function，後者則是利用for-loop, while-loop, do-while-loop之類的counter-controlled方式進行重複動作，兩者的terminate方式也不同

### 什麼時候使用Vector
一般來說使用vector的頻率會比array多很多，因為大部分時候不確定大小，如果大小固定並且追求極致效能，那再用array