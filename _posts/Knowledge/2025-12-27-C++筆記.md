---
layout: post
title: "C++筆記"
date: 2025-12-27
category: "Knowledge"
tags: []
draft: false
toc: true
comments: true
---

# C++筆記
<!-- more -->

## Terminology
* Class(類別): 類似藍圖的概念
* Object(物件): Class的，也就是Class的Instance
* Data Member: Class 中的 Variable
* Member Function: Class中的Function，和**Method**類似
* Constructor: 開一個Class的Instance時，預設會執行的初始化Function，就類似Python的`__init__`，只要在Class中創一個名稱為`{Class Name}`的function，就可以當作constructor
* Private: 只有該Class可以使用
* Public: 其他Class可以使用
* Protected: 繼承父類別的子類別可以使用，但類別以外的地方，就無法使用

### Keyword
#### Storage-class Specifiers
C++提供五個不同的keyword決定lifetime、scope、linkage
* auto: 自動讓編譯器推導data type
    ```c++
    auto double x;
    ```
* extern
* register: c時代的遺物，拜託compiler把變數放在CPU暫存器
* mutable:
* static: static是最重要的
    1. Local Variable的Static: 只初始化一次，值會保留，常用來<span style="background-color: yellow">記住上次的狀態</span>
    2. Global Variable的Static: 限制只能在此file中使用
    3. Class中的Static: 屬於class而不是物件，所有object共用一份
        ```c++
        class A{
            public: 
            static int x;
        };

        int A::x=10;
        ```

|Keyword|主要用途|Lifetime|Scope|
|---|---|---|---|
|auto|(default)Local Variable|Block|Block|
|register|放暫存器|Block|Block|
|extern|使用外部Variable/Function|Global|跨File|
|static|保存狀態/限制可見性|Global|視位置而定|
|mutable|只用於class成員，允許修改const變數|Object的Lifetime|class|

#### class相關
* friend
* explicit
* export
* template
* this: 類似Python的`self`，都是用來指向物件本身
* inline: 通常用於inline function，程式較少的副程式，沒有function call、push/pop stack也沒有call/ret，會直接寫死在main program中，會比較快
    ```c++
    inline double cube(const double side)
    {
        return side * side * side;
    }

    int main(){
        double sideValue = 10.5;
        cout << cube(sideValue) << endl;
    }
    ```

#### Pure Virtual Function
* virtual: 會用在class中修飾member function，意思是該member function不給出確切實作，而是交由被繼承的子類別個別定義，重點是**等於0**
    ```c++
    virtual return_type function_name(...) = 0;
    ```
* 以下這三個東西都屬於 C++ 的 RTTI（Run-Time Type Information，執行期型別資訊），用來在「多型（polymorphism）」情境下，在執行時判斷物件的真實型別。
    * dynamic_cast: 在繼承關係中，安全地做「向下轉型（downcast）」，成功條件是
        * Base 必須是 polymorphic class（有 virtual）
        * b 實際指向 Derived 物件
        * 轉型方向必須在繼承樹中合法
        ```c++
        Base* b = new Derived();
        Derived* d = dynamic_cast<Derived*>(b);
        ```
    * typeid: 在執行期取得「實際型別資訊」
        ```c++
        Base* b = new Derived();
        cout << typeid(*b).name() << endl;
        ```
    * type_info: 主要用途是typeid 的回傳型別
        ```c++
        if (typeid(*b) == typeid(Derived)) {// 真的是 Derived}
        ```

#### 其他
* enum: 把一組⌈有限、固定選項⌋，用有意義的名字表示，本質上還是整數，只是比較好讀
    ```c++
    enum Status {CONTINUE, WON, LOST}; // 定義新的data type Status，定義CONTINUE是0，WON是1，LOST是2
    Status gameStatus;

    if (gameStatus == WON) {cout << "You win" << endl;}
    else if (gameStatus == LOST) {cout << "You lost" << endl;}
    else if (gameStatus == CONTINUE) {cout << "Continue" << endl;}
    ```
* sizeof
* struct
* typedef
* union
* volatile
* compl
* const_cast
* new: 開一個記憶體空間出來給某個物件，比方說class instance, vector等等
* reinterpret_cast
* static_cast: 要`# include <iomanip>`，目的是暫時改變某個variable的data type變成另外一個data type，運算完就消失了
    ```c++
    // total 原本是int，暫時變成double這個type
    average = static_cast<double>(total) / gradeCounter;
    ```
* typename
* using
* wchar_t

### 其他
* EOF(End of File)是`Ctrl+Z`
* Scope Resolution Operator(::): 代表這個東西在某個namespace/class/global中`ing num = 7; int main(){cout << ::num << endl;}`
* subscript/index: 在Array中，代表`[]`的數值，`[0]`含數字的叫做subscript notation

### Data Type

| 型別                    | 常見大小*       | 說明               |
| --------------------- | ----------- | ---------------- |
| `bool`                | 1 byte      | `true` / `false` |
| `char`                | 1 byte      | 字元或小整數           |
| `signed char`         | 1 byte      | 有號字元             |
| `unsigned char`       | 1 byte      | 無號字元             |
| `short` (`short int`) | 2 bytes     | 短整數              |
| `unsigned short`      | 2 bytes     |                  |
| `int`                 | 4 bytes     | 最常用整數            |
| `unsigned int`        | 4 bytes     |                  |
| `long`                | 4 或 8 bytes | 視平台              |
| `unsigned long`       | 4 或 8 bytes |                  |
| `long long`           | 8 bytes     | 長整數              |
| `unsigned long long`  | 8 bytes     |                  |
| `float`       | 4 bytes      | 單精度      |
| `double`      | 8 bytes      | 雙精度（最常用） |
| `long double` | 8 / 16 bytes | 高精度      |

### Standard Library
* `<cstdlib>`: 處理記憶體/系統/轉型的問題(malloc/calloc/realoc/free/atoi/atol/strtol/strtod/rand/srand/exit/abort/getenv/qsort/bsearch)
* `<cctype>`: 字元分類及轉換(isdigit/isalpha/isalnum/isspace/toupper/tolower)
* `<cstring>` / `<string>`: 字串處理(strlen/strcpy/strncpy/strcat/strcmp/strncmp/strchr/strstr/memcpy/memmove/memset/memcmp)，後者的差別是實行自動化管理memory且安全性較高(s.size(), s.length()/s+t+u+.../s.substr())
* `<fstream>`: 處理file的讀取和寫入
* `<cassert>`: debug用，用來檢查理論上一定要成立的條件`int x = 10; assert(x>0);`
* `<climits>` / `<limits>`: 是一種巨集，定義`INT_MAX`, `INT_MIN`, `CHAR_BIT`

### Standard Template Library
`<vector>`, `<list>`, `<deque>`, `<queue>`, `<stack>`, `<map>`, `<set>`, `<bitset>`

## 語法
### 基本
* Basic Class
    ```c++
    # include <iostream>
    using namespace std;

    class GradeBook
    {
        public:
            void displayMessage()
            {
                cout << "Welcome to the Grade Book!" << endl;
            }
    };

    int main()
    {
        GradeBook myGradeBook;
        myGradeBook.displayMessage();
    }
    ```
* if(Conditional Operator): `cout << (grade >= 60 ? "Passed" : "Failed")`
* For Loop
    ```c++
    for (int counter = 1; counter <= 10; counter++>)
        count << counter << endl;
    ```
* Reference: 和Pointer不一樣，是完全兩個不同的東西，所以`&`不是取位址，以下例子代表<span style="background-color: yellow">y永遠參考(綁定)x</span>，所以改y就會改道x，因為實際的記憶體中只有一份data，y也不是一個獨立的空間。使用refernce之前要初始化
    ```c++
    int &y = x;
    ```
    ```c++
    int squareByValue(int num){
        return num *= num;
    }

    void squareByRefernce(int &numRef){
        numRef *= numRef;
    }

    int main(){
        int x = 2, z = 4;

        cout << x << endl; // 2
        cout << squareByValue(x) << endl; // 4
        cout << x << endl; // 2

        cout << z << endl; // 4
        cout << squareByRefernce(z) << endl; // 16
        cout << z << endl; // 16->已經改變了
    }
    ```
* Array: `type arrayName[ arraySize ];`，代表array中所有的element都是同樣的data type，如果想要什麼type都能放，要用vector搭配Variant
    ```c++
    # include <Variant>
    # include <vector>
    using Var = std::variant<int, double, std::string>;

    std::vector<Var> v;
    v.push_back(10);
    v.push_back(3.14);
    v.push_back("hello");

    // 如果要存取
    for(auto& x:v){
        std::visit([](auto&& value){
            std::cout<< value << "\n";
        }, x);
    }
    ```
    另外，array也可以當作argument傳入function`void modifyArray(int b[], int sizeOfArray){for (int k = 0; k < sizeOfArray; k++)b[k] *= 2;}`

    多維的表示方式: `int a[2][3];`

* `vector`: 是一種class template，所以要使用template notation的寫法
    ```c++
    # include
    ```

* Function
    ArgumentName前面可以加static/const/static const，也可以用在object，但不能用在class之前；另外，member function 和data member都可以加static/const/static const
    ```c++
    // Function that take no argument
    dataType functionName();

    // Inline function
    inline dataType functionName( dataType argumentName )

    // Pass by reference
    dataType functionName( dataType &argumentName ){
    argumentName.classMemberFumction(); // 假設argumentName是一個object，想要使用/存取其中的member要用句點
    }

    // Function with default argument
    dataType functionName( dataType argumentName = value )

    // Function Template
    template<class T>
    T className( T argumentName ){
    T variableName = value;
    }

    // Array argument
    dataType functionName( dataType argumentName[] )

    // Vector as argument
    dataType functionName( vector<dataType> argumentName & )

    // Pass by reference with pointer
    dataType functionName( dataType *argumentName ){
    argumentName->classMemberFumction(); // 假設argumentName是一個object，想要使用/存取其中的member要用箭頭
    }

    dataType functionName( const dataType *argumentName ) // 代表*argumentName指的對象不能改，但argumentName本身可以改指其他memory

    dataType functionName( dataType * const argumentName ) // 代表argumentName本身不能改，但是指到的對象可以

    // Function pointer
    dataType functionName( FunctionDataType (*) (ArgumentDataType) ) // 看Argument有多少就要有幾個
    ```
* Class
    ```c++
    class className{
    public:
    // Constructor w/ default argument
    className( dataType = value );

    // deconstructor
    ~className ();

    // Const member function(保護return value不能改，在cpp的實作也要加const)
    dataType functionName() const;
    }


    // Constructor initializer for data member (初始化data member)
    // A.h
    class A{
    friend dataType outsideFunctionName( A &); // Class A授權外部function可以使用class A中的成員

    public:
    A( int c = 0, int i = 1, const x & ); // constructor
    A& e( dataType ); // 代表可以做到Cascaded member function / method chaining

    private:
    int a;
    const int b;
    const x y; // x是另外一個class，y是x的object
    };

    // A.cpp
    #include "A.h"
    using namespace std;

    A::A( int c, int d, const x &z ): a(c), b(d), y(z){} // 會這樣設計是因為這樣也可以初始化const member，同樣的概念也可以用來初始化object

    dataType outsideFunctionName ( A &B ){ cout << B.a;}

    A &A::e( dataType ) {return *this;} // 回傳物件本身，實現cascaded function / method chaining -> a.e(f).e(g)
    ```

* new例子
    ```c++
    dataType variableName = new (class object/array/dataType(value))
    Time *timePtr = new Time;
    delete timePtr;
    double *ptr = new double(3.14);
    int *gradeArray = new int[10];
    int gradeArray[] = new int[10];
    delete [] gradeArray;
    ```

## 開發注意事項
### Header 可以寫什麼
* `class`/`struct`的宣告
    ```c++
    // foo.h
    class Foo {
    public:
        Foo();          // 建構子宣告
        void bar();     // member function 宣告

    private:
        int x;
    };
    ```
* 常數、型別定義
    ```c++
    // config.h
    constexpr int MAX_SIZE = 100;

    using ID = unsigned int;
    typedef unsigned long ulong;
    ```
* Template: 實作也要寫在header file中，和一般的class不一樣
    ```c++
    // max.h
    template<typename T>
    T max(T a, T b) {
        return a > b ? a : b;
    }
    ```

### Header 和 CPP要分開
* header 負責「說有什麼」，source 負責「怎麼做」，也就是前者只負責宣告 Member Variable 和Member Functions，但把實作寫在後者，
* 因為假設把兩者都寫在同一個cpp，那麼其他cpp需要用到某個function就無法使用，也不可以把實作直接寫在header file中

否則:
1. 增加編譯時間
    一般來說使用者會拿到`.h` + (`.dll` or `a`)，前者類似給使用者的說明書，讓他知道可以用什麼以及怎麼用，然後include之後實際使用的program則是會放在`.dll`或`.a`中，編譯的時候會直接link過去，好處是可以把實作的細節褒裝起來不讓其他人輕易看到，以及要修改header file的實作細節時，所有include的cpp不需要再重新編譯
2. 破壞封裝（Encapsulation）
    封裝的核心是：用的人只知道「能做什麼」，不知道「怎麼做到」，如果 header 暴露實作：
    * 私有資料結構被看見
    * 未來很難改內部實作
    * 使用者可能「依賴細節」
3. 降低可維護性與可讀性: 實作混進來後： Header 又長又亂、找介面變困難、新人難上手

### ++a VS a++
前者是先+1再往後使用，後者則是相反
```c++
c = 5;
cout << c++ << endl; // 5
cout << c << endl; // 6

c = 5;
cout << ++c << endl; // 6
cout << c << endl; // 6
```

### Function Overloading
可以定義名稱相同的function，只要return/argument的 data type不同，signature就會不一樣，那compiler就會視為不同的東西

### Function Template
是Function Overloading的推演，既然所有logic都一樣，只有data type不同，那就設計一個邏輯通用的template，讓compiler自行推導該用什麼data type(實際使用的時候)
```c++
template < class T >
T maximum( T value1, T value2, T value3){
    T maximumValue = value1;
    if (value2 > maximumValue) maximumValue = value2;

    if (value3 > maximumValue) maximumValue = value3;

    return maximumValue;
}
```
T可以帶入`int`, `double`, `float`, `char`之類的

### Recusive VS. Iterative Function
前者是重複動作並呼叫自己的function，後者則是利用for-loop, while-loop, do-while-loop之類的counter-controlled方式進行重複動作，兩者的terminate方式也不同

### 什麼時候使用Vector
一般來說使用vector的頻率會比array多很多，因為大部分時候不確定大小，如果大小固定並且追求極致效能，那再用array