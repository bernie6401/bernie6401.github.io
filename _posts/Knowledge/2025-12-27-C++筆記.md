---
layout: post
title: "C++筆記"
date: 2025-12-27
category: "Knowledge"
tags: []
draft: false
toc: true
comments: true
---

# C++筆記
<!-- more -->

## 語法
### Terminology
* Class(類別): 類似藍圖的概念
* Object(物件): Class的，也就是Class的Instance
* Data Member: Class 中的 Variable
* Member Function: Class中的Function，和**Method**類似
* Constructor: 開一個Class的Instance時，預設會執行的初始化Function，就類似Python的`__init__`，只要在Class中創一個名稱為`{Class Name}`的function，就可以當作constructor

### 基本
* Basic Class
```c++
# include <iostream>
using namespace std;

class GradeBook
{
    public:
        void displayMessage()
        {
            cout << "Welcome to the Grade Book!" << endl;
        }
};

int main()
{
    GradeBook myGradeBook;
    myGradeBook.displayMessage();
}
```

## 開發注意事項
### Header 可以寫什麼
* `class`/`struct`的宣告
    ```c++
    // foo.h
    class Foo {
    public:
        Foo();          // 建構子宣告
        void bar();     // member function 宣告

    private:
        int x;
    };
    ```
* 常數、型別定義
    ```c++
    // config.h
    constexpr int MAX_SIZE = 100;

    using ID = unsigned int;
    typedef unsigned long ulong;
    ```
* Template
    ```c++
    // max.h
    template<typename T>
    T max(T a, T b) {
        return a > b ? a : b;
    }
    ```
### Header 和 CPP要分開
* header 負責「說有什麼」，source 負責「怎麼做」，也就是前者只負責宣告 Member Variable 和Member Functions，但把實作寫在後者，
* 因為假設把兩者都寫在同一個cpp，那麼其他cpp需要用到某個function就無法使用，也不可以把實作直接寫在header file中

否則:
1. 增加編譯時間
    一般來說使用者會拿到`.h` + (`.dll` or `a`)，前者類似給使用者的說明書，讓他知道可以用什麼以及怎麼用，然後include之後實際使用的program則是會放在`.dll`或`.a`中，編譯的時候會直接link過去，好處是可以把實作的細節褒裝起來不讓其他人輕易看到，以及要修改header file的實作細節時，所有include的cpp不需要再重新編譯
2. 破壞封裝（Encapsulation）
    封裝的核心是：用的人只知道「能做什麼」，不知道「怎麼做到」，如果 header 暴露實作：
    * 私有資料結構被看見
    * 未來很難改內部實作
    * 使用者可能「依賴細節」
3. 降低可維護性與可讀性: 實作混進來後： Header 又長又亂、找介面變困難、新人難上手