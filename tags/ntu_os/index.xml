<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>NTU_OS :: Tag :: SBK Hugo Site</title><link>https://bernie6401.github.io/tags/ntu_os/index.html</link><description/><generator>Hugo</generator><language>en-us</language><atom:link href="https://bernie6401.github.io/tags/ntu_os/index.xml" rel="self" type="application/rss+xml"/><item><title>NTU Operating System Project 1</title><link>https://bernie6401.github.io/security/course/ntu-os/ntu-operating-system-project-1/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-os/ntu-operating-system-project-1/index.html</guid><description>NTU Operating System Project 1 tags: NTU_OS Operating System NachOS Thread Management :::spoiler [TOC] :::
How to parse this project You can research userkernel.cc file first. UserProgKernel will parse the command line and store the file you want to execute in execfile variable which defined at userkernel.h. Then you’ll find something interesting. ForkExecute(Thread *t) {t->space->Execute(t->getName());} // space and getName() are defined at thread.h // Execute is defined at addrspace.h This is what we’ve learned on lecture that it’ll clone a child process and execute the same program as parent process just like a multi-thread. Next, you can observe Run() function void UserProgKernel::Run() { cout &lt;&lt; "Total threads number is " &lt;&lt; execfileNum &lt;&lt; endl; for (int n=1;n&lt;=execfileNum;n++) { t[n] = new Thread(execfile[n]); t[n]->space = new AddrSpace(); t[n]->Fork((VoidFunctionPtr) &amp;ForkExecute, (void *)t[n]); cout &lt;&lt; "Thread " &lt;&lt; execfile[n] &lt;&lt; " is executing." &lt;&lt; endl; } ThreadedKernel::Run(); } Review a very simple concept: Process Representation in Linux // Represented by the C structure task_struct pid t pid; /* process identifier */ long state; /* state of the process */ unsigned int time slice /* scheduling information */ struct task struct *parent; /* this process’s parent */ struct list head children; /* this process’s children */ struct files struct *files; /* list of open files */ struct mm struct *mm; /* address space of this process */ Another related concept is Process Creation Address space Child duplicate of parent Child has a program loaded into it UNIX examples fork() system call creates new process exec() system call used after a fork() to replace the process’ memory space with a new program After reviewing the concept above, we can continue to answer next question(Please follow the next section -> Q2) Project Q&amp;A Q1: Why the result is not congruent with expected? Because OS has multi-thread concept like the code above and it’ll fork child process. When more than 1 process be executed simultaneously without any precondition, it’ll happend what we unexpected. And the precondition or you can say the real problem in this case is context switching which is the progress between preocesses switching by CPU. Q2: How to solve the issue?(You can include some code and explain it) According to the previous question, NachOS didn’t manage memory for executing multi program and this’ll cause the current program’s page overlap to the others running program. Thus, we have to revise these two program and let the program’s virtual memory map to the real memory that no one used. code/userprog/addrspace.cc code/userprog/addrspace.h Add the code in addrspace.cc at the beginning to stored the usage of all physical pages and stored how many free pages can be used now.</description></item><item><title>NTU Operating System Project 2</title><link>https://bernie6401.github.io/security/course/ntu-os/ntu-operating-system-project-2/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-os/ntu-operating-system-project-2/index.html</guid><description>NTU Operating System Project 2 tags: NTU_OS Operating System NachOS CPU Scheduling System Call [TOC]
Motivation For the first task, We’d like to add sleep() function in system call that can help us call sleep in our program. For the second task, we’d like to implement CPU scheduling by FIFO(First-In-First-Out), SJF(Shortest-Job-First), Priority, RR(Round-Robin), and multi-level queue. Implementation Task1 - System Call First of all, we need to define a new token, SC_Sleep, that compiler(scanner) can recognize in code/userprog/syscall.h.</description></item><item><title>NTU Operating System Project 3</title><link>https://bernie6401.github.io/security/course/ntu-os/ntu-operating-system-project-3/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-os/ntu-operating-system-project-3/index.html</guid><description>NTU Operating System Project 3 tags: NTU_OS Operating System NachOS Memory Management [TOC]
Description First I used the code from Project2 directly and obtained the correct value, 1 and 7220, by the command ./nachos -e ../test/sort -e ../test/matmult respectively. After debugging a while, I knew what’s the matter. In project2, I set const unsigned int NumPhysPages = 256; so that it can handle huge computing resource. In order to address this project, we must change it back to 32.</description></item><item><title>NTU Operating System Review Notes</title><link>https://bernie6401.github.io/security/course/ntu-os/ntu-operating-system-review-notes/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-os/ntu-operating-system-review-notes/index.html</guid><description>NTU Operating System Review Notes tags: NTU_OS Operating System [TOC]
Ch 6 Synchronization Process communication Race condition 就是Project1提到的共享記憶體的問題，導致multi-thread執行的結果會完全錯誤
解決策略 Disable interrupt process在對shared memory進行變數存取之前，先disable interrupt，直到完成此次存取後才enable，這樣的話這段時間，CPU就不會被其他processes搶走(preempted) Critical section design 必須滿足三個criteria Mutual exclusion: 在任何時間點，最多只允許一個process在他自己的CS內活動，不可同時有多個process在各自的CS內活動 Progress: 如果有人想進去CS，遲早進的去 Bounded waiting: 在一定時間內一定進的去 架構圖 spinlock busy waiting Critical section design的方法 Software solution 兩個processes Peterson’s solution: 有turn和flag兩個變數，分別代表目前的token在誰手上(turn)，以及表示有無意願進入CS(flag) N個processes Bakery’s ALG: 就是領號碼牌，號碼最小的人優先，若同時有多人持有相同的號碼牌，則以PID最小的優先 Hardware 指令支援 OS提出了mutex lock的概念，並用acquire()和release()的方法實踐 Semaphore 一種可以解決CS design和processes synchronization problem的data type，會提供兩個atomic operations: wait(s)和signal(s) wait(s): while(s&lt;=0) {do nothing;}s--; signal(s): s++ 簡單來說，s就是看現在可以使用的資源有多少(例如有多少台printer)，如果資源被分出去一個，s就減一，如果都沒有資源了，就一直等待，直到有人釋放資源，釋放資源的時候，s就會加一，所以和前面提到的mutex lock幾乎一樣，wait(s)就是acquire()，而signal(s)就是release() Semaphore的種類 有使用busy-waiting: spinlock semaphore:其實就是上面說的mutex lock和正常semaphore的概念 沒有使用busy-waiting: Non-Busy-Waiting semaphore: 看講義 Monitor 用來解決synchronization problem的高階資料結構 其實就是物件導向的方式，利用private、initialization等方式，創造monitor這個class object Message Passing技術</description></item></channel></rss>