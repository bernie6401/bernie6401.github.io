<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>NYCU :: Tag :: SBK Hugo Site</title><link>https://bernie6401.github.io/tags/nycu/index.html</link><description/><generator>Hugo</generator><language>en-us</language><atom:link href="https://bernie6401.github.io/tags/nycu/index.xml" rel="self" type="application/rss+xml"/><item><title>Data Structure</title><link>https://bernie6401.github.io/data-structure/data-structure/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/data-structure/data-structure/index.html</guid><description>Data Structure tags: Data Structure NYCU Lecture 1 Lecture 2 Lecture 3 Lecture 4 Lecture 5 Lecture 6 Lecture 7 Lecture 8 Lecture 10</description></item><item><title>Lecture 10</title><link>https://bernie6401.github.io/data-structure/lecture-10/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/data-structure/lecture-10/index.html</guid><description>Lecture 10 tags: Data Structure NYCU Reference Lec10 資料結構 第六週課程
Rewind Stack / Queue也可以用link-list實作，所以兩者不能和array畫上等號，只能說兩者都是一種data structure，只是用不同方式implement而已 :::spoiler Implementation Example ::: 之前提到的多項式也可以用link-list實作，同樣也可以解決sparse的問題 :::spoiler Implementation Example ::: Free pool的概念就是像glibc中那樣的回收場(Fast bin/Small bin/Large bin/Unsorted bin) Equivalence Relations A relation over a set, S, is said to be an equivalence relations over S iff it is symmetric, reflexive, and transitive over S.</description></item><item><title>Lecture 2</title><link>https://bernie6401.github.io/data-structure/lecture-2/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/data-structure/lecture-2/index.html</guid><description>Lecture 2 tags: Data Structure NYCU [TOC]
Reference Lec02 資料結構 第二週課程
Note Recursive Algorithms Type Direct Recursion: 簡單來說就是自己呼叫自己 Indirect Recursion: A calls B $\to$ B calls itself Boundary Condition Recursive algorithm是會停止的，如果他能夠寫出一個完整的通式或過程，就代表有上限，當達到這個上限時就會停止 :::spoiler Example :::
Application of Recursive Function Permutation Detailed description can browse the original video 如果不用Recursive解決Permutation的問題，可以考慮用For-Loop但是要考慮重複出現的問題 :::spoiler Example 在這個例子中boundary condition就是只剩下一個字元需要做排列的時候 :::</description></item><item><title>Lecture 4</title><link>https://bernie6401.github.io/data-structure/lecture-4/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/data-structure/lecture-4/index.html</guid><description>Lecture 4 tags: Data Structure NYCU Reference Lec04 資料結構 第三週課程
Note Array 用array表達一個多項式 $\to$ e.g.: $$ A(X)=3X^{20}+2X^{5}+4\ B(X)=X^{4}+10X^{3}+1 $$
Type 1 多項式的係數就是Array中存放的element，而指數代表Array的index 缺點： 如下圖的$A(X)$，如果有一個sparse的array，這樣開的空間就只會有兩個index有存放數值，其他就會被浪費掉 Type 2 老師表示回家自己看書
Type 3 用一個global array存放所有的多項式，以上圖為例，global array存放$A(X)$和$B(X)$，存放index和相對應的coefficient :::info How to implement? Refer to original video at timestamp 5:30 ::: :::danger 如果Global Array滿了怎麼辦?最簡單的作法是看前面有無可回收的多項式(寫在Descrutor) :::
Matrix 最簡單的就是直接declare一個2-dim的陣列，存放矩陣的element，缺點也和上面提到的sparse array一樣會有sparse matrix，如果太多index沒有存放東西，就會很浪費
Sparse Matrix Solution 直接紀錄該位置不是零的那些index的row和column就結束了(我也有想到)，排序是先看row再看column(1-dim的array) e.g. :::info 如何implement transportation?最簡單的做法就是row和column互換，再做排序(一樣是先依照row再看column) :::</description></item><item><title>Lecture 6</title><link>https://bernie6401.github.io/data-structure/lecture-6/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/data-structure/lecture-6/index.html</guid><description>Lecture 6 tags: Data Structure NYCU [TOC]
Reference Lec06 資料結構 第四週課程 [C/C++] C/C++ 箭頭(->) 、點(.)、雙冒號(::) 用法
Rewind String Matching Task 最笨的作法是一個字元依依比對 KMP Algorithm 有沒有可能一次不要只移動一個字元， 又充分利用已經比對過的資訊進行位移 原理 運用到的就是建立一個Failure Function，如下圖為例，在index=5的地方failure function是3，代表從index=5往回看3個字元，會和整個字串的開頭往後看3個字元會相等 這樣的話就可以快速的移動比對的字串，例如下圖，index i和j不相等，則可以往回看j-1的failure function儲存的相等字元有多少，如果是3代表可以直接移動到P到相等字元的地方(也就是p[3+1]的地方開始比對)，也就是粉紅色的地方對齊，這樣的話就可以移動不只一個字元</description></item><item><title>Lecture 8</title><link>https://bernie6401.github.io/data-structure/lecture-8/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/data-structure/lecture-8/index.html</guid><description>Lecture 8 tags: Data Structure NYCU Reference &amp; Background Lec08 資料結構 第五週課程 C語言: 超好懂的指標，初學者請進～
Note Rewind Array 之前提到Array的結構，其缺點是大小是固定的，但有時候需要儲存的東西可能是動態改變的，且沒有用到的空間就會變成一種浪費 Solution 此時就可能可以考慮用Link-List的結構處理這樣的資料 Link-List 主要結構 每一個Element都會有兩個儲存單位，一個是儲存資料本體，另一個是儲存pointer，指向下一個Element的位置 Insert GAT Create新的node，儲存GAT，並改變前後的指標，原本FAT的指標要assign給GAT的pointer，然後GAT的位址也要assign給FAT Delete GAT 把HAT的位址assign給FAT 缺點：如果要delete某一個Element就需要"先找到該Element的位置在哪裡"，如果Link-List 很長，則要做到這件事情的Overhead就會很高 Solution: Double-Link-List，可以從前後同時找要刪除的Element，這樣的話就會比較快 Implement :::spoiler Source Code - Composite Classes
class ThreeLetterList; // forward delcanon class ThreeLetterNode { friend class ThreeLetterList; private char data[3]; // 每一個Elment就是只有儲存三個字元 ThreeLetterNode *link; }; class ThreeLetterList{ public: // List Manipulat10n operabons private: ThreeLetterNode *first; }; :::</description></item></channel></rss>