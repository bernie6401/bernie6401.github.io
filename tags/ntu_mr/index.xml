<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>NTU_MR :: Tag :: SBK Hugo Site</title><link>https://bernie6401.github.io/tags/ntu_mr/index.html</link><description/><generator>Hugo</generator><language>en-us</language><atom:link href="https://bernie6401.github.io/tags/ntu_mr/index.xml" rel="self" type="application/rss+xml"/><item><title>NTU Malware Reverse Final Project Notes</title><link>https://bernie6401.github.io/security/course/ntu-mr/ntu-malware-reverse-final-project-notes/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-mr/ntu-malware-reverse-final-project-notes/index.html</guid><description>NTU Malware Reverse Final Project Notes tags: NTU_MR Malware Reverse Engineering and Analysis Deep learning at the shallow end Malware classification for non-domain experts How to reproduce? Construct Environment The whole construction step can see 安裝 tensorflow 及 cuda cudnn 心得. Refer to documentation for tensorflow, I choose the library shown as below…
Object CUDA cuDNN Python GPU Driver Version tensorflow tensorflow-gpu Version 11.2 8.1 3.6.13 526.98 2.6.2 2.6.0 Then refer to NVIDIA CUDNN DOCUMENTATION, just use zlibwapi.dll provided by this page directly. This compressed folder is for x64 processor. Notice that, DO NOT USE this page and this page. These are for x86 processor.</description></item><item><title>NTU Malware Reverse HW 1 write up</title><link>https://bernie6401.github.io/security/course/ntu-mr/ntu-malware-reverse-hw-1-write-up/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-mr/ntu-malware-reverse-hw-1-write-up/index.html</guid><description>NTU Malware Reverse HW 1 write up tags: NTU_MR Malware Reverse Engineering and Analysis NTU [TOC]
Task 1 Analyze the Lab06-01.exe What is the major code construct found in the only subroutine called by main? Ans: It has only an if statement in the main function. What is the subroutine located at 0x40105F? Ans: It’s just a printf function. At the beginning, I can not recognize this code block do exactly until I analyze the program behavior by using string side bar to search the specific string in the code.</description></item><item><title>NTU Malware Reverse HW 2 write up</title><link>https://bernie6401.github.io/security/course/ntu-mr/ntu-malware-reverse-hw-2-write-up/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-mr/ntu-malware-reverse-hw-2-write-up/index.html</guid><description>NTU Malware Reverse HW 2 write up tags: NTU_MR Malware Reverse Engineering and Analysis NTU [TOC]
Task 1 執行勒索病毒Dharma與Process monitor並截圖Dharma的Process Tree，並分析說明每個Process行為 Ans:
Conhost.exe: It’s defined by Microsoft and is normally legal and safe. Working on Win7, Win8, and Win10. The main function of this PE file is to let Command Prompt and Windows File Explorer can interact. The other function is to support users who can drag the file or folder to the command prompt directly. Most of the time, it’s a safe file that even repeats execution many times. However, in some circumstances, the viruses will pretend a conhost.exe file to use massive memory or store it in the wrong folder.[1]</description></item><item><title>NTU Malware Reverse HW 3 write up</title><link>https://bernie6401.github.io/security/course/ntu-mr/ntu-malware-reverse-hw-3-write-up/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-mr/ntu-malware-reverse-hw-3-write-up/index.html</guid><description>NTU Malware Reverse HW 3 write up tags: NTU_MR Malware Reverse Engineering and Analysis [TOC]
Name 何秉學 StuID R11921A16 Task 1: Lab 15-01.exe Observation When I execute the file, it print out a message: Son, I am disappoint. Refer to the description below, I must enter some parameter that match the secret code.
Analyze the sample found in the file Lab15-01.exe. This is a command-line program that takes an argument and prints Good Job! if the argument matches a secret code.</description></item><item><title>NTU Malware Reverse Lab 1 write up</title><link>https://bernie6401.github.io/security/course/ntu-mr/ntu-malware-reverse-lab-1-write-up/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-mr/ntu-malware-reverse-lab-1-write-up/index.html</guid><description>NTU Malware Reverse Lab 1 write up tags: NTU_MR Malware Reverse Engineering and Analysis NTU Name 何秉學 StuID R11921A16 WannaCry Change variable and data type Follow the video and replace most of the variable that ghidra did not recognize and retype them also. According to the video, you must search the entry point function(local_6c = FUN_00408140();) first and replace the signature by here Then click into WinMain function and you’ll see a strange url at the beginning of the top. Try to rename and retype it as char*. Ghidra can not recognize InternetOpenA, and InternetOpenUrlA. But you can found that ghidra cannot recognize hinternet datatype as well. So, we must create new datatype in Datt Type Manager. And in write_1831_to_tasksche.exe function, the first if-statement has 4 variable that ghidra can’t recognize, including createProcessA, _createFileA, _writeFile, _closeHandle. So, you’re not only rename them but retype them for the following statement for each of them.(Ghidra has all type of them but it just can not recognize.) When you have 1831.bin file(you can follow Analyze part at 5-th and 6-th section), useing Defined String window to check out some function including unzip_something function. Scroll down the Defined String, you’ll see string 13AM4VW2dhxYgXeQepoHkHSQuy6NgaEb94 at 0x0040f488. Then in assembly code, there’re 3 similar function be called at the sametime. We called it bitcoin_something function. Analyze For the first part to analyze, you can check out for loop after strange_url variable. It does this loop for 14 times and copy strange_url to strange_url_copy by andding 4. Next, you can find an if statement at the below. Check this out carefully, it the internet request failed, it’ll access wannacry_real_entry() function. Enter to wannacry_real_entry function, you’ll see another if statement to examine your argument input. If you keyin less than 1 argument, it’ll execute no_argument_handler function and start create_wannacry_service function. Checking wannacry program in second function of no_argument_handler function by assembly language, you’ll find there’re two sprintf structure are not correct in the middle paragraph. Because, there’re two more argument should be pushed in stack but not be recognized by ghidra, including s_tasksche.exe_0043136c and 0x00407dea and s_WINDOWS_00431367 at 0x00407df2. So, we have to override this line signature and add the remaining argument back to sprinf. So, let’s take a look at this flow chart of what happened so far Then I used another VM(Ubuntu) to command wrestool to analyze wannacry file and output another file named 1831.bin. Using ghidra to analyze this file. Then do the same thing as above that what we do to analyze wannacry file such as change WinMain signature or renamee variable or retype variable, etc. While you’re analyzing in WinMain function, you’ll see a strange variable &amp;_Str2_0040f538 which store ‘/i’ characters. You can just press ‘c’ in assembly code to show ‘\i’. Next, scroll down this file, you’ll see a strange swprintf parameter called _Count_0040f40c. Then select all addr type data and right click mouse and select clear with option. You’ll see many unicode strings. Finally, right click DAT_0040f40c and choose Data/TerminatedUnicode. Finally, you can check this figure to know the whole operation flow 1.1 What is the ‘killswitch’ string? Ans: http://www.iuqerfsodp9ifjaposdfj 1.2 What is the unzip password? (as show in below) Ans: WNcry@2o17</description></item><item><title>NTU Malware Reverse Lab 2 write up</title><link>https://bernie6401.github.io/security/course/ntu-mr/ntu-malware-reverse-lab-2-write-up/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-mr/ntu-malware-reverse-lab-2-write-up/index.html</guid><description>NTU Malware Reverse Lab 2 write up tags: NTU_MR Malware Reverse Engineering and Analysis NTU Name 何秉學 StuID R11921A16 Analyze the malware 1 found in the file Lab13-02.zip -> Lab13-02.exe, generate ‘yourself’ write ups (with screenshots) and answer the follow questions : 1.1 Using dynamic analysis, determine what this malware creates. Ans:
According to reference, you can also use procmon(Process Monitor) to monitor the whole progress after executing this file. The progress of first iteration is shown as below Then use PEiD to check if the file has shell or not. And refer to the result as below, it seems has not shell, so that we can use IDA directly. I used IDA to analyze this executable file and observe that it’ll execute sub_401851 function every 10 seconds. And when I execute it in VM, it’ll create a temp file name temp00XXXXXX. int __cdecl main(int argc, const char **argv, const char **envp) { while ( 1 ) { Sleep(5000u); sub_401851(); Sleep(5000u); } } 1.2 Use static techniques such as an xor search, FindCrypt2, KANAL, and the IDA Entropy Plugin to look for potential encoding. What do you find?(Install findcrypt and IDA Entropy plugin can refer to Appendix 1, 2) Ans:</description></item><item><title>NTU Malware Reverse Lab 3 write up</title><link>https://bernie6401.github.io/security/course/ntu-mr/ntu-malware-reverse-lab-3-write-up/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-mr/ntu-malware-reverse-lab-3-write-up/index.html</guid><description>NTU Malware Reverse Lab 3 write up tags: NTU_MR Malware Reverse Engineering and Analysis NTU [TOC]
Name 何秉學 StuID R11921A16 Review Packing and Unpacking How does packing and unpacking work? 作者會把原本的code section和data section，放在UPX1，並且用unpacking stub(裡面存放解殼的程式)，把UPX1的內容一點一點的還原回UPX0(也就是空區段)，並跳回正常程式的執行進入點(original entry point, OEP)，最後跳回去的動作叫做Tail Jump或Long Jump，另外，多長的jump才是長，可能要依照經驗值判斷，或是直接跳過去後分析程式在幹嘛 實際上執行脫殼的時候，除了OEP的重建外，還需要重建Imports，這兩者都處理好後才算是脫殼完成 當分析脫殼執行到如下圖這樣的情況時，就離終點不遠了，也就是jmp的地址離目前的程式很遠，且之後的程式有很多空指令或垃圾byte，此為UXP殼的特徵 可以用PEiD這個工具(或是用Entropy之類的，但是不一定準確)判斷樣本有沒有加殼，或是加了甚麼殼，上圖是沒有加殼的一般程式，下圖是加了UPX的加殼程式 若是要處理Import Table Reconstruction，可以用OllyDump、ImpRec或是Scylla這些工具來進行，在Practice中是用Scylla演示(且可以搭配x32dbg或x64dbg進行) 老師有說在Long Jump之前會搭配pop instruction，這可能可以當作解析OEP的線索 Tail Jump，不一定是用jmp，也可以是call instruction；另外，跳轉的地址也不一定是一個明確的地址，也可能用暫存器存起來，這部分可以注意一下 Practice - upx_exercise.exe Observation First things first, we can observe the file by executing it directly. Obviously, you should enter correct CTF key by analyzing. Unpacking Static analysis - IDA Pro You are not allowed to disassembly by doing nothing, because it was packed by UPX. Therefore, our objective is to unpack it and try to analyze it original code to get the CTF Flag. Dynamic analysis - x32dbg In UPX-based packing, it has a feature that in order to not let the data be flushed during unpacking, it must store all data to the stack by using pushad instruction. Then, you’ll see a lot of jmp instruction to unpack the original code. Scrolling down the code, you’ll see a popad instruction at 0x0134AEDE , a jmp instruction at 0x010EAEEC, and a lots of null instruction which all three are satisfied all features that UPX-based packing method has. It’ll restore all data that stored in stack and jump to upx_exercise.134244D. Set the break-point and press run button in x32dbg, then press step into button to observe the code. Now, the code has already unpacked, then we can use Scylla to do Import Reconstruction. Press IAT Autosearch(Import Address Table) button to search and then press Get Imports button. Finally, you will get all imports that this file used, and Scylla will help you to rebuild it. Press Dump button to get IAT file. Press Fix Dump and choose the file what we dump to reconnect the IAT and this file. You’ll see the log said Import Rebuild success and you’ll get a new file named upx_exercise_dump_SCY.exe that repaired by Scylla. Analyze Re-static analysis - IDA Pro Used IDA to reanalyze the unpacking file. Used string searching to find the string nope that appear in your cmd. Used cross reference to find which part has used it. The main part is shown as below ... sub_E01EB0(std::cin, &amp;Memory); LOBYTE(v116) = 1; MEMORY[0] = 0; v96 = 0xFCC1D3C4; v97 = 0xD8D2C8DE; v98 = 0xD8D3E8E0; v99 = 0xD8C2EFB0; v100 = 0xC2ECB3C1; v101 = 0xB3EBE1D8; v102 = 0xD5F3D8BE; v103 = 0xB3EFD8DE; v104 = 0xF5C2E3D5; v105 = 0xFAD6D6D8; v64 = 1; HIBYTE(v95) = 1; v65 = 0; v93 = 0; while ( v65 &lt; 40 ) { v66 = (char *)&amp;Memory; if ( v111 >= 16 ) v66 = (char *)Memory; v67 = v66[v65] ^ 0x87; v68 = *((unsigned __int8 *)&amp;v96 + v65); v94 = 0; if ( v67 != v68 ) v64 = v94; HIBYTE(v95) = v64; v93 = ++v65; } v69 = "Congratz?!"; if ( !v64 ) v69 = "Nope!"; ... From v96 to v105, it stored 40 bytes and it seems do something in while loop 40 times. In addition, v67 = v66[v65] ^ 0x87; this line used xor instruction that seems a encrypt part. And then it compared &amp;v96 + v65 and v67 that encrypt the string what you input. If all the strings you input after process xor to 0x87 are strictly the same with v96 to v105, then it’ll print Congratz?!, otherwise, print Nope. Used online_xor to get v96 to v105 encrypted strings. And then used online_hex2ascii to get the CTF Flag. The answer is **CTF{YOU_goT_7hE_F4kE_fl49_tRY_h4RdEr_QQ}**, though it is not a real answer. Note that, the demo from TA is finished, therefore, I still don’t know the real flag is. Homework - upx_Revil.exe Static Analysis Observation Use IDA to analyze this sample and obviously packed sample Use the skill above then you can answer the question easily. Homework - custom_packer_Revil.exe Static Analysis Observation - DetectItEasy Though I used the tool, DetectItEasy to check if this sample was packed or not, the answer is not quite explicit.</description></item></channel></rss>