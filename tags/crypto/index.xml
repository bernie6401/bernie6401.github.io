<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Crypto :: Tag :: SBK Hugo Site</title><link>https://bernie6401.github.io/tags/crypto/index.html</link><description/><generator>Hugo</generator><language>en-us</language><atom:link href="https://bernie6401.github.io/tags/crypto/index.xml" rel="self" type="application/rss+xml"/><item><title>Crypto Cheat Sheet</title><link>https://bernie6401.github.io/tools/ctf/crypto-cheat-sheet/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/tools/ctf/crypto-cheat-sheet/index.html</guid><description>Crypto Cheat Sheet Online Tools - Classic Crypto Complex Substitution Cipher Vigenère Cipher CyberChef Substitution Cipher Solver Tool Known Key Python - pycipher libraryonline - Vigenère cipherCAP4 quipqiup Unknown KeyVigenère Cipher CodebreakerVigenere Solver RSA相關攻擊 其實整裡的文章內容都差不多
【技術分享】CTF中RSA的常見攻擊方法 Mod相關攻擊 CTF RSA Coding Tools 大數運算: gmpy2/sage math online - cocalc/sage math online - sagecell/WolframAlpha:這是一個線上的搜索引擎，但凡和數學相關的都能進行運算，使用解說可以看這裡 $ sudo apt install sagemath # or $ conda create --name sageenv sage=10.0 -c conda-forge -y # just only for wsl --- # 想要在sage中安裝python library $ sage -pip install {library name} :::spoiler To address Discrete Log Problem p = 117635180960139721127318189832610714114593440637486157582828661167364276581210599344857316369131977790468647533227778603367761815400416396281259234299247850289710613080530669849409358755399675041263469367135430665518150110493389671646158566214130516002949975036799297119111385228596853422400303735447298026283 q = 163800729847029979711295941089800020300275211671661376396219775666688832353701752860857691086339595920419175562271802936423756228938551439950541873798393442729921516031775531740506399414675546114663346731428381174638773512946351966471041847661507898143967764453261943807056370639171597924004988320983393199599 c = 0x8788542cefd7490c9282c06b8d24280d56c6706b996bdf580290cdf2cb90e45efd2ce185fc07d2b916c24b0512d38ca14de0ee608a9d6003f258859bbbed97dad15c1d07410a34fd55cd8305eb43418d38f1ca6e024725b97fd9da701a39c23fe55a13d43b4bf9a3d9ebb44d7fe67bd60beffc29ec27bb4baf05ec5b250bfa68360df0d1379c066297a7878e59d27e68cf6a0da90755450827623e54e4f3d9f280fef53c7620d58decfbd10dd64e9d1d5507b5460603c58f5be70c82e2a8e613d730a950caea4c4389c5fc0521f8207ead5fb26c04eb6d0486fd6fe8d015fdabbda00139b42163acc86ffb30c12988058c6247344c42b8f3cdc984c06f4276f8 g = Mod(3,p) m = discrete_log(c,g) print(hex(m)) g2 = Mod(3,q) m2 = discrete_log(c,g2) print(m2) print(hex(m2)[2:]) ::: Crypto常用library: pycryptodom $ pip install pycryptodome :::spoiler pycryptodome generate PEM file >>> from Crypto.PublicKey import RSA >>> n = 0xb4f98200f1309e8a486824051051ac80790f8e66dac4744e2ce5134fb432121f41c5471e3459d01e56e64befd2034c65eb300ebf0045342221bff206b6cdda7f3349c17b08563a576731f95a64e2f00af70b5cbb2f4f388d49ce82da76ca609a6ec1529f29b0fa0bedc5764b86472e2c5ac5198cedb6f5e1e8e0ca950ea11bc4cf5e5a0497db3ad96f5a745cf902d56be394a259068fe198bc9de8fe8d034a71013f46c2ac72451211eb1127286c19467eaf3a10049942d46b0f49f3c51c01c06a2f8c94416cc1aadaeb191de959f0241ce8f32575c848bd2f4f8f84dab46e2aa7ad45de1c6060fbbee9668f8e9cb6d366b8cd6ce99f78bbef145f2b7b7e5222f762ccb95f17b1538260c2ea45571061b0d873fbe60d61dd87aa4833ac71b802f2b91d30f38e30ae9da39fbd1c53e80496f511521285b3bb1da3dc79931463d278d1fe28a77880a9f2368029c4cefffebbbd6904f85291b3606d0b5ed3efd8c1ee14538dc051274665f4b0f55d6c6e12d2cb728ac15f7a6572b71a5bd6fa01bddb0af211091bff4c8ec7e93efae4654b2abae09e35be29afbfc3f4df8e4348c525b9d8662a1ac344dadb15b953905f639b48fec7cfcfdf27cc0ad82b936d5efe7c0d891bf9752d3fb0857d38337df033e4b681d19ec8603535504d05a421036c077694482eee919a44b3296e2a4c272cbf7bbf14b6d62eb194e4ee83ba227fed >>> e = 0x10001 >>> d = 0x737efcd1df1b7942a53d1927c62769a0c022066e6bd58ea8498c948b7c63ac1f18996f6ebe584732e5a0a9fbce9ade49f913bd857605b464c80738cdc22293fc33de314574a79b2a26a8c50b447174627b115c47f5c46841fb45794b351ea91245f6c8e4dcf59e4eb89b1988cf9463ca58cf8b23de9db2444f9c0e8d9c3d837c521f53f1b47c6c0d523c7720d2a655503a78a4378eb18a773080d2ae898dfd172b8597822c0ded38c008b5f4b89e6c6f09f0886caa92a90ce99a6346d897ac2281620124a8b060d4ca4bd9c6b622f8d8033f43d5b75a6fd994f50091f805c87d1e6fbdb42785f6bf1332df8a64a86d21736023720b9303b964b62a9a9480a4a7ab5fac794f583109d5663998ccc893590ebe26ae076e17c2b93c2238106612094fd4c6a56ec84ca5fa6ee3608ba3422f931828772e6732c337fcd6d4e6cb4a907d2e978227423d783c112f7a7d3e6d7c91ac7c540f0095d39842a6be534321a67d7a3fcb1c62c0f9e8a6d6e10281e10ff957449770d19f939153692c73f940450eab03f58ef55d2adf98c3f8479d05bb02997667381d3583c8f0eba6ea91bce512b001a27788309a4aa15952c73572a329b2f3acd6a11f43e3ae00532ccfbe9f157702162b534d26ca1e668d4cdbfd0116b7cb724603ea99e8aa08c90410534dd681b59350542c59523cb1259428e05e1fe0aab479c4b5af2a44d18ef713cd61 >>> p = 0xd73e2ef8f2e4f1de44ee80070beef39943d4fa89a7a7ab4b0061e851aca7deb4f717f2baf4a0c018f3dcdab92148596bc50800fd6eb2f2e7757e0343534aea2241f0a2d34795a08f8e5ccc7959184b9cf8e3007a8ad63acd7d4b350dbf2d4caf04f4bc98d74a3b01d3b1aced745133186fd8460a2dff536a74ee4d041c988d5743cc9355144f48fe5f52db0449a46ba7c15c04001a5cb141796b5b42d9d72c36cca6d6bb8f177aee1699a47ba5d87c7ee886467af18403dbd84e102a952ebee03cc70bcf072c26b1b1f0f5094be08470c6c1769b417feffd5c89a0c373f75a350d177309618bfeb16316c660c6b2a341a984c8845081ede7c42e22cc9272aa15 >>> q = 0xd73e2ef8f2e4f1de44ee80070beef39943d4fa89a7a7ab4b0061e851aca7deb4f717f2baf4a0c018f3dcdab92148596bc50800fd6eb2f2e7757e0343534aea2241f0a2d34795a08f8e5ccc7959184b9cf8e3007a8ad63acd7d4b350dbf2d4caf04f4bc98d74a3b01d3b1aced745133186fd8460a2dff536a74ee4d041c988d5743cc9355144f48fe5f52db0449a46ba7c15c04001a5cb141796b5b42d9d72c36cca6d6bb8f177aee1699a47ba5d87c7ee886467af18403dbd84e102a952ebee03cc70bcf072c26b1b1f0f5094be08470c6c1769b417feffd5c89a0c373f75a350d177309618bfeb16316c660c6b2a341a984c8845081eded2ff580f9f582ac79 >>> key_params = (n, e, d, p, q) >>> key = RSA.construct(key_params) >>> f = open('./rsaprivatekey.pem', 'w') >>> f.write(key.exportKey().decode()) >>> f.close() ::: openssl - RSA(很清楚) :::spoiler Cheat Sheet '''AES / DES''' $ openssl des-ecb –e –in xxx.txt –out yyy.out –k password (DES encrypt) $ openssl des-ecb –d –in yyy.out –out xxx.txt –k password (DES decrypt) $ openssl des-ede3 –d –in yyy.out –out xxx.txt –k password (TDES encrypt) $ openssl aes-128-ecb –d –in yyy.out –out xxx.txt –k password (AES decrypt) '''RSA''' $ openssl genrsa –out rsa_privatekey.pem –passout pass:password –des3 1024 # (generate RSA private key) $ openssl rsa –in rsa_privatekey.pem –passin pass:password –pubout –out rsa_publickey.pem (generate RSA public key) $ openssl rsautl –encrypt –pubin –inkey rsa_publickey.pem –in xxx.txt –out yyy.txt # (use public key to encrpt) $ openssl rsaut –decrypt –ik i k n ey rsa_privatekey.pem –in yyy.txt –out xxx.txt # To print out the components of a private key to standard output $ openssl rsa -in key.pem -text -noout # 把certificate轉成pem file $ openssl openssl x509 -in cert -pubkey -noout -----BEGIN PUBLIC KEY----- MCIwDQYJKoZIhvcNAQEBBQADEQAwDgIHEaTUUhKxfwIDAQAB -----END PUBLIC KEY----- # 把單純public key的內容(n, e)(就是上面的東西)印出來 $ openssl rsa -pubin -in public.pem -text RSA Public-Key: (53 bit) Modulus: 4966306421059967 (0x11a4d45212b17f) Exponent: 65537 (0x10001) writing RSA key -----BEGIN PUBLIC KEY----- MCIwDQYJKoZIhvcNAQEBBQADEQAwDgIHEaTUUhKxfwIDAQAB -----END PUBLIC KEY----- // 產出私鑰 openssl genrsa -out key.pem 2048 // 用同一把私鑰，產出兩組不同的憑證 openssl req -x509 -new -key key.pem -sha256 -nodes -keyout key.pem -out cert1.pem -days 30 openssl req -x509 -new -key key.pem -sha256 -nodes -keyout key.pem -out cert2.pem -days 30 // 顯示公鑰是一樣 openssl x509 -pubkey -noout -in cert1.pem openssl x509 -pubkey -noout -in cert2.pem // 顯示憑證內容是不一樣 openssl x509 -inform pem -in cert2.pem openssl x509 -inform pem -in cert1.pem ::: Factoring Tools Factor DB Yafu Prime Factorization Online</description></item><item><title>NTU CS 2023 HW1 Write Up</title><link>https://bernie6401.github.io/security/course/ntu-cs/crypto/ntu-cs-2023-hw1-write-up/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-cs/crypto/ntu-cs-2023-hw1-write-up/index.html</guid><description>NTU CS 2023 HW1 Write Up Name: 何秉學 Student ID: R11921A16 :::spoiler TOC [TOC] :::
Lab-COR Flag: FLAG{Corre1ati0n_Attack!_!}
解題流程與思路 這一題是簡單的padding oracle attack，他一樣是應用在CBC mode上，只是他padding的方式和上課教的有一點不一樣，他會先在最後放一個0x80然後接續放0x00直到長度%16==0，同樣的，我們可以用上課教的方式:
What we have: 我們有的東西就是密文，所以可以利用它動一些手腳 Our Goal 1: 目標是要取得原本和47進行XOR的數字是多少 Our Goal 2: 這樣才可以取得最後的明文69 How to achieve: 我們可以簡單猜一個byte，從0x00開始，把密文換成猜測的byte，這樣256種組合和原本的Goal 1所求的byte進行XOR後會padding正確(也就是0x01)，此時假設我們已經猜到目前是0x2f符合padding正確的目標，代表現在的假明文是0x01，則原本和0x47進行XOR的數字就是0x01⊕0x2f，然後我們就可以回到原本解密的流程，也就是原本的密文0x47⊕剛剛得知的(0x01⊕0x2f)，就會得到想要的正確的明文0x69 所以套用到今天的lab意思也是一樣，如果要知道padding是否正確可以問oracle，反正只要符合明文+0x80+(0…15)*0x00，這一題的flag長度可以從題目給的ciphertext看出來，顯然扣掉16bytes的initial vector後，flag的長度是32 bytes，也就是說我們從第二個block開始解，我們可以單獨把第一個ciphertext block當成第二個ciphertext block的initial vector，合併後再一起送出去，然後不斷變化IV的最後一個byte，如果oracle回傳Well received :)代表第一個bytes猜對了，我們就可以把flag的最後一個bytes求出來$\to$我們猜的byte⊕原本ciphertext的最後一個byte⊕0x80(0x80是我們判斷padding正確的依據)，當然找到真正的plaintext byte後要把我們猜測的block恢復原狀，接著繼續找下一個byte
Lab-LSB Flag: FLAG{Viycx_qsklsjgmeld_fgd_spkgjo}
解題流程與思路 這一題是變形過的Lease Significant Bit，上課教的例子是mod 2下的結果，而看source code可以知道目前他是mod 3下的結果，但換湯不換藥，只要把上課教的部分全部換成mod 3就可以了</description></item><item><title>PicoCTF - AES-ABC</title><link>https://bernie6401.github.io/security/practice/picoctf/crypto/des-aes/picoctf---aes-abc/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/practice/picoctf/crypto/des-aes/picoctf---aes-abc/index.html</guid><description>PicoCTF - AES-ABC tags: PicoCTF CTF Crypto Background What is PPM file?
Source code :::spoiler Source Code
#!/usr/bin/env python from Crypto.Cipher import AES from key import KEY import os import math BLOCK_SIZE = 16 UMAX = int(math.pow(256, BLOCK_SIZE)) def to_bytes(n): s = hex(n) s_n = s[2:] if 'L' in s_n: s_n = s_n.replace('L', '') if len(s_n) % 2 != 0: s_n = '0' + s_n decoded = s_n.decode('hex') pad = (len(decoded) % BLOCK_SIZE) if pad != 0: decoded = "\0" * (BLOCK_SIZE - pad) + decoded return decoded def remove_line(s): # returns the header line, and the rest of the file return s[:s.index('\n') + 1], s[s.index('\n')+1:] def parse_header_ppm(f): data = f.read() header = "" for i in range(3): header_i, data = remove_line(data) header += header_i return header, data def pad(pt): padding = BLOCK_SIZE - len(pt) % BLOCK_SIZE return pt + (chr(padding) * padding) def aes_abc_encrypt(pt): cipher = AES.new(KEY, AES.MODE_ECB) ct = cipher.encrypt(pad(pt)) blocks = [ct[i * BLOCK_SIZE:(i+1) * BLOCK_SIZE] for i in range(len(ct) / BLOCK_SIZE)] iv = os.urandom(16) blocks.insert(0, iv) for i in range(len(blocks) - 1): prev_blk = int(blocks[i].encode('hex'), 16) curr_blk = int(blocks[i+1].encode('hex'), 16) n_curr_blk = (prev_blk + curr_blk) % UMAX blocks[i+1] = to_bytes(n_curr_blk) ct_abc = "".join(blocks) return iv, ct_abc, ct if __name__=="__main__": with open('flag.ppm', 'rb') as f: header, data = parse_header_ppm(f) iv, c_img, ct = aes_abc_encrypt(data) with open('body.enc.ppm', 'wb') as fw: fw.write(header) fw.write(c_img) :::</description></item><item><title>PicoCTF - Compress and Attack</title><link>https://bernie6401.github.io/security/practice/picoctf/crypto/picoctf---compress-and-attack/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/practice/picoctf/crypto/picoctf---compress-and-attack/index.html</guid><description>PicoCTF - Compress and Attack tags: PicoCTF CTF Crypto Background zlib compression property 詳細說明一下zlib的壓縮特性是當壓縮的內容出現重複字元的時候，壓縮過後的長度會不變 >>> import zlib >>> enc = zlib.compress(bytes("picoCTF{picoCTF{testing_123456}".encode("utf-8"))) >>> len(enc) 33 >>> enc = zlib.compress(bytes("picoCTF{tepicoCTF{testing_123456}".encode("utf-8"))) >>> len(enc) 33 >>> enc = zlib.compress(bytes("picoCTF{tekpicoCTF{testing_123456}".encode("utf-8"))) >>> len(enc) 34 此時重複的部分就是picoCTF{，若是繼續增加重複的部分(例如：picoCTF{te)，壓縮後的長度也不會變，這樣就可以當作一個oracle，也就是利用長度來判斷增加的字元是不是flag重複的一部分
Source code :::spoiler
#!/usr/bin/python3 -u import zlib from random import randint import os from Crypto.Cipher import Salsa20 flag = open("./flag").read() def compress(text): return zlib.compress(bytes(text.encode("utf-8"))) def encrypt(plaintext): secret = os.urandom(32) cipher = Salsa20.new(key=secret) return cipher.nonce + cipher.encrypt(plaintext) def main(): while True: usr_input = input("Enter your text to be encrypted: ") compressed_text = compress(flag + usr_input) encrypted = encrypt(compressed_text) nonce = encrypted[:8] encrypted_text = encrypted[8:] print(nonce) print(encrypted_text) print(len(encrypted_text)) if __name__ == '__main__': main() :::</description></item><item><title>PicoCTF - corrupt-key-1</title><link>https://bernie6401.github.io/security/practice/picoctf/crypto/rsa/picoctf---corrupt-key-1/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/practice/picoctf/crypto/rsa/picoctf---corrupt-key-1/index.html</guid><description>PicoCTF - corrupt-key-1 tags: PicoCTF CTF Crypto Source code private.key -----BEGIN RSA PRIVATE KEY----- MIICXAIBAAKBgQC4yxzKmbasQYdsGIRXMqXL/Idd80bukALOYIUItfz2tgpax3Iq LWTvdOFEOjOOcKc+Y6MD86ya3xmFlWmfbp8wwAnSGcfZjE7IQgNhCDQCnHlWfvwI 9mtLw/Vkv7VxVGoGt+SPs1u5zOqaLNRDSfgpJCB436ZNUlknv9VdCZwCTwIDAQAB AoGAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACQQDnAFaP9Qa9WJKv klkhJeBsvpvUXf6v6TGjM8E0YwI9TwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA AAAAAAAAAkEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAJBAAAAAAAAAAAAAAAAAAAAAAAAAAAA AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACQAAA AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA AAAAAAAAAAAAAAAAAAACQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA= -----END RSA PRIVATE KEY----- msg.enc 71dc d160 9ac4 a05c d14f 04a9 b43c 2aa3 83d2 a8d6 749b b978 75d5 437a a944 45f2 4073 f605 ef1c 5657 8d0e 7a2d f3be b5c1 7741 8476 0b3d 44fc b97e 6631 b6fe 2487 6258 d445 a7d7 4c7c e3cc 00ec f925 f442 c91d 10c9 cefb 9ca6 9c88 da3c 9d26 6c96 9033 63d5 6a13 7b64 1fc3 8709 2416 f7fb eb4c 4c94 cc8e 157f cc0e d122 159c 27d5 Recon 可見private.key的內文被corrupted了，必須要修復才能夠解密ciphertext，但看來看去也找不到相關的write up，或是修復的方法，從連結這篇write up也看不懂如何修復，雖然他有附上code，但是很多error也無法debug(主要是看不懂)，總而言之我們的目標就是找出$p$為何</description></item><item><title>PicoCTF - Dachshund Attacks</title><link>https://bernie6401.github.io/security/practice/picoctf/crypto/rsa/picoctf---dachshund-attacks/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/practice/picoctf/crypto/rsa/picoctf---dachshund-attacks/index.html</guid><description>PicoCTF - Dachshund Attacks tags: PicoCTF CTF Crypto Background How about if the private key is too small? Refer Extending Wiener’s Attack Exploit - Small Private Key git clone https://github.com/pablocelayes/rsa-wiener-attack Put the exploit file in this repo. Whole Exploit from pwn import * from Crypto.Util.number import long_to_bytes import ContinuedFractions, Arithmetic context.arch = 'amd64' r = remote("mercury.picoctf.net", 37455) def wiener_hack(e, n): # firstly git clone https://github.com/pablocelayes/rsa-wiener-attack.git ! frac = ContinuedFractions.rational_to_contfrac(e, n) convergents = ContinuedFractions.convergents_from_contfrac(frac) for (k, d) in convergents: if k != 0 and (e * d - 1) % k == 0: phi = (e * d - 1) // k s = n - phi + 1 discr = s * s - 4 * n if (discr >= 0): t = Arithmetic.is_perfect_square(discr) if t != -1 and (s + t) % 2 == 0: print("Hacked!") return d return False r.recvline() e = int(str(r.recvline().strip().decode()).split(" ")[-1]) n = int(str(r.recvline().strip().decode()).split(" ")[-1]) c = int(str(r.recvline().strip().decode()).split(" ")[-1]) d = wiener_hack(e, n) print(long_to_bytes(pow(c, d, n))) r.interactive() Reference CTF_RSA解密学习指南(三) - 低解密指数攻击</description></item><item><title>PicoCTF - Double DES</title><link>https://bernie6401.github.io/security/practice/picoctf/crypto/des-aes/picoctf---double-des/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/practice/picoctf/crypto/des-aes/picoctf---double-des/index.html</guid><description>PicoCTF - Double DES tags: PicoCTF CTF Crypto Background Meet in the middle attack Source code :::spoiler
#!/usr/bin/python3 -u from Crypto.Cipher import DES import binascii import itertools import random import string def pad(msg): block_len = 8 over = len(msg) % block_len pad = block_len - over return (msg + " " * pad).encode() def generate_key(): return pad("".join(random.choice(string.digits) for _ in range(6))) FLAG = open("flag").read().rstrip() KEY1 = generate_key() KEY2 = generate_key() def get_input(): try: res = binascii.unhexlify(input("What data would you like to encrypt? ").rstrip()).decode() except: res = None return res def double_encrypt(m): msg = pad(m) cipher1 = DES.new(KEY1, DES.MODE_ECB) enc_msg = cipher1.encrypt(msg) cipher2 = DES.new(KEY2, DES.MODE_ECB) return binascii.hexlify(cipher2.encrypt(enc_msg)).decode() print("Here is the flag:") print(double_encrypt(FLAG)) while True: inputs = get_input() if inputs: print(double_encrypt(inputs)) else: print("Invalid input.") :::</description></item><item><title>PicoCTF - Easy Peasy</title><link>https://bernie6401.github.io/security/practice/picoctf/crypto/classic/picoctf---easy-peasy/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/practice/picoctf/crypto/classic/picoctf---easy-peasy/index.html</guid><description>PicoCTF - Easy Peasy tags: PicoCTF CTF Crypto Challenge: Easy Peasy
Background Source code :::spoiler source code
#!/usr/bin/python3 -u import os.path KEY_FILE = "key" KEY_LEN = 50000 FLAG_FILE = "flag" def startup(key_location): flag = open(FLAG_FILE).read() kf = open(KEY_FILE, "rb").read() start = key_location stop = key_location + len(flag) key = kf[start:stop] key_location = stop result = list(map(lambda p, k: "{:02x}".format(ord(p) ^ k), flag, key)) print("This is the encrypted flag!\n{}\n".format("".join(result))) return key_location def encrypt(key_location): ui = input("What data would you like to encrypt? ").rstrip() if len(ui) == 0 or len(ui) > KEY_LEN: return -1 start = key_location stop = key_location + len(ui) kf = open(KEY_FILE, "rb").read() if stop >= KEY_LEN: stop = stop % KEY_LEN key = kf[start:] + kf[:stop] else: key = kf[start:stop] key_location = stop result = list(map(lambda p, k: "{:02x}".format(ord(p) ^ k), ui, key)) print("Here ya go!\n{}\n".format("".join(result))) return key_location print("******************Welcome to our OTP implementation!******************") c = startup(0) while c >= 0: c = encrypt(c) :::</description></item><item><title>PicoCTF - It's Not My Fault 1</title><link>https://bernie6401.github.io/security/practice/picoctf/crypto/rsa/picoctf---its-not-my-fault-1/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/practice/picoctf/crypto/rsa/picoctf---its-not-my-fault-1/index.html</guid><description>PicoCTF - It’s Not My Fault 1 tags: PicoCTF CTF Crypto Background Source code :::spoiler Source code
#!/usr/bin/python3 -u import random import string import hashlib import time from Crypto.Util.number import inverse, getPrime, bytes_to_long, GCD from sympy.ntheory.modular import solve_congruence FLAG = open('flag.txt', 'r').read() def CRT(a, m, b, n): val, mod = solve_congruence((a, m), (b, n)) return val def gen_key(): while True: p = getPrime(512) q = getPrime(512) if GCD(p-1, q-1) == 2: return p, q def get_clue(p, q, BITS): while True: d_p = random.randint(1, 1 &lt;&lt; BITS) d_q = random.randint(1, q - 1) if d_p % 2 == d_q % 2: d = CRT(d_p, p - 1, d_q, q - 1) e = inverse(d, (p - 1) * (q - 1)) print("Clue : ", e) return def get_flag(p, q): start = time.time() ans = int(input()) if (time.time() - start) > (15 * 60): print("Too long!") exit() else: if ans == p + q: print(FLAG) else: print("oops...") #PoW vals1 = "".join([random.choice(string.digits) for _ in range(5)]) vals2 = "".join([random.choice(string.hexdigits.lower()) for _ in range(6)]) user_input = input("Enter a string that starts with \"{}\" (no quotes) which creates an md5 hash that ends in these six hex digits: {}\n".format(vals1, vals2)) user_hash = hashlib.md5(user_input.encode()).hexdigest() if user_input[:5] == vals1 and user_hash[-6:] == vals2: p, q = gen_key() n = p * q print("Public Modulus : ", n) get_clue(p, q, 20) get_flag(p, q) :::</description></item><item><title>PicoCTF - john_pollard</title><link>https://bernie6401.github.io/security/practice/picoctf/crypto/rsa/picoctf---john_pollard/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/practice/picoctf/crypto/rsa/picoctf---john_pollard/index.html</guid><description>PicoCTF - john_pollard tags: PicoCTF CTF Crypto Background openssl - rsa
Source code -----BEGIN CERTIFICATE----- MIIB6zCB1AICMDkwDQYJKoZIhvcNAQECBQAwEjEQMA4GA1UEAxMHUGljb0NURjAe Fw0xOTA3MDgwNzIxMThaFw0xOTA2MjYxNzM0MzhaMGcxEDAOBgNVBAsTB1BpY29D VEYxEDAOBgNVBAoTB1BpY29DVEYxEDAOBgNVBAcTB1BpY29DVEYxEDAOBgNVBAgT B1BpY29DVEYxCzAJBgNVBAYTAlVTMRAwDgYDVQQDEwdQaWNvQ1RGMCIwDQYJKoZI hvcNAQEBBQADEQAwDgIHEaTUUhKxfwIDAQABMA0GCSqGSIb3DQEBAgUAA4IBAQAH al1hMsGeBb3rd/Oq+7uDguueopOvDC864hrpdGubgtjv/hrIsph7FtxM2B4rkkyA eIV708y31HIplCLruxFdspqvfGvLsCynkYfsY70i6I/dOA6l4Qq/NdmkPDx7edqO T/zK4jhnRafebqJucXFH8Ak+G6ASNRWhKfFZJTWj5CoyTMIutLU9lDiTXng3rDU1 BhXg04ei1jvAf0UrtpeOA6jUyeCLaKDFRbrOm35xI79r28yO8ng1UAzTRclvkORt b8LMxw7e+vdIntBGqf7T25PLn/MycGPPvNXyIsTzvvY/MXXJHnAqpI5DlqwzbRHz q16/S1WLvzg4PsElmv1f -----END CERTIFICATE----- Recon Hint 1: The flag is in the format picoCTF{p,q} Hint 2: Try swapping p and q if it does not work 這一題就只是把certificate解出來，發現n超小，所以就直接 Exploit - openssl $ openssl openssl x509 -in cert -pubkey -noout > public.pem -----BEGIN PUBLIC KEY----- MCIwDQYJKoZIhvcNAQEBBQADEQAwDgIHEaTUUhKxfwIDAQAB -----END PUBLIC KEY----- $ openssl rsa -pubin -in public.pem -text RSA Public-Key: (53 bit) Modulus: 4966306421059967 (0x11a4d45212b17f) Exponent: 65537 (0x10001) writing RSA key -----BEGIN PUBLIC KEY----- MCIwDQYJKoZIhvcNAQEBBQADEQAwDgIHEaTUUhKxfwIDAQAB -----END PUBLIC KEY----- Use online tool to factor p = 67867967 q = 73176001</description></item><item><title>PicoCTF - Mind your Ps and Qs</title><link>https://bernie6401.github.io/security/practice/picoctf/crypto/rsa/picoctf---mind-your-ps-and-qs/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/practice/picoctf/crypto/rsa/picoctf---mind-your-ps-and-qs/index.html</guid><description>PicoCTF - Mind your Ps and Qs tags: PicoCTF CTF Crypto Challenge: Mind your Ps and Qs
Background RSA (觀念篇) Source code Decrypt my super sick RSA: c: 421345306292040663864066688931456845278496274597031632020995583473619804626233684 n: 631371953793368771804570727896887140714495090919073481680274581226742748040342637 e: 65537 Exploit - Find P &amp; Q By Online Tool Find P &amp; Q Use online tool to do prime factorize on n p $\to$ 1461849912200000206276283741896701133693 q $\to$ 431899300006243611356963607089521499045809
Write exploit
e = 65537 M = 631371953793368771804570727896887140714061729769155038068711341335911329840163136 k = 1 # p = 1461849912200000206276283741896701133693 # q = 431899300006243611356963607089521499045809 def egcd(a, b): if a == 0: return (b, 0, 1) else: g, y, x = egcd(b % a, a) return (g, x-(b//a)*y, y) def modinv(a, m): g, x, y = egcd(a, m) if g != 1: raise Exception('modular inverse does not exist') else: return x % m while(True): if (1 + k * M) % e == 0: print('k = ', k, ' and d = ', (1 + k * M) / e) break else: k += 1 d = modinv(e, M) c = 421345306292040663864066688931456845278496274597031632020995583473619804626233684 n = 631371953793368771804570727896887140714495090919073481680274581226742748040342637 plain = pow(c, d, n) print(plain) print(hex(plain)) print(bytearray.fromhex(hex(plain)[2:])) Reference picoCTF 2021 Mind your Ps and Qs</description></item><item><title>PicoCTF - Mini RSA</title><link>https://bernie6401.github.io/security/practice/picoctf/crypto/rsa/picoctf---mini-rsa/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/practice/picoctf/crypto/rsa/picoctf---mini-rsa/index.html</guid><description>PicoCTF - Mini RSA tags: PicoCTF CTF Crypto Challenge: Mini RSA
Source code N: 1615765684321463054078226051959887884233678317734892901740763321135213636796075462401950274602405095138589898087428337758445013281488966866073355710771864671726991918706558071231266976427184673800225254531695928541272546385146495736420261815693810544589811104967829354461491178200126099661909654163542661541699404839644035177445092988952614918424317082380174383819025585076206641993479326576180793544321194357018916215113009742654408597083724508169216182008449693917227497813165444372201517541788989925461711067825681947947471001390843774746442699739386923285801022685451221261010798837646928092277556198145662924691803032880040492762442561497760689933601781401617086600593482127465655390841361154025890679757514060456103104199255917164678161972735858939464790960448345988941481499050248673128656508055285037090026439683847266536283160142071643015434813473463469733112182328678706702116054036618277506997666534567846763938692335069955755244438415377933440029498378955355877502743215305768814857864433151287 e: 3 ciphertext (c): 1220012318588871886132524757898884422174534558055593713309088304910273991073554732659977133980685370899257850121970812405700793710546674062154237544840177616746805668666317481140872605653768484867292138139949076102907399831998827567645230986345455915692863094364797526497302082734955903755050638155202890599808147130204332030239454609548193370732857240300019596815816006860639254992255194738107991811397196500685989396810773222940007523267032630601449381770324467476670441511297695830038371195786166055669921467988355155696963689199852044947912413082022187178952733134865103084455914904057821890898745653261258346107276390058792338949223415878232277034434046142510780902482500716765933896331360282637705554071922268580430157241598567522324772752885039646885713317810775113741411461898837845999905524246804112266440620557624165618470709586812253893125417659761396612984740891016230905299327084673080946823376058367658665796414168107502482827882764000030048859751949099453053128663379477059252309685864790106 Exploit - Small e attack import gmpy2 from Crypto.Util.number import long_to_bytes N = 1615765684321463054078226051959887884233678317734892901740763321135213636796075462401950274602405095138589898087428337758445013281488966866073355710771864671726991918706558071231266976427184673800225254531695928541272546385146495736420261815693810544589811104967829354461491178200126099661909654163542661541699404839644035177445092988952614918424317082380174383819025585076206641993479326576180793544321194357018916215113009742654408597083724508169216182008449693917227497813165444372201517541788989925461711067825681947947471001390843774746442699739386923285801022685451221261010798837646928092277556198145662924691803032880040492762442561497760689933601781401617086600593482127465655390841361154025890679757514060456103104199255917164678161972735858939464790960448345988941481499050248673128656508055285037090026439683847266536283160142071643015434813473463469733112182328678706702116054036618277506997666534567846763938692335069955755244438415377933440029498378955355877502743215305768814857864433151287 e = 3 c = 1220012318588871886132524757898884422174534558055593713309088304910273991073554732659977133980685370899257850121970812405700793710546674062154237544840177616746805668666317481140872605653768484867292138139949076102907399831998827567645230986345455915692863094364797526497302082734955903755050638155202890599808147130204332030239454609548193370732857240300019596815816006860639254992255194738107991811397196500685989396810773222940007523267032630601449381770324467476670441511297695830038371195786166055669921467988355155696963689199852044947912413082022187178952733134865103084455914904057821890898745653261258346107276390058792338949223415878232277034434046142510780902482500716765933896331360282637705554071922268580430157241598567522324772752885039646885713317810775113741411461898837845999905524246804112266440620557624165618470709586812253893125417659761396612984740891016230905299327084673080946823376058367658665796414168107502482827882764000030048859751949099453053128663379477059252309685864790106 k = 1 while True: if gmpy2.iroot(c + N * k, 3)[1]==1: res=gmpy2.iroot(c + N * k, 3)[0] print(k, res) print(long_to_bytes(res)) break k += 1 Reference CTF_RSA解密学习指南(三) - e=3 小明文攻击</description></item><item><title>PicoCTF - New Caesar</title><link>https://bernie6401.github.io/security/practice/picoctf/crypto/classic/picoctf---new-caesar/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/practice/picoctf/crypto/classic/picoctf---new-caesar/index.html</guid><description>PicoCTF - New Caesar tags: PicoCTF CTF Crypto Challenge: New Caesar
Source code ::: spoiler source code
import string LOWERCASE_OFFSET = ord("a") ALPHABET = string.ascii_lowercase[:16] def b16_encode(plain): enc = "" for c in plain: binary = "{0:08b}".format(ord(c)) enc += ALPHABET[int(binary[:4], 2)] enc += ALPHABET[int(binary[4:], 2)] return enc def shift(c, k): t1 = ord(c) - LOWERCASE_OFFSET t2 = ord(k) - LOWERCASE_OFFSET return ALPHABET[(t1 + t2) % len(ALPHABET)] flag = "redacted" key = "redacted" assert all([k in ALPHABET for k in key]) assert len(key) == 1 b16 = b16_encode(flag) enc = "" for i, c in enumerate(b16): enc += shift(c, key[i % len(key)]) print(enc) :::</description></item><item><title>PicoCTF - No Padding, No Problem</title><link>https://bernie6401.github.io/security/practice/picoctf/crypto/rsa/picoctf---no-padding-no-problem/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/practice/picoctf/crypto/rsa/picoctf---no-padding-no-problem/index.html</guid><description>PicoCTF - No Padding, No Problem tags: PicoCTF CTF Crypto Description Oracles can be your best friend, they will decrypt anything, except the flag’s ciphertext. How will you break it? Connect with nc mercury.picoctf.net 10333.
Hint What can you do with a different pair of ciphertext and plaintext? What if it is not so different after all…
Recon We can try to decrypt ciphertext directly.
ciphertext: 1969221237575652521155717732207422245260989124462636800279815175985091279976278420735388546000111469136091964900122438057245980826047478280799307045156672217664430153262319375993342808217618594292553441397334562535792273632256157246548036534684500140935101268806406561259397100648254721771966657212392193037 Give me ciphertext to decrypt: 1969221237575652521155717732207422245260989124462636800279815175985091279976278420735388546000111469136091964900122438057245980826047478280799307045156672217664430153262319375993342808217618594292553441397334562535792273632256157246548036534684500140935101268806406561259397100648254721771966657212392193037 Will not decrypt the ciphertext. Try Again Exploit We know that $Enc(m_1) * Enc(m_2) = ((m_1^e) * (m_2^e))\ mod\ n = (m_1 * m_2)^e\ mod\ n = Enc(m_1 * m_2)$ $$ c’ = 2^e\ (mod\ n)*c \ \begin{align} m’ &amp;= {c’}^d\ (mod\ n) \ &amp;= 2^{ed}*c^d\ (mod\ n) \ &amp;= 2 * c^d\ (mod\ n) \ \end{align}\ m = m’ // 2 $$</description></item><item><title>PicoCTF - NSA Backdoor</title><link>https://bernie6401.github.io/security/practice/picoctf/crypto/rsa/picoctf---nsa-backdoor/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/practice/picoctf/crypto/rsa/picoctf---nsa-backdoor/index.html</guid><description>PicoCTF - NSA Backdoor tags: PicoCTF CTF Crypto Background Baby Step Giant Step - BSGS
用来解决如下方程最小正整數解的 $A^x\equiv B(mod\ C)$，其中$0\le x\lt C$ 如果$A\ge C, B\ge C$，那麼我們可以先取模，即$A% = C, B% = C$，所以在這裡我們只討論$0\le A, B\lt C$的情況。 普通的BSGS的步驟是這樣的：
首先確定$x$的下限是$0$，上限是$C$，我們令$M=\lceil C\rceil$ 把$A^0~A^M\ mod\ C$的值存到一个Hash表裡面 把$(A^M)^0~(A^M)^M\ mod\ C$的值一一枚舉出來，每枚舉一個就在Hash表裡面尋找是否有一個$val$值滿足$val \cdot (A^M)^i\ mod\ C=B$，如果有則找到答案，否則繼續 最終答案就是$i\cdot M+val$的值對應的原來$A$的冪 上面是普通Baby Step Giant Step的步驟，比較簡單，只適用為素數的情況。如果為合數呢？ 拓展的過程詳見全文
離散對數問題 - pohlig-hellman算法講解
需要注意的是，pohlig-hellman算法的覆雜度在一般情況下比BSGS高！ 因此，使用pohlig-hellman的場合只能是較為特殊的情況，即:$p$是質數，且$p-1$包含的質因子較少&amp;較小。
和BSGS算法一樣，pohlig-hellman算法也是用於解決離散對數問題（也有很多文獻提到是解決橢圓曲線之類的）。即給定$a,b,p$,求 $a^x \equiv b(mod\ p)$。
歐拉定理: 若$(a,p)=1$，那麽$a^{φ(p)} \equiv1(mod\ p)······(*)$ 證明略。
費馬小定理: 如果$p$是質數，那$φ(p)=p-1$。</description></item><item><title>PicoCTF - PowerAnalysis Part 1 / Part 2</title><link>https://bernie6401.github.io/security/practice/picoctf/crypto/sidechannel/picoctf---poweranalysis-part-1-_-part-2/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/practice/picoctf/crypto/sidechannel/picoctf---poweranalysis-part-1-_-part-2/index.html</guid><description>PicoCTF - PowerAnalysis Part 1 / Part 2 Background Simple Welcome 0x13(2023 HW - Power Analysis):two:
Recon 這一題幾乎就和上課教的差不多，只是因為有雜訊，所以要慎選trace point，我是直接看第一個trace的分布，決定採用300~400的point，而不管是利用自己刻的correlation coefficient還是用scipy的pearsonr都一樣可以順利解出key但是如果像homework一樣用numpy的corrcoef會有兩個bytes和正解不一樣，超哭，找超久(10/18更新，如果用自己刻的也是要碰用氣，所以如果可以的話，多送幾個trace，或者多用幾個算correlation coefficient的library) Part 2的部分幾乎一模一樣，就只是他先幫你紀錄好所有的trace，再讓我們做後續的分析 Exploit 首先先把資料從server拉下來，在存成json from pwn import * from string import ascii_letters, digits import json from tqdm import trange def gen_plaintext(length): return ''.join(random.choice(ascii_letters + digits) for _ in range(length)) pt = [gen_plaintext(16) for _ in range(50)] print(pt) json_file = [None] * len(pt) for i in trange(len(pt)): r = remote('saturn.picoctf.net', 52339) r.sendlineafter(b'hex: ', pt[i].encode('utf-8').hex().encode()) r.recvuntil(b'power measurement result: ') pm = r.recvline().decode().strip() json_file[i] = {} json_file[i]["pt"] = [ord(digit) for digit in pt[i]] json_file[i]["pm"] = pm r.close() json_object = json.dumps(json_file) with open("./Crypto/PowerAnalysis- Part 1/trace.json", 'w') as outfile: outfile.write(json_object) 然後再去解析AES key import json from tqdm import trange import numpy as np import copy from string import ascii_letters, digits from numpy import corrcoef import matplotlib.pyplot as plt from scipy.stats import pearsonr jsonFile = open('./PicoCTF/Crypto/PowerAnalysis- Part 1/trace.json', 'r') j = json.load(jsonFile) s_box = [ [0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76], [0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0], [0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15], [0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75], [0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84], [0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF], [0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8], [0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2], [0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73], [0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB], [0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79], [0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08], [0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A], [0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E], [0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF], [0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16] ] def data_preprocess(json_data): pt_col = [] # ct_col = [] trace_col = [] for bytes in range(16): tmp_pt_col = [] # tmp_ct_col = [] for trace_idx in range(len(json_data)): tmp_pt_col.append(json_data[trace_idx]['pt'][bytes]) # tmp_ct_col.append(json_data[trace_idx]['ct'][bytes]) pt_col.append(tmp_pt_col) # ct_col.append(tmp_ct_col) for point in range(300, 400):#len(json_data[0]['pm']) tmp_trace_col = [] for trace_idx in range(len(json_data)): tmp_trace_col.append(json_data[trace_idx]['pm'][point]) trace_col.append(tmp_trace_col) return pt_col, trace_col def sbox_preprocess(pt_col): sbox_result_tmp = [] for sbox_key in range(256): # 總共有256個sbox key tmp = [] for trace in range(len(pt_col)): # 有50個trace tmp.append(pt_col[trace] ^ sbox_key) sbox_result_tmp.append(tmp) return sbox_result_tmp def choose_sbox(sbox_result_tmp): sbox_result = copy.deepcopy(sbox_result_tmp) for sbox_key in range(256): for trace in range(50): hex_value = '{0:0>2x}'.format(sbox_result_tmp[sbox_key][trace]) x, y = hex_value[0], hex_value[1] sbox_result[sbox_key][trace] = s_box[int(x, 16)][int(y, 16)] return sbox_result def cal_hamming_weight(sbox_result_col): hw_model = copy.deepcopy(sbox_result_col) for i in range(len(sbox_result_col)): # 256 for j in range(len(sbox_result_col[i])): # 50 hw_model[i][j] = bin(sbox_result_col[i][j]).count('1') return hw_model def cal_correlation(hw_model_col_result, trace_col): correlation_result = [] for i in trange(len(hw_model_col_result)):#(ascii_letters + digits).encode(): for j in range(biggest_length):#len(trace_col) # correlation_result.append(corrcoef(hw_model_col_result[i], trace_col[j])[0, -1]) # correlation_result.append(pearsonr(hw_model_col_result[i], trace_col[j])[0]) correlation_result.append(run_pearson_correlation(hw_model_col_result[i], trace_col[j])) return correlation_result def run_pearson_correlation(x, y): mean_x = np.mean(x) mean_y = np.mean(y) covariance = np.sum((x - mean_x) * (y - mean_y)) std_dev_x = np.sqrt(np.sum((x - mean_x)**2)) std_dev_y = np.sqrt(np.sum((y - mean_y)**2)) correlation = covariance / (std_dev_x * std_dev_y) return correlation def display_pt(offset:int, data_offset = (0, len(j[0]["pm"]))): plt.plot(range(data_offset[0], data_offset[1]), j[offset]["pm"][data_offset[0]:data_offset[1]]) plt.savefig(fname="./PicoCTF/Crypto/PowerAnalysis- Part 1/pt_" + str(offset) + ".jpg") plt.clf() # display_pt(1, (0, 700)) # display_pt(1) pt_col, trace_col = data_preprocess(j) flag = '' biggest_length = 100#len(trace_col) for idx in trange(16): sbox_preprocess_result = sbox_preprocess(pt_col[idx]) choose_sbox_result = choose_sbox(sbox_preprocess_result) hw_model_col_result = cal_hamming_weight(choose_sbox_result) correlation_result = cal_correlation(hw_model_col_result, trace_col) key_idx = correlation_result.index(max(correlation_result)) # flag += (ascii_letters + digits)[key_idx // biggest_length] from Crypto.Util.number import long_to_bytes flag += long_to_bytes(key_idx // biggest_length).hex() print('The key of AES is: ' + flag ) Flag: picoCTF{4999139026d84bf20427eb48d4edec53}</description></item><item><title>PicoCTF - Scrambled: RSA</title><link>https://bernie6401.github.io/security/practice/picoctf/crypto/rsa/picoctf---scrambled_-rsa/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/practice/picoctf/crypto/rsa/picoctf---scrambled_-rsa/index.html</guid><description>PicoCTF - Scrambled: RSA tags: PicoCTF CTF Crypto Hint Look at the ciphertext, anything fishy, maybe a little bit long? What happens if you encrypt the same input multiple times? Is RSA deterministic, why would outputs vary? Recon - 通靈 這一題也是頗有趣但要通靈，可以先亂Try
$ nc mercury.picoctf.net 61477 flag = ... I will encrypt whatever you give me: b Here you go: 26990049735578409030682378965549085676344091481060419655306695078226500400679435180914414853843456517959269938025436462371813167477339887511293320498195667717320879617653974074204687042294887795784122711621510485951142842770951325298677811102706200275406899117894241145575602912451443892687252208402011904237 I will encrypt whatever you give me: ba Here you go: 2699004973557840903068237896554908567634409148106041965530669507822650040067943518091441485384345651795926993802543646237181316747733988751129332049819566771732087961765397407420468704229488779578412271162151048595114284277095132529867781110270620027540689911789424114557560291245144389268725220840201190423748281433709412944662646587136176334777506529508638551296181668932027523016538393747587852449462326357575277427356480410273494280971757044562513629423400967407332448126388859817313684399195291279961899276921240210270110225654310423792352532266414306766344869066386142998118001891330035563388790707576505068944 I will encrypt whatever you give me: bac Here you go: 482814337094129446626465871361763347775065295086385512961816689320275230165383937475878524494623263575752774273564804102734942809717570445625136294234009674073324481263888598173136843991952912799618992769212402102701102256543104237923525322664143067663448690663861429981180018913300355633887907075765050689449619429085627210113794723864117161956939961066630142420889676674025917593454737310140819887001206562193281145515990410131903949359211712425034234736366286462137700473579439657314154736719868903719111785858132034797052503447042089004862886989401543635700329455353580959453911569277021402998961166474045310601826990049735578409030682378965549085676344091481060419655306695078226500400679435180914414853843456517959269938025436462371813167477339887511293320498195667717320879617653974074204687042294887795784122711621510485951142842770951325298677811102706200275406899117894241145575602912451443892687252208402011904237 ... 一開始加密的b是269900...904237，第二個加密的ba是26990...5068944，但如果仔細看其實第一個加密的密文其實也存在其中，他其實是269900...904237+482814...5068944，可以加密第三個bac試看看，也會發現是482814...5068944+961942...3106018+269900...904237 所以我們可以再往這個方向測試一下，我們知道一開始的flag一定是picoCTF{，我們加密p會發現密文其實存在原始的flag密文當中，因此我們可以寫一個腳本，像上一題一樣暴力破解，如果加密的密文有存在原本的flag ciphertext中的話，就代表我們猜對了，反之就繼續找</description></item><item><title>PicoCTF - Sequences</title><link>https://bernie6401.github.io/security/practice/picoctf/crypto/classic/picoctf---sequences/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/practice/picoctf/crypto/classic/picoctf---sequences/index.html</guid><description>PicoCTF - Sequences Source code :::spoiler Source Code
import math import hashlib import sys from tqdm import tqdm import functools ITERS = int(2e7) VERIF_KEY = "96cc5f3b460732b442814fd33cf8537c" ENCRYPTED_FLAG = bytes.fromhex("42cbbce1487b443de1acf4834baed794f4bbd0dfe2d6046e248ff7962b") # This will overflow the stack, it will need to be significantly optimized in order to get the answer :) @functools.cache def m_func(i): if i == 0: return 1 if i == 1: return 2 if i == 2: return 3 if i == 3: return 4 return 55692*m_func(i-4) - 9549*m_func(i-3) + 301*m_func(i-2) + 21*m_func(i-1) # Decrypt the flag def decrypt_flag(sol): sol = sol % (10**10000) sol = str(sol) sol_md5 = hashlib.md5(sol.encode()).hexdigest() if sol_md5 != VERIF_KEY: print("Incorrect solution") sys.exit(1) key = hashlib.sha256(sol.encode()).digest() flag = bytearray([char ^ key[i] for i, char in enumerate(ENCRYPTED_FLAG)]).decode() print(flag) if __name__ == "__main__": sol = m_func(ITERS) decrypt_flag(sol) :::</description></item><item><title>PicoCTF - SRA</title><link>https://bernie6401.github.io/security/practice/picoctf/crypto/rsa/picoctf---sra/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/practice/picoctf/crypto/rsa/picoctf---sra/index.html</guid><description>PicoCTF - SRA tags: PicoCTF CTF Crypto Source code :::spoiler Source Code
from Crypto.Util.number import getPrime, inverse, bytes_to_long from string import ascii_letters, digits from random import choice pride = "".join(choice(ascii_letters + digits) for _ in range(16)) gluttony = getPrime(128) greed = getPrime(128) lust = gluttony * greed sloth = 65537 envy = inverse(sloth, (gluttony - 1) * (greed - 1)) anger = pow(bytes_to_long(pride.encode()), sloth, lust) print(f"{anger = }") print(f"{envy = }") print("vainglory?") vainglory = input("> ").strip() if vainglory == pride: print("Conquered!") with open("/challenge/flag.txt") as f: print(f.read()) else: print("Hubris!") :::</description></item><item><title>PicoCTF - Very Smooth</title><link>https://bernie6401.github.io/security/practice/picoctf/crypto/rsa/picoctf---very-smooth/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/practice/picoctf/crypto/rsa/picoctf---very-smooth/index.html</guid><description>PicoCTF - Very Smooth tags: PicoCTF CTF Crypto Background $p-1$ Smooth
Source code :::spoiler Source Code
#!/usr/bin/python from binascii import hexlify from gmpy2 import * import math import os import sys if sys.version_info &lt; (3, 9): math.gcd = gcd math.lcm = lcm _DEBUG = False FLAG = open('flag.txt').read().strip() FLAG = mpz(hexlify(FLAG.encode()), 16) SEED = mpz(hexlify(os.urandom(32)).decode(), 16) STATE = random_state(SEED) def get_prime(state, bits): return next_prime(mpz_urandomb(state, bits) | (1 &lt;&lt; (bits - 1))) def get_smooth_prime(state, bits, smoothness=16): p = mpz(2) p_factors = [p] while p.bit_length() &lt; bits - 2 * smoothness: factor = get_prime(state, smoothness) p_factors.append(factor) p *= factor bitcnt = (bits - p.bit_length()) // 2 while True: prime1 = get_prime(state, bitcnt) prime2 = get_prime(state, bitcnt) tmpp = p * prime1 * prime2 if tmpp.bit_length() &lt; bits: bitcnt += 1 continue if tmpp.bit_length() > bits: bitcnt -= 1 continue if is_prime(tmpp + 1): p_factors.append(prime1) p_factors.append(prime2) p = tmpp + 1 break p_factors.sort() return (p, p_factors) e = 0x10001 while True: p, p_factors = get_smooth_prime(STATE, 1024, 16) if len(p_factors) != len(set(p_factors)): continue # Smoothness should be different or some might encounter issues. q, q_factors = get_smooth_prime(STATE, 1024, 17) if len(q_factors) != len(set(q_factors)): continue factors = p_factors + q_factors if e not in factors: break if _DEBUG: import sys sys.stderr.write(f'p = {p.digits(16)}\n\n') sys.stderr.write(f'p_factors = [\n') for factor in p_factors: sys.stderr.write(f' {factor.digits(16)},\n') sys.stderr.write(f']\n\n') sys.stderr.write(f'q = {q.digits(16)}\n\n') sys.stderr.write(f'q_factors = [\n') for factor in q_factors: sys.stderr.write(f' {factor.digits(16)},\n') sys.stderr.write(f']\n\n') n = p * q m = math.lcm(p - 1, q - 1) d = pow(e, -1, m) c = pow(FLAG, e, n) print(f'n = {n.digits(10)}') print(f'c = {c.digits(10)}') :::</description></item><item><title>PicoCTF - XtraORdinary</title><link>https://bernie6401.github.io/security/practice/picoctf/crypto/classic/picoctf---xtraordinary/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/practice/picoctf/crypto/classic/picoctf---xtraordinary/index.html</guid><description>PicoCTF - XtraORdinary Background How to Convert Hex String to Bytes in Python? Python 好用模組介紹 - itertools &amp; more-itertools Python File readline() Method Python append to a file
Source code :::spoiler Source Code
#!/usr/bin/env python3 from random import randint with open('flag.txt', 'rb') as f: flag = f.read() with open('secret-key.txt', 'rb') as f: key = f.read() def encrypt(ptxt, key): ctxt = b'' for i in range(len(ptxt)): a = ptxt[i] b = key[i % len(key)] ctxt += bytes([a ^ b]) return ctxt ctxt = encrypt(flag, key) random_strs = [ b'my encryption method', b'is absolutely impenetrable', b'and you will never', b'ever', b'ever', b'ever', b'ever', b'ever', b'ever', b'break it' ] for random_str in random_strs: for i in range(randint(0, pow(2, 8))): for j in range(randint(0, pow(2, 6))): for k in range(randint(0, pow(2, 4))): for l in range(randint(0, pow(2, 2))): for m in range(randint(0, pow(2, 0))): ctxt = encrypt(ctxt, random_str) with open('output.txt', 'w') as f: f.write(ctxt.hex()) :::</description></item><item><title>Simple Crypto - 0x01(Modular Operation)</title><link>https://bernie6401.github.io/security/course/ntu-cs/crypto/simple-crypto---0x01modular-operation/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-cs/crypto/simple-crypto---0x01modular-operation/index.html</guid><description>Simple Crypto - 0x01(Modular Operation) tags: CTF Crypto eductf Background 『Day 23密碼卷宗現代篇非對稱章 - RSA 模运算与逆元 模運算基本特性: $$ (a + b) % p = (a % p + b % p) % p \ (a - b) % p = (a % p - b % p) % p \ (a * b) % p = (a % p * b % p) % p \ (a ^ b) % p = ((a % p) ^ b ) % p $$ 模運算的结合律： $$ ((a + b) % p + c) % p= (a + (b + c) % p) % p \ ((a * b) % p * c) % p = (a * (b * c) % p ) % p $$ 交換律： $$ (a + b) % p = (b+a) % p \ (a * b) % p = (b * a) % p $$ 分配率： $$ ((a +b) % p * c) % p = ((a * c) % p + (b * c) % p) % p $$</description></item><item><title>Simple Crypto - 0x02(Random Number Generator - LCG)</title><link>https://bernie6401.github.io/security/course/ntu-cs/crypto/simple-crypto---0x02random-number-generator---lcg/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-cs/crypto/simple-crypto---0x02random-number-generator---lcg/index.html</guid><description>Simple Crypto - 0x02(Random Number Generator - LCG) tags: CTF Crypto eductf Background Linear Congruential Generator: Analysis LCG Formula $$ \begin{aligned} Unknown: S_0&amp;=Seed,\ A,\ B,\ m = 2^{32} \ Given: S_1&amp;,\ S_2,\ S_3\ S_1 &amp;\equiv (AS_0\ +\ B)\ %\ m\ S_2 &amp;\equiv (AS_1\ +\ B)\ %\ m\ S_3 &amp;\equiv (AS_2\ +\ B)\ %\ m\ \end{aligned} $$
Derived A $$ \begin{aligned} &amp;\left{ \begin{array}{c} S_2 &amp;\equiv (AS_1\ +\ B)\ %\ m\ S_3 &amp;\equiv (AS_2\ +\ B)\ %\ m \end{array} \right. \ \ \ \ \ \ minus \ two \ formula\ \ &amp;\to (S_2-S_3) \equiv (AS_1\ +\ B)\ %\ m-(AS_2\ +\ B)\ %\ m \ &amp;\to (S_2-S_3)\ % \ m\equiv [(AS_1\ +\ B)\ %\ m-(AS_2\ +\ B)\ %\ m]\ %\ m \ &amp;\to (S_2-S_3)\ % \ m\equiv [(AS_1\ +\ B)-(AS_2\ +\ B)]\ %\ m \ &amp;\to (S_2-S_3)\ % \ m\equiv \ A\ (S_1-S_2)\ \ %\ m =(S_2-S_3)\ A&amp;=((S_2-S_3)(S_1-S_2)^{-1})\ %\ m \end{aligned} $$</description></item><item><title>Simple Crypto - 0x03(2023 Lab - COR)</title><link>https://bernie6401.github.io/security/course/ntu-cs/crypto/simple-crypto---0x032023-lab---cor/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-cs/crypto/simple-crypto---0x032023-lab---cor/index.html</guid><description>Simple Crypto - 0x03(2023 Lab - COR) Background Simple Crypto - 0x03(Lab - LFSR)
Source Code :::spoiler
import random from secret import FLAG class LFSR: def __init__(self, tap, state): self._tap = tap self._state = state def getbit(self): f = sum([self._state[i] for i in self._tap]) &amp; 1 x = self._state[0] self._state = self._state[1:] + [f] return x class triLFSR: def __init__(self, lfsr1, lfsr2, lfsr3): self.lfsr1 = lfsr1 self.lfsr2 = lfsr2 self.lfsr3 = lfsr3 def getbit(self): x1 = self.lfsr1.getbit() x2 = self.lfsr2.getbit() x3 = self.lfsr3.getbit() return x2 if x1 else x3 lfsr1 = LFSR([0, 1, 2, 5], [random.randrange(2) for _ in range(19)]) lfsr2 = LFSR([0, 1, 2, 5], [random.randrange(2) for _ in range(23)]) lfsr3 = LFSR([0, 1, 2, 5], [random.randrange(2) for _ in range(27)]) cipher = triLFSR(lfsr1, lfsr2, lfsr3) flag = map(int, ''.join(["{:08b}".format(c) for c in FLAG])) output = [] for _ in range(200): output.append(cipher.getbit()) for b in flag: output.append(cipher.getbit() ^ b) print(output) # [0, 1, 1, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 0, 0, 1, 0, 1, 0, 1, 1, 0, 1, 1, 0, 0, 0, 1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 0, 0, 1, 1, 1, 0, 1, 1, 0, 0, 0, 1, 0, 1, 1, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 0, 1, 1, 1, 0, 1, 1, 0, 1, 0, 1, 0, 0, 1, 0, 0, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 0, 0, 1, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 0, 1, 1, 0, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 1, 0, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 1, 0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 1, 0, 0, 0, 1, 1, 1, 0, 1, 1, 1, 0, 0] :::</description></item><item><title>Simple Crypto - 0x03(Lab - LFSR)</title><link>https://bernie6401.github.io/security/course/ntu-cs/crypto/simple-crypto---0x03lab---lfsr/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-cs/crypto/simple-crypto---0x03lab---lfsr/index.html</guid><description>Simple Crypto - 0x03(Lab - LFSR) tags: eductf CTF Crypto Background [2022 fall] 0923 Crypto - LFSR Crypto I - LFSR
Source Code Must read the source code first with some comment I added :::spoiler source code
import random # from secret import FLAG FLAG = b'00001111' class LFSR: def __init__(self, tap, state): self._tap = tap self._state = state def getbit(self): # f is the new bit that append in last position f = sum([self._state[i] for i in self._tap]) &amp; 1 # x is the output bit x = self._state[0] # self._state is a new state self._state = self._state[1:] + [f] return x class triLFSR: def __init__(self, lfsr1, lfsr2, lfsr3): self.lfsr1 = lfsr1 self.lfsr2 = lfsr2 self.lfsr3 = lfsr3 def getbit(self): x1 = self.lfsr1.getbit() x2 = self.lfsr2.getbit() x3 = self.lfsr3.getbit() return x2 if x1 else x3 # These are the state of lfsr1, lfsr2, and lfsr3 A = [random.randrange(2) for _ in range(27)] B = [random.randrange(2) for _ in range(23)] C = [random.randrange(2) for _ in range(25)] print(A, B, C) # tap is a filter that decide the last bit is 1 or 0 tap1 = [0, 13, 16, 26] tap2 = [0, 5, 7, 22] tap3 = [0, 17, 19, 24] lfsr1 = LFSR(tap1, A) lfsr2 = LFSR(tap2, B) lfsr3 = LFSR(tap3, C) cipher = triLFSR(lfsr1, lfsr2, lfsr3) # Transfer the flag to ascii code and expressed in binary # e.g. FLAG = '00001111' → '3030303031313131' → '001100000011000000110000...00110001'(64 bits) flag = map(int, ''.join(["{:08b}".format(c) for c in FLAG])) output = [] for b in flag: # print(b) output.append(cipher.getbit() ^ b) for _ in range(200): output.append(cipher.getbit()) # print(output) :::</description></item><item><title>Simple Crypto - 0x04(2023 Lab - POA)</title><link>https://bernie6401.github.io/security/course/ntu-cs/crypto/simple-crypto---0x042023-lab---poa/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-cs/crypto/simple-crypto---0x042023-lab---poa/index.html</guid><description>Simple Crypto - 0x04(2023 Lab - POA) Background Crypto I - Timmy
Source Code :::spoiler Source Code
#! /usr/bin/python3 from Crypto.Cipher import AES import os from secret import FLAG def pad(data, block_size): data += bytes([0x80] + [0x00] * (15 - len(data) % block_size)) return data # padding style: &lt;oooooo[0x80][0x00]...[0x00]> (find first [0x80]) def unpad(data, block_size): if len(data) % block_size: raise ValueError padding_len = 0 for i in range(1, len(data) + 1): if data[-i] == 0x80: padding_len = i break elif data[-i] != 0x00: raise ValueError else: raise ValueError return data[:-padding_len] key = os.urandom(16) cipher = AES.new(key, AES.MODE_CBC) ct = cipher.encrypt(pad(FLAG, AES.block_size)) iv = cipher.iv print((iv + ct).hex()) # same encryption while True: try: inp = bytes.fromhex(input().strip()) # hex style input iv, ct = inp[:16], inp[16:] # get first 16 bytes from input cipher = AES.new(key, AES.MODE_CBC, iv) pt = unpad(cipher.decrypt(ct), AES.block_size) print("Well received :)") except ValueError: print("Something went wrong :(") :::</description></item><item><title>Simple Crypto - 0x05(2023 Lab - LSB)</title><link>https://bernie6401.github.io/security/course/ntu-cs/crypto/simple-crypto---0x052023-lab---lsb/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-cs/crypto/simple-crypto---0x052023-lab---lsb/index.html</guid><description>Simple Crypto - 0x05(2023 Lab - LSB) Background [edu-ctf 2023] week01 - crypto1 Source code :::spoiler Source Code
#! /usr/bin/python3 from Crypto.Util.number import bytes_to_long, getPrime import os from secret import FLAG p = getPrime(1024) q = getPrime(1024) n = p * q phi = (p - 1) * (q - 1) e = 65537 d = pow(e, -1, phi) m = bytes_to_long(FLAG + os.urandom(256 - len(FLAG))) assert m &lt; n enc = pow(m, e, n) print(n) print(e) print(enc) while True: inp = int(input().strip()) pt = pow(inp, d, n) print(pt % 3) :::</description></item><item><title>Simple Crypto - 0x06(2023 HW - LFSR)</title><link>https://bernie6401.github.io/security/course/ntu-cs/crypto/simple-crypto---0x062023-hw---lfsr/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-cs/crypto/simple-crypto---0x062023-hw---lfsr/index.html</guid><description>Simple Crypto - 0x06(2023 HW - LFSR) Background Python – List XOR from funtools import reduce test_list = [4, 6, 2, 3, 8, 9] res = reduce(lambda x, y: x ^ y, test_list) # The output is 2 Numpy矩陣乘法，但不是乘法，而是XOR的元素 import numpy as np m1 = np.array([[1, 0, 0], [0, 0, 0], [0, 0, 0]]) m2 = np.array([[1, 0, 1], [0, 0, 1], [1, 1, 1]]) mr = np.empty((m2.shape[0], m1.shape[1]), dtype = np.int64) for i in range(mr.shape[0]): for j in range(mr.shape[1]): mr[i, j] = np.sum(m1[:, j] ^ m2[i, :]) print(mr) 使用 Python 來認識矩陣 [Day07]Learning Numpy - 建立、合併、分割 - CheetSheet for Numpy Sage $ sudo apt install sagemath -y # wsl/unix base可以直接安裝，如果是windows要下載sage binary，有1.4GB $ sage -n # 開起sage notebook，也就是可以用sage kernel運行jupyter $ sage &lt;.py/.sage file> # 用sage運行腳本 $ sage # 直接開啟sage interactive shell Recon 這一題和前面的triLFSR不一樣的地方在於他只有一層的LFSR，但他只會每個70個才會給一個state，換句話說我們只能拿到$S_{710+70},\ S_{711+70},\ S_{712+70},\ S_{713+70}…$(從0開始算)，而前面256個拿到的State最後會和flag進行XOR，只有最後70個是最純粹的State</description></item><item><title>Simple Crypto - 0x07(2023 HW - Oracle)</title><link>https://bernie6401.github.io/security/course/ntu-cs/crypto/simple-crypto---0x072023-hw---oracle/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-cs/crypto/simple-crypto---0x072023-hw---oracle/index.html</guid><description>Simple Crypto - 0x07(2023 HW - Oracle) Background POA/RSA
Source code :::spoiler Oracle.py
from Crypto.Util.number import bytes_to_long from Crypto.Cipher import AES from random import randbytes from secret import aes_key, p, q def pad(m): length = 16-len(m) % 16 return m + chr(length).encode()*length def unpad(c): length = c[-1] for char in c[-length:]: if char != length: raise ValueError return c[:-length] def asymmetric_encryption(message, N, e): # encrypt message with RSA # message must be 16 bytes # padding 100 bytes random value padded_message = randbytes(100) + message return pow(bytes_to_long(padded_message), e, N) def symmetric_encryption(message, key): # ecrypt message with AES + CBC Mode # message can be arbitrary length cipher = AES.new(key, AES.MODE_CBC) ct = cipher.encrypt(pad(message)) iv = cipher.iv return iv, ct ## Alice: This is my public key. # p = getPrime(512) # q = getPrime(512) N = p * q e = 65537 print( f"{N = }, {e = }" ) # N = 69214008498642035761243756357619851816607540327248468473247478342523127723748756926949706235406640562827724567100157104972969498385528097714986614165867074449238186426536742677816881849038677123630836686152379963670139334109846133566156815333584764063197379180877984670843831985941733688575703811651087495223 # e = 65537 ## Bob: I want to send message to Alice! But my message is too looooooong...... flag = open("flag.png", "rb").read() ## Bob: Oh! I can use symmetric encryption. iv, ct = symmetric_encryption(flag, aes_key) encrypted_key = asymmetric_encryption(aes_key, N, e) encrypted_iv = asymmetric_encryption(iv, N, e) print( f"{encrypted_key = }" ) print( f"{encrypted_iv = }" ) open("encrypted_flag.not_png", "wb").write(ct) ## Bob: Ha ha! Now no one can decrypt my message except Alice! # encrypted_key = 65690013242775728459842109842683020587149462096059598501313133592635945234121561534622365974927219223034823754673718159579772056712404749324225325531206903216411508240699572153162745754564955215041783396329242482406426376133687186983187563217156659178000486342335478915053049498619169740534463504372971359692 # encrypted_iv = 35154524936059729204581782839781987236407179504895959653768093617367549802652967862418906182387861924584809825831862791349195432705129622783580000716829283234184762744224095175044663151370869751957952842383581513986293064879608592662677541628813345923397286253057417592725291925603753086190402107943880261658 ::: :::spoiler Alice.py</description></item><item><title>Simple Crypto - 0x08(2023 Lab - dlog)</title><link>https://bernie6401.github.io/security/course/ntu-cs/crypto/simple-crypto---0x082023-lab---dlog/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-cs/crypto/simple-crypto---0x082023-lab---dlog/index.html</guid><description>Simple Crypto - 0x08(2023 Lab - dlog) Background [edu-ctf 2023] week03 - crypto2 Cryptography and Network Security – Homework 2 - Little Knowledge Proof
Source code :::spoiler Source Code
from Crypto.Util.number import isPrime, bytes_to_long import os from secret import FLAG p = int(input("give me a prime: ").strip()) if not isPrime(p): print("Do you know what is primes?") exit(0) if p.bit_length() != 1024: print("Bit length need to be 1024") exit(0) g = int(input("give me a number: ").strip()) flag = bytes_to_long(FLAG) print('The hint about my secret:', pow(g, flag, p)) :::</description></item><item><title>Simple Crypto - 0x09(2023 Lab - signature)</title><link>https://bernie6401.github.io/security/course/ntu-cs/crypto/simple-crypto---0x092023-lab---signature/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-cs/crypto/simple-crypto---0x092023-lab---signature/index.html</guid><description>Simple Crypto - 0x09(2023 Lab - signature) Background [edu-ctf 2023] week03 - crypto2 - ECDSA
Source code :::spoiler Source Code
from random import randint from Crypto.Util.number import * from hashlib import sha256 from ecdsa import SECP256k1 from ecdsa.ecdsa import Public_key, Private_key, Signature from secret import FLAG E = SECP256k1 G, n = E.generator, E.order d = randint(1, n) k = randint(1, n) pubkey = Public_key(G, d*G) prikey = Private_key(pubkey, d) print(f'P = ({pubkey.point.x()}, {pubkey.point.y()})') for _ in range(3): print(''' 1) Request for Signature 2) Check the Permission 3) exit''') option = input() if option == '1': msg = input('What do you want? ') if msg == 'Give me the FLAG.': print('No way!') else: h = sha256(msg.encode()).digest() # k = k * 1337 % n sig = prikey.sign(bytes_to_long(h), k) print(f'sig = ({sig.r}, {sig.s})') elif option == '2': msg = 'Give me the FLAG.' r = input('r: ') s = input('s: ') h = bytes_to_long(sha256(msg.encode()).digest()) verified = pubkey.verifies(h, Signature(int(r), int(s))) if verified: print(FLAG) else: print('Bad signature') else: print("bye~") break :::</description></item><item><title>Simple Crypto - 0x10(2023 Lab - coppersmith)</title><link>https://bernie6401.github.io/security/course/ntu-cs/crypto/simple-crypto---0x102023-lab---coppersmith/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-cs/crypto/simple-crypto---0x102023-lab---coppersmith/index.html</guid><description>Simple Crypto - 0x10(2023 Lab - coppersmith) Background coppersmith相關攻擊
Source code :::spoiler Source Code
from Crypto.Util.number import bytes_to_long, getPrime from secret import FLAG assert len(FLAG) &lt;= 30 p = getPrime(1024) q = getPrime(1024) n = p * q e = 3 padding = b"Padding in cryptography is a fundamental concept employed to ensure that data, typically in the form of plaintext, aligns properly with the encryption algorithm's block size. This process is crucial for symmetric block ciphers like AES and asymmetric encryption algorithms such as RSA. Padding involves adding extra bits to the input data before encryption, making it fit neatly into fixed-size blocks. The primary purpose of padding is to prevent information leakage by ensuring that the last block of plaintext is always complete, even when the original data's size isn't a perfect multiple of the block size. Common padding schemes include PKCS#7, PKCS#1 (for RSA), and ANSI X.923, each with its rules for padding and unpadding data. Proper padding ensures data integrity, security, and compatibility within cryptographic protocols." pt = padding + FLAG ct = pow(bytes_to_long(pt), e, n) print(f"{e = }") print(f"{n = }") print(f"{ct = }") # e = 3 # n = 11548249006448728920152703839381630946834097081458641312395741399152626808167055308830597218237419306363812953570976143239712039037941209800604194908083149885941768218371746741812573578768412807189143962911312361667909189521442378332430658999991458388376075547304981934158525694587528155624390264161508298680598416212224037418377397597560818727159266535257243347737195812548494888452510974912762585150695881388036715559552242157015756455473208463066542053661043988897316002396230791287157322382659981842882278113445574922266102197380093864871418103716702341116793118630092030597784102701252267617442078055768183287429 # ct = 10016669153906644953016660527326048255337800602435656916304698358749910229624738375584073093905785564737742726549033330343901680652357648652891913260149958947299067801907769873568759955053120633017158582128001396334187309835478967775943564724073809481988489791896725867047366927584419210464759674986336704398037888892734158765679221980466827060998749130113847401820986980535379266905587107992796676977541915779320084736207068268591500847603252838325486939367980604888710370629644796971859833251926677637185722683564847418746350226830775205063128441515048529918173084258483536354002888691012853231754416802134513394608 :::</description></item><item><title>Simple Crypto 0x11(2023 HW - invalid_curve_attack)</title><link>https://bernie6401.github.io/security/course/ntu-cs/crypto/simple-crypto-0x112023-hw---invalid_curve_attack/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-cs/crypto/simple-crypto-0x112023-hw---invalid_curve_attack/index.html</guid><description>Simple Crypto 0x11(2023 HW - invalid_curve_attack) Background pekobot - maple
這邊我會嘗試用簡單的講法把這個攻擊簡述一遍，詳細還是建議 Crypton 或是其他地方的說明。
Invalid Curve Attack 大致上來說利用的是當一個不在原本曲線 $E$ 上的 $P$ 進行 scalar multiplication 的一些特性，使用類似 Pohlig–Hellman algorithm 的辦法在不同的 subgroup 解 DLP 然後用 CRT 解回原本的 private key。
一個 Short Weierstrass curve 長這樣:
$$ y^2 = x^3 + ax + b $$
而它的 point doubling formula ($R=2P$) 是:
$$ \begin{aligned} s &amp;= \frac{3x_P^2+a}{2y_P} \ x_R &amp;= s^2 - 2x_P \ y_R &amp;= y_P + s(x_R - x_P) \end{aligned} $$</description></item><item><title>Simple Crypto 0x12(2023 HW - signature_revenge)</title><link>https://bernie6401.github.io/security/course/ntu-cs/crypto/simple-crypto-0x122023-hw---signature_revenge/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-cs/crypto/simple-crypto-0x122023-hw---signature_revenge/index.html</guid><description>Simple Crypto 0x12(2023 HW - signature_revenge) Background Source code :::spoiler Source Code
from Crypto.Util.number import * from hashlib import sha256, md5 from ecdsa import SECP256k1 from ecdsa.ecdsa import Public_key, Private_key from secret import FLAG import os E = SECP256k1 G, n = E.generator, E.order d = bytes_to_long( os.urandom(32 - len(FLAG)) + FLAG ) pubkey = Public_key(G, d*G) prikey = Private_key(pubkey, d) magic1 = md5(d.to_bytes(32, "big")).digest() magic2 = md5(d.to_bytes(32, "big")[::-1]).digest() h1 = sha256(b"https://www.youtube.com/watch?v=IBnrn2pnPG8").digest() h2 = sha256(b"https://www.youtube.com/watch?v=1H2cyhWYXrE").digest() k1 = bytes_to_long(magic1 + magic2) k2 = bytes_to_long(magic2 + magic1) sig1 = prikey.sign(bytes_to_long(h1), k1) sig2 = prikey.sign(bytes_to_long(h2), k2) print(f'P = ({pubkey.point.x()}, {pubkey.point.y()})') print(f'sig1 = ({sig1.r}, {sig1.s})') print(f'sig2 = ({sig2.r}, {sig2.s})') # P = (70427896289635684269185763735464004880272487387417064603929487585697794861713, 83106938517126976838986116917338443942453391221542116900720022828358221631968) # sig1 = (26150478759659181410183574739595997895638116875172347795980556499925372918857, 50639168022751577246163934860133616960953696675993100806612269138066992704236) # sig2 = (8256687378196792904669428303872036025324883507048772044875872623403155644190, 90323515158120328162524865800363952831516312527470472160064097576156608261906) :::</description></item><item><title>Simple Crypto 0x13(2023 HW - Power Analysis)</title><link>https://bernie6401.github.io/security/course/ntu-cs/crypto/simple-crypto-0x132023-hw---power-analysis/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-cs/crypto/simple-crypto-0x132023-hw---power-analysis/index.html</guid><description>Simple Crypto 0x13(2023 HW - Power Analysis) Background [edu-ctf 2023] week04 - crypto3 [1:30:36]
Source code json file recorded by TA
Recon 這一題全部都是刻出來的，也包含算correlation coefficient，後面才知道numpy有這東西，但反正根據老師上課的作法一步一步跟著做是絕對沒有問題的，包含以下步驟:
Preprocessing 也就是把pt, ct, pm都按照簡報上的方式排列(各個trace的第一個byte都蒐集在一起，第二個byte都蒐集再一起…) 計算和sbox key XOR的結果 查表sbox 計算hamming weight model 計算和trace的correlation coefficient 看哪一個結果的數值最大，並把index結果記錄下來算它的ascii repeat以上操作後共可得16 bytes的flag 加速的方法: 可以把整個trace的圖片plot出來看看，會發現題目給的json file是把整段加密的過程記錄下來，所以我們可以只取前一兩百個point就可以完成key的還原 Exploit import json from tqdm import trange import numpy as np import copy from string import ascii_letters, digits from numpy import corrcoef jsonFile = open('./Crypto/HW3/traces.json', 'r') j = json.load(jsonFile) s_box = [ [0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76], [0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0], [0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15], [0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75], [0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84], [0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF], [0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8], [0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2], [0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73], [0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB], [0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79], [0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08], [0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A], [0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E], [0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF], [0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16] ] def data_preprocess(json_data): pt_col = [] ct_col = [] trace_col = [] for bytes in range(16): tmp_pt_col = [] tmp_ct_col = [] for trace_idx in range(len(json_data)): tmp_pt_col.append(json_data[trace_idx]['pt'][bytes]) tmp_ct_col.append(json_data[trace_idx]['ct'][bytes]) pt_col.append(tmp_pt_col) ct_col.append(tmp_ct_col) for point in range(len(json_data[0]['pm'])): tmp_trace_col = [] for trace_idx in range(len(json_data)): tmp_trace_col.append(json_data[trace_idx]['pm'][point]) trace_col.append(tmp_trace_col) return pt_col, ct_col, trace_col def sbox_preprocess(pt_col): sbox_result_tmp = [] for sbox_key in range(256): # 總共有256個sbox key tmp = [] for trace in range(len(pt_col)): # 有50個trace tmp.append(pt_col[trace] ^ sbox_key) sbox_result_tmp.append(tmp) return sbox_result_tmp def choose_sbox(sbox_result_tmp): sbox_result = copy.deepcopy(sbox_result_tmp) for sbox_key in range(256): for trace in range(50): hex_value = '{0:0>2x}'.format(sbox_result_tmp[sbox_key][trace]) x, y = hex_value[0], hex_value[1] sbox_result[sbox_key][trace] = s_box[int(x, 16)][int(y, 16)] return sbox_result def cal_hamming_weight(sbox_result_col): hw_model = copy.deepcopy(sbox_result_col) for i in range(len(sbox_result_col)): # 256 for j in range(len(sbox_result_col[i])): # 50 hw_model[i][j] = bin(sbox_result_col[i][j]).count('1') return hw_model def cal_correlation(hw_model_col_result, trace_col): correlation_result = [] for i in (ascii_letters + digits).encode():#trange(len(hw_model_col_result)): &lt;- 加速的部分 for j in range(biggest_length): correlation_result.append(corrcoef(hw_model_col_result[i], trace_col[j])[0, -1]) return correlation_result def run_pearson_correlation(x, y): mean_x = np.mean(x) mean_y = np.mean(y) covariance = np.sum((x - mean_x) * (y - mean_y)) std_dev_x = np.sqrt(np.sum((x - mean_x)**2)) std_dev_y = np.sqrt(np.sum((y - mean_y)**2)) correlation = covariance / (std_dev_x * std_dev_y) return correlation def display_pt(offset:int, data_offset = (0, len(j[0]["pm"]))): plt.plot(range(data_offset[0], data_offset[1]), j[offset]["pm"][data_offset[0]:data_offset[1]]) plt.savefig(fname="pt_" + str(offset) + ".jpg") plt.clf() # display_pt(0, (0, 95)) # display_pt(0) pt_col, ct_col, trace_col = data_preprocess(j) flag = '' biggest_length = 95# len(trace_col) for idx in trange(16): sbox_preprocess_result = sbox_preprocess(pt_col[idx]) choose_sbox_result = choose_sbox(sbox_preprocess_result) hw_model_col_result = cal_hamming_weight(choose_sbox_result) correlation_result = cal_correlation(hw_model_col_result, trace_col) key_idx = correlation_result.index(max(correlation_result)) flag += (ascii_letters + digits)[key_idx // biggest_length] # from Crypto.Util.number import long_to_bytes # flag += long_to_bytes(key_idx // biggest_length).decode("cp437") print('The key of AES is: FLAG{' + flag + '}') 有嘗試過只選擇常見可使用的字元也就是abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789，以及trace只選擇前95個data，也可以正常解析出AES key並且算的更快(大約快77倍左右)</description></item><item><title>Simple Welcome 0x01(Lab - Let's meet at class)</title><link>https://bernie6401.github.io/security/course/ntu-cs/welcome/simple-welcome-0x01lab---lets-meet-at-class/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-cs/welcome/simple-welcome-0x01lab---lets-meet-at-class/index.html</guid><description>Simple Welcome 0x01(Lab - Let’s meet at class) Description Crypto part of homework 0. The key space is $10^{15}$. I used my supercomputer(i5 7th gen) to solve it in about 10 minutes. It’s impossible for you guys to enumerate all the keys in 2 weeks, or maybe you can… (Use pip3 install pycryptodome to install Crypto)
Source Code :::spoiler Source
from Crypto.Util.number import bytes_to_long, getPrime import random import math import os from secret import FLAG FLAG += os.urandom(128 - len(FLAG)) flag = bytes_to_long(FLAG) p = getPrime(1024) keys = [pow(random.randint(1000 * i + 2, 1000 * (i+1) ), 65537, p) for i in range(5)] enc = flag for i in range(5): enc = enc * keys[i] % p hint = keys[0] ^ keys[1] ^ keys[2] ^ keys[3] ^ keys[4] print('p =', p) print('enc =', enc) print('hint =', hint) ::: :::spoiler</description></item></channel></rss>