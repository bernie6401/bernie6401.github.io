<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>NTU_CT :: Tag :: SBK Hugo Site</title><link>https://bernie6401.github.io/tags/ntu_ct/index.html</link><description/><generator>Hugo</generator><language>en-us</language><atom:link href="https://bernie6401.github.io/tags/ntu_ct/index.xml" rel="self" type="application/rss+xml"/><item><title>NTU Compiler Technology Previous Exam 2019 Spring</title><link>https://bernie6401.github.io/security/course/ntu-ct/ntu-compiler-technology-previous-exam-2019-spring/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-ct/ntu-compiler-technology-previous-exam-2019-spring/index.html</guid><description>NTU Compiler Technology Previous Exam 2019 Spring tags: NTU_CT NTU Compiler Techonology of Programming Language Final Exam Please explain three different compiler optimization techniques : (a) 1st compiler optimization technique: (5points/5) (b) 2nd compiler optimization technique: (5points/10) (c) 3rd compiler optimization techniques: (5points/15)
Many computer systems provide an interactive debugger (for example, gdb or db x) to assist users in diagnosing and correcting runtime errors. Although a debugger is run long after a compiler has done its job, the two tools still must cooperate. What information (beyond the translation of a program) must a compiler supply to support effective runtime debugging? (5 points/20)</description></item><item><title>NTU Compiler Technology Previous Exam 2020 Spring</title><link>https://bernie6401.github.io/security/course/ntu-ct/ntu-compiler-technology-previous-exam-2020-spring/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-ct/ntu-compiler-technology-previous-exam-2020-spring/index.html</guid><description>NTU Compiler Technology Previous Exam 2020 Spring tags: NTU_CT NTU Compiler Techonology of Programming Language Final Exam According to the grammar of AC in the right , please write down the recursive descent parsing procedure for nonterminal Expr. (10 points/10) Please write down a regular expression that defines the set of strings recognized by the FA in the following and explain your answer (5points/ 15)</description></item><item><title>NTU Compiler Technology Project 1</title><link>https://bernie6401.github.io/security/course/ntu-ct/ntu-compiler-technology-project-1/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-ct/ntu-compiler-technology-project-1/index.html</guid><description>NTU Compiler Technology Project 1 tags: NTU_CT NTU Compiler Techonology of Programming Language AcDc Compiler Description This is a project from NTU (National Taiwan University) course, Compiler Technology of Programming Language. First project is aim to add multiplier and division operation in this compiler let compiler can recognize multi character identifier(variable) name by alphabet string use constant folding to optimize the statement How to use? You can browse Assignment1.pdf. You must run in Linux OS environment(more conveniently). When you finish the coding, use $ make command directly. $ ./AcDc &lt;input sample address> &lt;output file address> For instance: $ ./AcDc ../test/sample1.ac ./output Something need to know first It can not recognize the bottom line as identifier name. It can not print negative value like $1-2=-1$ expression. Actually speaking, it can calculate correctly but it can not print it out.(I’ll check it out later.) You can check constfold testbench Solution and Why: In Dc Language, the bottom line represent negative symbol. You can not just use minus as negative symbol, replace it by bottom line instead. It can not recognize identifier name with numbers. You can check longname.ac The other testbenchs can compile from Ac language to Dc language correctly. Reference AcDc AcDcCompiler</description></item><item><title>NTU Compiler Technology Project 2</title><link>https://bernie6401.github.io/security/course/ntu-ct/ntu-compiler-technology-project-2/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-ct/ntu-compiler-technology-project-2/index.html</guid><description>NTU Compiler Technology Project 2 tags: NTU_CT NTU Compiler Techonology of Programming Language Scanner :::spoiler [TOC] :::
Objective This is compiler project 2 that aim to construct the scanner by handmade with some sample code. The output is symbol table that the frequency of each identifier and the result is sorted.
Run and Test $ make /*use make in src folder*/ $ ./scanner ../test/sample1.ac Output of each sample For sample1.ac</description></item><item><title>NTU Compiler Technology Project 3</title><link>https://bernie6401.github.io/security/course/ntu-ct/ntu-compiler-technology-project-3/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-ct/ntu-compiler-technology-project-3/index.html</guid><description>NTU Compiler Technology Project 3 tags: NTU_CT NTU Compiler Techonology of Programming Language YACC Lex [TOC]
Objective The main task for this project is to revise src/parser.y and generate parser file properly to compile test code in test folder. And then use Graphviz command to visualize the structure of these test code How to run? Just use make to compile all files in /src. Though you’ll get a lots of warning shown as below, you can ignore them and obtain the target file parser. bison -v -d parser.y parser.y: warning: 1 shift/reduce conflict [-Wconflicts-sr] flex lexer.l gcc -g -c alloc.c gcc -g -c parser.tab.c parser.tab.c: In function ‘yyparse’: parser.tab.c:2565:7: warning: implicit declaration of function ‘yyerror’; did you mean ‘yyerrok’? [-Wimplicit-function-declaration] yyerror (YY_("syntax error")); ^~~~~~~ yyerrok parser.y: At top level: parser.y:825:3: warning: data definition has no type or storage class yydebug = 1; ^~~~~~~ parser.y:825:3: warning: type defaults to ‘int’ in declaration of ‘yydebug’ [-Wimplicit-int] parser.y:827:1: warning: return type defaults to ‘int’ [-Wimplicit-int] main (argc, argv) ^~~~ parser.y: In function ‘main’: parser.y:834:5: warning: implicit declaration of function ‘printGV’; did you mean ‘printf’? [-Wimplicit-function-declaration] printGV(prog, NULL); ^~~~~~~ printf gcc -g -c functions.c gcc -g -o parser parser.tab.o alloc.o functions.o -lfl Use parser to compile all files in /test folder and you will get AST_Graph.gv in /test folder. /src ./parser ../test/control.c dot -Tpng -o ../test/control.png ../test/AST_Graph.gv ./parser ../test/decl.c dot -Tpng -o ../test/decl.png ../test/AST_Graph.gv ./parser ../test/expr.c dot -Tpng -o ../test/expr.png ../test/AST_Graph.gv ./parser ../test/func.c dot -Tpng -o ../test/func.png ../test/AST_Graph.gv Note that in parser.y, I set yydebug = 1 so that we can see the debug message from parser #ifdef YYDEBUG yydebug = 1; #endif For TA I changed a little bit functions.c that will generate AST_Graph.gv at test/ folder. void printGV(AST_NODE *root, char* fileName) { if (fileName == NULL) { fileName = "../test/AST_Graph.gv"; } ... } Analysis You can see the relationship between structure map and test code by yourself. control.c int main() { int i; int p; int k, j; for (i=0; i&lt;9; i=i+1) { /* empty */ } for (i=0, p=4+4; i&lt;9; i=i+1, p=i) { write("test"); } for (;;) { /*empty*/ } while (1) { } while (2) { write("haha"); write("wow"); } if (k == j) { write("first"); } if (k == j) { write("first"); } else if (j == k) { write("second"); } else { write("third"); } } decl.c typedef float GFLOAT; int main() { typedef int INT, INT2, INT3; typedef float FLOAT; typedef void VOID; typedef void VOID2, VOID3; INT f[3][3*3-(4+2)/2]; FLOAT f2; } expr.c int fn1() { return 1; } float fn3() { return 1.0; } int fn4(int a, int b) { return 1; } int expr(int a, int b, int c, int d, float fa, float fb, float fc) { int i, j, k, l; float fi = 1.0, fj = 2.0, fk = 3.0, fl = 4.0; fi = 1.2*fi + -fj * (fl - fk * fn3()); fi = -fn3() -(-(-(4))); fi = !fn3() -(!(!(4))); i = !fn1(); i = 1 &lt; 2; i = 1 > 2; i = 1 >= 2; i = 1 &lt;= 2; i = 1 != 2; i = 1 == 2; i = fn4(1+3*4*fn4(2,3), 3); return 1; } int main() { } func.c int fn1() { int ABC = 5; return ABC+5; } void fn2() { } void fn3(int a, int b[3][4]) { } int main() { int b[4][4]; fn1(); fn2(); fn3(2, b); } Reference Github example Simple intro of yacc &amp; lex Simple intro of Graphviz A GUIDE TO LEX &amp; YACC from TA 大推：以lex/yacc實作算式計算機</description></item><item><title>NTU Compiler Technology Project 4</title><link>https://bernie6401.github.io/security/course/ntu-ct/ntu-compiler-technology-project-4/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-ct/ntu-compiler-technology-project-4/index.html</guid><description>NTU Compiler Technology Project 4 tags: NTU_CT NTU Compiler Techonology of Programming Language Code Generation [TOC]
How to run? First, put your testing file and main.S to the folder same as parser file
$ make $ ./parser [testing file].c $ aarch64-linux-gnu-gcc -static -O0 main.S $ qemu-aarch64-static ./a.out Or, you can put the run.sh and main.S in the same directory and run
$ ./run.sh [your parser] [the C file] $ qemu-aarch64-static ./a.out Note that you must change your test file’s main() to MAIN()</description></item></channel></rss>