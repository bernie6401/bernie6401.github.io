<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>NTU :: Tag :: SBK Hugo Site</title><link>https://bernie6401.github.io/tags/ntu/index.html</link><description/><generator>Hugo</generator><language>en-us</language><atom:link href="https://bernie6401.github.io/tags/ntu/index.xml" rel="self" type="application/rss+xml"/><item><title>A MITM Based Penetration Test Efficiency Improvement Approach for Traffic-Encrypted Mobile Apps of Power Industry</title><link>https://bernie6401.github.io/survey-papers/android-+-security/a-mitm-based-penetration-test-efficiency-improvement-approach-for-traffic-encrypted-mobile-apps-of-power-industry/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/survey-papers/android-+-security/a-mitm-based-penetration-test-efficiency-improvement-approach-for-traffic-encrypted-mobile-apps-of-power-industry/index.html</guid><description>A MITM Based Penetration Test Efficiency Improvement Approach for Traffic-Encrypted Mobile Applications of Power Industry :::info Zhang, L., Wang, B., Shen, Q., Song, Y., Guo, N., &amp; Xie, L. (2021, April). A MITM Based Penetration Test Efficiency Improvement Approach for Traffic-Encrypted Mobile Applications of Power Industry. In 2021 IEEE 6th International Conference on Computer and Communication Systems (ICCCS) (pp. 743-747). IEEE. ::: 這一篇蠻有趣的，和我想要做的東西幾乎一樣，不過他論文闡述的重點不一樣，但也還是給我一些之後需要注意的地方，
Introduction 他是站在電力相關的Android App的角度去審視如果利用MITM Based做到滲透測試要怎麼做，以及和傳統的方式相比可以減少多少時間、效率提升多少。但其實內文和電力幾乎一點關係也沒有，代換成其他的App也可以，如果我們要利用MITM Based做到Penetration Testing，就必須要手動克服中間會加密的問題，所以他就試圖提出一個==3-Layers Proxy Based==的東西(如下圖) 從上圖可知，手機到Web Server中間總共有三層的Proxy，第一和第三層都是MITM Proxy，主要是負責訊息的加解密，而中間的那一層就可以很彈性的替換成各式各樣的自動化測試工具或腳本，例如Burp Suite或是SQLMAP之類的 :::info 這個架構會需要三層其實是因為他所測試的App，不只是傳輸的那一層會被SSL加密，而在傳送的封包body還會再加密一次，所以需要三層，不然照理來說，一層的MITM Proxy就可以解決SSL加解密的問題，不需要用到三層那麼多，而且也不需要深入探索他用的是哪一套加解密演算法，因為傳輸層的演算法都一樣才對，這是和學長討論出來的結果 :::</description></item><item><title>A Mitmproxy-based Dynamic Vulnerability Detection System For Android Applications</title><link>https://bernie6401.github.io/survey-papers/android-+-security/a-mitmproxy-based-dynamic-vulnerability-detection-system-for-android-applications/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/survey-papers/android-+-security/a-mitmproxy-based-dynamic-vulnerability-detection-system-for-android-applications/index.html</guid><description>A Mitmproxy-based Dynamic Vulnerability Detection System For Android Applications :::info Lv, X., Peng, T., Tang, J., He, R., Hu, X., Jiang, M., … &amp; Cao, W. (2022, December). A Mitmproxy-based Dynamic Vulnerability Detection System For Android Applications. In 2022 18th International Conference on Mobility, Sensing and Networking (MSN) (pp. 408-416). IEEE. ::: 這一篇也和我想做的主題有一點關聯，他是利用MITMProxy-based達到偵測應用程式在做Hotfix時，有沒有Code Injection(dex injection)的問題。
Introduction 現在有很多的App都會實現Hotfix這項技術，也就是不斷電更新，傳統的App更新方式為廠商發佈新的版本後，使用者需要重新卸載再安裝新的版本，但現在有了Hotfix的技術，使用者在沒有感知的情況下就會自動完成更新，如下圖所述，當然在更新之前會進行驗證Hash、SSL憑證和簽章，但如果沒有簽章呢?是不是就可以被MITM篡改Hash和進行Code Injection，這一篇文章就是在自動化的檢測這件事情的可行性 Background Hotfix的流程 按照論文中的說明，利用hotfix更新patch的方式當然不是直接從server傳過來到client端，而是會把dex file打包成.jar或是.zip的patch package，然後放在某個地方。從server那邊會送出一個json file，裡面有一個URL Key會紀錄這個打包好的patch package在哪裡，然後client端自行去下載會來進行patch Android的簽章 在Android系統安全中有3個主要的技術: Permission Management, Signature Authentication, 以及Sandbox Mechanism，現在主要探討的問題就是在簽章的技術底下。Android的數位簽章總共會包含三個東西: MANIFEST.MF, CERT.SF, CERT.RSA MANIFEST.MF 是一個Digest File也就是存所有更新的打包檔案的Hash Value CERT.SF 是一個Signature File，他會用SHA1計算MANIFEST.MF中的所有東西再用Base64進行Encode CERT.RSA 存放Public Key+加密演算法是哪一個+用自己的Private Key加密CERT.SF中的所有東西的結果 綜上所述，如果一個廠商在進行Hotfix更新時，被MITM Hijack，那MANIFEST.MF和CERT.SF可以被換掉，但CERT.RSA這個檔案，因為沒有廠商的私鑰，故無法替換 Proposed Method</description></item><item><title>A&amp;D of Network Security - Lab 12</title><link>https://bernie6401.github.io/security/course/ntu-padns/ad-of-network-security---lab-12/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-padns/ad-of-network-security---lab-12/index.html</guid><description>A&amp;D of Network Security - Lab 12 tags: Practicum of A&amp;D of NS NTU Video NTU PADNS Lecture 12
Background What is _mbscmp?
int _mbscmp( const unsigned char *string1, const unsigned char *string2 ); Return Value
&lt;0 string1 is less than string2 =0 string1 is identical to string2 >0 string1 is greater than string2
Recon Static - IDA Pro :::spoiler Main Source Code
int __cdecl main(int argc, const char **argv, const char **envp) { char v4; // [esp+10h] [ebp-181Ch] char v5; // [esp+410h] [ebp-141Ch] char v6; // [esp+810h] [ebp-101Ch] char v7; // [esp+C10h] [ebp-C1Ch] CHAR v8; // [esp+1024h] [ebp-808h] CHAR ServiceName; // [esp+1428h] [ebp-404h] const char *v10; // [esp+1828h] [ebp-4h] if ( argc == 1 ) { if ( !sub_401000() ) sub_402410(); sub_402360(); } else { v10 = argv[argc - 1]; if ( !sub_402510(v10) ) sub_402410(); if ( _mbscmp((const unsigned __int8 *)argv[1], &amp;byte_40C170) ) { if ( _mbscmp((const unsigned __int8 *)argv[1], &amp;byte_40C16C) ) { if ( _mbscmp((const unsigned __int8 *)argv[1], &amp;byte_40C168) ) { if ( _mbscmp((const unsigned __int8 *)argv[1], aCc) ) sub_402410(); if ( argc != 3 ) sub_402410(); if ( !sub_401280(&amp;v5, 1024, &amp;v6, 1024, &amp;v4, 1024, &amp;v7) ) sub_402E7E(aKSHSPSPerS, &amp;v5); } else { if ( argc != 7 ) sub_402410(); sub_401070(argv[2], argv[3], argv[4], argv[5]); } } else if ( argc == 3 ) { if ( sub_4025B0(&amp;v8) ) return -1; sub_402900(&amp;v8); } else { if ( argc != 4 ) sub_402410(); sub_402900(argv[2]); } } else if ( argc == 3 ) { if ( sub_4025B0(&amp;ServiceName) ) return -1; sub_402600(&amp;ServiceName); } else { if ( argc != 4 ) sub_402410(); sub_402600(argv[2]); } } return 0; } :::</description></item><item><title>A&amp;D of Network Security - Lab 13</title><link>https://bernie6401.github.io/security/course/ntu-padns/ad-of-network-security---lab-13/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-padns/ad-of-network-security---lab-13/index.html</guid><description>A&amp;D of Network Security - Lab 13 tags: Practicum of A&amp;D of NS NTU Metasploit with Bluekeep Vulnerability (CVE-2019-0708) Setting up environment Open Windows 7 and Kali-Linux with localhost only mode :::spoiler Screenshot :::
Then we can note that the IP of these two machines are different: :::spoiler Screenshot</description></item><item><title>A&amp;D of Network Security - Lab 14</title><link>https://bernie6401.github.io/security/course/ntu-padns/ad-of-network-security---lab-14/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-padns/ad-of-network-security---lab-14/index.html</guid><description>A&amp;D of Network Security - Lab 14 tags: Practicum of A&amp;D of NS NTU Video Class Description Lab Implementation
Background snort Rule :::spoiler Rule Screenshot Format Action Option Option - Payload ::: Lab Lab 1: Packet sniffer Mode show出 sniff ICMP封包的結果 Payload:</description></item><item><title>A&amp;D of Network Security - Lab 2</title><link>https://bernie6401.github.io/security/course/ntu-padns/ad-of-network-security---lab-2/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-padns/ad-of-network-security---lab-2/index.html</guid><description>A&amp;D of Network Security - Lab 2 tags: Practicum of A&amp;D of NS NTU Lab Cheat Sheet(Cisco Packet Tracer) Setting VLAN :::spoiler Switch
Switch>enable Switch#configure Configuring from terminal, memory, or network [terminal]? Enter configuration commands, one per line. End with CNTL/Z. Switch(config)#vlan 10 Switch(config-vlan)#name green Switch(config-vlan)#vlan 20 Switch(config-vlan)#name yellow Switch(config-vlan)# Switch# %SYS-5-CONFIG_I: Configured from console by console Switch#show vlan VLAN Name Status Ports ---- -------------------------------- --------- ------------------------------- 1 default active Fa0/5, Fa0/6, Fa0/7, Fa0/8 Fa0/9, Fa0/10, Fa0/11, Fa0/12 Fa0/13, Fa0/14, Fa0/15, Fa0/16 Fa0/17, Fa0/18, Fa0/19, Fa0/20 Fa0/21, Fa0/22, Fa0/23, Fa0/24 Gig0/1, Gig0/2 10 green active 20 yellow active ... ::: :::spoiler Switch相對應的Interface</description></item><item><title>A&amp;D of Network Security - Lab 3</title><link>https://bernie6401.github.io/security/course/ntu-padns/ad-of-network-security---lab-3/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-padns/ad-of-network-security---lab-3/index.html</guid><description>A&amp;D of Network Security - Lab 3 tags: Practicum of A&amp;D of NS NTU Background Network setting type in virtual box Ping two machine in internal mode :::spoiler Detailed Process
Clone another VM Setting Network Configuration Setting 2 VMs’ network config as above. Note that, must check MAC address is different, promiscuous mode is Allow All and the adapter is the same.</description></item><item><title>A&amp;D of Network Security - Lab 4(ARP &amp; DNS SPOOFING)</title><link>https://bernie6401.github.io/security/course/ntu-padns/ad-of-network-security---lab-4arp--dns-spoofing/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-padns/ad-of-network-security---lab-4arp--dns-spoofing/index.html</guid><description>A&amp;D of Network Security - Lab 4(ARP &amp; DNS SPOOFING) tags: Practicum of A&amp;D of NS NTU Background ARP Spoofing at 1:15:00
ARP SPOOFING Setting 2 VMs’ network interface as Bridged adapter :::danger You supposed to use your own network instead of public network :::
Checking IP And check the victim gateway by nmap</description></item><item><title>A&amp;D of Network Security - Lab 7</title><link>https://bernie6401.github.io/security/course/ntu-padns/ad-of-network-security---lab-7/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-padns/ad-of-network-security---lab-7/index.html</guid><description>A&amp;D of Network Security - Lab 7 tags: Practicum of A&amp;D of NS NTU Background What is foremost and How to use it?
RSA CTF Exercise - RSA Given
p = 9648423029010515676590551740010426534945737639235739800643989352039852507298491399561035009163427050370107570733633350911691280297777160200625281665378483 q = 11874843837980297032092405848653656852760910154543380907650040190704283358909208578251063047732443992230647903887510065547947313543299303261986053486569407 e = 65537 c = 83208298995174604174773590298203639360540024871256126892889661345742403314929861939100492666605647316646576486526217457006376842280869728581726746401583705899941768214138742259689334840735633553053887641847651173776251820293087212885670180367406807406765923638973161375817392737747832762751690104423869019034 Then I can use decrypt function to fetch plaintext. Flag(hex): 12058e43d9e0c22559c19774 :::spoiler source code
from Crypto.Util.number import long_to_bytes, inverse, bytes_to_long p = 9648423029010515676590551740010426534945737639235739800643989352039852507298491399561035009163427050370107570733633350911691280297777160200625281665378483 q = 11874843837980297032092405848653656852760910154543380907650040190704283358909208578251063047732443992230647903887510065547947313543299303261986053486569407 e = 65537 c = 83208298995174604174773590298203639360540024871256126892889661345742403314929861939100492666605647316646576486526217457006376842280869728581726746401583705899941768214138742259689334840735633553053887641847651173776251820293087212885670180367406807406765923638973161375817392737747832762751690104423869019034 n = p * q phi = (q-1)*(p-1) d = inverse(e, phi) print(long_to_bytes(pow(c,d,n)).hex()) :::</description></item><item><title>A&amp;D of Network Security Note</title><link>https://bernie6401.github.io/security/course/ntu-padns/ad-of-network-security-note/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-padns/ad-of-network-security-note/index.html</guid><description>A&amp;D of Network Security Note tags: Practicum of A&amp;D of NS NTU Background :::spoiler IP / 遮罩 / 閘道 三者的關係
用日常生活中的例子來比喻，IP 就好比在社區中的門牌地址，如果是要找同社區(一樣遮罩範圍的)，就只要透過社區廣播喊一聲。如果找不到人，表示在社區外，就要出社區大門(閘道)去外面問
所以遮罩設定錯誤，代表硬把兩個不同社區的給劃在一起，但是實際上遞送封包就會找不到 (明明住光復國宅結果你跟郵差說光復國宅跟孟竹國宅都在一區)
閘道設定錯誤則是連大門都搞錯了，這樣蓮社區都出不去，自然網路也無法連線 :::
:::spoiler [網路] 淺談 ARP (Address Resolution Protocol) 運作原理
在乙太網路上，資料的傳遞必須要有實體位址 (MAC Address)，Layer 2 設備會驗證 Frame 的實體位址，不是找它的一律捨棄，但設備一開機總不可能就有所有設備的實體位址吧？所以就需要 ARP 協定來協助取得各個設備的實體位址
ARP 是利用乙太網路的廣播功能所設計出來的位址解析協定，它的主要特性是它的位址對應關係是動態的，以查詢的方式來獲得 I P位址 (IP Address) 和實體位址 (MAC Address / Physical Address) 的對應關係。
只要是 Layer 3 的設備都一定會有 ARP Cache，並且會在 ARP 快取內建立 ARP 表格 (ARP Table) 用來記錄 IP 位址和實體位址的對應關係。這個 Table 會依據自身的存活時間遞減而消失，以確保資料的正確性。</description></item><item><title>Cross-site Scripting Attacks on Android Hybrid Applications</title><link>https://bernie6401.github.io/survey-papers/android-+-security/cross-site-scripting-attacks-on-android-hybrid-applications/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/survey-papers/android-+-security/cross-site-scripting-attacks-on-android-hybrid-applications/index.html</guid><description>Cross-site Scripting Attacks on Android Hybrid Applications :::info Bao, W., Yao, W., Zong, M., &amp; Wang, D. (2017, March). Cross-site scripting attacks on android hybrid applications. In Proceedings of the 2017 International Conference on Cryptography, Security and Privacy (pp. 56-61). :::
這一篇論文雖然很舊了，但還是蠻有趣的
Introduction 他在講的是現在市面上的App通常會用一些像是Apache Cordova(早期叫做PhoneGap)這類型的Hybrid框架製作一款App，但是PhoneGap的做法是利用WebView渲染畫面，因此就勢必會出現XSS相關的攻擊，這一篇論文就是在探討如何達成攻擊，以及受害範圍有多廣
Gartner 的一份報告稱，Hybrid App在基於 HTML5 的 Web App和本機 App之間提供了平衡，到 2016 年，將在超過 50% 的行動 App中使用 為了美化 UI 並在 JavaScript 程式碼中使用行動裝置的原生功能，Hybrid App必須包含第三方元件，而且它們的程式碼可能不可靠。 在本文的其餘部分，我們首先對WebView和PhoneGap框架的漏洞進行深入分析。 然後根據我們日常生活中行動應用的使用場景，建立了XSS攻擊混合應用的一般流程。 攻擊結果表明，對Hybrid App的 XSS 攻擊可能會對使用者的行動裝置造成更大的破壞性結果。 Background What is PhoneGap? 上圖顯示了PhoneGap App的架構以及如何和device component互動，當Hybrid App的某個功能需要使用 PhoneGap API 時， App可以使用 JavaScript 程式碼呼叫 API，然後 App中的特殊層將 PhoneGap API 呼叫轉換為適合幕後特定功能的device API。 Proposed Method How XSS attack success on PhoneGap’s App? 有兩種方是可以達成這個攻擊 首先從上圖可以知道，外部的資料有很多種型態，可能是一般文字、QRcode、藍牙等等媒介，而當傳送的資料出現malicious code的時候，PhoneGap Interface的App就會接收這些有問題的資料，並且直接被WebView所render，此時attacker就可以直接根據傳送的payload達到竊取機敏資料的目的 在使用者的幫助下注入程式碼。 當使用者開啟將行動裝置連接到外界的通道時，將提供存取權限以允許來自另一個裝置的攻擊。 惡意程式碼是透過在不知不覺中與另一個裝置互動來注入的，然後按照與第一個裝置類似的流程來實現攻擊。</description></item><item><title>Cryptography and Network Security - Final Project</title><link>https://bernie6401.github.io/security/course/ntu-cns/cryptography-and-network-security---final-project/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-cns/cryptography-and-network-security---final-project/index.html</guid><description>Cryptography and Network Security - Final Project Threshold HE Description With a designed scheme in place for threshold homomorphic encryption, private keys are divided into various shares among participating individuals who then work together to collaborate on computations without revealing plaintext material.
Decryption requires collaboration from at least the minimum requirement, e.g. $(t,n)$ means there’re $n$ participate parties but need at least $t$ parties’ granting to decrypt the secret just like secret sharing scheme proposed by Shamir. Threshold homomorphic’s primary objective is secure computation involving confidential information with lesser exposure or accessibility risks for single individuals - due to a shared understanding by several stakeholders.</description></item><item><title>Cryptography and Network Security - Regular Critique 2</title><link>https://bernie6401.github.io/security/course/ntu-cns/paper-critique/cryptography-and-network-security---regular-critique-2/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-cns/paper-critique/cryptography-and-network-security---regular-critique-2/index.html</guid><description>Cryptography and Network Security - Regular Critique 2 Reading Topic: A key-management scheme for distributed sensor networks tags: NTUCNS Name: 何秉學	Student ID: R11921A16
Summary Distributed Sensor Networks (DSNs) are quite different from traditional embedded system networks, such as the number of nodes. Therefore, the security of the communication between each node is crucial. However, the storage capacity and computation capability of each node is the shallow level which is not enough to handle. So, we can’t use high computing power techniques such as asymmetric cipher (RSA) to deal with it. In contrast, they decided to use a symmetric cipher system to implement it and focus the point on how to manage and keep the key safe. This paper aimed to address the number of keys that each node in DSNs has too much. For example, if the number of nodes in DSN is n, then each node has to keep n-1 shared keys for connecting. This is not a good plan to implement. Overall, they proposed a brand-new key management scheme for large-scale DSNs and attempt to find the balance between safety and efficiency. In addition, according to the simulation result, they found out the comparison is highly better than the traditional key pre-distribution scheme.</description></item><item><title>Cryptography and Network Security – Comparative Critique 1</title><link>https://bernie6401.github.io/security/course/ntu-cns/paper-critique/cryptography-and-network-security--comparative-critique-1/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-cns/paper-critique/cryptography-and-network-security--comparative-critique-1/index.html</guid><description>Cryptography and Network Security – Comparative Critique 1 Reading Topic: Reflections on trusting distributed trust Reading Topic: Reflections on Trusting Trust tags: NTUCNS Name: 何秉學	Student ID: R11921A16
:::spoiler Background 什麼是 Intel® SGX？
提供以硬體為基礎的記憶體加密功能，可在記憶體內隔離特定的應用程式碼與資料。Intel® SGX 允許將使用者層級的程式碼配置於記憶體中的隱私區域，這稱為「指定位址空間」(enclave)，其設計是為了在較高權限層級的執行程序中受到保護
What is firefox Telemetry
這個功能對 Mozilla 工程師來說很有幫助，它可以幫助工程師了解 Firefox 實際的運作狀況。Telemetry 會傳送使用量及體驗的資訊給 Mozilla。當您使用 Firefox 時，Telemetry 就會測量與收集與個人隱私無關的資訊，例如記憶體消耗、反應時間和各種功能的使用頻率。這些資訊會每天例行傳送給 Mozilla 利用，讓 Firefox 越來越完善。
Let’s Encrypt &amp; ISRG
Let’s Encrypt 是免費、自動化和開放的憑證頒發機構，由非營利組織網路安全研究小組 (Internet Security Research Group, ISRG) 營運。</description></item><item><title>Cryptography and Network Security – Comparative Critique 2</title><link>https://bernie6401.github.io/security/course/ntu-cns/paper-critique/cryptography-and-network-security--comparative-critique-2/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-cns/paper-critique/cryptography-and-network-security--comparative-critique-2/index.html</guid><description>Cryptography and Network Security – Comparative Critique 2 Reading Topic: The Password Reset MitM Attack Reading Topic: Is Real-time Phishing Eliminated with FIDO? Social Engineering Downgrade Attacks against FIDO Protocols tags: NTUCNS Name: 何秉學	Student ID: R11921A16
Background Downgrade Attack FIDO 是什麼？ Topic 1 Translation
Summary of paper 1 The Password Reset MitM Attack" paper aims to address a security vulnerability in the password reset process that allows attackers to intercept a victim’s password reset link and gain access to their account. This problem matters because attackers can compromise personal information and sensitive data. The paper presents the Password Reset Man-in-the-Middle (PRMitM) attack and proposes several defenses to mitigate the risk, including challenge-response protocols and additional authentication factors. The authors conclude that PRMitM attacks are a significant threat to online account security, and suggest implementing additional security measures and informing users of the risks to strengthen the security of their accounts.</description></item><item><title>Cryptography and Network Security – Comparative Critique 3</title><link>https://bernie6401.github.io/security/course/ntu-cns/paper-critique/cryptography-and-network-security--comparative-critique-3/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-cns/paper-critique/cryptography-and-network-security--comparative-critique-3/index.html</guid><description>Cryptography and Network Security – Comparative Critique 3 Reading Topic: DNSSEC VS DoH(DNS-over-HTTPS) tags: NTUCNS Name: 何秉學	Student ID: R11921A16
Background 什麼是 DNSSEC？
什麼是 DNSSEC？
網域名稱系統安全性擴充 (DNSSEC) 可為網域名稱的 DNS (網域名稱系統) 加上電子簽名，藉此判斷來源網路名稱的真實性。此功能可以保護網路使用者不受假造 DNS 資料的威脅，讓使用者要求正確網址時不會取得其他有意誤導或惡意製作的網址。
啟用 DNSSEC 後，DNS 查閱會使用電子簽名驗證網站 DNS 來源是否有效，這樣做可以協助防止受到特定類型的攻擊，而當電子簽名不一致的時候，瀏覽器便不會顯示網站。
What is DNS Cache Poisoning? - 小心網域名稱伺服器快取毒害(DNS cache poisoning)攻擊
簡單的說，DNS 通常都會實做快取(Cache)功能，若 DNS 收到來自惡意假造的 DNS 封包，導致將錯誤的 Domain Name v.s. IP 對應資料快取在 DNS Server 中，就會讓使用這台 DNS Server 的使用者連結到錯誤的 IP，這將會是個十分嚴重的安全性漏洞！而這樣的安全性漏洞就稱之為 DNS cache poisoning</description></item><item><title>Cryptography and Network Security – Homework 1</title><link>https://bernie6401.github.io/security/course/ntu-cns/homework/cryptography-and-network-security--homework-1/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-cns/homework/cryptography-and-network-security--homework-1/index.html</guid><description>Cryptography and Network Security – Homework 1 tags: NTUCNS :::spoiler TOC [TOC] ::: :::info Official Solution ::: Student ID: R11921A16 Name: 何秉學
Handwriting 1. CIA Ans: Confidentiality means all of the sensitive messages or information that can be protected so that just the people who have the authentication can edit or browse the information.
Integrity refers to the completeness of the message you transferred and ensured that the message is not altered by an unauthenticated person.</description></item><item><title>Cryptography and Network Security – Homework 2</title><link>https://bernie6401.github.io/security/course/ntu-cns/homework/cryptography-and-network-security--homework-2/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-cns/homework/cryptography-and-network-security--homework-2/index.html</guid><description>Cryptography and Network Security – Homework 2 tags: NTUCNS :::spoiler TOC [TOC] ::: Student ID: R11921A16 Name: 何秉學
Handwriting 1. SYN Cookies Ans: This strategy involves the creation of a cookie by the server. In order to avoid the risk of dropping connections when the backlog has been filled, the server responds to each connection request with a SYN-ACK packet but then drops the SYN request from the backlog, removing the request from memory and leaving the port open and ready to make a new connection. If the connection is a legitimate request, and a final ACK packet is sent from the client machine back to the server, the server will then reconstruct (with some limitations) the SYN backlog queue entry. While this mitigation effort does lose some information about the TCP connection, it is better than allowing denial-of-service to occur to legitimate users as a result of an attack.</description></item><item><title>Cryptography and Network Security – Homework 3</title><link>https://bernie6401.github.io/security/course/ntu-cns/homework/cryptography-and-network-security--homework-3/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-cns/homework/cryptography-and-network-security--homework-3/index.html</guid><description>Cryptography and Network Security – Homework 3 tags: NTUCNS :::spoiler TOC [TOC] :::
1. DDoS 1) Hint: You can use I/O Graphs to find the time that the flow starts to burst. Then you can find the first packet near there.
Ans: Using I/O graph in Statistic/I/O Graphs in wireshark, then you can figure out the whole trend of this network flow. :::spoiler Result Screenshot ::: Also, you can set the different scale of the graph and figure out the attack time precisely. I set the Interval=100ms and find the increasing time at 24.8s which is No.55862 packet shown as below. :::spoiler Result Screenshot ::: Thus, the attack time should be at 24.945277 and the victim is 192.168.232.95 :::spoiler Result Screenshot :::</description></item><item><title>Cryptography and Network Security – HW0</title><link>https://bernie6401.github.io/security/course/ntu-cns/homework/cryptography-and-network-security--hw0/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-cns/homework/cryptography-and-network-security--hw0/index.html</guid><description>Cryptography and Network Security – HW0 Reading Topic: The Tangled Web of Password Reuse tags: NTUCNS Name: 何秉學	Student ID: R11921A16
Summary Password security is a critical issue that we may pay attention. However, most people choose easy-remembered strings as their online-service password, which may cause the users to re-used the password as a different online service. Unfortunately, the number of network attacks is increasing, and attackers contain tons of users’ information including re-used passwords. They tried to propose a guessing password algorithm including character sequence, deletions, insertion, capitalization, reversal, leet-speak, and substring movement to guess a series of candidate passwords that users may use at different websites according to a set of leaked passwords. Their prototype guessing algorithm is able to crack approximately 10% of the nonidentical password pairs in less than 10 attempts and approximately 30% such pairs in less than 100 attempts.</description></item><item><title>Cryptography and Network Security – Regular Critique 3</title><link>https://bernie6401.github.io/security/course/ntu-cns/paper-critique/cryptography-and-network-security--regular-critique-3/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-cns/paper-critique/cryptography-and-network-security--regular-critique-3/index.html</guid><description>Cryptography and Network Security – Regular Critique 3 Reading Topic: Automated Detection of IPv6 Privacy Leakage in Home Networks tags: NTUCNS Name: 何秉學	Student ID: R11921A16
Background What is Customer Premise Equipment? - 用戶終端設備(CPE)
英文名稱為Customer Premise Equipment，是指網路連接至用戶端的相關設備，包括數據機、寬頻路由器、寬頻閘道器等，但隨著電信網路應用服務逐漸多元化，只要是用戶端所使用的網路服務設備，都可稱為CPE裝置，包括VoIP閘道器、IP phone、雙模手機、IP STB等。
What is EUI-64?
IPv6 Address太長，要網管人員逐個Interface設定IPv6 Address肯定是件痛苦的事。EUI-64讓我們只需幫Interface试定Prefix部份,然後Interface就會用MAC Address自動產生Interface ID，基於MAC Address 獨一無二，利用 EUI-64 必能生成獨一無二的 IPv6 Address。EUI-64 產生 Interface ID 的辦法是先把MAC Address （共48 Bits）斬開兩等份.中間插入FFFE供16 Bits），使其成為64 Bits，然後把第7 Bit由0改成1。最後在前面加上Prefix歟成為一組IPv6 Address 了。</description></item><item><title>Cryptography and Network Security – Regular Critique 4</title><link>https://bernie6401.github.io/security/course/ntu-cns/paper-critique/cryptography-and-network-security--regular-critique-4/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-cns/paper-critique/cryptography-and-network-security--regular-critique-4/index.html</guid><description>Cryptography and Network Security – Regular Critique 4 Reading Topic: Dos and Don’ts of Machine Learning in Computer Security tags: NTUCNS Name: 何秉學	Student ID: R11921A16
Summary In this paper, they tried to point out some pitfalls of computer security paper that are associated with machine learning. Especially the paper in the last 10 years published at top-tier conferences. In addition, they identify 10 common pitfalls such as sampling bias problems, label inaccuracy, data snooping problems, spurious correlations, etc that are associated with the whole machine learning workflow, i.e. data collection and labeling, system design and learning, performance evaluation and deployment, and operation. They also provide some recommendations and some remedies and try to mitigate the threat. The top 3 pitfalls in their research are sampling bias, data snooping, and lab-only evaluation.</description></item><item><title>Cryptography Lec 1(Overview) - Notes</title><link>https://bernie6401.github.io/security/course/ntu-crypto/cryptography-lec-1overview---notes/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-crypto/cryptography-lec-1overview---notes/index.html</guid><description>Cryptography Lec 1(Overview) - Notes tags: Cryptography NTU Background Chosen Plaintext Attack(CPA security) Attacker只可以拿到plaintext相對應的ciphertext，通常是在同一把key重複使用的情況下
Chosen Cipnertext Attack(CCA security) Attacker不只可以拿到plaintext相對應的ciphertext，他也可以知道ciphertext相對應的plaintext，進而得知很多額外的資訊
Mode of Operation e.g. ECB, CBC, CTR, GCM…(Nonsecure $\to$ Secure) 選擇甚麼樣的mode和選擇麼加密演算法是完全獨立的事情，也可以每一個block都使用完全不同的加密演算法</description></item><item><title>Cryptography Lec 2(Historical Ciphers) - Notes</title><link>https://bernie6401.github.io/security/course/ntu-crypto/cryptography-lec-2historical-ciphers---notes/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-crypto/cryptography-lec-2historical-ciphers---notes/index.html</guid><description>Cryptography Lec 2(Historical Ciphers) - Notes tags: Cryptography NTU :::spoiler 資訊安全筆記2 The Vigenere Cipher
The Vigenere Cipher是一種"polyalphabetic cipher"用一串的 Key 不斷地重複！例如 abcabcabcabc 計算方法： 例如key = d 代表a會變成d所以 w 會變成 Z
課本上的例子： :::
:::spoiler Playfair Cipher
The Playfair Cipher Encryption Algorithm: The Algorithm consists of 2 steps:
Generate the key Square(5×5): Algorithm to encrypt the plain text: The plaintext is split into pairs of two letters (digraphs). If there is an odd number of letters, a Z is added to the last letter. > For example: PlainText: "instruments" After Split: 'in' 'st' 'ru' 'me' 'nt' 'sz' :::info Note that: Pair cannot be made with same letter. Break the letter in single and add a bogus letter to the previous letter. :::</description></item><item><title>Cryptography Lec 3(Mathematical Background) - Notes</title><link>https://bernie6401.github.io/security/course/ntu-crypto/cryptography-lec-3mathematical-background---notes/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-crypto/cryptography-lec-3mathematical-background---notes/index.html</guid><description>Cryptography Lec 3(Mathematical Background) - Notes tags: Cryptography NTU Background :::spoiler Euclidean Algorithm(輾轉相除法) Given $a$ and $b$ with $a \ge b$ Compute $gcd(a,\ b)=gcd(b,\ a\ mod\ b)$, $gcd(a,\ 0)=a$ For example $$ Compute\ gcd(140,\ 297)\ 297=2140+17 \ 140=817+4 \ 17=44+1 \ 4=44+0 $$ Then we found the $gcd(140,\ 297)=1$
Another Example: $$ Compute\ gcd(270,\ 192)\ 270=1192+78\ 192=278+36\ 78=236+6\ 36=66+0 $$ Then we found $gcd(270,\ 192)=6$ :::
:::spoiler Extended Euclidean Algorithm 其實就只是把原本用Euclidean Algorithm算出來的$gdc(a,\ b)$，變成Linear Combination的形式而已 For example above: As we know $gcd(270,\ 192)=6$, then… $$ 6=78-362\ 36=192-278\ 78=270-1192 $$ $$\downarrow$$ $$ \begin{aligned} 6&amp;=78-(192-278)2\ &amp;=78-[192-2(270-1192)]2\ &amp;=78-[1923-2270]2\ &amp;=270-1192-1926+4270\ &amp;=2705-7192 \end{aligned} $$ Then we know the linear combination coefficient of $gcd(270,\ 192)$ is $+5$ and $-7$ :::</description></item><item><title>Cryptography Lec 4(Information Theory) - Notes</title><link>https://bernie6401.github.io/security/course/ntu-crypto/cryptography-lec-4information-theory---notes/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-crypto/cryptography-lec-4information-theory---notes/index.html</guid><description>Cryptography Lec 4(Information Theory) - Notes tags: Cryptography NTU Background :::spoiler Shannon’s Theorem 假設：$(P,\ C,\ K,\ e_k(\cdot),\ d_k(\cdot))$是一個cryptosystem，且$P,\ C,\ K$各自集合的數量都是一樣的 則： $$此cryptosystem具有perfect\ secrecy\ iff\ 每一把key被使用的機率都相同，i.e.{1 \over #K}，且對於每個m\in P和c\in C都有一個獨立的key\ k使得e_k(m)=c $$</description></item><item><title>Cryptography Lec 5(Symmetric Key Cryptography) - Notes</title><link>https://bernie6401.github.io/security/course/ntu-crypto/cryptography-lec-5symmetric-key-cryptography---notes/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-crypto/cryptography-lec-5symmetric-key-cryptography---notes/index.html</guid><description>Cryptography Lec 5(Symmetric Key Cryptography) - Notes tags: Cryptography NTU Background What is MDC and MAC? - 【CN007】数据安全笔记8 —— MDC 和 MAC
MDC 是一種用於驗證數據完整性的摘要信息，保證數據沒有被更改。 MAC 在 MDC 的基礎上增加了 Key 的使用。同時驗證數據完整性和發送者，保證發送者是特定人並且傳輸過程中數據沒有被更改。MAC 函數又稱為 Key 哈希函數（Keyed Hash Function） :::spoiler About RC4
第一部分 前置作業
建立一個 S-box（寫作 S） 決定密鑰 建立密鑰列表 K 第二部分 把 S 打亂
第三部分 加密
S = [0,1,2,3,4,5,6,7] K = [1,2,3,1,2,3,1,2] P = [5,3,6,7] j = 0 for i in range(8): j = ( j + S[i] + K[i] ) %8 S[i], S[j] = S[j], S[i] i, j = 0, 0 flag = 0 c_list = [] while flag &lt; len(P): i = (i + 1) % 8 j = (j +S[i]) % 8 S[i], S[j] = S[j], S[i] t = (S[i] + S[j] ) % 8 k = S[t] k = '{:03b}'.format(k) p = '{:03b}'.format(P[flag]) c = '' for n in range(3): c += str(int(k[n])^int(p[n])) c_list.append(int(c, 2)) flag += 1 print(c_list) Drawback RC4在後來被指出他所產生的密鑰並不隨機，存在統計上的偏誤，並且密文有洩漏明文資訊的可能， 因此已不再被建議使用。 :::</description></item><item><title>Cryptography Lec 6(Key Agreement Protocol) - Notes</title><link>https://bernie6401.github.io/security/course/ntu-crypto/cryptography-lec-6key-agreement-protocol---notes/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-crypto/cryptography-lec-6key-agreement-protocol---notes/index.html</guid><description>Cryptography Lec 6(Key Agreement Protocol) - Notes tags: Cryptography NTU Background About HSM(Hardware Security Module) - 什麼是硬體安全模組？
What is Wide-Mouth Frog?
The Wide Mouth Frog Protocol is a computer network verification protocol typically used on unsecured networks. It permits people communicating over a network to verify their identity to each other, it also helps in preventing replay attacks, or snooping and offers detection of any alteration and the prevention of any unwanted reading. This can be demonstrated by means of BAN (Burrows–Abadi–Needham) logic. However, to avoid active attacks, some form of message authentication or authenticated encryption must be used.</description></item><item><title>DEEPCASE Semi-Supervised Contextual Analysis of Security Events - Notes</title><link>https://bernie6401.github.io/survey-papers/ml-dl-+-security/deepcase-semi-supervised-contextual-analysis-of-security-events---notes/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/survey-papers/ml-dl-+-security/deepcase-semi-supervised-contextual-analysis-of-security-events---notes/index.html</guid><description>DEEPCASE Semi-Supervised Contextual Analysis of Security Events - Notes tags: Meeting Paper NTU :::info Van Ede, T., Aghakhani, H., Spahn, N., Bortolameotti, R., Cova, M., Continella, A., … &amp; Vigna, G. (2022, May). Deepcase: Semi-supervised contextual analysis of security events. In 2022 IEEE Symposium on Security and Privacy (SP) (pp. 522-539). IEEE. :::
Background What is NSM(Network Security Monitors)?
NSM主要目的是偵測、找出入侵者，提高能見度。它建立在「我們一定會被攻擊，而且最終防禦一定會被突破」的思惟上。假設意志堅決的駭客最終打穿我們辛苦建立的防禦，但只要能在入侵者進一步破壞、感染系統前偵測、做出回應，讓入侵者無法達到目的，便能阻擋這波攻擊
NSM不是等接收IDS/IPS等等資安設備觸發警示後才開始收集，而是平時便預先主動收集資料，提供NSM平台審視、分析，強化可見度，主動找出入侵軌跡
What is IDS(Intrusion Detection Systems)?
入侵偵測系統（Intrusion Detection System，IDS）是用來偵測資訊系統或網路上潛在的惡意破壞活動</description></item><item><title>DeepLog: Anomaly Detection and Diagnosis from System Logs through Deep Learning</title><link>https://bernie6401.github.io/survey-papers/ml-dl-+-security/deeplog_-anomaly-detection-and-diagnosis-from-system-logs-through-deep-learning/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/survey-papers/ml-dl-+-security/deeplog_-anomaly-detection-and-diagnosis-from-system-logs-through-deep-learning/index.html</guid><description>DeepLog: Anomaly Detection and Diagnosis from System Logs through Deep Learning tags: Meeting Paper NTU :::info Du, M., Li, F., Zheng, G., &amp; Srikumar, V. (2017, October). Deeplog: Anomaly detection and diagnosis from system logs through deep learning. In Proceedings of the 2017 ACM SIGSAC conference on computer and communications security (pp. 1285-1298). :::
Background Model - Log Parser Longest Common Subsequence(LCS) 認識 OpenStack
Some attack Blind Return Oriented Programming(BROP)</description></item><item><title>EIFFeL: Ensuring Integrity For Federated Learning - Notes</title><link>https://bernie6401.github.io/survey-papers/federated-learning/eiffel_-ensuring-integrity-for-federated-learning---notes/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/survey-papers/federated-learning/eiffel_-ensuring-integrity-for-federated-learning---notes/index.html</guid><description>EIFFeL: Ensuring Integrity For Federated Learning - Notes tags: Meeting Paper NTU :::info Roy Chowdhury, A., Guo, C., Jha, S., &amp; van der Maaten, L. (2022, November). Eiffel: Ensuring integrity for federated learning. In Proceedings of the 2022 ACM SIGSAC Conference on Computer and Communications Security (pp. 2535-2549). :::
Background 聯邦學習的簡單介紹
聯邦學習的流程大致上可以分成4步驟：
確定架構(拓樸) Formulate topology 梯度計算 Gradient compute 資訊交換 Information exchange 模型聚合 model aggregation What is Secure Aggregation?
What is Byzantine attacks?</description></item><item><title>Exploiting ML ALG for Efficient Detection and Prevention of JS-XSS Attacks in Android Based Hybrid Applications</title><link>https://bernie6401.github.io/survey-papers/android-+-security/exploiting-ml-alg-for-efficient-detection-and-prevention-of-js-xss-attacks-in-android-based-hybrid-applications/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/survey-papers/android-+-security/exploiting-ml-alg-for-efficient-detection-and-prevention-of-js-xss-attacks-in-android-based-hybrid-applications/index.html</guid><description>Exploiting ML algorithms for Efficient Detection and Prevention of JavaScript-XSS Attacks in Android Based Hybrid Applications :::info Khalid, U., Abdullah, M., &amp; Inayat, K. (2020). Exploiting ML algorithms for Efficient Detection and Prevention of JavaScript-XSS Attacks in Android Based Hybrid Applications. arXiv preprint arXiv:2006.07350. ::: 這一篇論文對於我的研究只有一點點用，大概補足了一些我對Android的XSS漏洞的認識。主要是在利用一些feature，訓練出能夠檢測有無XSS攻擊的模型
Introduction 首先，很多的手機App中都會使用WebView這個Component，也就是能夠直接嵌入一個mini browser在App中而不需要另外開啟外部的Browser才能瀏覽網頁，所以JS語言就能夠和Java語言互動，問題在於當從 JavaScript 呼叫 Java 時，攻擊者會將惡意 JavaScript 程式碼儲存在網頁中，當網頁在應用程式中開啟時，然後在 WebView 中註冊一個物件。 首先，攻擊者透過 JavaScript 存取該對象，並透過該對象存取該應用程式的本機方法，攻擊者可以透過觸發本機方法內的重要內建函數輕鬆取得不同的智慧型手機資源。
Contribution 自行創建一個Dataset，並且從500個不同的Apps中extract出7個不同的feature 訓練7種不同的ML 模型: Evolutionary-Support Vector Machine (E-SVM), Neural Network, Naive Bayes, Support Vector Machine(SVM), Bagging, Random Forest and J48 根據實驗結果給出F1-Score和執行時間，結果顯示Random Forest是最好的模型 Background WebView 這個component的存在理由如上所述，其中會用到幾的API: setJavaScriptEnabled API addJavascriptInterface API loadUrl API 第一個是enable可以使用JS，第二個是註冊Java物件，第三個就是實際把網頁load進來 Sandbox 如上圖，一般來說webview的瀏覽是會經過sandbox，確保可以控制web browser的access，讓他和本地資源不會共享；網頁和網頁之間要隔離，而網頁和主系統之間也會隔離 Bypassing sandbox mechanism 從上圖可以看出，儘管WebView中存在沙箱安全機制來保護行動裝置本地資源免受JavaScript攻擊，但WebView本身借助WebView提供的API繞過了沙箱機制。 這創建了一條路徑，JavaScript 可以輕鬆地與本機 Java 通訊。 並且攻擊者可以觸發Java的不同類別方法發動XSS攻擊，透過原生Java程式碼存取行動裝置的重要功能包括本機資源。 哪些類型的易受攻擊的 API 可以透過 Java 物件觸發？ 作者有整理出來一個表如下: Proposed Method 現在的重點是要如何分辨一個App他啟動了webview之後，是否會造成XSS攻擊，作者提出了由四個Level組成的偵測框架以及三個Layers的預防框架</description></item><item><title>FedML-HE - An Efficient Homomorphic-Encryption-Based Privacy-Preserving Federated Learning System - Notes</title><link>https://bernie6401.github.io/survey-papers/federated-learning/fedml-he---an-efficient-homomorphic-encryption-based-privacy-preserving-federated-learning-system---notes/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/survey-papers/federated-learning/fedml-he---an-efficient-homomorphic-encryption-based-privacy-preserving-federated-learning-system---notes/index.html</guid><description>FedML-HE - An Efficient Homomorphic-Encryption-Based Privacy-Preserving Federated Learning System - Notes tags: Meeting Paper NTU :::info Jin, W., Yao, Y., Han, S., Joe-Wong, C., Ravi, S., Avestimehr, S., &amp; He, C. (2023). FedML-HE: An Efficient Homomorphic-Encryption-Based Privacy-Preserving Federated Learning System. arXiv preprint arXiv:2303.10837. ::: [TOC]
Background 聯邦學習：攻擊方式 :::spoiler
成員推理攻擊 攻擊者試圖確定某些資料是否是訓練的一部分與模型反轉攻擊一樣，攻擊者利用返回的分類分數來創建多個這些 影子 模型，模型與受攻擊的原始模型具有相似的分類邊界。 給定一個 黑盒 機器學習模型和一個資料記錄，確定該記錄是否用作模型的訓練資料集的一部分，被證明是可能的，具有極高的準確性。 因此，僅對在給定輸入上返回模型輸出的黑盒 API 進行簡單的查詢訪問，就可能洩露有關模型訓練所依據的各個資料記錄的大量訊息。 推理攻擊的準確性隨著類別數量的增加而增加。 :::
What is Multi Party Computation (MPC)? :::spoiler
一方面，這突破了我們對溝通、合作與娛樂方式的想像，但另一方面，這也使得我們更容易受到資料誤用與竊取的侵害，尤其當這些資料與內部安全金鑰全都列為集中式管理。於是朝向安全多方運算(multi-party computation，MPC)技術發展。</description></item><item><title>How to Securely Collaborate on Data: Decentralized Threshold HE and Secure Key Update - Notes</title><link>https://bernie6401.github.io/survey-papers/crypto/how-to-securely-collaborate-on-data_-decentralized-threshold-he-and-secure-key-update---notes/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/survey-papers/crypto/how-to-securely-collaborate-on-data_-decentralized-threshold-he-and-secure-key-update---notes/index.html</guid><description>How to Securely Collaborate on Data: Decentralized Threshold HE and Secure Key Update - Notes tags: Meeting Paper NTU :::info Kim, E., Jeong, J., Yoon, H., Kim, Y., Cho, J., &amp; Cheon, J. H. (2020). How to securely collaborate on data: Decentralized threshold he and secure key update. IEEE Access, 8, 191319-191329. ::: [TOC]
Background Threshold Homomorphic Encryption - 閾值同態加密在隱私計算中的應用 :::spoiler
單密鑰同態加密 只有一個私鑰，且不同公鑰加密的密文無法相互計算。 閾值同態加密（多密鑰加密） 支持多個私鑰，不同公鑰加密的密文可以互相計算。 問題 多方聯合計算最安全的途徑是各自生成、保存公私鑰,但由於算法限制,不同公鑰加密的信息無法進行相互計算,導致隱私計算無法進行 假設多方使用一套公私鑰,雖然計算可以順利進行,但系統安全性會大大下降,系統中只要有一方被成功攻擊,私鑰就會泄露。 假設多方使用一套公私鑰,則無法決定由哪個參與方生成公私鑰 Solution - Threshold Homomorphic Encryption 由於單密鑰同態加密在實際應用中存在諸多關於密鑰使用、管理的問題,閾值同態加密(多密鑰同態加密)應運而生。簡單來說,閾值同態加密算法中存在多個私鑰、一個(或多個公鑰,使用該公鑰系統加密的密文之間可以相互計算,並且只有當參與解密的私鑰數量達到一定閾值時,才能成功解密密文,所以這種多密鑰同態加密算法又被稱為閾值同態加密</description></item><item><title>Identifying vulnerabilities of SSL/TLS certificate verification in Android apps with static and dynamic analysis</title><link>https://bernie6401.github.io/survey-papers/android-+-security/identifying-vulnerabilities-of-ssl_tls-certificate-verification-in-android-apps-with-static-and-dynamic-analysis/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/survey-papers/android-+-security/identifying-vulnerabilities-of-ssl_tls-certificate-verification-in-android-apps-with-static-and-dynamic-analysis/index.html</guid><description>Identifying vulnerabilities of SSL_TLS certificate verification in Android apps with static and dynamic analysis :::info Wang, Y., Xu, G., Liu, X., Mao, W., Si, C., Pedrycz, W., &amp; Wang, W. (2020). Identifying vulnerabilities of SSL/TLS certificate verification in Android apps with static and dynamic analysis. Journal of Systems and Software, 167, 110609. ::: 這一篇論文對我要做的東西非常類似，雖然本質上不一樣但有很多的觀點以及解決方式是可以參照的
Introduction 這篇文章探討了在Android應用程式中SSL/TLS憑證驗證的弱點，並提出了一種名為DCDroid的工具來偵測這些弱點。作者結合靜態和動態分析，分析了來自Google Play和360app的2213個應用程式，發現其中有20.65%可能存在弱點。透過DCDroid在兩部Android智慧手機上執行這些應用程式，最終確認了11.07%的應用程式對MITM和釣魚攻擊存在真正的弱點。
Background SSL/TLS and Android 一般來說，正確的驗證憑證的步驟為
在憑證鏈中的所有憑證有無過期 憑證或憑證鏈中的根憑證由客戶端的憑證授權單位（CA）簽署 證書中的網域名稱與所連接的伺服器的網域名稱相符 但是基於一些原因(例如: 使用self-signed certificate/伺服器的root憑證不在手機的CA list中/糾正某些第三方庫的不安全實作)導致開發者會自行實做一個憑證驗證的方法，而這時候就有可能會產生一些漏洞發生，例如: :::warning</description></item><item><title>Local Model Poisoning Attacks to Byzantine-Robust Federated Learning - Notes</title><link>https://bernie6401.github.io/survey-papers/federated-learning/local-model-poisoning-attacks-to-byzantine-robust-federated-learning---notes/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/survey-papers/federated-learning/local-model-poisoning-attacks-to-byzantine-robust-federated-learning---notes/index.html</guid><description>Local Model Poisoning Attacks to Byzantine-Robust Federated Learning - Notes tags: Meeting Paper NTU :::info Fang, M., Cao, X., Jia, J., &amp; Gong, N. (2020). Local model poisoning attacks to {Byzantine-Robust} federated learning. In 29th USENIX security symposium (USENIX Security 20) (pp. 1605-1622). :::
Background What is Non-IID? 首先：什麽是獨立同分布？
同分布：所有items均來自同一種概率分布； e.g. 你丟骰子，每次丟骰子到任何一個數字的概率都是1/6，是相等概率。或者說，在概率空間里面，你不論進行幾次抽樣實驗，他們都服從同樣一個分布。 獨立：這些sample items全部都是獨立事件； e.g. 每次抽樣之間沒有關系，不會相互影響。比如你在隨便丟骰子，每次拋到的數字是幾就是幾，是獨立的。但如果我要求你要兩次拋到的數字和大於等於9，第一次和第二次拋就不獨立，因為他們相互關聯。 非獨立：有些數據處理的順序不夠隨機。比如有些按時間和其他一些標準來排序的數據會出現相關的情況，違反非獨立的原則。 非同分布：數據因所處在不同的分區而出現不同的分布。 Non-IID其實有三種：不獨立但同分布，獨立不同分布，不獨立也不同分布。 實用拜占庭容錯機制理解 拜占庭將軍問題是一個協議問題，拜占庭帝國軍隊的將軍們必須全體一致的決定是否攻擊某一支敵軍。問題是這些將軍在地理上是分隔開來的，並且將軍中存在叛徒。叛徒可以任意行動以達到以下目標：欺騙某些將軍采取進攻行動；促成一個不是所有將軍都同意的決定，如當將軍們不希望進攻時促成進攻行動；或者迷惑某些將軍，使他們無法做出決定。如果叛徒達到了這些目的之一，則任何攻擊行動的結果都是注定要失敗的，只有完全達成一致的努力才能獲得勝利。
這一問題是一種對現實世界的模型化，尤指網絡當中由於軟硬件錯誤、網絡阻塞及惡意攻擊導致的各種未知行為。
拜占庭容錯 拜占庭將軍問題提出後，有很多的算法被提出用於解決這個問題。這類算法統稱拜占庭容錯算法（BFT: Byzantine Fault Tolerance）。簡略來說，拜占庭容錯（BFT）不是某一個具體算法，而是能夠抵抗拜占庭將軍問題導致的一系列失利的系統特點。 這意味著即使某些節點出現缺點或惡意行為，拜占庭容錯系統也能夠繼續運轉。本質上來說，拜占庭容錯方案就是少數服從多數。
拜占庭容錯系統需要達成如下兩個指標： 安全性：任何已經完成的請求都不會被更改，它可以在以後請求看到。在區塊鏈系統中，可以理解為，已經生成的賬本不可篡改，並且可以被節點隨時查看。 活性：可以接受並且執行非拜占庭客戶端的請求，不會被任何因素影響而導致非拜占庭客戶端的請求不能執行。在區塊鏈系統中，可以理解為，系統需要持續生成區塊，為用戶記賬，這主要靠挖礦的激勵機制來保證。 Aggregation Rules Krum Algorithm Krum算法原理 Krum算法的核心思想是在每輪訓練結束後，對參與者的本地模型權重進行一種特殊的排序和選擇。具體來說，Krum算法遵循以下步驟：</description></item><item><title>Machine Learning Hand-write Homework &amp; Answer</title><link>https://bernie6401.github.io/security/course/ntu-ml/machine-learning-hand-write-homework--answer/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-ml/machine-learning-hand-write-homework--answer/index.html</guid><description>Machine Learning Hand-write Homework &amp; Answer tags: NTU_ML Machine Learning HW1 HW1-Ans HW2 HW2-Ans HW3 HW3-Ans HW4 HW4-Ans</description></item><item><title>NTU CNS Final Project Proposal</title><link>https://bernie6401.github.io/security/course/ntu-cns/ntu-cns-final-project-proposal/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-cns/ntu-cns-final-project-proposal/index.html</guid><description>NTU CNS Final Project Proposal tags: NTUCNS Problem description / Research question(秉學) Terminology Federated Learning is a decentralized machine learning method that enables training models without exposing data. Traditional machine learning methods require all data to be centralized in one location for training, but Federated Learning enables models to be trained on many distributed devices, such as smartphones, tablets, or embedded devices, with each device training its own local data. This greatly reduces data transmission and storage requirements and better protects user privacy.</description></item><item><title>NTU Compiler Technology Previous Exam 2019 Spring</title><link>https://bernie6401.github.io/security/course/ntu-ct/ntu-compiler-technology-previous-exam-2019-spring/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-ct/ntu-compiler-technology-previous-exam-2019-spring/index.html</guid><description>NTU Compiler Technology Previous Exam 2019 Spring tags: NTU_CT NTU Compiler Techonology of Programming Language Final Exam Please explain three different compiler optimization techniques : (a) 1st compiler optimization technique: (5points/5) (b) 2nd compiler optimization technique: (5points/10) (c) 3rd compiler optimization techniques: (5points/15)
Many computer systems provide an interactive debugger (for example, gdb or db x) to assist users in diagnosing and correcting runtime errors. Although a debugger is run long after a compiler has done its job, the two tools still must cooperate. What information (beyond the translation of a program) must a compiler supply to support effective runtime debugging? (5 points/20)</description></item><item><title>NTU Compiler Technology Previous Exam 2020 Spring</title><link>https://bernie6401.github.io/security/course/ntu-ct/ntu-compiler-technology-previous-exam-2020-spring/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-ct/ntu-compiler-technology-previous-exam-2020-spring/index.html</guid><description>NTU Compiler Technology Previous Exam 2020 Spring tags: NTU_CT NTU Compiler Techonology of Programming Language Final Exam According to the grammar of AC in the right , please write down the recursive descent parsing procedure for nonterminal Expr. (10 points/10) Please write down a regular expression that defines the set of strings recognized by the FA in the following and explain your answer (5points/ 15)</description></item><item><title>NTU Compiler Technology Project 1</title><link>https://bernie6401.github.io/security/course/ntu-ct/ntu-compiler-technology-project-1/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-ct/ntu-compiler-technology-project-1/index.html</guid><description>NTU Compiler Technology Project 1 tags: NTU_CT NTU Compiler Techonology of Programming Language AcDc Compiler Description This is a project from NTU (National Taiwan University) course, Compiler Technology of Programming Language. First project is aim to add multiplier and division operation in this compiler let compiler can recognize multi character identifier(variable) name by alphabet string use constant folding to optimize the statement How to use? You can browse Assignment1.pdf. You must run in Linux OS environment(more conveniently). When you finish the coding, use $ make command directly. $ ./AcDc &lt;input sample address> &lt;output file address> For instance: $ ./AcDc ../test/sample1.ac ./output Something need to know first It can not recognize the bottom line as identifier name. It can not print negative value like $1-2=-1$ expression. Actually speaking, it can calculate correctly but it can not print it out.(I’ll check it out later.) You can check constfold testbench Solution and Why: In Dc Language, the bottom line represent negative symbol. You can not just use minus as negative symbol, replace it by bottom line instead. It can not recognize identifier name with numbers. You can check longname.ac The other testbenchs can compile from Ac language to Dc language correctly. Reference AcDc AcDcCompiler</description></item><item><title>NTU Compiler Technology Project 2</title><link>https://bernie6401.github.io/security/course/ntu-ct/ntu-compiler-technology-project-2/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-ct/ntu-compiler-technology-project-2/index.html</guid><description>NTU Compiler Technology Project 2 tags: NTU_CT NTU Compiler Techonology of Programming Language Scanner :::spoiler [TOC] :::
Objective This is compiler project 2 that aim to construct the scanner by handmade with some sample code. The output is symbol table that the frequency of each identifier and the result is sorted.
Run and Test $ make /*use make in src folder*/ $ ./scanner ../test/sample1.ac Output of each sample For sample1.ac</description></item><item><title>NTU Compiler Technology Project 3</title><link>https://bernie6401.github.io/security/course/ntu-ct/ntu-compiler-technology-project-3/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-ct/ntu-compiler-technology-project-3/index.html</guid><description>NTU Compiler Technology Project 3 tags: NTU_CT NTU Compiler Techonology of Programming Language YACC Lex [TOC]
Objective The main task for this project is to revise src/parser.y and generate parser file properly to compile test code in test folder. And then use Graphviz command to visualize the structure of these test code How to run? Just use make to compile all files in /src. Though you’ll get a lots of warning shown as below, you can ignore them and obtain the target file parser. bison -v -d parser.y parser.y: warning: 1 shift/reduce conflict [-Wconflicts-sr] flex lexer.l gcc -g -c alloc.c gcc -g -c parser.tab.c parser.tab.c: In function ‘yyparse’: parser.tab.c:2565:7: warning: implicit declaration of function ‘yyerror’; did you mean ‘yyerrok’? [-Wimplicit-function-declaration] yyerror (YY_("syntax error")); ^~~~~~~ yyerrok parser.y: At top level: parser.y:825:3: warning: data definition has no type or storage class yydebug = 1; ^~~~~~~ parser.y:825:3: warning: type defaults to ‘int’ in declaration of ‘yydebug’ [-Wimplicit-int] parser.y:827:1: warning: return type defaults to ‘int’ [-Wimplicit-int] main (argc, argv) ^~~~ parser.y: In function ‘main’: parser.y:834:5: warning: implicit declaration of function ‘printGV’; did you mean ‘printf’? [-Wimplicit-function-declaration] printGV(prog, NULL); ^~~~~~~ printf gcc -g -c functions.c gcc -g -o parser parser.tab.o alloc.o functions.o -lfl Use parser to compile all files in /test folder and you will get AST_Graph.gv in /test folder. /src ./parser ../test/control.c dot -Tpng -o ../test/control.png ../test/AST_Graph.gv ./parser ../test/decl.c dot -Tpng -o ../test/decl.png ../test/AST_Graph.gv ./parser ../test/expr.c dot -Tpng -o ../test/expr.png ../test/AST_Graph.gv ./parser ../test/func.c dot -Tpng -o ../test/func.png ../test/AST_Graph.gv Note that in parser.y, I set yydebug = 1 so that we can see the debug message from parser #ifdef YYDEBUG yydebug = 1; #endif For TA I changed a little bit functions.c that will generate AST_Graph.gv at test/ folder. void printGV(AST_NODE *root, char* fileName) { if (fileName == NULL) { fileName = "../test/AST_Graph.gv"; } ... } Analysis You can see the relationship between structure map and test code by yourself. control.c int main() { int i; int p; int k, j; for (i=0; i&lt;9; i=i+1) { /* empty */ } for (i=0, p=4+4; i&lt;9; i=i+1, p=i) { write("test"); } for (;;) { /*empty*/ } while (1) { } while (2) { write("haha"); write("wow"); } if (k == j) { write("first"); } if (k == j) { write("first"); } else if (j == k) { write("second"); } else { write("third"); } } decl.c typedef float GFLOAT; int main() { typedef int INT, INT2, INT3; typedef float FLOAT; typedef void VOID; typedef void VOID2, VOID3; INT f[3][3*3-(4+2)/2]; FLOAT f2; } expr.c int fn1() { return 1; } float fn3() { return 1.0; } int fn4(int a, int b) { return 1; } int expr(int a, int b, int c, int d, float fa, float fb, float fc) { int i, j, k, l; float fi = 1.0, fj = 2.0, fk = 3.0, fl = 4.0; fi = 1.2*fi + -fj * (fl - fk * fn3()); fi = -fn3() -(-(-(4))); fi = !fn3() -(!(!(4))); i = !fn1(); i = 1 &lt; 2; i = 1 > 2; i = 1 >= 2; i = 1 &lt;= 2; i = 1 != 2; i = 1 == 2; i = fn4(1+3*4*fn4(2,3), 3); return 1; } int main() { } func.c int fn1() { int ABC = 5; return ABC+5; } void fn2() { } void fn3(int a, int b[3][4]) { } int main() { int b[4][4]; fn1(); fn2(); fn3(2, b); } Reference Github example Simple intro of yacc &amp; lex Simple intro of Graphviz A GUIDE TO LEX &amp; YACC from TA 大推：以lex/yacc實作算式計算機</description></item><item><title>NTU Compiler Technology Project 4</title><link>https://bernie6401.github.io/security/course/ntu-ct/ntu-compiler-technology-project-4/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-ct/ntu-compiler-technology-project-4/index.html</guid><description>NTU Compiler Technology Project 4 tags: NTU_CT NTU Compiler Techonology of Programming Language Code Generation [TOC]
How to run? First, put your testing file and main.S to the folder same as parser file
$ make $ ./parser [testing file].c $ aarch64-linux-gnu-gcc -static -O0 main.S $ qemu-aarch64-static ./a.out Or, you can put the run.sh and main.S in the same directory and run
$ ./run.sh [your parser] [the C file] $ qemu-aarch64-static ./a.out Note that you must change your test file’s main() to MAIN()</description></item><item><title>NTU Machine Learning Final Project Proposal Notes</title><link>https://bernie6401.github.io/security/course/ntu-ml/ntu-machine-learning-final-project-proposal-notes-1/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-ml/ntu-machine-learning-final-project-proposal-notes-1/index.html</guid><description>NTU Machine Learning Final Project Proposal Notes tags: NTU_ML Machine Learning Paper Used Technique / Ingenuity Suitable / Unsuitable Reason Replace to [1] Models overview3D maps of gray and/or white matter (deep learning models: six layer CNN, ResNet, and Inception V1)vertex wise measurements from the surface-based processing (models BLUP and SVM)Model 1: Best Linear Unbiased Predictor(BLUP)Model 2: Support Vector RegressionModel 3: Six-Layer Convolutional Neural NetworksModel 4: Specialized Six-Layer Convolutional Neural Networks for Younger and Older SubjectsModel 5: ResNetModel 6: Inception V1 Additional ExperimentsDifferent Types of Model Combination: Linear Regression vs. Random ForestCombining Seven (Identical) Convolutional Neural Networks or the Seven Best EpochsInfluence of the Type of Brain Features on Prediction Accuracy Suitable:In this field, it’s very clearly on comparing 6 variety models which can help us to know the implementation what we learned in class.Also can aware of the result between high level model and custom level modelFor linear regression and random forest, they trained the ensemble algorithms on a random subset. They repeated this process 500 times to get a bootstrap estimate of the SE of the MAE. N/A [2] 2D and 3D-CNN on age estimationFor 2D-CNN, we consider the features as an image of size 168×60 (DH×M) ignoring the days as temporal information.However, for 3D-CNN, we consider the features as a 3D volume with temporal information across the days, where each day has 24 hours and an hour is 60 minutes. So to break it down, we represent the features as a three dimensional information of 7×24×60 (D×H×M) minutes. Unsuitable: Though the topic is interesting, the technique content is less then expectation and the . No Idea Yet [3] Model for classification:Random Forest, GLMNet, SVM(including e1071, which is a package of LibSVM in R language, LiblinearR, kernlab, Rgtsvm), and xgboostCalibration Algorithm(i.e. post-processing):logistic regression(GLM function), BRGLM, GLMNetPerformance evaluation: HandTill2001 Suitable:The reason is as the same as [1] which also used various methods and compare it to other papers detailed. N/A Appendix The custom model in [1]</description></item><item><title>NTU Machine Learning Final Project Proposal Notes</title><link>https://bernie6401.github.io/security/course/ntu-ml/ntu-machine-learning-final-project-proposal-notes/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-ml/ntu-machine-learning-final-project-proposal-notes/index.html</guid><description>NTU Machine Learning Final Project Proposal Notes tags: NTU_ML Machine Learning Deep6mAPred: A CNN and Bi-LSTM-based deep learning method for predicting DNA N6-methyladenosine sites across plant species Introduction &amp; Motivation DNA methylation alters activities of DNA segments without changing the sequence, which thus yields a wide variety of roles in the cellular processes across organisms or tissues DNA methylation is widely distributed both in prokaryote and in eukaryote, but the proportion of methylated residues differs greatly with species DNA methylation is essential for normal development DNA methylation is increasingly attracting attentions from biologists Related works Even Luo et al.[41] - proposed the DNA 6mA as a new epigenetic mark in eukaryotes</description></item><item><title>NTU Machine Learning Homework 1</title><link>https://bernie6401.github.io/security/course/ntu-ml/ntu-machine-learning-homework-1/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-ml/ntu-machine-learning-homework-1/index.html</guid><description>NTU Machine Learning Homework 1 tags: NTU_ML Machine Learning How to choose features of data After observing the training data visualized image, you can be aware of the relationship between the PM2.5 feature and the others. For instance, the CO image, NO image, NO2 image, and NOx image are much more correlated with PM2.5. I also choose PM10, WS_HR, RAINFALL, RH, WIND_SPEED, and PM2.5 which you can see here I used Zscore normalization to implement in my project and can see as below You can see the different result of using or unusing normalization with the same config. Epoch Regression LR Feats Batch Size Loss Fn. Opti. RMSE Data Filter Norm. Data 200 1st-order 0.015 [1-4, 6-9, 13, 14] 1024 MSE Adam 2.44623 Yes Yes 200 1st-order 0.015 [1-4, 6-9, 13, 14] 1024 MSE Adam 2.44623 Yes No Hyperparameter and Preprocessing All my testing config can be found in Training Result.xlsx I used a filter to choose valid data and set a threshold by observing the visualized figure of all features. My takeaway **(Solved->See the last paragraph)**Using normalization is not like what I thought. Practically speaking, using normalization can gather all data to a specific area that the model can converge much more rapidly. But, in this case, the result is worse and also appear negative value of the PM2.5 result. According to this page, maybe the normalization method is not suitable in my case. **(Solved->See the last paragraph)**I also figured that using the stored weight and bias by my pretrained model is not the right way. I used pickle to store the dump parameters during the training and used the best one as my pretrained parameter. But it’s still not that good enough. The better way in this project to enhance your accuracy is tuning your training config and select good features. After discussing with my friend, I figured out the problem and tried to solve it successfully by fitting numpy random seed. Then, the parameter will truly fix but normalization is still not working to help model converging. Update 2022/12/06 update - Refer to 相關 taught by Dr.李柏堅, I use Pearson Correlation to compute the correlation of each factor and PM2.5 and the result is shown as below. According to the video, |r| &lt; 0.4 is low correlation, 0.4 ≦ |r| &lt; 0.7is medium correlation, and 0.7 ≦ |r| &lt; 1 is high correlation. So, the factor CO, NO, NO2, NOx, PM10, and SO2 are quite suitable as our input data to address this regression problem. Factor AMB_TEMP CO NO NO2 NOx O3 PM10 WS_HR RAINFALL RH SO2 WD_HR WIND_DIREC WIND_SPEED r -0.176147465 0.659147668 0.227219147 0.554273687 0.51365014 0.233923944 0.818868214 -0.102047405 -0.060801221 -0.081576429 0.361333416 0.171932397 0.137658351 -0.10119696</description></item><item><title>NTU Machine Learning Homework 2</title><link>https://bernie6401.github.io/security/course/ntu-ml/ntu-machine-learning-homework-2/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-ml/ntu-machine-learning-homework-2/index.html</guid><description>NTU Machine Learning Homework 2 tags: NTU_ML Machine Learning :::spoiler Click to open TOC [TOC] :::
Objective We’d like to classify human-being emotion by using CNN model that self-construct or others ready-made such as ResNet or VGG model.
Data We used emotional dataset from FER2013 that were preprocessed by lecture TA.
Models Originial
self.conv_0 = nn.Sequential( nn.Conv2d(1, 64, kernel_size=3, padding=1), nn.BatchNorm2d(64, eps=1e-05, affine=True), nn.LeakyReLU(negative_slope=0.05), nn.MaxPool2d((2, 2)), ) I’ve used 3-level model for training but not have good result</description></item><item><title>NTU Malware Reverse HW 1 write up</title><link>https://bernie6401.github.io/security/course/ntu-mr/ntu-malware-reverse-hw-1-write-up/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-mr/ntu-malware-reverse-hw-1-write-up/index.html</guid><description>NTU Malware Reverse HW 1 write up tags: NTU_MR Malware Reverse Engineering and Analysis NTU [TOC]
Task 1 Analyze the Lab06-01.exe What is the major code construct found in the only subroutine called by main? Ans: It has only an if statement in the main function. What is the subroutine located at 0x40105F? Ans: It’s just a printf function. At the beginning, I can not recognize this code block do exactly until I analyze the program behavior by using string side bar to search the specific string in the code.</description></item><item><title>NTU Malware Reverse HW 2 write up</title><link>https://bernie6401.github.io/security/course/ntu-mr/ntu-malware-reverse-hw-2-write-up/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-mr/ntu-malware-reverse-hw-2-write-up/index.html</guid><description>NTU Malware Reverse HW 2 write up tags: NTU_MR Malware Reverse Engineering and Analysis NTU [TOC]
Task 1 執行勒索病毒Dharma與Process monitor並截圖Dharma的Process Tree，並分析說明每個Process行為 Ans:
Conhost.exe: It’s defined by Microsoft and is normally legal and safe. Working on Win7, Win8, and Win10. The main function of this PE file is to let Command Prompt and Windows File Explorer can interact. The other function is to support users who can drag the file or folder to the command prompt directly. Most of the time, it’s a safe file that even repeats execution many times. However, in some circumstances, the viruses will pretend a conhost.exe file to use massive memory or store it in the wrong folder.[1]</description></item><item><title>NTU Malware Reverse Lab 1 write up</title><link>https://bernie6401.github.io/security/course/ntu-mr/ntu-malware-reverse-lab-1-write-up/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-mr/ntu-malware-reverse-lab-1-write-up/index.html</guid><description>NTU Malware Reverse Lab 1 write up tags: NTU_MR Malware Reverse Engineering and Analysis NTU Name 何秉學 StuID R11921A16 WannaCry Change variable and data type Follow the video and replace most of the variable that ghidra did not recognize and retype them also. According to the video, you must search the entry point function(local_6c = FUN_00408140();) first and replace the signature by here Then click into WinMain function and you’ll see a strange url at the beginning of the top. Try to rename and retype it as char*. Ghidra can not recognize InternetOpenA, and InternetOpenUrlA. But you can found that ghidra cannot recognize hinternet datatype as well. So, we must create new datatype in Datt Type Manager. And in write_1831_to_tasksche.exe function, the first if-statement has 4 variable that ghidra can’t recognize, including createProcessA, _createFileA, _writeFile, _closeHandle. So, you’re not only rename them but retype them for the following statement for each of them.(Ghidra has all type of them but it just can not recognize.) When you have 1831.bin file(you can follow Analyze part at 5-th and 6-th section), useing Defined String window to check out some function including unzip_something function. Scroll down the Defined String, you’ll see string 13AM4VW2dhxYgXeQepoHkHSQuy6NgaEb94 at 0x0040f488. Then in assembly code, there’re 3 similar function be called at the sametime. We called it bitcoin_something function. Analyze For the first part to analyze, you can check out for loop after strange_url variable. It does this loop for 14 times and copy strange_url to strange_url_copy by andding 4. Next, you can find an if statement at the below. Check this out carefully, it the internet request failed, it’ll access wannacry_real_entry() function. Enter to wannacry_real_entry function, you’ll see another if statement to examine your argument input. If you keyin less than 1 argument, it’ll execute no_argument_handler function and start create_wannacry_service function. Checking wannacry program in second function of no_argument_handler function by assembly language, you’ll find there’re two sprintf structure are not correct in the middle paragraph. Because, there’re two more argument should be pushed in stack but not be recognized by ghidra, including s_tasksche.exe_0043136c and 0x00407dea and s_WINDOWS_00431367 at 0x00407df2. So, we have to override this line signature and add the remaining argument back to sprinf. So, let’s take a look at this flow chart of what happened so far Then I used another VM(Ubuntu) to command wrestool to analyze wannacry file and output another file named 1831.bin. Using ghidra to analyze this file. Then do the same thing as above that what we do to analyze wannacry file such as change WinMain signature or renamee variable or retype variable, etc. While you’re analyzing in WinMain function, you’ll see a strange variable &amp;_Str2_0040f538 which store ‘/i’ characters. You can just press ‘c’ in assembly code to show ‘\i’. Next, scroll down this file, you’ll see a strange swprintf parameter called _Count_0040f40c. Then select all addr type data and right click mouse and select clear with option. You’ll see many unicode strings. Finally, right click DAT_0040f40c and choose Data/TerminatedUnicode. Finally, you can check this figure to know the whole operation flow 1.1 What is the ‘killswitch’ string? Ans: http://www.iuqerfsodp9ifjaposdfj 1.2 What is the unzip password? (as show in below) Ans: WNcry@2o17</description></item><item><title>NTU Malware Reverse Lab 2 write up</title><link>https://bernie6401.github.io/security/course/ntu-mr/ntu-malware-reverse-lab-2-write-up/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-mr/ntu-malware-reverse-lab-2-write-up/index.html</guid><description>NTU Malware Reverse Lab 2 write up tags: NTU_MR Malware Reverse Engineering and Analysis NTU Name 何秉學 StuID R11921A16 Analyze the malware 1 found in the file Lab13-02.zip -> Lab13-02.exe, generate ‘yourself’ write ups (with screenshots) and answer the follow questions : 1.1 Using dynamic analysis, determine what this malware creates. Ans:
According to reference, you can also use procmon(Process Monitor) to monitor the whole progress after executing this file. The progress of first iteration is shown as below Then use PEiD to check if the file has shell or not. And refer to the result as below, it seems has not shell, so that we can use IDA directly. I used IDA to analyze this executable file and observe that it’ll execute sub_401851 function every 10 seconds. And when I execute it in VM, it’ll create a temp file name temp00XXXXXX. int __cdecl main(int argc, const char **argv, const char **envp) { while ( 1 ) { Sleep(5000u); sub_401851(); Sleep(5000u); } } 1.2 Use static techniques such as an xor search, FindCrypt2, KANAL, and the IDA Entropy Plugin to look for potential encoding. What do you find?(Install findcrypt and IDA Entropy plugin can refer to Appendix 1, 2) Ans:</description></item><item><title>NTU Malware Reverse Lab 3 write up</title><link>https://bernie6401.github.io/security/course/ntu-mr/ntu-malware-reverse-lab-3-write-up/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-mr/ntu-malware-reverse-lab-3-write-up/index.html</guid><description>NTU Malware Reverse Lab 3 write up tags: NTU_MR Malware Reverse Engineering and Analysis NTU [TOC]
Name 何秉學 StuID R11921A16 Review Packing and Unpacking How does packing and unpacking work? 作者會把原本的code section和data section，放在UPX1，並且用unpacking stub(裡面存放解殼的程式)，把UPX1的內容一點一點的還原回UPX0(也就是空區段)，並跳回正常程式的執行進入點(original entry point, OEP)，最後跳回去的動作叫做Tail Jump或Long Jump，另外，多長的jump才是長，可能要依照經驗值判斷，或是直接跳過去後分析程式在幹嘛 實際上執行脫殼的時候，除了OEP的重建外，還需要重建Imports，這兩者都處理好後才算是脫殼完成 當分析脫殼執行到如下圖這樣的情況時，就離終點不遠了，也就是jmp的地址離目前的程式很遠，且之後的程式有很多空指令或垃圾byte，此為UXP殼的特徵 可以用PEiD這個工具(或是用Entropy之類的，但是不一定準確)判斷樣本有沒有加殼，或是加了甚麼殼，上圖是沒有加殼的一般程式，下圖是加了UPX的加殼程式 若是要處理Import Table Reconstruction，可以用OllyDump、ImpRec或是Scylla這些工具來進行，在Practice中是用Scylla演示(且可以搭配x32dbg或x64dbg進行) 老師有說在Long Jump之前會搭配pop instruction，這可能可以當作解析OEP的線索 Tail Jump，不一定是用jmp，也可以是call instruction；另外，跳轉的地址也不一定是一個明確的地址，也可能用暫存器存起來，這部分可以注意一下 Practice - upx_exercise.exe Observation First things first, we can observe the file by executing it directly. Obviously, you should enter correct CTF key by analyzing. Unpacking Static analysis - IDA Pro You are not allowed to disassembly by doing nothing, because it was packed by UPX. Therefore, our objective is to unpack it and try to analyze it original code to get the CTF Flag. Dynamic analysis - x32dbg In UPX-based packing, it has a feature that in order to not let the data be flushed during unpacking, it must store all data to the stack by using pushad instruction. Then, you’ll see a lot of jmp instruction to unpack the original code. Scrolling down the code, you’ll see a popad instruction at 0x0134AEDE , a jmp instruction at 0x010EAEEC, and a lots of null instruction which all three are satisfied all features that UPX-based packing method has. It’ll restore all data that stored in stack and jump to upx_exercise.134244D. Set the break-point and press run button in x32dbg, then press step into button to observe the code. Now, the code has already unpacked, then we can use Scylla to do Import Reconstruction. Press IAT Autosearch(Import Address Table) button to search and then press Get Imports button. Finally, you will get all imports that this file used, and Scylla will help you to rebuild it. Press Dump button to get IAT file. Press Fix Dump and choose the file what we dump to reconnect the IAT and this file. You’ll see the log said Import Rebuild success and you’ll get a new file named upx_exercise_dump_SCY.exe that repaired by Scylla. Analyze Re-static analysis - IDA Pro Used IDA to reanalyze the unpacking file. Used string searching to find the string nope that appear in your cmd. Used cross reference to find which part has used it. The main part is shown as below ... sub_E01EB0(std::cin, &amp;Memory); LOBYTE(v116) = 1; MEMORY[0] = 0; v96 = 0xFCC1D3C4; v97 = 0xD8D2C8DE; v98 = 0xD8D3E8E0; v99 = 0xD8C2EFB0; v100 = 0xC2ECB3C1; v101 = 0xB3EBE1D8; v102 = 0xD5F3D8BE; v103 = 0xB3EFD8DE; v104 = 0xF5C2E3D5; v105 = 0xFAD6D6D8; v64 = 1; HIBYTE(v95) = 1; v65 = 0; v93 = 0; while ( v65 &lt; 40 ) { v66 = (char *)&amp;Memory; if ( v111 >= 16 ) v66 = (char *)Memory; v67 = v66[v65] ^ 0x87; v68 = *((unsigned __int8 *)&amp;v96 + v65); v94 = 0; if ( v67 != v68 ) v64 = v94; HIBYTE(v95) = v64; v93 = ++v65; } v69 = "Congratz?!"; if ( !v64 ) v69 = "Nope!"; ... From v96 to v105, it stored 40 bytes and it seems do something in while loop 40 times. In addition, v67 = v66[v65] ^ 0x87; this line used xor instruction that seems a encrypt part. And then it compared &amp;v96 + v65 and v67 that encrypt the string what you input. If all the strings you input after process xor to 0x87 are strictly the same with v96 to v105, then it’ll print Congratz?!, otherwise, print Nope. Used online_xor to get v96 to v105 encrypted strings. And then used online_hex2ascii to get the CTF Flag. The answer is **CTF{YOU_goT_7hE_F4kE_fl49_tRY_h4RdEr_QQ}**, though it is not a real answer. Note that, the demo from TA is finished, therefore, I still don’t know the real flag is. Homework - upx_Revil.exe Static Analysis Observation Use IDA to analyze this sample and obviously packed sample Use the skill above then you can answer the question easily. Homework - custom_packer_Revil.exe Static Analysis Observation - DetectItEasy Though I used the tool, DetectItEasy to check if this sample was packed or not, the answer is not quite explicit.</description></item><item><title>NTU Operating System Project 1</title><link>https://bernie6401.github.io/security/course/ntu-os/ntu-operating-system-project-1/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-os/ntu-operating-system-project-1/index.html</guid><description>NTU Operating System Project 1 tags: NTU_OS Operating System NachOS Thread Management :::spoiler [TOC] :::
How to parse this project You can research userkernel.cc file first. UserProgKernel will parse the command line and store the file you want to execute in execfile variable which defined at userkernel.h. Then you’ll find something interesting. ForkExecute(Thread *t) {t->space->Execute(t->getName());} // space and getName() are defined at thread.h // Execute is defined at addrspace.h This is what we’ve learned on lecture that it’ll clone a child process and execute the same program as parent process just like a multi-thread. Next, you can observe Run() function void UserProgKernel::Run() { cout &lt;&lt; "Total threads number is " &lt;&lt; execfileNum &lt;&lt; endl; for (int n=1;n&lt;=execfileNum;n++) { t[n] = new Thread(execfile[n]); t[n]->space = new AddrSpace(); t[n]->Fork((VoidFunctionPtr) &amp;ForkExecute, (void *)t[n]); cout &lt;&lt; "Thread " &lt;&lt; execfile[n] &lt;&lt; " is executing." &lt;&lt; endl; } ThreadedKernel::Run(); } Review a very simple concept: Process Representation in Linux // Represented by the C structure task_struct pid t pid; /* process identifier */ long state; /* state of the process */ unsigned int time slice /* scheduling information */ struct task struct *parent; /* this process’s parent */ struct list head children; /* this process’s children */ struct files struct *files; /* list of open files */ struct mm struct *mm; /* address space of this process */ Another related concept is Process Creation Address space Child duplicate of parent Child has a program loaded into it UNIX examples fork() system call creates new process exec() system call used after a fork() to replace the process’ memory space with a new program After reviewing the concept above, we can continue to answer next question(Please follow the next section -> Q2) Project Q&amp;A Q1: Why the result is not congruent with expected? Because OS has multi-thread concept like the code above and it’ll fork child process. When more than 1 process be executed simultaneously without any precondition, it’ll happend what we unexpected. And the precondition or you can say the real problem in this case is context switching which is the progress between preocesses switching by CPU. Q2: How to solve the issue?(You can include some code and explain it) According to the previous question, NachOS didn’t manage memory for executing multi program and this’ll cause the current program’s page overlap to the others running program. Thus, we have to revise these two program and let the program’s virtual memory map to the real memory that no one used. code/userprog/addrspace.cc code/userprog/addrspace.h Add the code in addrspace.cc at the beginning to stored the usage of all physical pages and stored how many free pages can be used now.</description></item><item><title>NTU Operating System Project 2</title><link>https://bernie6401.github.io/security/course/ntu-os/ntu-operating-system-project-2/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-os/ntu-operating-system-project-2/index.html</guid><description>NTU Operating System Project 2 tags: NTU_OS Operating System NachOS CPU Scheduling System Call [TOC]
Motivation For the first task, We’d like to add sleep() function in system call that can help us call sleep in our program. For the second task, we’d like to implement CPU scheduling by FIFO(First-In-First-Out), SJF(Shortest-Job-First), Priority, RR(Round-Robin), and multi-level queue. Implementation Task1 - System Call First of all, we need to define a new token, SC_Sleep, that compiler(scanner) can recognize in code/userprog/syscall.h.</description></item><item><title>NTU Operating System Project 3</title><link>https://bernie6401.github.io/security/course/ntu-os/ntu-operating-system-project-3/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-os/ntu-operating-system-project-3/index.html</guid><description>NTU Operating System Project 3 tags: NTU_OS Operating System NachOS Memory Management [TOC]
Description First I used the code from Project2 directly and obtained the correct value, 1 and 7220, by the command ./nachos -e ../test/sort -e ../test/matmult respectively. After debugging a while, I knew what’s the matter. In project2, I set const unsigned int NumPhysPages = 256; so that it can handle huge computing resource. In order to address this project, we must change it back to 32.</description></item><item><title>NTU Operating System Review Notes</title><link>https://bernie6401.github.io/security/course/ntu-os/ntu-operating-system-review-notes/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-os/ntu-operating-system-review-notes/index.html</guid><description>NTU Operating System Review Notes tags: NTU_OS Operating System [TOC]
Ch 6 Synchronization Process communication Race condition 就是Project1提到的共享記憶體的問題，導致multi-thread執行的結果會完全錯誤
解決策略 Disable interrupt process在對shared memory進行變數存取之前，先disable interrupt，直到完成此次存取後才enable，這樣的話這段時間，CPU就不會被其他processes搶走(preempted) Critical section design 必須滿足三個criteria Mutual exclusion: 在任何時間點，最多只允許一個process在他自己的CS內活動，不可同時有多個process在各自的CS內活動 Progress: 如果有人想進去CS，遲早進的去 Bounded waiting: 在一定時間內一定進的去 架構圖 spinlock busy waiting Critical section design的方法 Software solution 兩個processes Peterson’s solution: 有turn和flag兩個變數，分別代表目前的token在誰手上(turn)，以及表示有無意願進入CS(flag) N個processes Bakery’s ALG: 就是領號碼牌，號碼最小的人優先，若同時有多人持有相同的號碼牌，則以PID最小的優先 Hardware 指令支援 OS提出了mutex lock的概念，並用acquire()和release()的方法實踐 Semaphore 一種可以解決CS design和processes synchronization problem的data type，會提供兩個atomic operations: wait(s)和signal(s) wait(s): while(s&lt;=0) {do nothing;}s--; signal(s): s++ 簡單來說，s就是看現在可以使用的資源有多少(例如有多少台printer)，如果資源被分出去一個，s就減一，如果都沒有資源了，就一直等待，直到有人釋放資源，釋放資源的時候，s就會加一，所以和前面提到的mutex lock幾乎一樣，wait(s)就是acquire()，而signal(s)就是release() Semaphore的種類 有使用busy-waiting: spinlock semaphore:其實就是上面說的mutex lock和正常semaphore的概念 沒有使用busy-waiting: Non-Busy-Waiting semaphore: 看講義 Monitor 用來解決synchronization problem的高階資料結構 其實就是物件導向的方式，利用private、initialization等方式，創造monitor這個class object Message Passing技術</description></item><item><title>NTU Software Testing Notes</title><link>https://bernie6401.github.io/security/course/ntu-st/ntu-software-testing-notes-1/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-st/ntu-software-testing-notes-1/index.html</guid><description>NTU Software Testing Notes tags: NTU_ST Software Testing All content in this presentation is refer to Pro. Farn Wang Website
:::spoiler Click to open TOC [TOC] :::
6.1 Regression Testing Definition The process of re-testing software that has been modified 重複執行既有的全部或部分的相同測試 - by Esther
Note that: Most of our testing effort is regression testing Regression tests must be automated
Type of tools Capture / Replay: Capture values entered into a GUI and replay those values on new versions(抓取輸入到GUI的value並replay到新的版本) Version control: 追踪測試集合、預期結果、測試來源、使用的標準及其過去的有效性(Keeps track of collections of tests, expected results, where the tests came from, the criterion used, and their past effectiveness) Scripting software: 管理以下流程，包含獲取測試輸入、執行軟體、獲取輸出、比較結果和生成測試報告等等(Manages the process of obtaining test inputs, executing the software, obtaining the outputs, comparing the results, and generating test reports Tools are plentiful and cheap</description></item><item><title>NTU Software Testing Notes</title><link>https://bernie6401.github.io/security/course/ntu-st/ntu-software-testing-notes/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-st/ntu-software-testing-notes/index.html</guid><description>NTU Software Testing Notes tags: NTU_ST Software Testing All content in this presentation is refer to Pro. Farn Wang Website
:::spoiler Click to open TOC [TOC] :::
2.5 Graph Coverage for Specifications Design Spec. What is design specification? 描述軟體應該有的行為(可見或不可見都有可能) What is different between requirement and specification requirement: 顧客端 / specification: 技術端 Sequence就是一連串的行為和狀態->script Testing就是在看script有發生該發生的事情 Two types of description are used in this chapter Sequencing constraints State behavior Sequencing constraints Constraint有可能是document的一些潛規則或是method上順序的限制，e.g. stack data structure在沒有push前不能pop Queue Example: precondiction就是這個例子的sequence constraint File ADT Example ADT: Abstract Data Type其實就是早期的class sequence constraint about example 寫之前要先打開file 關閉之前要先打開file 在close file之後除非再open file，不然不可以write file close file前一定要write file，不然就浪費這個procedure Static Checking: 先不跑test input，先針對畫出來的graph做checking</description></item><item><title>Pentest Tools Survey</title><link>https://bernie6401.github.io/survey-papers/android-+-security/tool/pentest-tools-survey/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/survey-papers/android-+-security/tool/pentest-tools-survey/index.html</guid><description>Mobile Application Security Penetration Testing Based on OWASP :::info Alanda, A., Satria, D., Mooduto, H. A., &amp; Kurniawan, B. (2020, May). Mobile application security penetration testing based on OWASP. In IOP Conference Series: Materials Science and Engineering (Vol. 846, No. 1, p. 012036). IOP Publishing. :::
Introduction 研究針對Android行動應用程式安全性進行滲透測試,主要基於OWASP(開放式Web應用程式安全專案)的10大行動應用程式弱點。測試結果顯示,有80%的測試應用程式存在OWASP Mobile Top 10所列出的弱點，研究提供了各種弱點的測試方法與結果分析,並給出相應的安全修復建議,以增強Android行動應用程式的安全性。
以 Andorid 實驗案例探討 OWASP 行動裝置應用程式之十大威脅 :::info 許振銘, &amp; 許登凱. (2014). 以 Andorid 實驗案例探討 OWASP 行動裝置應用程式之十大威脅. Communications of the CCISA, 20(2), 77-96. :::</description></item><item><title>The State of Ethereum Smart Contracts Security: Vulnerabilities, Countermeasures, and Tool Support - Notes</title><link>https://bernie6401.github.io/survey-papers/digital-currency/the-state-of-ethereum-smart-contracts-security_-vulnerabilities-countermeasures-and-tool-support---notes/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/survey-papers/digital-currency/the-state-of-ethereum-smart-contracts-security_-vulnerabilities-countermeasures-and-tool-support---notes/index.html</guid><description>The State of Ethereum Smart Contracts Security: Vulnerabilities, Countermeasures, and Tool Support - Notes tags: Meeting Paper NTU Seminar :::info Zhou, H., Milani Fard, A., &amp; Makanju, A. (2022). The state of ethereum smart contracts security: Vulnerabilities, countermeasures, and tool support. Journal of Cybersecurity and Privacy, 2(2), 358-378. :::
Background :::spoiler 以太幣(Ether) VS 以太坊(Ethereum)
以太坊是一個區塊鏈平台，而以太幣是裡面所使用的貨幣，智能合約的運算費用、區塊鏈上的交易手續費、礦工挖礦的獎勵等，都會用以太幣支付。
以太坊目的是打造一個「去中心化的世界電腦」，執行的方式是透過區塊鏈技術，實現去中心化智能合約平台，以太坊和比特幣一樣具有可挖礦的公鏈系統，但多了智能合約、Dapp的技術。 ::: :::spoiler What is Smart Contract? 智能合約是一種將雙方的協議條款，並用代碼形式在區塊鏈上運行，儲存在一個公共資料庫中，不能被更改。
智能合約中發生的交易是由區塊鏈處理的，這意味著它們可以在沒有第三者的情況下自動執行，只有當協議中的條件得到滿足時，交易才會發生，是完全去中心化的交易。
智能合約 VS 傳統合約</description></item><item><title>Uncovering Intent based Leak of Sensitive Data in Android Framework</title><link>https://bernie6401.github.io/survey-papers/android-+-security/uncovering-intent-based-leak-of-sensitive-data-in-android-framework/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/survey-papers/android-+-security/uncovering-intent-based-leak-of-sensitive-data-in-android-framework/index.html</guid><description>Uncovering Intent based Leak of Sensitive Data in Android Framework tags: Meeting Paper NTU :::info Zhou, H., Luo, X., Wang, H., &amp; Cai, H. (2022, November). Uncovering Intent based Leak of Sensitive Data in Android Framework. In Proceedings of the 2022 ACM SIGSAC Conference on Computer and Communications Security (pp. 3239-3252). :::
Background :::spoiler [Android] Activity基本介紹
什麼是Activity? Activity是App中，提供畫面的一個元件， 例如：使用Google地圖App時，顯示地圖的那個畫面。
只有Activity可以顯示畫面嗎？ 不是，除了Activity以外還有其他元件可以顯示畫面， 例如：Dialog，但每一個App至少要有一個Activity，但這有個例外，如果這個App不提供介面的話也是可以不用有Activity的。
Activity其他注意事項
兩個Activity傳遞資訊是透過Intent Intent intent = new Intent(this, TwoActivity.class); startActivity(intent); Intent 能傳遞的資訊大小要小於512k 每一個Activity都要在AndroidManifest中聲明 &lt;manifest ... > &lt;application ... > &lt;activity android:name=".MainActivity" /> ... &lt;/application ... > ... &lt;/manifest > :::</description></item><item><title>Understanding Real-world Threats to Deep Learning Models in Android Apps</title><link>https://bernie6401.github.io/survey-papers/android-+-security/understanding-real-world-threats-to-deep-learning-models-in-android-apps/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/survey-papers/android-+-security/understanding-real-world-threats-to-deep-learning-models-in-android-apps/index.html</guid><description>Understanding Real-world Threats to Deep Learning Models in Android Apps tags: Meeting Paper NTU :::info Deng, Z., Chen, K., Meng, G., Zhang, X., Xu, K., &amp; Cheng, Y. (2022, November). Understanding real-world threats to deep learning models in android apps. In Proceedings of the 2022 ACM SIGSAC Conference on Computer and Communications Security (pp. 785-799). :::
Background :::spoiler What is Adversarial Example? - 運用對抗例攻擊深度學習模型
所謂對抗例，是一種刻意製造的、讓機器學習模型判斷錯誤的輸入資料。最早是 Szegedy et al（2013）發現對於用 ImageNet、AlexNet 等資料集訓練出來的影像辨識模型，常常只需要輸入端的微小的變動，就可以讓輸出結果有大幅度的改變。例如取一張卡車的照片，可以被模型正確辨識，但只要改變影像中的少數像素，就可以讓模型辨識錯誤，而且前後對影像的改變非常少，對肉眼而言根本分不出差異。 :::</description></item><item><title>Unit Test Practice</title><link>https://bernie6401.github.io/security/course/ntu-st/unit-test-practice/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-st/unit-test-practice/index.html</guid><description>Unit Test Practice tags: NTU_ST Software Testing :::spoiler Click to open TOC [TOC] :::
Install the environment Install Visual Studio with .NET that we can use C# language to implement unit test properly. Create a project to test Create a new project and choose C# as your language and named the project Bank. Rename Program.cs as BankAccount.cs and replace all content by the following code. using System; namespace BankAccountNS public class BankAccount { private readonly string m_customerName; private double m_balance; private BankAccount() { } public BankAccount(string customerName, double balance) { m_customerName = customerName; m_balance = balance; } public string CustomerName { get { return m_customerName; } } public double Balance { get { return m_balance; } } public void Debit(double amount) { if (amount > m_balance) { throw new ArgumentOutOfRangeException("amount"); } if (amount &lt; 0) { throw new ArgumentOutOfRangeException("amount"); } m_balance += amount; // intentionally incorrect code } public void Credit(double amount) { if (amount &lt; 0) { throw new ArgumentOutOfRangeException("amount"); } m_balance += amount; } public static void Main() { BankAccount ba = new BankAccount("Mr. Bryan Walton", 11.99); ba.Credit(5.77); ba.Debit(11.22); Console.WriteLine("Current balance is ${0}", ba.Balance); } } } Build it by clicking Build Solution in Build menu. Create a unit test project Create a new project at solution explorer and named it BankTests. The other part just maintain default setup. Select MSTest Test Project &lt;-This is important. Add reference by selecting Add Reference at BankTests/Dependencies In the Reference Manager dialog box, expand Projects, select Solution, and then check the Bank item. Create the test class Rename UnitTest1.cs to BankAccountTests.cs and replace the original code with the following section and add using statement at the top of the class file. using Microsoft.VisualStudio.TestTools.UnitTesting; namespace BankTests { [TestClass] public class BankAccountTests { [TestMethod] public void TestMethod1() { } } } BTW, the default class part can be ignored. Create the first test method Replace the default class with the following code [TestMethod] public void Debit_WithValidAmount_UpdatesBalance() { // Arrange double beginningBalance = 11.99; double debitAmount = 4.55; double expected = 7.44; BankAccount account = new BankAccount("Mr. Bryan Walton", beginningBalance); // Act account.Debit(debitAmount); // Assert double actual = account.Balance; Assert.AreEqual(expected, actual, 0.001, "Account not debited correctly"); } Analyze this part: Assert.AreEqual method will catch the exception when expected value unequal actual value or their difference larger than delta(0.001). Comparing with BankAccount.cs, the truly process of Debit function is $beginningBalance - debitAmount = expected$ -> $11.99 - 4.55 = 7.44$ Build and run the test On the Build menu, choose Build Solution (or press Ctrl + SHIFT + B) and press Ctrl + E, T to open Test Explorer, then Run All. You’ll find that all Test are failed, so you must modify somewhere incorrect. Fix your code and rerun your tests Return to BankAccount.cs and observe Debit() function. Must change m_balance += amount; to m_balance -= amount; Build and Run the code again and you’ll find the test is correct this time Create and run new test methods Add the following program in test class and rebuild it. [TestMethod] public void Debit_WhenAmountIsLessThanZero_ShouldThrowArgumentOutOfRange() { // Arrange double beginningBalance = 11.99; double debitAmount = -100.00; BankAccount account = new BankAccount("Mr. Bryan Walton", beginningBalance); // Act and assert Assert.ThrowsException&lt;System.ArgumentOutOfRangeException>(() => account.Debit(debitAmount)); } [TestMethod] public void Debit_WhenAmountIsMoreThanBalance_ShouldThrowArgumentOutOfRange() { // Arrange double beginningBalance = 11.99; double debitAmount = 200.00; BankAccount account = new BankAccount("Mr. Bryan Walton", beginningBalance); // Act and assert Assert.ThrowsException&lt;System.ArgumentOutOfRangeException>(() => account.Debit(debitAmount)); } Analyze: you’ll find out that the debitAmout in the 1st test method is less than zero and the debitAmount in 2nd test method is larger than beginningBalance. After runing test explorer, these 2 code block are working properly, but you don’t know what kind of exception is(amount > m_balance or amount &lt; 0), we just know somewhere throw back an exception message. Revise BankAccount.cs Trace back to BankAccount.Debit and you’ll notice that they used the same exception, so you can determine to use ArgumentOutOfRangeException(String, Object, String) to contain the name of the argument, the argument value, and a user-defined message. if (amount > m_balance) { throw new ArgumentOutOfRangeException("amount"); } if (amount &lt; 0) { throw new ArgumentOutOfRangeException("amount"); } Refactor the code under test Define 2 constants for the error message at class scope, put the following code block in the class under test, BankAccout. public const string DebitAmountExceedsBalanceMessage = "Debit amount exceeds balance"; public const string DebitAmountLessThanZeroMessage = "Debit amount is less than zero"; Then modify the 2 conditional statements in the Debit method. if (amount > m_balance) { throw new System.ArgumentOutOfRangeException("amount", amount, DebitAmountExceedsBalanceMessage); } if (amount &lt; 0) { throw new System.ArgumentOutOfRangeException("amount", amount, DebitAmountLessThanZeroMessage); } Refactor test method like this. Replacing Assert.ThrowsException with using try/catch method to catch unexpected exception situation. [TestMethod] public void Debit_WhenAmountIsMoreThanBalance_ShouldThrowArgumentOutOfRange() { // Arrange double beginningBalance = 11.99; double debitAmount = 20.0; BankAccount account = new BankAccount("Mr. Bryan Walton", beginningBalance); // Act try { account.Debit(debitAmount); } catch (System.ArgumentOutOfRangeException e) { // Assert StringAssert.Contains(e.Message, BankAccount.DebitAmountExceedsBalanceMessage); } } The last part Not really understatnd about adding Assert.Fail at the end of the test method. Final Result</description></item><item><title>VAPTAi: A Threat Model for Vulnerability Assessment and Pentesting of Android and iOS Mobile Banking Apps</title><link>https://bernie6401.github.io/survey-papers/android-+-security/vaptai_-a-threat-model-for-vulnerability-assessment-and-pentesting-of-android-and-ios-mobile-banking-apps/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/survey-papers/android-+-security/vaptai_-a-threat-model-for-vulnerability-assessment-and-pentesting-of-android-and-ios-mobile-banking-apps/index.html</guid><description>VAPTAi: A Threat Model for Vulnerability Assessment and Penetration Testing of Android and iOS Mobile Banking Apps :::info Bojjagani, S., &amp; Sastry, V. N. (2017, October). VAPTAi: a threat model for vulnerability assessment and penetration testing of android and iOS mobile banking apps. In 2017 IEEE 3rd international conference on collaboration and internet computing (CIC) (pp. 77-86). IEEE. :::
Introduction 隨著移動設備的使用急速增加，Mobile Banking Application(MBA)也備受黑客和惡意使用者的目標。這些MBA存儲、傳輸和存取敏感和機密資訊，因此必須優先確保其安全性。本文提出了一個威脅模型，以系統性地測試和分析行動銀行應用程式，檢測和緩解應用程式級和通信級別的漏洞。作者對5個Android和3個iOS的MBA進行了安全測試，發現了許多未知漏洞，並展示了MBA易受中間人攻擊的情況。部分MBA使用簡單的HTTP協議傳輸用戶數據，未考慮安全要求。多數情況下，MBA無條件接受偽造或自簽名的證書，導致SSL/TLS中間人攻擊。
Background Proposed Method</description></item><item><title>WIGHT: Wired Ghost Touch Attack on Capacitive Touchscreens</title><link>https://bernie6401.github.io/survey-papers/android-+-security/wight_-wired-ghost-touch-attack-on-capacitive-touchscreens/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/survey-papers/android-+-security/wight_-wired-ghost-touch-attack-on-capacitive-touchscreens/index.html</guid><description>WIGHT: Wired Ghost Touch Attack on Capacitive Touchscreens tags: Meeting Paper NTU :::info Jiang, Y., Ji, X., Wang, K., Yan, C., Mitev, R., Sadeghi, A. R., &amp; Xu, W. (2022, May). Wight: Wired ghost touch attack on capacitive touchscreens. In 2022 IEEE Symposium on Security and Privacy (SP) (pp. 984-1001). IEEE. :::
Background What is ghost touch?
What is common-mode signal and differential-mode signal - 高中電子學_運算放大器_2. 運算放大器之特性與參數_2.3 運算放大器的動態特性參數 1_支裕文</description></item><item><title>有關Pentest但貢獻很爛的三篇論文</title><link>https://bernie6401.github.io/survey-papers/android-+-security/tool/%E6%9C%89%E9%97%9Cpentest%E4%BD%86%E8%B2%A2%E7%8D%BB%E5%BE%88%E7%88%9B%E7%9A%84%E4%B8%89%E7%AF%87%E8%AB%96%E6%96%87/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/survey-papers/android-+-security/tool/%E6%9C%89%E9%97%9Cpentest%E4%BD%86%E8%B2%A2%E7%8D%BB%E5%BE%88%E7%88%9B%E7%9A%84%E4%B8%89%E7%AF%87%E8%AB%96%E6%96%87/index.html</guid><description>Risk analysis and Android application penetration testing based on OWASP 2016 :::info Borja, T., Benalcázar, M. E., Valdivieso Caraguay, Á. L., &amp; Barona López, L. I. (2021). Risk analysis and Android application penetration testing based on OWASP 2016. In Information Technology and Systems: ICITS 2021, Volume 1 (pp. 461-478). Springer International Publishing. :::
Introduction 嚴格來說，這一篇不是完全沒用，但真的貢獻超級低，他基本上就是照著之前寫過的1流程和動機甚至實驗方法做而已，最後再加上自己的一些見解(也就是所謂的風險評估矩陣和針對每一個Risk寫出自己的建議或是mitigation)，就這樣沒了，詳細對比如下 ![圖片](https://hackmd.io/_uploads/r1eR14KBA.png =400x) Reference 8就是1
Proposed Method 作者自行創立一個Score Scale如下 總共有四個向度，前三個向度相加取平均後*最後一個向度就是該Risk的分數， 實驗後的級距分野如下 ![圖片](https://hackmd.io/_uploads/HJlAg4tBR.png =300x)</description></item></channel></rss>