<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Software Testing :: Tag :: SBK Hugo Site</title><link>https://bernie6401.github.io/tags/software-testing/index.html</link><description/><generator>Hugo</generator><language>en-us</language><atom:link href="https://bernie6401.github.io/tags/software-testing/index.xml" rel="self" type="application/rss+xml"/><item><title>NTU Software Testing Notes</title><link>https://bernie6401.github.io/security/course/ntu-st/ntu-software-testing-notes-1/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-st/ntu-software-testing-notes-1/index.html</guid><description>NTU Software Testing Notes tags: NTU_ST Software Testing All content in this presentation is refer to Pro. Farn Wang Website
:::spoiler Click to open TOC [TOC] :::
6.1 Regression Testing Definition The process of re-testing software that has been modified 重複執行既有的全部或部分的相同測試 - by Esther
Note that: Most of our testing effort is regression testing Regression tests must be automated
Type of tools Capture / Replay: Capture values entered into a GUI and replay those values on new versions(抓取輸入到GUI的value並replay到新的版本) Version control: 追踪測試集合、預期結果、測試來源、使用的標準及其過去的有效性(Keeps track of collections of tests, expected results, where the tests came from, the criterion used, and their past effectiveness) Scripting software: 管理以下流程，包含獲取測試輸入、執行軟體、獲取輸出、比較結果和生成測試報告等等(Manages the process of obtaining test inputs, executing the software, obtaining the outputs, comparing the results, and generating test reports Tools are plentiful and cheap</description></item><item><title>NTU Software Testing Notes</title><link>https://bernie6401.github.io/security/course/ntu-st/ntu-software-testing-notes/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-st/ntu-software-testing-notes/index.html</guid><description>NTU Software Testing Notes tags: NTU_ST Software Testing All content in this presentation is refer to Pro. Farn Wang Website
:::spoiler Click to open TOC [TOC] :::
2.5 Graph Coverage for Specifications Design Spec. What is design specification? 描述軟體應該有的行為(可見或不可見都有可能) What is different between requirement and specification requirement: 顧客端 / specification: 技術端 Sequence就是一連串的行為和狀態->script Testing就是在看script有發生該發生的事情 Two types of description are used in this chapter Sequencing constraints State behavior Sequencing constraints Constraint有可能是document的一些潛規則或是method上順序的限制，e.g. stack data structure在沒有push前不能pop Queue Example: precondiction就是這個例子的sequence constraint File ADT Example ADT: Abstract Data Type其實就是早期的class sequence constraint about example 寫之前要先打開file 關閉之前要先打開file 在close file之後除非再open file，不然不可以write file close file前一定要write file，不然就浪費這個procedure Static Checking: 先不跑test input，先針對畫出來的graph做checking</description></item><item><title>Unit Test Practice</title><link>https://bernie6401.github.io/security/course/ntu-st/unit-test-practice/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-st/unit-test-practice/index.html</guid><description>Unit Test Practice tags: NTU_ST Software Testing :::spoiler Click to open TOC [TOC] :::
Install the environment Install Visual Studio with .NET that we can use C# language to implement unit test properly. Create a project to test Create a new project and choose C# as your language and named the project Bank. Rename Program.cs as BankAccount.cs and replace all content by the following code. using System; namespace BankAccountNS public class BankAccount { private readonly string m_customerName; private double m_balance; private BankAccount() { } public BankAccount(string customerName, double balance) { m_customerName = customerName; m_balance = balance; } public string CustomerName { get { return m_customerName; } } public double Balance { get { return m_balance; } } public void Debit(double amount) { if (amount > m_balance) { throw new ArgumentOutOfRangeException("amount"); } if (amount &lt; 0) { throw new ArgumentOutOfRangeException("amount"); } m_balance += amount; // intentionally incorrect code } public void Credit(double amount) { if (amount &lt; 0) { throw new ArgumentOutOfRangeException("amount"); } m_balance += amount; } public static void Main() { BankAccount ba = new BankAccount("Mr. Bryan Walton", 11.99); ba.Credit(5.77); ba.Debit(11.22); Console.WriteLine("Current balance is ${0}", ba.Balance); } } } Build it by clicking Build Solution in Build menu. Create a unit test project Create a new project at solution explorer and named it BankTests. The other part just maintain default setup. Select MSTest Test Project &lt;-This is important. Add reference by selecting Add Reference at BankTests/Dependencies In the Reference Manager dialog box, expand Projects, select Solution, and then check the Bank item. Create the test class Rename UnitTest1.cs to BankAccountTests.cs and replace the original code with the following section and add using statement at the top of the class file. using Microsoft.VisualStudio.TestTools.UnitTesting; namespace BankTests { [TestClass] public class BankAccountTests { [TestMethod] public void TestMethod1() { } } } BTW, the default class part can be ignored. Create the first test method Replace the default class with the following code [TestMethod] public void Debit_WithValidAmount_UpdatesBalance() { // Arrange double beginningBalance = 11.99; double debitAmount = 4.55; double expected = 7.44; BankAccount account = new BankAccount("Mr. Bryan Walton", beginningBalance); // Act account.Debit(debitAmount); // Assert double actual = account.Balance; Assert.AreEqual(expected, actual, 0.001, "Account not debited correctly"); } Analyze this part: Assert.AreEqual method will catch the exception when expected value unequal actual value or their difference larger than delta(0.001). Comparing with BankAccount.cs, the truly process of Debit function is $beginningBalance - debitAmount = expected$ -> $11.99 - 4.55 = 7.44$ Build and run the test On the Build menu, choose Build Solution (or press Ctrl + SHIFT + B) and press Ctrl + E, T to open Test Explorer, then Run All. You’ll find that all Test are failed, so you must modify somewhere incorrect. Fix your code and rerun your tests Return to BankAccount.cs and observe Debit() function. Must change m_balance += amount; to m_balance -= amount; Build and Run the code again and you’ll find the test is correct this time Create and run new test methods Add the following program in test class and rebuild it. [TestMethod] public void Debit_WhenAmountIsLessThanZero_ShouldThrowArgumentOutOfRange() { // Arrange double beginningBalance = 11.99; double debitAmount = -100.00; BankAccount account = new BankAccount("Mr. Bryan Walton", beginningBalance); // Act and assert Assert.ThrowsException&lt;System.ArgumentOutOfRangeException>(() => account.Debit(debitAmount)); } [TestMethod] public void Debit_WhenAmountIsMoreThanBalance_ShouldThrowArgumentOutOfRange() { // Arrange double beginningBalance = 11.99; double debitAmount = 200.00; BankAccount account = new BankAccount("Mr. Bryan Walton", beginningBalance); // Act and assert Assert.ThrowsException&lt;System.ArgumentOutOfRangeException>(() => account.Debit(debitAmount)); } Analyze: you’ll find out that the debitAmout in the 1st test method is less than zero and the debitAmount in 2nd test method is larger than beginningBalance. After runing test explorer, these 2 code block are working properly, but you don’t know what kind of exception is(amount > m_balance or amount &lt; 0), we just know somewhere throw back an exception message. Revise BankAccount.cs Trace back to BankAccount.Debit and you’ll notice that they used the same exception, so you can determine to use ArgumentOutOfRangeException(String, Object, String) to contain the name of the argument, the argument value, and a user-defined message. if (amount > m_balance) { throw new ArgumentOutOfRangeException("amount"); } if (amount &lt; 0) { throw new ArgumentOutOfRangeException("amount"); } Refactor the code under test Define 2 constants for the error message at class scope, put the following code block in the class under test, BankAccout. public const string DebitAmountExceedsBalanceMessage = "Debit amount exceeds balance"; public const string DebitAmountLessThanZeroMessage = "Debit amount is less than zero"; Then modify the 2 conditional statements in the Debit method. if (amount > m_balance) { throw new System.ArgumentOutOfRangeException("amount", amount, DebitAmountExceedsBalanceMessage); } if (amount &lt; 0) { throw new System.ArgumentOutOfRangeException("amount", amount, DebitAmountLessThanZeroMessage); } Refactor test method like this. Replacing Assert.ThrowsException with using try/catch method to catch unexpected exception situation. [TestMethod] public void Debit_WhenAmountIsMoreThanBalance_ShouldThrowArgumentOutOfRange() { // Arrange double beginningBalance = 11.99; double debitAmount = 20.0; BankAccount account = new BankAccount("Mr. Bryan Walton", beginningBalance); // Act try { account.Debit(debitAmount); } catch (System.ArgumentOutOfRangeException e) { // Assert StringAssert.Contains(e.Message, BankAccount.DebitAmountExceedsBalanceMessage); } } The last part Not really understatnd about adding Assert.Fail at the end of the test method. Final Result</description></item></channel></rss>