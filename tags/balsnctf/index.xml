<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>BalsnCTF on SBK Site</title><link>https://bernie6401.github.io/tags/balsnctf/</link><description>Recent content in BalsnCTF on SBK Site</description><generator>Hugo</generator><language>en-us</language><atom:link href="https://bernie6401.github.io/tags/balsnctf/index.xml" rel="self" type="application/rss+xml"/><item><title>BalsnCTF 2023</title><link>https://bernie6401.github.io/docs/security/competition/balsnctf-2023/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/docs/security/competition/balsnctf-2023/</guid><description>&lt;h1 id="balsnctf-2023">
 BalsnCTF 2023
 &lt;a class="anchor" href="#balsnctf-2023">#&lt;/a>
&lt;/h1>
&lt;h2 id="reverse">
 Reverse
 &lt;a class="anchor" href="#reverse">#&lt;/a>
&lt;/h2>
&lt;h3 id="lucky">
 Lucky
 &lt;a class="anchor" href="#lucky">#&lt;/a>
&lt;/h3>
&lt;h4 id="source-code">
 Source code
 &lt;a class="anchor" href="#source-code">#&lt;/a>
&lt;/h4>
&lt;p>:::spoiler IDA Main Function&lt;/p>
&lt;pre tabindex="0">&lt;code class="language-cpp=" data-lang="cpp=">__int64 main_fn()
{
 __int64 idx; // r15
 int v1; // ebp
 __int64 v2; // rbx
 unsigned __int64 v3; // r14
 int v4; // r9d
 int v5; // r9d
 char v6; // al
 __int64 v7; // rdx
 unsigned int v9; // [rsp+Ch] [rbp-9Ch] BYREF
 char v10[32]; // [rsp+10h] [rbp-98h] BYREF
 __int128 user_input[2]; // [rsp+30h] [rbp-78h] BYREF
 __int64 v12; // [rsp+50h] [rbp-58h]
 char v13; // [rsp+58h] [rbp-50h]
 unsigned __int64 v14; // [rsp+68h] [rbp-40h]

 idx = 10000000000000000LL;
 v1 = 0;
 v14 = __readfsqword(0x28u);
 v2 = sub_40C2B0(&amp;#34;/dev/urandom&amp;#34;, &amp;amp;unk_498004);
 do
 {
 sub_40C3B0(&amp;amp;v9, 4uLL, 1LL, v2);
 v3 = v9 % 100000000uLL;
 sub_40C3B0(&amp;amp;v9, 4uLL, 1LL, v2);
 v1 -= (v3 * v3 + v9 % 100000000uLL * (v9 % 100000000uLL) &amp;gt; 9999999999999999LL) - 1;
 --idx;
 }
 while ( idx );
 sub_44A050(v10, 1u, 30LL, &amp;#34;%lu&amp;#34;, 4 * v1 - 0x4F430000, v4);
 v13 = 0;
 v6 = 0x73;
 v12 = 0LL;
 memset(user_input, 0, sizeof(user_input));
 while ( 1 )
 {
 v7 = idx &amp;amp; 0xF;
 *(user_input + idx++) = v10[v7] ^ v6;
 if ( idx == 40 )
 break;
 v6 = byte_498040[idx];
 }
 if ( LOBYTE(user_input[0]) == &amp;#39;B&amp;#39; &amp;amp;&amp;amp; *(user_input + 1) == &amp;#39;NSLA&amp;#39; &amp;amp;&amp;amp; BYTE5(user_input[0]) == &amp;#39;{&amp;#39; &amp;amp;&amp;amp; HIBYTE(v12) == &amp;#39;}&amp;#39; )
 sub_44A130(1, &amp;#34;Lucky! flag is %s\n&amp;#34;, user_input, byte_498040, user_input, v5);
 else
 (sub_40C4B0)(&amp;#34;Not so lucky ...&amp;#34;, 1LL, v7, byte_498040, user_input);
 if ( v14 != __readfsqword(0x28u) )
 (sub_44A220)();
 return 0LL;
}
&lt;/code>&lt;/pre>&lt;p>:::&lt;/p></description></item></channel></rss>