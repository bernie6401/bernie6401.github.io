<!doctype html><html lang=en-us dir=ltr><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="
  Programming Related
  #


  What is namespace in programming?
  #

From ChatGPT
在程式語言中，namespace（命名空間）是一種用來組織和管理代碼的機制，目的是避免名稱衝突並提升代碼的可讀性和結構化。


  Namespace 的概念與作用
  #



名稱分隔
命名空間可以將代碼中的名稱（如變數、函數、類別等）組織起來，避免與其他代碼中的名稱發生衝突。

例如，兩個不同的模組中可能都定義了名稱為 calculate 的函數，但由於它們位於不同的命名空間，因此可以共存。



代碼組織
命名空間可以將相關聯的功能分組在一起，使代碼結構更加清晰，便於維護和重用。


避免名稱污染
命名空間可以避免全域命名空間中的名稱被不小心覆蓋或污染，降低了意外錯誤的可能性。




  Namespace 的具體表現
  #


  1. C++
  #

在 C++ 中，命名空間是通過 namespace 關鍵字來實現的。
#include <iostream>

namespace Math {
    int add(int a, int b) {
        return a + b;
    }
}

namespace Physics {
    int add(int a, int b) {
        return a - b;
    }
}

int main() {
    std::cout << Math::add(3, 4) << std::endl;  // 使用 Math 的 add 函數
    std::cout << Physics::add(3, 4) << std::endl; // 使用 Physics 的 add 函數
    return 0;
}

  2. Python
  #

在 Python 中，每個模組（module）本身就是一個命名空間，通過 import 來使用其他命名空間的內容。"><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#343a40"><meta name=color-scheme content="light dark"><meta property="og:url" content="https://bernie6401.github.io/terminology/programming-related/"><meta property="og:site_name" content="SBK Hugo Site"><meta property="og:title" content="Programming Related"><meta property="og:description" content="Programming Related # What is namespace in programming? # From ChatGPT 在程式語言中，namespace（命名空間）是一種用來組織和管理代碼的機制，目的是避免名稱衝突並提升代碼的可讀性和結構化。
Namespace 的概念與作用 # 名稱分隔
命名空間可以將代碼中的名稱（如變數、函數、類別等）組織起來，避免與其他代碼中的名稱發生衝突。
例如，兩個不同的模組中可能都定義了名稱為 calculate 的函數，但由於它們位於不同的命名空間，因此可以共存。 代碼組織
命名空間可以將相關聯的功能分組在一起，使代碼結構更加清晰，便於維護和重用。
避免名稱污染
命名空間可以避免全域命名空間中的名稱被不小心覆蓋或污染，降低了意外錯誤的可能性。
Namespace 的具體表現 # 1. C++ # 在 C++ 中，命名空間是通過 namespace 關鍵字來實現的。
#include <iostream> namespace Math { int add(int a, int b) { return a + b; } } namespace Physics { int add(int a, int b) { return a - b; } } int main() { std::cout << Math::add(3, 4) << std::endl; // 使用 Math 的 add 函數 std::cout << Physics::add(3, 4) << std::endl; // 使用 Physics 的 add 函數 return 0; } 2. Python # 在 Python 中，每個模組（module）本身就是一個命名空間，通過 import 來使用其他命名空間的內容。"><meta property="og:locale" content="en_us"><meta property="og:type" content="article"><meta property="article:section" content="terminology"><meta property="article:tag" content="名詞解釋"><title>Programming Related | SBK Hugo Site</title>
<link rel=icon href=/favicon.png><link rel=manifest href=/manifest.json><link rel=canonical href=https://bernie6401.github.io/terminology/programming-related/><link rel=stylesheet href=/book.min.6c8b9d2a1fc95075ed7da46ca81060b39add8fff6741ac51259f768929281e2c.css integrity="sha256-bIudKh/JUHXtfaRsqBBgs5rdj/9nQaxRJZ92iSkoHiw=" crossorigin=anonymous><script defer src=/fuse.min.js></script><script defer src=/en.search.min.acdc41c8d39e6c69d70d8a23779875e0a3733fefead3e428d5344966bb12f562.js integrity="sha256-rNxByNOebGnXDYojd5h14KNzP+/q0+Qo1TRJZrsS9WI=" crossorigin=anonymous></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/><span>SBK Hugo Site</span></a></h2><div class="book-search hidden"><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><script>document.querySelector(".book-search").classList.remove("hidden")</script></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu></label><h3>Programming Related</h3><label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#what-is-namespace-in-programming>What is namespace in programming?</a><ul><li><a href=#namespace-的概念與作用><strong>Namespace 的概念與作用</strong></a></li><li><a href=#namespace-的具體表現><strong>Namespace 的具體表現</strong></a></li><li><a href=#namespace-的好處><strong>Namespace 的好處</strong></a></li><li><a href=#總結><strong>總結</strong></a></li></ul></li><li><a href=#what-is-decorator-in-python>What is decorator in Python?</a><ul><li><a href=#在flask中常常看到route也有用這個東西意思是一樣的嗎>在Flask中，常常看到route也有用@這個東西，意思是一樣的嗎</a></li></ul></li><li><a href=#what-is-cmakegccg>What is CMake/GCC/G++</a><ul><li><a href=#cmake-vs-gccg-的區別><strong>CMake vs. GCC/G++ 的區別</strong></a></li><li><a href=#1-gccg><strong>1. GCC/G++</strong></a></li><li><a href=#2-cmake><strong>2. CMake</strong></a></li><li><a href=#cmake-典型用法><strong>CMake 典型用法</strong></a></li><li><a href=#cmake-與-gccg-的關係><strong>CMake 與 GCC/G++ 的關係</strong></a></li><li><a href=#何時使用-cmake><strong>何時使用 CMake？</strong></a></li><li><a href=#g-vs-gcc-的主要區別><strong>g++ vs. gcc 的主要區別</strong></a></li><li><a href=#1><strong>1. <code>gcc</code> 編譯 C 程式</strong></a></li><li><a href=#2><strong>2. <code>gcc</code> 編譯 C++ 程式（需要手動指定標準庫）</strong></a></li><li><a href=#3><strong>3. <code>g++</code> 編譯 C++ 程式（推薦方式）</strong></a></li><li><a href=#4><strong>4. <code>gcc</code> 和 <code>g++</code> 在多檔案專案的行為</strong></a></li><li><a href=#結論該用哪個><strong>結論：該用哪個？</strong></a></li></ul></li></ul></nav></aside></header><article class="markdown book-article"><h1 id=programming-related>Programming Related
<a class=anchor href=#programming-related>#</a></h1><h2 id=what-is-namespace-in-programming>What is namespace in programming?
<a class=anchor href=#what-is-namespace-in-programming>#</a></h2><p>From ChatGPT
在程式語言中，<strong>namespace</strong>（命名空間）是一種用來<strong>組織和管理代碼</strong>的機制，目的是避免名稱衝突並提升代碼的可讀性和結構化。</p><hr><h3 id=namespace-的概念與作用><strong>Namespace 的概念與作用</strong>
<a class=anchor href=#namespace-%e7%9a%84%e6%a6%82%e5%bf%b5%e8%88%87%e4%bd%9c%e7%94%a8>#</a></h3><ol><li><p><strong>名稱分隔</strong><br>命名空間可以將代碼中的名稱（如變數、函數、類別等）組織起來，避免與其他代碼中的名稱發生衝突。</p><ul><li>例如，兩個不同的模組中可能都定義了名稱為 <code>calculate</code> 的函數，但由於它們位於不同的命名空間，因此可以共存。</li></ul></li><li><p><strong>代碼組織</strong><br>命名空間可以將相關聯的功能分組在一起，使代碼結構更加清晰，便於維護和重用。</p></li><li><p><strong>避免名稱污染</strong><br>命名空間可以避免全域命名空間中的名稱被不小心覆蓋或污染，降低了意外錯誤的可能性。</p></li></ol><hr><h3 id=namespace-的具體表現><strong>Namespace 的具體表現</strong>
<a class=anchor href=#namespace-%e7%9a%84%e5%85%b7%e9%ab%94%e8%a1%a8%e7%8f%be>#</a></h3><h4 id=1-c>1. <strong>C++</strong>
<a class=anchor href=#1-c>#</a></h4><p>在 C++ 中，命名空間是通過 <code>namespace</code> 關鍵字來實現的。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;iostream&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>namespace</span> Math {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>add</span>(<span style=color:#66d9ef>int</span> a, <span style=color:#66d9ef>int</span> b) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> a <span style=color:#f92672>+</span> b;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>namespace</span> Physics {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>add</span>(<span style=color:#66d9ef>int</span> a, <span style=color:#66d9ef>int</span> b) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> a <span style=color:#f92672>-</span> b;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> Math<span style=color:#f92672>::</span>add(<span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>4</span>) <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl;  <span style=color:#75715e>// 使用 Math 的 add 函數
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> Physics<span style=color:#f92672>::</span>add(<span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>4</span>) <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl; <span style=color:#75715e>// 使用 Physics 的 add 函數
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=2-python>2. <strong>Python</strong>
<a class=anchor href=#2-python>#</a></h4><p>在 Python 中，每個模組（module）本身就是一個命名空間，通過 <code>import</code> 來使用其他命名空間的內容。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#75715e># math.py</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>calculate</span>():
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#e6db74>&#34;Math calculate&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># physics.py</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>calculate</span>():
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#e6db74>&#34;Physics calculate&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># main.py</span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> math
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> physics
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>print(math<span style=color:#f92672>.</span>calculate())   <span style=color:#75715e># 使用 math 的 calculate</span>
</span></span><span style=display:flex><span>print(physics<span style=color:#f92672>.</span>calculate())  <span style=color:#75715e># 使用 physics 的 calculate</span>
</span></span></code></pre></div><h4 id=3-java>3. <strong>Java</strong>
<a class=anchor href=#3-java>#</a></h4><p>在 Java 中，命名空間是通過「<strong>包（package）</strong>」來管理的。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#f92672>package</span> com.example.utils;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MathUtils</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>add</span>(<span style=color:#66d9ef>int</span> a, <span style=color:#66d9ef>int</span> b) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> a <span style=color:#f92672>+</span> b;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// main.java</span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> com.example.utils.MathUtils;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Main</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span>(String<span style=color:#f92672>[]</span> args) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> result <span style=color:#f92672>=</span> MathUtils.<span style=color:#a6e22e>add</span>(3, 4);
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(result);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=4-javascript>4. <strong>JavaScript</strong>
<a class=anchor href=#4-javascript>#</a></h4><p>在 JavaScript 中，命名空間可以用物件或模組的方式模擬。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>MathNamespace</span> <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>add</span><span style=color:#f92672>:</span> <span style=color:#66d9ef>function</span>(<span style=color:#a6e22e>a</span>, <span style=color:#a6e22e>b</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>a</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>b</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>PhysicsNamespace</span> <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>add</span><span style=color:#f92672>:</span> <span style=color:#66d9ef>function</span>(<span style=color:#a6e22e>a</span>, <span style=color:#a6e22e>b</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>a</span> <span style=color:#f92672>-</span> <span style=color:#a6e22e>b</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>MathNamespace</span>.<span style=color:#a6e22e>add</span>(<span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>4</span>));  <span style=color:#75715e>// 使用 MathNamespace 的 add
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>PhysicsNamespace</span>.<span style=color:#a6e22e>add</span>(<span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>4</span>));  <span style=color:#75715e>// 使用 PhysicsNamespace 的 add
</span></span></span></code></pre></div><h4 id=5-rust>5. <strong>Rust</strong>
<a class=anchor href=#5-rust>#</a></h4><p>Rust 使用模組（<code>mod</code>）作為命名空間的一種實現。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>mod</span> math {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>add</span>(a: <span style=color:#66d9ef>i32</span>, b: <span style=color:#66d9ef>i32</span>) -&gt; <span style=color:#66d9ef>i32</span> {
</span></span><span style=display:flex><span>        a <span style=color:#f92672>+</span> b
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>mod</span> physics {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>add</span>(a: <span style=color:#66d9ef>i32</span>, b: <span style=color:#66d9ef>i32</span>) -&gt; <span style=color:#66d9ef>i32</span> {
</span></span><span style=display:flex><span>        a <span style=color:#f92672>-</span> b
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    println!(<span style=color:#e6db74>&#34;</span><span style=color:#e6db74>{}</span><span style=color:#e6db74>&#34;</span>, math::add(<span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>4</span>));   <span style=color:#75715e>// 使用 math 的 add
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    println!(<span style=color:#e6db74>&#34;</span><span style=color:#e6db74>{}</span><span style=color:#e6db74>&#34;</span>, physics::add(<span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>4</span>)); <span style=color:#75715e>// 使用 physics 的 add
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><hr><h3 id=namespace-的好處><strong>Namespace 的好處</strong>
<a class=anchor href=#namespace-%e7%9a%84%e5%a5%bd%e8%99%95>#</a></h3><ol><li><strong>避免命名衝突</strong>：在大型項目中，不同開發者可能使用相同名稱，命名空間可以讓它們彼此隔離。</li><li><strong>提升可讀性</strong>：命名空間為名稱提供了上下文，開發者可以更清楚其來源。</li><li><strong>方便管理</strong>：將功能模組化，便於管理和維護代碼。</li></ol><hr><h3 id=總結><strong>總結</strong>
<a class=anchor href=#%e7%b8%bd%e7%b5%90>#</a></h3><p>命名空間的核心目的是為了<strong>組織代碼並避免名稱衝突</strong>。它在不同語言中的具體實現可能有所不同，但基本理念是一致的：提供一個結構化的方式來管理代碼名稱和功能。</p><h2 id=what-is-decorator-in-python>What is decorator in Python?
<a class=anchor href=#what-is-decorator-in-python>#</a></h2><p>參考資料: <a href=https://myapollo.com.tw/blog/python-decorator-tutorial/>https://myapollo.com.tw/blog/python-decorator-tutorial/</a>
以下為Chat-GPT提供
在 Python 中，裝飾器（decorator）是一種用於修改函數或方法行為的高級函數。裝飾器本質上是一個函數，它接受一個函數作為參數，並返回一個新的函數。裝飾器通常用於在不修改原函數代碼的情況下，添加額外的功能或行為。</p><p>裝飾器的常見用途包括：</p><ul><li>記錄日誌</li><li>訪問控製和權限檢查</li><li>緩存</li><li>性能計時</li><li>輸入驗證</li></ul><p>以下是一個簡單的裝飾器示例，用於記錄函數的執行時間：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>import</span> time
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> functools
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>time_it</span>(func):
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@functools.wraps</span>(func)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>wrapper</span>(<span style=color:#f92672>*</span>args, <span style=color:#f92672>**</span>kwargs):
</span></span><span style=display:flex><span>        start <span style=color:#f92672>=</span> time<span style=color:#f92672>.</span>time()
</span></span><span style=display:flex><span>        result <span style=color:#f92672>=</span> func(<span style=color:#f92672>*</span>args, <span style=color:#f92672>**</span>kwargs)
</span></span><span style=display:flex><span>        end <span style=color:#f92672>=</span> time<span style=color:#f92672>.</span>time()
</span></span><span style=display:flex><span>        print(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;</span><span style=color:#e6db74>{</span>func<span style=color:#f92672>.</span>__name__<span style=color:#e6db74>}</span><span style=color:#e6db74> 执行时间: </span><span style=color:#e6db74>{</span>end <span style=color:#f92672>-</span> start<span style=color:#e6db74>:</span><span style=color:#e6db74>.4f</span><span style=color:#e6db74>}</span><span style=color:#e6db74> 秒&#34;</span>)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> result
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> wrapper
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>@time_it</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>my_function</span>():
</span></span><span style=display:flex><span>    time<span style=color:#f92672>.</span>sleep(<span style=color:#ae81ff>2</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>my_function()
</span></span></code></pre></div><p>在這個示例中：</p><ol><li><code>time_it</code> 是一個裝飾器函數，它接受一個函數 <code>func</code> 作為參數。</li><li>在 <code>time_it</code> 函數內部，定義了一個 <code>wrapper</code> 函數。<code>wrapper</code> 函數在調用 <code>func</code> 之前記錄開始時間，在調用 <code>func</code> 之後記錄結束時間，並計算執行時間。</li><li>使用 <code>@functools.wraps(func)</code> 保留原函數的元數據（如函數名和文檔字符串），以便裝飾後的函數看起來像原函數。</li><li><code>time_it</code> 函數返回 <code>wrapper</code> 函數。</li><li>使用 <code>@time_it</code> 語法將 <code>my_function</code> 函數應用裝飾器。這樣，當調用 <code>my_function</code> 時，實際上調用的是 <code>wrapper</code> 函數。</li></ol><p>裝飾器可以堆疊使用，即一個函數可以被多個裝飾器裝飾，裝飾器的應用順序是從內到外。例如：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#a6e22e>@decorator1</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>@decorator2</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>my_function</span>():
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pass</span>
</span></span></code></pre></div><p>等价于：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>my_function</span>():
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pass</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>my_function <span style=color:#f92672>=</span> decorator1(decorator2(my_function))
</span></span></code></pre></div><p>装饰器是 Python 中非常强大的特性，可以用于简化代码、提高代码的可读性和可维护性。</p><h3 id=在flask中常常看到route也有用這個東西意思是一樣的嗎>在Flask中，常常看到route也有用@這個東西，意思是一樣的嗎
<a class=anchor href=#%e5%9c%a8flask%e4%b8%ad%e5%b8%b8%e5%b8%b8%e7%9c%8b%e5%88%b0route%e4%b9%9f%e6%9c%89%e7%94%a8%e9%80%99%e5%80%8b%e6%9d%b1%e8%a5%bf%e6%84%8f%e6%80%9d%e6%98%af%e4%b8%80%e6%a8%a3%e7%9a%84%e5%97%8e>#</a></h3><p>是的，在 Flask 中，<code>@route</code> 裝飾器的作用與 Python 中的其他裝飾器類似。它們都是用於在不修改原始函數代碼的情況下，動態地修改函數或方法的行為。</p><p>在 Flask 中，<code>@app.route</code> 裝飾器用於將 URL 路徑與視圖函數關聯起來。它的作用是告訴 Flask，當訪問特定 URL 時，應該調用哪個函數來處理請求。</p><p>以下是一個簡單的 Flask 應用示例，展示了如何使用 <code>@app.route</code> 裝飾器：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>from</span> flask <span style=color:#f92672>import</span> Flask
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>app <span style=color:#f92672>=</span> Flask(__name__)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>@app.route</span>(<span style=color:#e6db74>&#39;/&#39;</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>home</span>():
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#e6db74>&#34;Hello, World!&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>@app.route</span>(<span style=color:#e6db74>&#39;/about&#39;</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>about</span>():
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#e6db74>&#34;About Page&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> __name__ <span style=color:#f92672>==</span> <span style=color:#e6db74>&#39;__main__&#39;</span>:
</span></span><span style=display:flex><span>    app<span style=color:#f92672>.</span>run(debug<span style=color:#f92672>=</span><span style=color:#66d9ef>True</span>)
</span></span></code></pre></div><p>在這個示例中：</p><ol><li><code>@app.route('/')</code> 裝飾器將根 URL (<code>/</code>) 與 <code>home</code> 函數關聯起來。當用戶訪問根 URL 時，Flask 會調用 <code>home</code> 函數，並將返回的字符串作為響應發送給客戶端。</li><li><code>@app.route('/about')</code> 裝飾器將 <code>/about</code> URL 與 <code>about</code> 函數關聯起來。當用戶訪問 <code>/about</code> URL 時，Flask 會調用 <code>about</code> 函數，並將返回的字符串作為響應發送給客戶端。</li></ol><p>裝飾器的作用是將函數與特定的 URL 路徑關聯起來，而不需要在函數內部處理 URL 路徑的邏輯。這使得代碼更加簡潔和易於維護。</p><p>裝飾器在 Flask 中的使用示例展示了它們在 Web 開發中的強大功能。通過使用裝飾器，可以輕松地將 URL 路徑與視圖函數關聯起來，從而實現路由功能。裝飾器的這種特性使得代碼更加模塊化和可讀。</p><h2 id=what-is-cmakegccg>What is CMake/GCC/G++
<a class=anchor href=#what-is-cmakegccg>#</a></h2><h3 id=cmake-vs-gccg-的區別><strong>CMake vs. GCC/G++ 的區別</strong>
<a class=anchor href=#cmake-vs-gccg-%e7%9a%84%e5%8d%80%e5%88%a5>#</a></h3><p>CMake 和 GCC/G++ 在 C/C++ 專案的開發中扮演不同的角色：</p><table><thead><tr><th><strong>工具</strong></th><th><strong>功能</strong></th></tr></thead><tbody><tr><td><strong>GCC/G++</strong></td><td><strong>編譯器</strong>，將 C/C++ 程式碼編譯成執行檔或函式庫</td></tr><tr><td><strong>CMake</strong></td><td><strong>建構系統生成工具</strong>，用來產生 <code>Makefile</code> 或 <code>Visual Studio</code> 等建構文件，然後交給 GCC/G++ 或其他編譯器執行</td></tr></tbody></table><p>CMake <strong>不直接負責編譯</strong>，它是幫助開發者組織專案並讓編譯器（如 GCC/G++）能夠正確執行的工具。</p><ul><li><strong>GCC/G++</strong> = 工具（負責編譯程式碼）</li><li><strong>CMake</strong> = 施工藍圖（負責告訴工具如何組裝專案）</li></ul><h3 id=1-gccg><strong>1. GCC/G++</strong>
<a class=anchor href=#1-gccg>#</a></h3><p>🔹 <strong>GCC（GNU Compiler Collection）</strong> 是一個編譯器集合，支援多種語言，包括 C、C++、Fortran 等。</p><ul><li><strong>GCC 用於編譯 C 程式</strong><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>gcc main.c -o my_program
</span></span></code></pre></div></li><li><strong>G++ 用於編譯 C++ 程式</strong><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>g++ main.cpp -o my_program
</span></span></code></pre></div></li></ul><p>GCC/G++ 只會處理單一或少量檔案的編譯，但對於大型專案（有很多 C++ 檔案和函式庫），管理這些文件的依賴關係會很麻煩，這時候 <strong>CMake</strong> 就能派上用場。</p><hr><h3 id=2-cmake><strong>2. CMake</strong>
<a class=anchor href=#2-cmake>#</a></h3><p>🔹 <strong>CMake 是一個建構系統生成工具</strong>，它會根據 <code>CMakeLists.txt</code> 檔案產生適合當前環境的建構文件，例如：</p><ul><li><strong>Linux/macOS</strong> → <code>Makefile</code></li><li><strong>Windows（Visual Studio）</strong> → <code>.sln</code> 工程檔</li><li><strong>Ninja</strong> → <code>build.ninja</code></li></ul><p>然後，你可以使用 <code>make</code> 或 <code>ninja</code> 來執行實際的編譯。</p><h3 id=cmake-典型用法><strong>CMake 典型用法</strong>
<a class=anchor href=#cmake-%e5%85%b8%e5%9e%8b%e7%94%a8%e6%b3%95>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>mkdir build <span style=color:#f92672>&amp;&amp;</span> cd build
</span></span><span style=display:flex><span>cmake ..       <span style=color:#75715e># 產生 Makefile</span>
</span></span><span style=display:flex><span>make -j<span style=color:#66d9ef>$(</span>nproc<span style=color:#66d9ef>)</span>  <span style=color:#75715e># 使用 Make 來編譯</span>
</span></span></code></pre></div><p>CMake 不會直接執行 <code>gcc</code> 或 <code>g++</code>，但它會根據<strong>專案的需求</strong>自動選擇合適的編譯器。</p><hr><h3 id=cmake-與-gccg-的關係><strong>CMake 與 GCC/G++ 的關係</strong>
<a class=anchor href=#cmake-%e8%88%87-gccg-%e7%9a%84%e9%97%9c%e4%bf%82>#</a></h3><p>CMake 和 GCC/G++ 其實是<strong>互補關係</strong>，CMake <strong>負責管理建構過程</strong>，然後讓 GCC/G++ <strong>執行編譯</strong>。</p><p>在 CMake 的 <code>CMakeLists.txt</code> 檔案中，你可以指定使用 GCC：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cmake data-lang=cmake><span style=display:flex><span>set(<span style=color:#e6db74>CMAKE_C_COMPILER</span> <span style=color:#e6db74>gcc</span>)<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span>set(<span style=color:#e6db74>CMAKE_CXX_COMPILER</span> <span style=color:#e6db74>g++</span>)<span style=color:#960050;background-color:#1e0010>
</span></span></span></code></pre></div><p>然後執行 CMake 時，它就會使用 <strong>GCC/G++ 來編譯程式碼</strong>。</p><hr><h3 id=何時使用-cmake><strong>何時使用 CMake？</strong>
<a class=anchor href=#%e4%bd%95%e6%99%82%e4%bd%bf%e7%94%a8-cmake>#</a></h3><table><thead><tr><th><strong>場景</strong></th><th><strong>適合工具</strong></th></tr></thead><tbody><tr><td>編譯單個 C/C++ 檔案</td><td><code>gcc</code> / <code>g++</code></td></tr><tr><td>小型專案（幾個檔案）</td><td><code>make</code></td></tr><tr><td><strong>大型專案（多個目錄、函式庫、跨平台）</strong></td><td><code>CMake</code></td></tr></tbody></table><hr><h3 id=g-vs-gcc-的主要區別><strong>g++ vs. gcc 的主要區別</strong>
<a class=anchor href=#g-vs-gcc-%e7%9a%84%e4%b8%bb%e8%a6%81%e5%8d%80%e5%88%a5>#</a></h3><table><thead><tr><th><strong>比較項目</strong></th><th><strong>gcc</strong></th><th><strong>g++</strong></th></tr></thead><tbody><tr><td><strong>主要用途</strong></td><td>編譯 C 程式</td><td>編譯 C++ 程式</td></tr><tr><td><strong>編譯 C++ 時是否自動連結標準函式庫</strong></td><td>❌ 否，需要手動加 <code>-lstdc++</code></td><td>✅ 是，會自動連結 <code>libstdc++</code></td></tr><tr><td><strong>檔案預設行為</strong></td><td>預設識別 <code>.c</code> 為 C 語言</td><td>預設識別 <code>.cpp</code> 為 C++ 語言</td></tr><tr><td><strong>C++ 語法支援</strong></td><td>部分支援，但預設不啟用 C++ 標準</td><td>完整支援 C++</td></tr></tbody></table><hr><h3 id=1><strong>1. <code>gcc</code> 編譯 C 程式</strong>
<a class=anchor href=#1>#</a></h3><p>如果你用 <code>gcc</code> 編譯 C 程式：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>gcc main.c -o main
</span></span></code></pre></div><p>它會使用 C 語言的編譯規則。</p><hr><h3 id=2><strong>2. <code>gcc</code> 編譯 C++ 程式（需要手動指定標準庫）</strong>
<a class=anchor href=#2>#</a></h3><p>如果你用 <code>gcc</code> 編譯 C++ 程式：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>gcc main.cpp -o main
</span></span></code></pre></div><p>這會產生錯誤，因為 <code>gcc</code> <strong>不會自動連結 C++ 標準函式庫</strong>。你必須手動加上 <code>-lstdc++</code>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>gcc main.cpp -lstdc++ -o main
</span></span></code></pre></div><hr><h3 id=3><strong>3. <code>g++</code> 編譯 C++ 程式（推薦方式）</strong>
<a class=anchor href=#3>#</a></h3><p>如果你用 <code>g++</code> 編譯 C++ 程式：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>g++ main.cpp -o main
</span></span></code></pre></div><p>它<strong>自動連結 C++ 標準函式庫</strong>，不用額外加 <code>-lstdc++</code>，是<strong>推薦的方式</strong>。</p><hr><h3 id=4><strong>4. <code>gcc</code> 和 <code>g++</code> 在多檔案專案的行為</strong>
<a class=anchor href=#4>#</a></h3><h4 id=混合-c-和-c-的專案><strong>混合 C 和 C++ 的專案</strong>
<a class=anchor href=#%e6%b7%b7%e5%90%88-c-%e5%92%8c-c-%e7%9a%84%e5%b0%88%e6%a1%88>#</a></h4><p>假設我們有兩個檔案：</p><ul><li><code>main.cpp</code>（C++ 代碼）</li><li><code>utils.c</code>（C 代碼）</li></ul><p>用 <code>gcc</code> 來編譯（需要手動連結 C++ 標準庫）：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>gcc main.cpp utils.c -lstdc++ -o main
</span></span></code></pre></div><p>用 <code>g++</code> 來編譯：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>g++ main.cpp utils.c -o main
</span></span></code></pre></div><p><strong><code>g++</code> 會自動連結 <code>libstdc++</code>，所以更方便。</strong></p><hr><h3 id=結論該用哪個><strong>結論：該用哪個？</strong>
<a class=anchor href=#%e7%b5%90%e8%ab%96%e8%a9%b2%e7%94%a8%e5%93%aa%e5%80%8b>#</a></h3><table><thead><tr><th><strong>情境</strong></th><th><strong>建議工具</strong></th></tr></thead><tbody><tr><td><strong>純 C 程式</strong></td><td><code>gcc</code></td></tr><tr><td><strong>純 C++ 程式</strong></td><td><code>g++</code></td></tr><tr><td><strong>C 和 C++ 混合專案</strong></td><td><code>g++</code>（因為它會自動連結 C++ 標準庫）</td></tr></tbody></table><p>如果你的專案主要是 C++，<strong>優先使用 <code>g++</code></strong>，因為它會處理 C++ 標準函式庫連結。如果是 C，則用 <code>gcc</code>。</p></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#what-is-namespace-in-programming>What is namespace in programming?</a><ul><li><a href=#namespace-的概念與作用><strong>Namespace 的概念與作用</strong></a></li><li><a href=#namespace-的具體表現><strong>Namespace 的具體表現</strong></a></li><li><a href=#namespace-的好處><strong>Namespace 的好處</strong></a></li><li><a href=#總結><strong>總結</strong></a></li></ul></li><li><a href=#what-is-decorator-in-python>What is decorator in Python?</a><ul><li><a href=#在flask中常常看到route也有用這個東西意思是一樣的嗎>在Flask中，常常看到route也有用@這個東西，意思是一樣的嗎</a></li></ul></li><li><a href=#what-is-cmakegccg>What is CMake/GCC/G++</a><ul><li><a href=#cmake-vs-gccg-的區別><strong>CMake vs. GCC/G++ 的區別</strong></a></li><li><a href=#1-gccg><strong>1. GCC/G++</strong></a></li><li><a href=#2-cmake><strong>2. CMake</strong></a></li><li><a href=#cmake-典型用法><strong>CMake 典型用法</strong></a></li><li><a href=#cmake-與-gccg-的關係><strong>CMake 與 GCC/G++ 的關係</strong></a></li><li><a href=#何時使用-cmake><strong>何時使用 CMake？</strong></a></li><li><a href=#g-vs-gcc-的主要區別><strong>g++ vs. gcc 的主要區別</strong></a></li><li><a href=#1><strong>1. <code>gcc</code> 編譯 C 程式</strong></a></li><li><a href=#2><strong>2. <code>gcc</code> 編譯 C++ 程式（需要手動指定標準庫）</strong></a></li><li><a href=#3><strong>3. <code>g++</code> 編譯 C++ 程式（推薦方式）</strong></a></li><li><a href=#4><strong>4. <code>gcc</code> 和 <code>g++</code> 在多檔案專案的行為</strong></a></li><li><a href=#結論該用哪個><strong>結論：該用哪個？</strong></a></li></ul></li></ul></nav></div></aside></main></body></html>