<!doctype html><html lang=en-us dir=ltr itemscope itemtype=http://schema.org/Article data-r-output-format=html><head><meta charset=utf-8><meta name=viewport content="height=device-height,width=device-width,initial-scale=1,minimum-scale=1"><meta name=generator content="Hugo 0.145.0"><meta name=generator content="Relearn 7.6.0+b932d301d7838f3c1a50e318e216b55ce5cc9148"><meta name=description content="Programming Related What is namespace in programming? From ChatGPT 在程式語言中，namespace（命名空間）是一種用來組織和管理代碼的機制，目的是避免名稱衝突並提升代碼的可讀性和結構化。
Namespace 的概念與作用 名稱分隔
命名空間可以將代碼中的名稱（如變數、函數、類別等）組織起來，避免與其他代碼中的名稱發生衝突。
例如，兩個不同的模組中可能都定義了名稱為 calculate 的函數，但由於它們位於不同的命名空間，因此可以共存。 代碼組織
命名空間可以將相關聯的功能分組在一起，使代碼結構更加清晰，便於維護和重用。
避免名稱污染
命名空間可以避免全域命名空間中的名稱被不小心覆蓋或污染，降低了意外錯誤的可能性。
Namespace 的具體表現 1. C++ 在 C++ 中，命名空間是通過 namespace 關鍵字來實現的。
#include <iostream> namespace Math { int add(int a, int b) { return a + b; } } namespace Physics { int add(int a, int b) { return a - b; } } int main() { std::cout << Math::add(3, 4) << std::endl; // 使用 Math 的 add 函數 std::cout << Physics::add(3, 4) << std::endl; // 使用 Physics 的 add 函數 return 0; } 2. Python 在 Python 中，每個模組（module）本身就是一個命名空間，通過 import 來使用其他命名空間的內容。"><meta name=author content><meta name=twitter:card content="summary"><meta name=twitter:title content="Programming Related :: SBK Hugo Site"><meta name=twitter:description content="Programming Related What is namespace in programming? From ChatGPT 在程式語言中，namespace（命名空間）是一種用來組織和管理代碼的機制，目的是避免名稱衝突並提升代碼的可讀性和結構化。
Namespace 的概念與作用 名稱分隔
命名空間可以將代碼中的名稱（如變數、函數、類別等）組織起來，避免與其他代碼中的名稱發生衝突。
例如，兩個不同的模組中可能都定義了名稱為 calculate 的函數，但由於它們位於不同的命名空間，因此可以共存。 代碼組織
命名空間可以將相關聯的功能分組在一起，使代碼結構更加清晰，便於維護和重用。
避免名稱污染
命名空間可以避免全域命名空間中的名稱被不小心覆蓋或污染，降低了意外錯誤的可能性。
Namespace 的具體表現 1. C++ 在 C++ 中，命名空間是通過 namespace 關鍵字來實現的。
#include <iostream> namespace Math { int add(int a, int b) { return a + b; } } namespace Physics { int add(int a, int b) { return a - b; } } int main() { std::cout << Math::add(3, 4) << std::endl; // 使用 Math 的 add 函數 std::cout << Physics::add(3, 4) << std::endl; // 使用 Physics 的 add 函數 return 0; } 2. Python 在 Python 中，每個模組（module）本身就是一個命名空間，通過 import 來使用其他命名空間的內容。"><meta property="og:url" content="https://bernie6401.github.io/terminology/programming-related/index.html"><meta property="og:site_name" content="SBK Hugo Site"><meta property="og:title" content="Programming Related :: SBK Hugo Site"><meta property="og:description" content="Programming Related What is namespace in programming? From ChatGPT 在程式語言中，namespace（命名空間）是一種用來組織和管理代碼的機制，目的是避免名稱衝突並提升代碼的可讀性和結構化。
Namespace 的概念與作用 名稱分隔
命名空間可以將代碼中的名稱（如變數、函數、類別等）組織起來，避免與其他代碼中的名稱發生衝突。
例如，兩個不同的模組中可能都定義了名稱為 calculate 的函數，但由於它們位於不同的命名空間，因此可以共存。 代碼組織
命名空間可以將相關聯的功能分組在一起，使代碼結構更加清晰，便於維護和重用。
避免名稱污染
命名空間可以避免全域命名空間中的名稱被不小心覆蓋或污染，降低了意外錯誤的可能性。
Namespace 的具體表現 1. C++ 在 C++ 中，命名空間是通過 namespace 關鍵字來實現的。
#include <iostream> namespace Math { int add(int a, int b) { return a + b; } } namespace Physics { int add(int a, int b) { return a - b; } } int main() { std::cout << Math::add(3, 4) << std::endl; // 使用 Math 的 add 函數 std::cout << Physics::add(3, 4) << std::endl; // 使用 Physics 的 add 函數 return 0; } 2. Python 在 Python 中，每個模組（module）本身就是一個命名空間，通過 import 來使用其他命名空間的內容。"><meta property="og:locale" content="en_us"><meta property="og:type" content="article"><meta property="article:section" content="Terminologies"><meta property="article:tag" content="名詞解釋"><meta itemprop=name content="Programming Related :: SBK Hugo Site"><meta itemprop=description content="Programming Related What is namespace in programming? From ChatGPT 在程式語言中，namespace（命名空間）是一種用來組織和管理代碼的機制，目的是避免名稱衝突並提升代碼的可讀性和結構化。
Namespace 的概念與作用 名稱分隔
命名空間可以將代碼中的名稱（如變數、函數、類別等）組織起來，避免與其他代碼中的名稱發生衝突。
例如，兩個不同的模組中可能都定義了名稱為 calculate 的函數，但由於它們位於不同的命名空間，因此可以共存。 代碼組織
命名空間可以將相關聯的功能分組在一起，使代碼結構更加清晰，便於維護和重用。
避免名稱污染
命名空間可以避免全域命名空間中的名稱被不小心覆蓋或污染，降低了意外錯誤的可能性。
Namespace 的具體表現 1. C++ 在 C++ 中，命名空間是通過 namespace 關鍵字來實現的。
#include <iostream> namespace Math { int add(int a, int b) { return a + b; } } namespace Physics { int add(int a, int b) { return a - b; } } int main() { std::cout << Math::add(3, 4) << std::endl; // 使用 Math 的 add 函數 std::cout << Physics::add(3, 4) << std::endl; // 使用 Physics 的 add 函數 return 0; } 2. Python 在 Python 中，每個模組（module）本身就是一個命名空間，通過 import 來使用其他命名空間的內容。"><meta itemprop=wordCount content="790"><meta itemprop=keywords content="名詞解釋"><title>Programming Related :: SBK Hugo Site</title>
<link href=/fonts/fontawesome/css/fontawesome-all.min.css?1743619851 rel=stylesheet media=print onload='this.media="all",this.onload=null'><noscript><link href=/fonts/fontawesome/css/fontawesome-all.min.css?1743619851 rel=stylesheet></noscript><link href=/css/perfect-scrollbar/perfect-scrollbar.min.css?1743619851 rel=stylesheet><link href=/css/theme.min.css?1743619851 rel=stylesheet><link href=/css/format-html.min.css?1743619851 rel=stylesheet id=R-format-style><link href=/css/auto-complete/auto-complete.min.css?1743619851 rel=stylesheet><script src=/js/auto-complete/auto-complete.min.js?1743619851 defer></script><script src=/js/lunr/lunr.min.js?1743619851 defer></script><script src=/js/lunr/lunr.stemmer.support.min.js?1743619851 defer></script><script src=/js/lunr/lunr.multi.min.js?1743619851 defer></script><script src=/js/lunr/lunr.en.min.js?1743619851 defer></script><script src=/js/search.min.js?1743619851 defer></script><script>window.relearn=window.relearn||{},window.relearn.min=`.min`,window.relearn.path="/terminology/programming-related/index.html",window.relearn.relBasePath="../..",window.relearn.relBaseUri="../..",window.relearn.absBaseUri="https://bernie6401.github.io",window.relearn.contentLangs=["en"],window.relearn.index_js_url="/searchindex.en.js?1743619851",window.relearn.disableAnchorCopy=!1,window.relearn.disableAnchorScrolling=!1,window.relearn.disableInlineCopyToClipboard=!1,window.relearn.enableBlockCodeWrap=!0,window.relearn.getItem=(e,t)=>e.getItem(t),window.relearn.setItem=(e,t,n)=>e.setItem(t,n),window.relearn.removeItem=(e,t)=>e.removeItem(t),window.relearn.themevariants=["auto"],window.relearn.customvariantname="my-custom-variant",window.relearn.changeVariant=function(e){var t=document.documentElement.dataset.rThemeVariant;window.relearn.setItem(window.localStorage,window.relearn.absBaseUri+"/variant",e),document.documentElement.dataset.rThemeVariant=e,t!=e&&(document.dispatchEvent(new CustomEvent("themeVariantLoaded",{detail:{variant:e,oldVariant:t}})),window.relearn.markVariant())},window.relearn.markVariant=function(){var e=window.relearn.getItem(window.localStorage,window.relearn.absBaseUri+"/variant");document.querySelectorAll(".R-variantswitcher select").forEach(t=>{t.value=e})},window.relearn.initVariant=function(){var e=window.relearn.getItem(window.localStorage,window.relearn.absBaseUri+"/variant")??"";e==window.relearn.customvariantname||(!e||!window.relearn.themevariants.includes(e))&&(e=window.relearn.themevariants[0],window.relearn.setItem(window.localStorage,window.relearn.absBaseUri+"/variant",e)),document.documentElement.dataset.rThemeVariant=e},window.relearn.initVariant(),window.relearn.markVariant(),window.T_Copy_to_clipboard=`Copy to clipboard`,window.T_Copied_to_clipboard=`Copied to clipboard!`,window.T_Copy_link_to_clipboard=`Copy link to clipboard`,window.T_Link_copied_to_clipboard=`Copied link to clipboard!`,window.T_Reset_view=`Reset view`,window.T_View_reset=`View reset!`,window.T_No_results_found=`No results found for "{0}"`,window.T_N_results_found=`{1} results found for "{0}"`</script></head><body class="mobile-support html" data-url=/terminology/programming-related/index.html><div id=R-body class=default-animation><div id=R-body-overlay></div><nav id=R-topbar><div class=topbar-wrapper><div class=topbar-sidebar-divider></div><div class="topbar-area topbar-area-start" data-area=start><div class="topbar-button topbar-button-sidebar" data-content-empty=disable data-width-s=show data-width-m=hide data-width-l=hide><button class=topbar-control onclick=toggleNav() type=button title="Menu (CTRL+ALT+n)"><i class="fa-fw fas fa-bars"></i></button></div><div class="topbar-button topbar-button-toc" data-content-empty=hide data-width-s=show data-width-m=show data-width-l=show><button class=topbar-control onclick=toggleTopbarFlyout(this) type=button title="Table of Contents (CTRL+ALT+t)"><i class="fa-fw fas fa-list-alt"></i></button><div class=topbar-content><div class=topbar-content-wrapper><nav class=TableOfContents><ul><li><a href=#what-is-namespace-in-programming>What is namespace in programming?</a><ul><li><a href=#namespace-的概念與作用><strong>Namespace 的概念與作用</strong></a></li><li><a href=#namespace-的具體表現><strong>Namespace 的具體表現</strong></a></li><li><a href=#namespace-的好處><strong>Namespace 的好處</strong></a></li><li><a href=#總結><strong>總結</strong></a></li></ul></li><li><a href=#what-is-decorator-in-python>What is decorator in Python?</a><ul><li><a href=#在flask中常常看到route也有用這個東西意思是一樣的嗎>在Flask中，常常看到route也有用@這個東西，意思是一樣的嗎</a></li></ul></li><li><a href=#what-is-cmakegccg>What is CMake/GCC/G++</a><ul><li><a href=#cmake-vs-gccg-的區別><strong>CMake vs. GCC/G++ 的區別</strong></a></li><li><a href=#1-gccg><strong>1. GCC/G++</strong></a></li><li><a href=#2-cmake><strong>2. CMake</strong></a></li><li><a href=#cmake-典型用法><strong>CMake 典型用法</strong></a></li><li><a href=#cmake-與-gccg-的關係><strong>CMake 與 GCC/G++ 的關係</strong></a></li><li><a href=#何時使用-cmake><strong>何時使用 CMake？</strong></a></li><li><a href=#g-vs-gcc-的主要區別><strong>g++ vs. gcc 的主要區別</strong></a></li><li><a href=#1><strong>1. <code>gcc</code> 編譯 C 程式</strong></a></li><li><a href=#2><strong>2. <code>gcc</code> 編譯 C++ 程式（需要手動指定標準庫）</strong></a></li><li><a href=#3><strong>3. <code>g++</code> 編譯 C++ 程式（推薦方式）</strong></a></li><li><a href=#4><strong>4. <code>gcc</code> 和 <code>g++</code> 在多檔案專案的行為</strong></a></li><li><a href=#結論該用哪個><strong>結論：該用哪個？</strong></a></li></ul></li></ul></nav></div></div></div></div><ol class="topbar-breadcrumbs breadcrumbs highlightable" itemscope itemtype=http://schema.org/BreadcrumbList><li itemscope itemtype=https://schema.org/ListItem itemprop=itemListElement><a itemprop=item href=/index.html><span itemprop=name>SBK Hugo Site</span></a><meta itemprop=position content="1">&nbsp;>&nbsp;</li><li itemscope itemtype=https://schema.org/ListItem itemprop=itemListElement><a itemprop=item href=/terminology/index.html><span itemprop=name>Terminologies</span></a><meta itemprop=position content="2">&nbsp;>&nbsp;</li><li itemscope itemtype=https://schema.org/ListItem itemprop=itemListElement><span itemprop=name>Programming Related</span><meta itemprop=position content="3"></li></ol><div class="topbar-area topbar-area-end" data-area=end><div class="topbar-button topbar-button-prev" data-content-empty=disable data-width-s=show data-width-m=show data-width-l=show><a class=topbar-control href=/terminology/node-related/index.html title="Node Related (🡐)"><i class="fa-fw fas fa-chevron-left"></i></a></div><div class="topbar-button topbar-button-next" data-content-empty=disable data-width-s=show data-width-m=show data-width-l=show><a class=topbar-control href=/terminology/reinforcement-learning/index.html title="Reinforcement Learning (🡒)"><i class="fa-fw fas fa-chevron-right"></i></a></div><div class="topbar-button topbar-button-more" data-content-empty=hide data-width-s=show data-width-m=show data-width-l=show><button class=topbar-control onclick=toggleTopbarFlyout(this) type=button title=More><i class="fa-fw fas fa-ellipsis-v"></i></button><div class=topbar-content><div class=topbar-content-wrapper><div class="topbar-area topbar-area-more" data-area=more></div></div></div></div></div></div></nav><div id=R-main-overlay></div><main id=R-body-inner class="highlightable terminology" tabindex=-1><div class=flex-block-wrapper><article class=default><header class=headline><div class="R-taxonomy taxonomy-tags cstyle tags" title=Tags style=--VARIABLE-TAGS-BG-color:var(--INTERNAL-TAG-BG-color)><ul><li><a class=term-link href=/tags/%E5%90%8D%E8%A9%9E%E8%A7%A3%E9%87%8B/index.html>名詞解釋</a></li></ul></div></header><h1 id=programming-related>Programming Related</h1><h1 id=programming-related>Programming Related</h1><h2 id=what-is-namespace-in-programming>What is namespace in programming?</h2><p>From ChatGPT
在程式語言中，<strong>namespace</strong>（命名空間）是一種用來<strong>組織和管理代碼</strong>的機制，目的是避免名稱衝突並提升代碼的可讀性和結構化。</p><hr><h3 id=namespace-的概念與作用><strong>Namespace 的概念與作用</strong></h3><ol><li><p><strong>名稱分隔</strong><br>命名空間可以將代碼中的名稱（如變數、函數、類別等）組織起來，避免與其他代碼中的名稱發生衝突。</p><ul><li>例如，兩個不同的模組中可能都定義了名稱為 <code>calculate</code> 的函數，但由於它們位於不同的命名空間，因此可以共存。</li></ul></li><li><p><strong>代碼組織</strong><br>命名空間可以將相關聯的功能分組在一起，使代碼結構更加清晰，便於維護和重用。</p></li><li><p><strong>避免名稱污染</strong><br>命名空間可以避免全域命名空間中的名稱被不小心覆蓋或污染，降低了意外錯誤的可能性。</p></li></ol><hr><h3 id=namespace-的具體表現><strong>Namespace 的具體表現</strong></h3><h4 id=1-c>1. <strong>C++</strong></h4><p>在 C++ 中，命名空間是通過 <code>namespace</code> 關鍵字來實現的。</p><div class="highlight wrap-code" dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;iostream&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>namespace</span> Math {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>add</span>(<span style=color:#66d9ef>int</span> a, <span style=color:#66d9ef>int</span> b) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> a <span style=color:#f92672>+</span> b;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>namespace</span> Physics {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>add</span>(<span style=color:#66d9ef>int</span> a, <span style=color:#66d9ef>int</span> b) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> a <span style=color:#f92672>-</span> b;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> Math<span style=color:#f92672>::</span>add(<span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>4</span>) <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl;  <span style=color:#75715e>// 使用 Math 的 add 函數
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> Physics<span style=color:#f92672>::</span>add(<span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>4</span>) <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl; <span style=color:#75715e>// 使用 Physics 的 add 函數
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}</span></span></code></pre></div><h4 id=2-python>2. <strong>Python</strong></h4><p>在 Python 中，每個模組（module）本身就是一個命名空間，通過 <code>import</code> 來使用其他命名空間的內容。</p><div class="highlight wrap-code" dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#75715e># math.py</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>calculate</span>():
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#e6db74>&#34;Math calculate&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># physics.py</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>calculate</span>():
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#e6db74>&#34;Physics calculate&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># main.py</span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> math
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> physics
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>print(math<span style=color:#f92672>.</span>calculate())   <span style=color:#75715e># 使用 math 的 calculate</span>
</span></span><span style=display:flex><span>print(physics<span style=color:#f92672>.</span>calculate())  <span style=color:#75715e># 使用 physics 的 calculate</span></span></span></code></pre></div><h4 id=3-java>3. <strong>Java</strong></h4><p>在 Java 中，命名空間是通過「<strong>包（package）</strong>」來管理的。</p><div class="highlight wrap-code" dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#f92672>package</span> com.example.utils;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MathUtils</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>add</span>(<span style=color:#66d9ef>int</span> a, <span style=color:#66d9ef>int</span> b) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> a <span style=color:#f92672>+</span> b;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// main.java</span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> com.example.utils.MathUtils;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Main</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span>(String<span style=color:#f92672>[]</span> args) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> result <span style=color:#f92672>=</span> MathUtils.<span style=color:#a6e22e>add</span>(3, 4);
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(result);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}</span></span></code></pre></div><h4 id=4-javascript>4. <strong>JavaScript</strong></h4><p>在 JavaScript 中，命名空間可以用物件或模組的方式模擬。</p><div class="highlight wrap-code" dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>MathNamespace</span> <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>add</span><span style=color:#f92672>:</span> <span style=color:#66d9ef>function</span>(<span style=color:#a6e22e>a</span>, <span style=color:#a6e22e>b</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>a</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>b</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>PhysicsNamespace</span> <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>add</span><span style=color:#f92672>:</span> <span style=color:#66d9ef>function</span>(<span style=color:#a6e22e>a</span>, <span style=color:#a6e22e>b</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>a</span> <span style=color:#f92672>-</span> <span style=color:#a6e22e>b</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>MathNamespace</span>.<span style=color:#a6e22e>add</span>(<span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>4</span>));  <span style=color:#75715e>// 使用 MathNamespace 的 add
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>PhysicsNamespace</span>.<span style=color:#a6e22e>add</span>(<span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>4</span>));  <span style=color:#75715e>// 使用 PhysicsNamespace 的 add
</span></span></span></code></pre></div><h4 id=5-rust>5. <strong>Rust</strong></h4><p>Rust 使用模組（<code>mod</code>）作為命名空間的一種實現。</p><div class="highlight wrap-code" dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>mod</span> math {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>add</span>(a: <span style=color:#66d9ef>i32</span>, b: <span style=color:#66d9ef>i32</span>) -&gt; <span style=color:#66d9ef>i32</span> {
</span></span><span style=display:flex><span>        a <span style=color:#f92672>+</span> b
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>mod</span> physics {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>add</span>(a: <span style=color:#66d9ef>i32</span>, b: <span style=color:#66d9ef>i32</span>) -&gt; <span style=color:#66d9ef>i32</span> {
</span></span><span style=display:flex><span>        a <span style=color:#f92672>-</span> b
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    println!(<span style=color:#e6db74>&#34;</span><span style=color:#e6db74>{}</span><span style=color:#e6db74>&#34;</span>, math::add(<span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>4</span>));   <span style=color:#75715e>// 使用 math 的 add
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    println!(<span style=color:#e6db74>&#34;</span><span style=color:#e6db74>{}</span><span style=color:#e6db74>&#34;</span>, physics::add(<span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>4</span>)); <span style=color:#75715e>// 使用 physics 的 add
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}</span></span></code></pre></div><hr><h3 id=namespace-的好處><strong>Namespace 的好處</strong></h3><ol><li><strong>避免命名衝突</strong>：在大型項目中，不同開發者可能使用相同名稱，命名空間可以讓它們彼此隔離。</li><li><strong>提升可讀性</strong>：命名空間為名稱提供了上下文，開發者可以更清楚其來源。</li><li><strong>方便管理</strong>：將功能模組化，便於管理和維護代碼。</li></ol><hr><h3 id=總結><strong>總結</strong></h3><p>命名空間的核心目的是為了<strong>組織代碼並避免名稱衝突</strong>。它在不同語言中的具體實現可能有所不同，但基本理念是一致的：提供一個結構化的方式來管理代碼名稱和功能。</p><h2 id=what-is-decorator-in-python>What is decorator in Python?</h2><p>參考資料: <a href=https://myapollo.com.tw/blog/python-decorator-tutorial/ rel=external target=_blank>https://myapollo.com.tw/blog/python-decorator-tutorial/</a>
以下為Chat-GPT提供
在 Python 中，裝飾器（decorator）是一種用於修改函數或方法行為的高級函數。裝飾器本質上是一個函數，它接受一個函數作為參數，並返回一個新的函數。裝飾器通常用於在不修改原函數代碼的情況下，添加額外的功能或行為。</p><p>裝飾器的常見用途包括：</p><ul><li>記錄日誌</li><li>訪問控製和權限檢查</li><li>緩存</li><li>性能計時</li><li>輸入驗證</li></ul><p>以下是一個簡單的裝飾器示例，用於記錄函數的執行時間：</p><div class="highlight wrap-code" dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>import</span> time
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> functools
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>time_it</span>(func):
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@functools.wraps</span>(func)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>wrapper</span>(<span style=color:#f92672>*</span>args, <span style=color:#f92672>**</span>kwargs):
</span></span><span style=display:flex><span>        start <span style=color:#f92672>=</span> time<span style=color:#f92672>.</span>time()
</span></span><span style=display:flex><span>        result <span style=color:#f92672>=</span> func(<span style=color:#f92672>*</span>args, <span style=color:#f92672>**</span>kwargs)
</span></span><span style=display:flex><span>        end <span style=color:#f92672>=</span> time<span style=color:#f92672>.</span>time()
</span></span><span style=display:flex><span>        print(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;</span><span style=color:#e6db74>{</span>func<span style=color:#f92672>.</span>__name__<span style=color:#e6db74>}</span><span style=color:#e6db74> 执行时间: </span><span style=color:#e6db74>{</span>end <span style=color:#f92672>-</span> start<span style=color:#e6db74>:</span><span style=color:#e6db74>.4f</span><span style=color:#e6db74>}</span><span style=color:#e6db74> 秒&#34;</span>)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> result
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> wrapper
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>@time_it</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>my_function</span>():
</span></span><span style=display:flex><span>    time<span style=color:#f92672>.</span>sleep(<span style=color:#ae81ff>2</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>my_function()</span></span></code></pre></div><p>在這個示例中：</p><ol><li><code>time_it</code> 是一個裝飾器函數，它接受一個函數 <code>func</code> 作為參數。</li><li>在 <code>time_it</code> 函數內部，定義了一個 <code>wrapper</code> 函數。<code>wrapper</code> 函數在調用 <code>func</code> 之前記錄開始時間，在調用 <code>func</code> 之後記錄結束時間，並計算執行時間。</li><li>使用 <code>@functools.wraps(func)</code> 保留原函數的元數據（如函數名和文檔字符串），以便裝飾後的函數看起來像原函數。</li><li><code>time_it</code> 函數返回 <code>wrapper</code> 函數。</li><li>使用 <code>@time_it</code> 語法將 <code>my_function</code> 函數應用裝飾器。這樣，當調用 <code>my_function</code> 時，實際上調用的是 <code>wrapper</code> 函數。</li></ol><p>裝飾器可以堆疊使用，即一個函數可以被多個裝飾器裝飾，裝飾器的應用順序是從內到外。例如：</p><div class="highlight wrap-code" dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#a6e22e>@decorator1</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>@decorator2</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>my_function</span>():
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pass</span></span></span></code></pre></div><p>等价于：</p><div class="highlight wrap-code" dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>my_function</span>():
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pass</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>my_function <span style=color:#f92672>=</span> decorator1(decorator2(my_function))</span></span></code></pre></div><p>装饰器是 Python 中非常强大的特性，可以用于简化代码、提高代码的可读性和可维护性。</p><h3 id=在flask中常常看到route也有用這個東西意思是一樣的嗎>在Flask中，常常看到route也有用@這個東西，意思是一樣的嗎</h3><p>是的，在 Flask 中，<code>@route</code> 裝飾器的作用與 Python 中的其他裝飾器類似。它們都是用於在不修改原始函數代碼的情況下，動態地修改函數或方法的行為。</p><p>在 Flask 中，<code>@app.route</code> 裝飾器用於將 URL 路徑與視圖函數關聯起來。它的作用是告訴 Flask，當訪問特定 URL 時，應該調用哪個函數來處理請求。</p><p>以下是一個簡單的 Flask 應用示例，展示了如何使用 <code>@app.route</code> 裝飾器：</p><div class="highlight wrap-code" dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>from</span> flask <span style=color:#f92672>import</span> Flask
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>app <span style=color:#f92672>=</span> Flask(__name__)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>@app.route</span>(<span style=color:#e6db74>&#39;/&#39;</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>home</span>():
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#e6db74>&#34;Hello, World!&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>@app.route</span>(<span style=color:#e6db74>&#39;/about&#39;</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>about</span>():
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#e6db74>&#34;About Page&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> __name__ <span style=color:#f92672>==</span> <span style=color:#e6db74>&#39;__main__&#39;</span>:
</span></span><span style=display:flex><span>    app<span style=color:#f92672>.</span>run(debug<span style=color:#f92672>=</span><span style=color:#66d9ef>True</span>)</span></span></code></pre></div><p>在這個示例中：</p><ol><li><code>@app.route('/')</code> 裝飾器將根 URL (<code>/</code>) 與 <code>home</code> 函數關聯起來。當用戶訪問根 URL 時，Flask 會調用 <code>home</code> 函數，並將返回的字符串作為響應發送給客戶端。</li><li><code>@app.route('/about')</code> 裝飾器將 <code>/about</code> URL 與 <code>about</code> 函數關聯起來。當用戶訪問 <code>/about</code> URL 時，Flask 會調用 <code>about</code> 函數，並將返回的字符串作為響應發送給客戶端。</li></ol><p>裝飾器的作用是將函數與特定的 URL 路徑關聯起來，而不需要在函數內部處理 URL 路徑的邏輯。這使得代碼更加簡潔和易於維護。</p><p>裝飾器在 Flask 中的使用示例展示了它們在 Web 開發中的強大功能。通過使用裝飾器，可以輕松地將 URL 路徑與視圖函數關聯起來，從而實現路由功能。裝飾器的這種特性使得代碼更加模塊化和可讀。</p><h2 id=what-is-cmakegccg>What is CMake/GCC/G++</h2><h3 id=cmake-vs-gccg-的區別><strong>CMake vs. GCC/G++ 的區別</strong></h3><p>CMake 和 GCC/G++ 在 C/C++ 專案的開發中扮演不同的角色：</p><table><thead><tr><th><strong>工具</strong></th><th><strong>功能</strong></th></tr></thead><tbody><tr><td><strong>GCC/G++</strong></td><td><strong>編譯器</strong>，將 C/C++ 程式碼編譯成執行檔或函式庫</td></tr><tr><td><strong>CMake</strong></td><td><strong>建構系統生成工具</strong>，用來產生 <code>Makefile</code> 或 <code>Visual Studio</code> 等建構文件，然後交給 GCC/G++ 或其他編譯器執行</td></tr></tbody></table><p>CMake <strong>不直接負責編譯</strong>，它是幫助開發者組織專案並讓編譯器（如 GCC/G++）能夠正確執行的工具。</p><ul><li><strong>GCC/G++</strong> = 工具（負責編譯程式碼）</li><li><strong>CMake</strong> = 施工藍圖（負責告訴工具如何組裝專案）</li></ul><h3 id=1-gccg><strong>1. GCC/G++</strong></h3><p>🔹 <strong>GCC（GNU Compiler Collection）</strong> 是一個編譯器集合，支援多種語言，包括 C、C++、Fortran 等。</p><ul><li><strong>GCC 用於編譯 C 程式</strong><div class="highlight wrap-code" dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>gcc main.c -o my_program</span></span></code></pre></div></li><li><strong>G++ 用於編譯 C++ 程式</strong><div class="highlight wrap-code" dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>g++ main.cpp -o my_program</span></span></code></pre></div></li></ul><p>GCC/G++ 只會處理單一或少量檔案的編譯，但對於大型專案（有很多 C++ 檔案和函式庫），管理這些文件的依賴關係會很麻煩，這時候 <strong>CMake</strong> 就能派上用場。</p><hr><h3 id=2-cmake><strong>2. CMake</strong></h3><p>🔹 <strong>CMake 是一個建構系統生成工具</strong>，它會根據 <code>CMakeLists.txt</code> 檔案產生適合當前環境的建構文件，例如：</p><ul><li><strong>Linux/macOS</strong> → <code>Makefile</code></li><li><strong>Windows（Visual Studio）</strong> → <code>.sln</code> 工程檔</li><li><strong>Ninja</strong> → <code>build.ninja</code></li></ul><p>然後，你可以使用 <code>make</code> 或 <code>ninja</code> 來執行實際的編譯。</p><h3 id=cmake-典型用法><strong>CMake 典型用法</strong></h3><div class="highlight wrap-code" dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>mkdir build <span style=color:#f92672>&amp;&amp;</span> cd build
</span></span><span style=display:flex><span>cmake ..       <span style=color:#75715e># 產生 Makefile</span>
</span></span><span style=display:flex><span>make -j<span style=color:#66d9ef>$(</span>nproc<span style=color:#66d9ef>)</span>  <span style=color:#75715e># 使用 Make 來編譯</span></span></span></code></pre></div><p>CMake 不會直接執行 <code>gcc</code> 或 <code>g++</code>，但它會根據<strong>專案的需求</strong>自動選擇合適的編譯器。</p><hr><h3 id=cmake-與-gccg-的關係><strong>CMake 與 GCC/G++ 的關係</strong></h3><p>CMake 和 GCC/G++ 其實是<strong>互補關係</strong>，CMake <strong>負責管理建構過程</strong>，然後讓 GCC/G++ <strong>執行編譯</strong>。</p><p>在 CMake 的 <code>CMakeLists.txt</code> 檔案中，你可以指定使用 GCC：</p><div class="highlight wrap-code" dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cmake data-lang=cmake><span style=display:flex><span>set(<span style=color:#e6db74>CMAKE_C_COMPILER</span> <span style=color:#e6db74>gcc</span>)<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span>set(<span style=color:#e6db74>CMAKE_CXX_COMPILER</span> <span style=color:#e6db74>g++</span>)</span></span></code></pre></div><p>然後執行 CMake 時，它就會使用 <strong>GCC/G++ 來編譯程式碼</strong>。</p><hr><h3 id=何時使用-cmake><strong>何時使用 CMake？</strong></h3><table><thead><tr><th><strong>場景</strong></th><th><strong>適合工具</strong></th></tr></thead><tbody><tr><td>編譯單個 C/C++ 檔案</td><td><code>gcc</code> / <code>g++</code></td></tr><tr><td>小型專案（幾個檔案）</td><td><code>make</code></td></tr><tr><td><strong>大型專案（多個目錄、函式庫、跨平台）</strong></td><td><code>CMake</code></td></tr></tbody></table><hr><h3 id=g-vs-gcc-的主要區別><strong>g++ vs. gcc 的主要區別</strong></h3><table><thead><tr><th><strong>比較項目</strong></th><th><strong>gcc</strong></th><th><strong>g++</strong></th></tr></thead><tbody><tr><td><strong>主要用途</strong></td><td>編譯 C 程式</td><td>編譯 C++ 程式</td></tr><tr><td><strong>編譯 C++ 時是否自動連結標準函式庫</strong></td><td>❌ 否，需要手動加 <code>-lstdc++</code></td><td>✅ 是，會自動連結 <code>libstdc++</code></td></tr><tr><td><strong>檔案預設行為</strong></td><td>預設識別 <code>.c</code> 為 C 語言</td><td>預設識別 <code>.cpp</code> 為 C++ 語言</td></tr><tr><td><strong>C++ 語法支援</strong></td><td>部分支援，但預設不啟用 C++ 標準</td><td>完整支援 C++</td></tr></tbody></table><hr><h3 id=1><strong>1. <code>gcc</code> 編譯 C 程式</strong></h3><p>如果你用 <code>gcc</code> 編譯 C 程式：</p><div class="highlight wrap-code" dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>gcc main.c -o main</span></span></code></pre></div><p>它會使用 C 語言的編譯規則。</p><hr><h3 id=2><strong>2. <code>gcc</code> 編譯 C++ 程式（需要手動指定標準庫）</strong></h3><p>如果你用 <code>gcc</code> 編譯 C++ 程式：</p><div class="highlight wrap-code" dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>gcc main.cpp -o main</span></span></code></pre></div><p>這會產生錯誤，因為 <code>gcc</code> <strong>不會自動連結 C++ 標準函式庫</strong>。你必須手動加上 <code>-lstdc++</code>：</p><div class="highlight wrap-code" dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>gcc main.cpp -lstdc++ -o main</span></span></code></pre></div><hr><h3 id=3><strong>3. <code>g++</code> 編譯 C++ 程式（推薦方式）</strong></h3><p>如果你用 <code>g++</code> 編譯 C++ 程式：</p><div class="highlight wrap-code" dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>g++ main.cpp -o main</span></span></code></pre></div><p>它<strong>自動連結 C++ 標準函式庫</strong>，不用額外加 <code>-lstdc++</code>，是<strong>推薦的方式</strong>。</p><hr><h3 id=4><strong>4. <code>gcc</code> 和 <code>g++</code> 在多檔案專案的行為</strong></h3><h4 id=混合-c-和-c-的專案><strong>混合 C 和 C++ 的專案</strong></h4><p>假設我們有兩個檔案：</p><ul><li><code>main.cpp</code>（C++ 代碼）</li><li><code>utils.c</code>（C 代碼）</li></ul><p>用 <code>gcc</code> 來編譯（需要手動連結 C++ 標準庫）：</p><div class="highlight wrap-code" dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>gcc main.cpp utils.c -lstdc++ -o main</span></span></code></pre></div><p>用 <code>g++</code> 來編譯：</p><div class="highlight wrap-code" dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>g++ main.cpp utils.c -o main</span></span></code></pre></div><p><strong><code>g++</code> 會自動連結 <code>libstdc++</code>，所以更方便。</strong></p><hr><h3 id=結論該用哪個><strong>結論：該用哪個？</strong></h3><table><thead><tr><th><strong>情境</strong></th><th><strong>建議工具</strong></th></tr></thead><tbody><tr><td><strong>純 C 程式</strong></td><td><code>gcc</code></td></tr><tr><td><strong>純 C++ 程式</strong></td><td><code>g++</code></td></tr><tr><td><strong>C 和 C++ 混合專案</strong></td><td><code>g++</code>（因為它會自動連結 C++ 標準庫）</td></tr></tbody></table><p>如果你的專案主要是 C++，<strong>優先使用 <code>g++</code></strong>，因為它會處理 C++ 標準函式庫連結。如果是 C，則用 <code>gcc</code>。</p><footer class=footline></footer></article></div></main></div><aside id=R-sidebar class=default-animation><div id=R-header-topbar class=default-animation></div><div id=R-header-wrapper class=default-animation><div id=R-header class=default-animation><a id=R-logo class=R-default href=/index.html><div class=logo-title>SBK Hugo Site</div></a></div><search><form action=/search/index.html method=get><div class="searchbox default-animation"><button class=search-detail type=submit title="Search (CTRL+ALT+f)"><i class="fas fa-search"></i></button>
<label class=a11y-only for=R-search-by>Search</label>
<input data-search-input id=R-search-by name=search-by class=search-by type=search placeholder=Search...>
<button class=search-clear type=button data-search-clear title="Clear search"><i class="fas fa-times" title="Clear search"></i></button></div></form></search></div><div id=R-homelinks class="default-animation homelinks"><div class="R-menu-divider default-animation"><hr class=padding></div><div class="R-sidebarmenu R-shortcutmenu-homelinks"><ul class="space collapsible-menu"><li data-nav-id=/index.html><a class=padding href=/index.html><i class="fa-fw fas fa-home"></i> Home</a></li></ul></div><div class="R-menu-divider default-animation"><hr class=padding></div><div class="R-sidebarmenu R-shortcutmenu-headercontrols"><ul></ul></div><div class="R-menu-divider default-animation"><hr class=padding></div></div><div id=R-content-wrapper class=highlightable><div class="R-sidebarmenu R-shortcutmenu-main"><ul class="enlarge morespace collapsible-menu"><li data-nav-id=/books-notes/index.html><a class=padding href=/books-notes/index.html>Books Notes</a><ul id=R-subsections-0771445a148f63eb6cc1a9b7ad45a36a class=collapsible-menu></ul></li><li data-nav-id=/data-structure/index.html><a class=padding href=/data-structure/index.html>Data Structures</a><ul id=R-subsections-58892abc7cea06bf1839098c82b3eb4d class=collapsible-menu></ul></li><li data-nav-id=/job/index.html><a class=padding href=/job/index.html>Jobs</a><ul id=R-subsections-0fce2c1f4d6d23f49b605855a82f55aa class=collapsible-menu></ul></li><li data-nav-id=/knowledge/index.html><a class=padding href=/knowledge/index.html>Knowledges</a><ul id=R-subsections-0bdb754d722e03f187f2117c1ef8015d class=collapsible-menu></ul></li><li data-nav-id=/leetcode/index.html><a class=padding href=/leetcode/index.html>LeetCodes</a><ul id=R-subsections-76e85062179d09303530c47eb73fc667 class=collapsible-menu></ul></li><li data-nav-id=/problem-solutions/index.html><a class=padding href=/problem-solutions/index.html>Problem Solutions</a><ul id=R-subsections-4f9e0f3095337026c1723515d5409f89 class=collapsible-menu></ul></li><li data-nav-id=/security/index.html><a class=padding href=/security/index.html>Securities</a><ul id=R-subsections-66815ecaaecfc1c209e5637d03b258b2 class=collapsible-menu></ul></li><li data-nav-id=/side-project/index.html><a class=padding href=/side-project/index.html>Side Projects</a><ul id=R-subsections-3295de6e89859c4cf23a4292e734c881 class=collapsible-menu></ul></li><li data-nav-id=/survey-papers/index.html><a class=padding href=/survey-papers/index.html>Survey Papers</a><ul id=R-subsections-baa5a308e222e800d6e93248dad73a11 class=collapsible-menu></ul></li><li class=parent data-nav-id=/terminology/index.html><a class=padding href=/terminology/index.html>Terminologies</a><ul id=R-subsections-a19bf87a9a9aaf0a4146b803a35492f8 class=collapsible-menu><li data-nav-id=/terminology/android-related/index.html><a class=padding href=/terminology/android-related/index.html>Android Related</a></li><li data-nav-id=/terminology/linux-related/index.html><a class=padding href=/terminology/linux-related/index.html>Linux Related</a></li><li data-nav-id=/terminology/math-related/index.html><a class=padding href=/terminology/math-related/index.html>Math Related</a></li><li data-nav-id=/terminology/network-related/index.html><a class=padding href=/terminology/network-related/index.html>Network Related</a></li><li data-nav-id=/terminology/node-related/index.html><a class=padding href=/terminology/node-related/index.html>Node Related</a></li><li class=active data-nav-id=/terminology/programming-related/index.html><a class=padding href=/terminology/programming-related/index.html>Programming Related</a></li><li data-nav-id=/terminology/reinforcement-learning/index.html><a class=padding href=/terminology/reinforcement-learning/index.html>Reinforcement Learning</a></li><li data-nav-id=/terminology/what-is-devops-mlops-ci_cd_/index.html><a class=padding href=/terminology/what-is-devops-mlops-ci_cd_/index.html>What is DevOps, MLOps, CI/CD?</a></li><li data-nav-id=/terminology/what-is-ids-ips-edr-mdr-nsm-siem_/index.html><a class=padding href=/terminology/what-is-ids-ips-edr-mdr-nsm-siem_/index.html>What is IDS, IPS, EDR, MDR, NSM, SIEM?</a></li></ul></li><li data-nav-id=/toc/index.html><a class=padding href=/toc/index.html>TOCs</a><ul id=R-subsections-451d3779340ac1afa8683c0232808cbf class=collapsible-menu></ul></li><li data-nav-id=/tools/index.html><a class=padding href=/tools/index.html>Tools</a><ul id=R-subsections-bf1399820dde3dd110e03ace4147ff86 class=collapsible-menu></ul></li></ul></div><div class="R-sidebarmenu R-shortcutmenu-shortcuts"><ul class="space collapsible-menu"></ul></div><div id=R-footer-margin></div><div class="R-menu-divider default-animation"><hr class=padding></div><div class="R-sidebarmenu R-shortcutmenu-footercontrols"><ul></ul></div><div id=R-footer><p>Built with <a href=https://github.com/McShelby/hugo-theme-relearn title=love><i class="fas fa-heart"></i></a> by <a href=https://gohugo.io/>Hugo</a></p></div></div></aside><script src=/js/clipboard/clipboard.min.js?1743619851 defer></script><script src=/js/perfect-scrollbar/perfect-scrollbar.min.js?1743619851 defer></script><script src=/js/theme.min.js?1743619851 defer></script></body></html>