<!doctype html><html lang=en-us dir=ltr><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="
  How to Securely Collaborate on Data: Decentralized Threshold HE and Secure Key Update - Notes
  #


  tags: Meeting Paper NTU
  #

:::info
Kim, E., Jeong, J., Yoon, H., Kim, Y., Cho, J., & Cheon, J. H. (2020). How to securely collaborate on data: Decentralized threshold he and secure key update. IEEE Access, 8, 191319-191329.
:::
[TOC]

  Background
  #


  Threshold Homomorphic Encryption - 閾值同態加密在隱私計算中的應用
  #

:::spoiler


單密鑰同態加密
只有一個私鑰，且不同公鑰加密的密文無法相互計算。
閾值同態加密（多密鑰加密）
支持多個私鑰，不同公鑰加密的密文可以互相計算。


  問題
  #


多方聯合計算最安全的途徑是各自生成、保存公私鑰,但由於算法限制,不同公鑰加密的信息無法進行相互計算,導致隱私計算無法進行
假設多方使用一套公私鑰,雖然計算可以順利進行,但系統安全性會大大下降,系統中只要有一方被成功攻擊,私鑰就會泄露。
假設多方使用一套公私鑰,則無法決定由哪個參與方生成公私鑰


  Solution - Threshold Homomorphic Encryption
  #

由於單密鑰同態加密在實際應用中存在諸多關於密鑰使用、管理的問題,閾值同態加密(多密鑰同態加密)應運而生。簡單來說,閾值同態加密算法中存在多個私鑰、一個(或多個公鑰,使用該公鑰系統加密的密文之間可以相互計算,並且只有當參與解密的私鑰數量達到一定閾值時,才能成功解密密文,所以這種多密鑰同態加密算法又被稱為閾值同態加密"><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#343a40"><meta name=color-scheme content="light dark"><meta property="og:url" content="https://bernie6401.github.io/survey-papers/crypto/how-to-securely-collaborate-on-data_-decentralized-threshold-he-and-secure-key-update---notes/"><meta property="og:site_name" content="SBK Hugo Site"><meta property="og:title" content="How to Securely Collaborate on Data: Decentralized Threshold HE and Secure Key Update - Notes"><meta property="og:description" content="How to Securely Collaborate on Data: Decentralized Threshold HE and Secure Key Update - Notes # tags: Meeting Paper NTU # :::info Kim, E., Jeong, J., Yoon, H., Kim, Y., Cho, J., & Cheon, J. H. (2020). How to securely collaborate on data: Decentralized threshold he and secure key update. IEEE Access, 8, 191319-191329. ::: [TOC]
Background # Threshold Homomorphic Encryption - 閾值同態加密在隱私計算中的應用 # :::spoiler
單密鑰同態加密 只有一個私鑰，且不同公鑰加密的密文無法相互計算。 閾值同態加密（多密鑰加密） 支持多個私鑰，不同公鑰加密的密文可以互相計算。 問題 # 多方聯合計算最安全的途徑是各自生成、保存公私鑰,但由於算法限制,不同公鑰加密的信息無法進行相互計算,導致隱私計算無法進行 假設多方使用一套公私鑰,雖然計算可以順利進行,但系統安全性會大大下降,系統中只要有一方被成功攻擊,私鑰就會泄露。 假設多方使用一套公私鑰,則無法決定由哪個參與方生成公私鑰 Solution - Threshold Homomorphic Encryption # 由於單密鑰同態加密在實際應用中存在諸多關於密鑰使用、管理的問題,閾值同態加密(多密鑰同態加密)應運而生。簡單來說,閾值同態加密算法中存在多個私鑰、一個(或多個公鑰,使用該公鑰系統加密的密文之間可以相互計算,並且只有當參與解密的私鑰數量達到一定閾值時,才能成功解密密文,所以這種多密鑰同態加密算法又被稱為閾值同態加密"><meta property="og:locale" content="en_us"><meta property="og:type" content="article"><meta property="article:section" content="survey-papers"><meta property="article:tag" content="Meeting Paper"><meta property="article:tag" content="NTU"><title>How to Securely Collaborate on Data: Decentralized Threshold HE and Secure Key Update - Notes | SBK Hugo Site</title>
<link rel=icon href=/favicon.png><link rel=manifest href=/manifest.json><link rel=canonical href=https://bernie6401.github.io/survey-papers/crypto/how-to-securely-collaborate-on-data_-decentralized-threshold-he-and-secure-key-update---notes/><link rel=stylesheet href=/book.min.6c8b9d2a1fc95075ed7da46ca81060b39add8fff6741ac51259f768929281e2c.css integrity="sha256-bIudKh/JUHXtfaRsqBBgs5rdj/9nQaxRJZ92iSkoHiw=" crossorigin=anonymous><script defer src=/fuse.min.js></script><script defer src=/en.search.min.acdc41c8d39e6c69d70d8a23779875e0a3733fefead3e428d5344966bb12f562.js integrity="sha256-rNxByNOebGnXDYojd5h14KNzP+/q0+Qo1TRJZrsS9WI=" crossorigin=anonymous></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/><span>SBK Hugo Site</span></a></h2><div class="book-search hidden"><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><script>document.querySelector(".book-search").classList.remove("hidden")</script></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu></label><h3>How to Securely Collaborate on Data: Decentralized Threshold HE and Secure Key Update - Notes</h3><label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><ul><li></li></ul></li><li><a href=#background>Background</a><ul><li><a href=#threshold-homomorphic-encryption---閾值同態加密在隱私計算中的應用><a href=https://www.cnblogs.com/pam-sh/p/16446840.html>Threshold Homomorphic Encryption - 閾值同態加密在隱私計算中的應用</a></a></li><li><a href=#learning-with-errors-lwe><a href=https://zhuanlan.zhihu.com/p/621070457>Learning with Errors (LWE)</a></a></li><li><a href=#多密鑰同態加密><a href=https://blog.csdn.net/weixin_43476788/article/details/105388612>多密鑰同態加密</a></a></li><li><a href=#norm--infinity-norm><a href=https://ch-hsieh.blogspot.com/2010/04/norm.html>Norm</a> / <a href=https://juejin.cn/post/7022248588767920142>Infinity Norm</a></a></li></ul></li><li><a href=#in-this-paper>In This Paper</a><ul><li><a href=#threshold-he-vs-multi-key-he>Threshold HE VS. Multi-Key HE</a></li><li><a href=#proactive-secrete-sharing>Proactive Secrete Sharing</a></li><li><a href=#what-is-homomorphic-encryption-evaluation-key><a href=https://crypto.stackexchange.com/questions/73176/what-is-homomorphic-encryption-evaluation-key>What is Homomorphic encryption evaluation key</a></a></li><li><a href=#in-short>In short</a></li><li><a href=#in-detail>In detail</a></li></ul></li></ul></nav></aside></header><article class="markdown book-article"><h1 id=how-to-securely-collaborate-on-data-decentralized-threshold-he-and-secure-key-update---notes>How to Securely Collaborate on Data: Decentralized Threshold HE and Secure Key Update - Notes
<a class=anchor href=#how-to-securely-collaborate-on-data-decentralized-threshold-he-and-secure-key-update---notes>#</a></h1><h6 id=tags-meeting-paper-ntu>tags: <code>Meeting Paper</code> <code>NTU</code>
<a class=anchor href=#tags-meeting-paper-ntu>#</a></h6><p>:::info
Kim, E., Jeong, J., Yoon, H., Kim, Y., Cho, J., & Cheon, J. H. (2020). How to securely collaborate on data: Decentralized threshold he and secure key update. IEEE Access, 8, 191319-191329.
:::
[TOC]</p><h2 id=background>Background
<a class=anchor href=#background>#</a></h2><h3 id=threshold-homomorphic-encryption---閾值同態加密在隱私計算中的應用><a href=https://www.cnblogs.com/pam-sh/p/16446840.html>Threshold Homomorphic Encryption - 閾值同態加密在隱私計算中的應用</a>
<a class=anchor href=#threshold-homomorphic-encryption---%e9%96%be%e5%80%bc%e5%90%8c%e6%85%8b%e5%8a%a0%e5%af%86%e5%9c%a8%e9%9a%b1%e7%a7%81%e8%a8%88%e7%ae%97%e4%b8%ad%e7%9a%84%e6%87%89%e7%94%a8>#</a></h3><p>:::spoiler</p><blockquote><ol><li>單密鑰同態加密
只有一個私鑰，且不同公鑰加密的密文無法相互計算。</li><li>閾值同態加密（多密鑰加密）
支持多個私鑰，不同公鑰加密的密文可以互相計算。</li></ol><h4 id=問題>問題
<a class=anchor href=#%e5%95%8f%e9%a1%8c>#</a></h4><ol><li>多方聯合計算最安全的途徑是各自生成、保存公私鑰,但由於算法限制,不同公鑰加密的信息無法進行相互計算,導致隱私計算無法進行</li><li>假設多方使用一套公私鑰,雖然計算可以順利進行,但系統安全性會大大下降,系統中只要有一方被成功攻擊,私鑰就會泄露。</li><li>假設多方使用一套公私鑰,則無法決定由哪個參與方生成公私鑰</li></ol><h4 id=solution---threshold-homomorphic-encryption>Solution - Threshold Homomorphic Encryption
<a class=anchor href=#solution---threshold-homomorphic-encryption>#</a></h4><p>由於單密鑰同態加密在實際應用中存在諸多關於密鑰使用、管理的問題,閾值同態加密(多密鑰同態加密)應運而生。簡單來說,閾值同態加密算法中存在多個私鑰、一個(或多個公鑰,使用該公鑰系統加密的密文之間可以相互計算,並且只有當參與解密的私鑰數量達到一定閾值時,才能成功解密密文,所以這種多密鑰同態加密算法又被稱為閾值同態加密</p><h4 id=definition>Definition
<a class=anchor href=#definition>#</a></h4><p>閾值同態加密算法同樣可以概括為以下4個函數。(,,)</p><ul><li>$(pk, sk, ek) \leftarrow Keygen(Params)$: 密鑰生成函數,其中$pk$是公鑰、$sk$是私鑰、$ek$是用於計算的密鑰</li><li>$c \leftarrow Enc(pk, m)$: 加密函數,使用公鑰$pk$加密明文$m$信息得到密文$c$</li><li>$m \leftarrow Dec(c, sk_1, sk_2,\cdot \cdot \cdot ,sk_k)$: 解密函數,最少$k$個私鑰參與，才能解密得到明文</li><li>$c \leftarrow Eval((c_1,pk_1,ek_1), (c_2, pk_2, ek_2), \cdot \cdot \cdot , (c_N, pk_N, ek_N))$: 密文計算函數，在多個密文上進行計算、獲得最終結果，計算過程需要密鑰$ek$參與
:::</li></ul></blockquote><h3 id=learning-with-errors-lwe><a href=https://zhuanlan.zhihu.com/p/621070457>Learning with Errors (LWE)</a>
<a class=anchor href=#learning-with-errors-lwe>#</a></h3><h3 id=多密鑰同態加密><a href=https://blog.csdn.net/weixin_43476788/article/details/105388612>多密鑰同態加密</a>
<a class=anchor href=#%e5%a4%9a%e5%af%86%e9%91%b0%e5%90%8c%e6%85%8b%e5%8a%a0%e5%af%86>#</a></h3><p>:::spoiler</p><blockquote><p>多密鑰同態加密的概念，以及基於NTRU密碼系統的具體實現，最早由L’opez-Alt等人描述。該方案的一個缺點是，在密鑰生成時必須知道參與方數量的上限，因為參數隨著參與方數量的增加而增加。(類似的實現在LWE下是可能的，但它只支持固定數量的參與方)
:::</p></blockquote><h3 id=norm--infinity-norm><a href=https://ch-hsieh.blogspot.com/2010/04/norm.html>Norm</a> / <a href=https://juejin.cn/post/7022248588767920142>Infinity Norm</a>
<a class=anchor href=#norm--infinity-norm>#</a></h3><p>:::spoiler</p><blockquote><p>Norm：一般翻譯成範數
(在英語中 norm 有規範的意思，比如我們說normalization就是把某種東西/物品/事件 做 正規化，也就是加上規範使其正常化)，不過個人認為其實翻譯成 範數 也是看不懂的&mldr;這邊建議把 Norm 想成長度就好 (事實上norm是長度的抽象推廣)，</p><p>也許讀者會認為好端端的長度不用，為何又要發明一個 norm 來自討苦吃?? 既抽象又艱澀。</p><p>事實上想法是這樣的：
比如說現在想要比較兩個數字 $3 , 5$ 之間的大小，則我們可以馬上知道 $3&lt;5$；同樣的，如果再考慮小數與無理數如 $1.8753$ 與 $π$，我們仍然可以比較大小 $1.8753&lt;π=3.1415&mldr;$ 故可以發現我們有辦法對 &ldquo;純量&rdquo; 做明確的比大小，WHY? 因為前述例子中 $3, 5, 1.8753$ or $π$ 其各自的大小有辦法被 &ldquo;measure &ldquo;!</p><p>但是如果是現在考慮的是一組數字 我們如何去measure 其大小呢?? 比如說
$$x:=[1, -2, 0.1, 0 ]^T$$
上式的大小該是多少? 是 $1? −2? 0.1???$
再者如果更過分一點，我們考慮一個矩陣
$$A = \left[ {\begin{array}{*{20}{c}}
1&amp;2\
3&amp;4
\end{array}} \right]$$
也正是如此，可以發現我們確實需要新的 &ldquo;長度&rdquo; 的定義來幫助我們如何去 measure 矩陣/向量/甚至是函數的大小。</p><p>故此，我們首先定義甚麼是Norm，(也就是把 &ldquo;長度&rdquo; or &ldquo;大小&rdquo; 的本質抽離出來)</p></blockquote><hr><blockquote><p>L-infinity norm給出了一個向量的每個元素中最大的那個元素幅值。
例如，對於向量 $X= [-6, 4, 2]$，其 L-infinity norm就是$6$。
在L-infinity norm中，只有最大的元素有才具有影響。因此，例如，如果你的向量代表建造一座建築物的成本，通過最小化L-infinity norm，我們就可以做到減小建築物最昂貴的那部分成本。
:::</p></blockquote><h2 id=in-this-paper>In This Paper
<a class=anchor href=#in-this-paper>#</a></h2><h3 id=threshold-he-vs-multi-key-he>Threshold HE VS. Multi-Key HE
<a class=anchor href=#threshold-he-vs-multi-key-he>#</a></h3><p>兩者的差別依照原文的解釋是整合之前產生共同的公鑰的就是Threshold HE，而在整合之後產生公鑰的就是Multi-Key HE</p><h3 id=proactive-secrete-sharing>Proactive Secrete Sharing
<a class=anchor href=#proactive-secrete-sharing>#</a></h3><p>:::spoiler</p><blockquote><p>主動式秘密共享方案是指對移動敵手安全的秘密共享方案，這些敵手可以在一段時間內監視秘密共享者，但對一個時間單位內可訪問的共享者數量有限制。為了保護共享的秘密不被對手發現，應定期更新共享的秘密，使共享的秘密保持不變，以前的共享不再有用
:::</p></blockquote><h3 id=what-is-homomorphic-encryption-evaluation-key><a href=https://crypto.stackexchange.com/questions/73176/what-is-homomorphic-encryption-evaluation-key>What is Homomorphic encryption evaluation key</a>
<a class=anchor href=#what-is-homomorphic-encryption-evaluation-key>#</a></h3><p>:::spoiler</p><blockquote><h3 id=in-short>In short
<a class=anchor href=#in-short>#</a></h3><p>Public key is used to encrypt, private key is used to decrypt, and evaluation key is used to perform homomorphic operations (usually, homomorphic product or, the somehow equivalent operation, a logic AND gate).</p><h3 id=in-detail>In detail
<a class=anchor href=#in-detail>#</a></h3><p>Public and private keys in homomorphic encryption (HE) schemes are just the same as in other types of schemes.</p><p>The evaluation key ($evk$) is also public, it is typically generated using the private key, and it is used to control the noise growth or the ciphertext expansion during homomorphic evaluation.</p><p>Some schemes have a &ldquo;Key-switching&rdquo; key instead of the evaluation key, but they are more or less the same. For instance, in the description of FV and YASHE, you can see that to perform a homomorphic product, one first multiplies the ciphertexts, $\tilde{c}<em>{mult} := c_1 \otimes c_2$, then uses this &ldquo;extra public key&rdquo; to adjust $\tilde{c}</em>{mult}$, that is, to get a ciphertext cmult</p><p>with the correct dimension and that can be decrypted using the original secret key.</p><p>So, in general, this is how you use $evk$: you perform a homomorphic operation that introduces a lot of noise or that generates a ciphertext in higher dimension, then you perform an extra operation using $evk$ to &ldquo;correct&rdquo; that ciphertext.
:::</p></blockquote></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><ul><li></li></ul></li><li><a href=#background>Background</a><ul><li><a href=#threshold-homomorphic-encryption---閾值同態加密在隱私計算中的應用><a href=https://www.cnblogs.com/pam-sh/p/16446840.html>Threshold Homomorphic Encryption - 閾值同態加密在隱私計算中的應用</a></a></li><li><a href=#learning-with-errors-lwe><a href=https://zhuanlan.zhihu.com/p/621070457>Learning with Errors (LWE)</a></a></li><li><a href=#多密鑰同態加密><a href=https://blog.csdn.net/weixin_43476788/article/details/105388612>多密鑰同態加密</a></a></li><li><a href=#norm--infinity-norm><a href=https://ch-hsieh.blogspot.com/2010/04/norm.html>Norm</a> / <a href=https://juejin.cn/post/7022248588767920142>Infinity Norm</a></a></li></ul></li><li><a href=#in-this-paper>In This Paper</a><ul><li><a href=#threshold-he-vs-multi-key-he>Threshold HE VS. Multi-Key HE</a></li><li><a href=#proactive-secrete-sharing>Proactive Secrete Sharing</a></li><li><a href=#what-is-homomorphic-encryption-evaluation-key><a href=https://crypto.stackexchange.com/questions/73176/what-is-homomorphic-encryption-evaluation-key>What is Homomorphic encryption evaluation key</a></a></li><li><a href=#in-short>In short</a></li><li><a href=#in-detail>In detail</a></li></ul></li></ul></nav></div></aside></main></body></html>