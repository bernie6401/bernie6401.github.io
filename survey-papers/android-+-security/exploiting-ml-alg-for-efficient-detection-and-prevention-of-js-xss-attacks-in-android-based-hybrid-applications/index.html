<!doctype html><html lang=en-us dir=ltr><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="
  Exploiting ML algorithms for Efficient Detection and Prevention of JavaScript-XSS Attacks in Android Based Hybrid Applications
  #

:::info
Khalid, U., Abdullah, M., & Inayat, K. (2020). Exploiting ML algorithms for Efficient Detection and Prevention of JavaScript-XSS Attacks in Android Based Hybrid Applications. arXiv preprint arXiv:2006.07350.
:::
這一篇論文對於我的研究只有一點點用，大概補足了一些我對Android的XSS漏洞的認識。主要是在利用一些feature，訓練出能夠檢測有無XSS攻擊的模型

  Introduction
  #

首先，很多的手機App中都會使用WebView這個Component，也就是能夠直接嵌入一個mini browser在App中而不需要另外開啟外部的Browser才能瀏覽網頁，所以JS語言就能夠和Java語言互動，問題在於當從 JavaScript 呼叫 Java 時，攻擊者會將惡意 JavaScript 程式碼儲存在網頁中，當網頁在應用程式中開啟時，然後在 WebView 中註冊一個物件。 首先，攻擊者透過 JavaScript 存取該對象，並透過該對象存取該應用程式的本機方法，攻擊者可以透過觸發本機方法內的重要內建函數輕鬆取得不同的智慧型手機資源。

  Contribution
  #


自行創建一個Dataset，並且從500個不同的Apps中extract出7個不同的feature
訓練7種不同的ML 模型: Evolutionary-Support Vector Machine (E-SVM), Neural Network, Naive Bayes, Support Vector Machine(SVM), Bagging, Random Forest and J48
根據實驗結果給出F1-Score和執行時間，結果顯示Random Forest是最好的模型


  Background
  #


WebView
這個component的存在理由如上所述，其中會用到幾的API:
setJavaScriptEnabled API
addJavascriptInterface API
loadUrl API
第一個是enable可以使用JS，第二個是註冊Java物件，第三個就是實際把網頁load進來
Sandbox

如上圖，一般來說webview的瀏覽是會經過sandbox，確保可以控制web browser的access，讓他和本地資源不會共享；網頁和網頁之間要隔離，而網頁和主系統之間也會隔離
Bypassing sandbox mechanism

從上圖可以看出，儘管WebView中存在沙箱安全機制來保護行動裝置本地資源免受JavaScript攻擊，但WebView本身借助WebView提供的API繞過了沙箱機制。 這創建了一條路徑，JavaScript 可以輕鬆地與本機 Java 通訊。 並且攻擊者可以觸發Java的不同類別方法發動XSS攻擊，透過原生Java程式碼存取行動裝置的重要功能包括本機資源。
哪些類型的易受攻擊的 API 可以透過 Java 物件觸發？
作者有整理出來一個表如下:



  Proposed Method
  #

現在的重點是要如何分辨一個App他啟動了webview之後，是否會造成XSS攻擊，作者提出了由四個Level組成的偵測框架以及三個Layers的預防框架"><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#343a40"><meta name=color-scheme content="light dark"><meta property="og:url" content="https://bernie6401.github.io/survey-papers/android-+-security/exploiting-ml-alg-for-efficient-detection-and-prevention-of-js-xss-attacks-in-android-based-hybrid-applications/"><meta property="og:site_name" content="SBK Hugo Site"><meta property="og:title" content="Exploiting ML ALG for Efficient Detection and Prevention of JS-XSS Attacks in Android Based Hybrid Applications"><meta property="og:description" content="Exploiting ML algorithms for Efficient Detection and Prevention of JavaScript-XSS Attacks in Android Based Hybrid Applications # :::info Khalid, U., Abdullah, M., & Inayat, K. (2020). Exploiting ML algorithms for Efficient Detection and Prevention of JavaScript-XSS Attacks in Android Based Hybrid Applications. arXiv preprint arXiv:2006.07350. ::: 這一篇論文對於我的研究只有一點點用，大概補足了一些我對Android的XSS漏洞的認識。主要是在利用一些feature，訓練出能夠檢測有無XSS攻擊的模型
Introduction # 首先，很多的手機App中都會使用WebView這個Component，也就是能夠直接嵌入一個mini browser在App中而不需要另外開啟外部的Browser才能瀏覽網頁，所以JS語言就能夠和Java語言互動，問題在於當從 JavaScript 呼叫 Java 時，攻擊者會將惡意 JavaScript 程式碼儲存在網頁中，當網頁在應用程式中開啟時，然後在 WebView 中註冊一個物件。 首先，攻擊者透過 JavaScript 存取該對象，並透過該對象存取該應用程式的本機方法，攻擊者可以透過觸發本機方法內的重要內建函數輕鬆取得不同的智慧型手機資源。
Contribution # 自行創建一個Dataset，並且從500個不同的Apps中extract出7個不同的feature 訓練7種不同的ML 模型: Evolutionary-Support Vector Machine (E-SVM), Neural Network, Naive Bayes, Support Vector Machine(SVM), Bagging, Random Forest and J48 根據實驗結果給出F1-Score和執行時間，結果顯示Random Forest是最好的模型 Background # WebView 這個component的存在理由如上所述，其中會用到幾的API: setJavaScriptEnabled API addJavascriptInterface API loadUrl API 第一個是enable可以使用JS，第二個是註冊Java物件，第三個就是實際把網頁load進來 Sandbox 如上圖，一般來說webview的瀏覽是會經過sandbox，確保可以控制web browser的access，讓他和本地資源不會共享；網頁和網頁之間要隔離，而網頁和主系統之間也會隔離 Bypassing sandbox mechanism 從上圖可以看出，儘管WebView中存在沙箱安全機制來保護行動裝置本地資源免受JavaScript攻擊，但WebView本身借助WebView提供的API繞過了沙箱機制。 這創建了一條路徑，JavaScript 可以輕鬆地與本機 Java 通訊。 並且攻擊者可以觸發Java的不同類別方法發動XSS攻擊，透過原生Java程式碼存取行動裝置的重要功能包括本機資源。 哪些類型的易受攻擊的 API 可以透過 Java 物件觸發？ 作者有整理出來一個表如下: Proposed Method # 現在的重點是要如何分辨一個App他啟動了webview之後，是否會造成XSS攻擊，作者提出了由四個Level組成的偵測框架以及三個Layers的預防框架"><meta property="og:locale" content="en_us"><meta property="og:type" content="article"><meta property="article:section" content="survey-papers"><meta property="article:tag" content="Meeting Paper"><meta property="article:tag" content="NTU"><title>Exploiting ML ALG for Efficient Detection and Prevention of JS-XSS Attacks in Android Based Hybrid Applications | SBK Hugo Site</title>
<link rel=icon href=/favicon.png><link rel=manifest href=/manifest.json><link rel=canonical href=https://bernie6401.github.io/survey-papers/android-+-security/exploiting-ml-alg-for-efficient-detection-and-prevention-of-js-xss-attacks-in-android-based-hybrid-applications/><link rel=stylesheet href=/book.min.6c8b9d2a1fc95075ed7da46ca81060b39add8fff6741ac51259f768929281e2c.css integrity="sha256-bIudKh/JUHXtfaRsqBBgs5rdj/9nQaxRJZ92iSkoHiw=" crossorigin=anonymous><script defer src=/fuse.min.js></script><script defer src=/en.search.min.acdc41c8d39e6c69d70d8a23779875e0a3733fefead3e428d5344966bb12f562.js integrity="sha256-rNxByNOebGnXDYojd5h14KNzP+/q0+Qo1TRJZrsS9WI=" crossorigin=anonymous></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/><span>SBK Hugo Site</span></a></h2><div class="book-search hidden"><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><script>document.querySelector(".book-search").classList.remove("hidden")</script></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu></label><h3>Exploiting ML ALG for Efficient Detection and Prevention of JS-XSS Attacks in Android Based Hybrid Applications</h3><label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#introduction>Introduction</a></li><li><a href=#contribution>Contribution</a></li><li><a href=#background>Background</a></li><li><a href=#proposed-method>Proposed Method</a></li><li><a href=#experiment>Experiment</a><ul><li><a href=#tool>Tool</a></li><li><a href=#dataset>Dataset</a></li><li><a href=#result>Result</a></li></ul></li></ul></nav></aside></header><article class="markdown book-article"><h1 id=exploiting-ml-algorithms-for-efficient-detection-and-prevention-of-javascript-xss-attacks-in-android-based-hybrid-applications>Exploiting ML algorithms for Efficient Detection and Prevention of JavaScript-XSS Attacks in Android Based Hybrid Applications
<a class=anchor href=#exploiting-ml-algorithms-for-efficient-detection-and-prevention-of-javascript-xss-attacks-in-android-based-hybrid-applications>#</a></h1><p>:::info
Khalid, U., Abdullah, M., & Inayat, K. (2020). Exploiting ML algorithms for Efficient Detection and Prevention of JavaScript-XSS Attacks in Android Based Hybrid Applications. arXiv preprint arXiv:2006.07350.
:::
這一篇論文對於我的研究只有一點點用，大概補足了一些我對Android的XSS漏洞的認識。主要是在利用一些feature，訓練出能夠檢測有無XSS攻擊的模型</p><h2 id=introduction>Introduction
<a class=anchor href=#introduction>#</a></h2><p>首先，很多的手機App中都會使用WebView這個Component，也就是能夠直接嵌入一個mini browser在App中而不需要另外開啟外部的Browser才能瀏覽網頁，所以JS語言就能夠和Java語言互動，問題在於當從 JavaScript 呼叫 Java 時，攻擊者會將惡意 JavaScript 程式碼儲存在網頁中，當網頁在應用程式中開啟時，然後在 WebView 中註冊一個物件。 首先，攻擊者透過 JavaScript 存取該對象，並透過該對象存取該應用程式的本機方法，攻擊者可以透過觸發本機方法內的重要內建函數輕鬆取得不同的智慧型手機資源。</p><h2 id=contribution>Contribution
<a class=anchor href=#contribution>#</a></h2><ul><li>自行創建一個Dataset，並且從500個不同的Apps中extract出7個不同的feature</li><li>訓練7種不同的ML 模型: Evolutionary-Support Vector Machine (E-SVM), Neural Network, Naive Bayes, Support Vector Machine(SVM), Bagging, Random Forest and J48</li><li>根據實驗結果給出F1-Score和執行時間，結果顯示Random Forest是最好的模型</li></ul><h2 id=background>Background
<a class=anchor href=#background>#</a></h2><ul><li>WebView
這個component的存在理由如上所述，其中會用到幾的API:<pre tabindex=0><code>setJavaScriptEnabled API
addJavascriptInterface API
loadUrl API
</code></pre>第一個是enable可以使用JS，第二個是註冊Java物件，第三個就是實際把網頁load進來</li><li>Sandbox
<img src=https://hackmd.io/_uploads/r1C5aaRMC.png alt=圖片>
如上圖，一般來說webview的瀏覽是會經過sandbox，確保可以控制web browser的access，讓他和本地資源不會共享；網頁和網頁之間要隔離，而網頁和主系統之間也會隔離</li><li>Bypassing sandbox mechanism
<img src=https://hackmd.io/_uploads/BkBYapCGC.png alt=圖片>
從上圖可以看出，儘管WebView中存在沙箱安全機制來保護行動裝置本地資源免受JavaScript攻擊，但WebView本身借助WebView提供的API繞過了沙箱機制。 這創建了一條路徑，JavaScript 可以輕鬆地與本機 Java 通訊。 並且攻擊者可以觸發Java的不同類別方法發動XSS攻擊，透過原生Java程式碼存取行動裝置的重要功能包括本機資源。</li><li>哪些類型的易受攻擊的 API 可以透過 Java 物件觸發？
作者有整理出來一個表如下:
<img src=https://hackmd.io/_uploads/SJmIkA0zA.png alt=圖片></li></ul><h2 id=proposed-method>Proposed Method
<a class=anchor href=#proposed-method>#</a></h2><p>現在的重點是要如何分辨一個App他啟動了webview之後，是否會造成XSS攻擊，作者提出了由四個Level組成的偵測框架以及三個Layers的預防框架</p><ul><li>Detection Framework
<img src=https://hackmd.io/_uploads/Hy-Je0AzC.png alt=圖片><ul><li>Level 1: 蒐集資料與前處理</li><li>Level 2: 10-fold cross validation去訓練模型</li><li>Level 3: 結果評估以及預測有無攻擊</li><li>Level 4: 利用Selection Algorithm評估各個features的重要性是多少</li></ul></li><li>Prevention Framework
<img src=https://hackmd.io/_uploads/Bkx7WA0f0.png alt=圖片><ol><li>首先，當一個App在Webview中啟動了惡意網站，並且call了addJavaScriptInterface() API</li><li>在完成註冊之前，有關Java物件的資訊進入Threat Prevention Unit。</li><li>然後特徵提取器從Threat Prevention Unit提取Java物件的特徵並將特徵資訊提供給檢測單元。</li><li>偵測單元取得所有特徵，並使用 ML 演算法對這些特徵進行分類，如前所述。 之後，它將最終結果（是否攻擊[Yes / No]）發送給威脅預防單元，因此檢測單元透過這種方式攔截對addJavaScriptInterface() API的呼叫。</li><li>如果Threat Prevention Unit從檢測單元接收到“是”，則建議的方法呼叫警報應用程式：否則，它繼續進行步驟(9)，以自動允許，然後繼續進行步驟(10)以完成Jave物件註冊。</li><li>警報應用程式警告使用者有關威脅的訊息，其中顯示有關攻擊網頁名稱、物件名稱、物件呼叫的安全敏感 API 的資訊。</li><li>使用者回覆警報應用程式以決定是否停用Java物件。</li><li>警報應用程式將使用者的決定轉發給威脅預防單元。</li><li>Threat Prevention Unit根據使用者的決定進一步決定是否停用該物件。</li><li>如果Threat Prevention Unit的決定是“是”，則它允許物件註冊並物件取得 Java 類別的存取方法，從中可以存取不同的移動庫。</li><li>如果威脅防護單元做出「否」決定，則會停用 Java 物件並封鎖網站。</li></ol></li></ul><h2 id=experiment>Experiment
<a class=anchor href=#experiment>#</a></h2><h3 id=tool>Tool
<a class=anchor href=#tool>#</a></h3><p>RapidMiner Softwrare Platform</p><h3 id=dataset>Dataset
<a class=anchor href=#dataset>#</a></h3><p>作者自行提出一個Dataset叫做<code>APK_XSS_ATTACK</code>，為了收集基準數據，創建了演示受害者應用程式並對其發起了即時攻擊，然後在運行時記錄了這些即時攻擊。 作者取得了 17 個即時攻擊條目並記錄了 XSS 攻擊的模式，這樣我們產生了 444 個原始 XSS 攻擊以滿足標準資料集要求。 在此資料集中，攻擊比例為 50%。 作者收集了 20 個 APK 的 460 個樣本。而提取的features如下
<img src=https://hackmd.io/_uploads/S15ZSC0f0.png alt=圖片></p><h3 id=result>Result
<a class=anchor href=#result>#</a></h3><ul><li>在實驗中，從Selection Algorithm中的數據如下可以知道，API Name這個Feature是最重要的，其次是Permission或是Location
<img src=https://hackmd.io/_uploads/BkcrHARfA.png alt=圖片></li><li>從F-Score和Accuracy可以知道，最好的演算法是Random Forest；其次是E-SVM
<img src=https://hackmd.io/_uploads/r13hH0AGR.png alt=圖片>
但從花費時間來看，E-SVM花的時間是最多的
<img src=https://hackmd.io/_uploads/SJn1IARf0.png alt=圖片></li></ul></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#introduction>Introduction</a></li><li><a href=#contribution>Contribution</a></li><li><a href=#background>Background</a></li><li><a href=#proposed-method>Proposed Method</a></li><li><a href=#experiment>Experiment</a><ul><li><a href=#tool>Tool</a></li><li><a href=#dataset>Dataset</a></li><li><a href=#result>Result</a></li></ul></li></ul></nav></div></aside></main></body></html>