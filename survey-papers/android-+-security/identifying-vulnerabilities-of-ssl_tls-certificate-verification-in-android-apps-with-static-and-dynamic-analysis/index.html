<!doctype html><html lang=en-us dir=ltr itemscope itemtype=http://schema.org/Article data-r-output-format=html><head><meta charset=utf-8><meta name=viewport content="height=device-height,width=device-width,initial-scale=1,minimum-scale=1"><meta name=generator content="Hugo 0.145.0"><meta name=generator content="Relearn 7.6.0+b932d301d7838f3c1a50e318e216b55ce5cc9148"><meta name=description content="Identifying vulnerabilities of SSL_TLS certificate verification in Android apps with static and dynamic analysis :::info Wang, Y., Xu, G., Liu, X., Mao, W., Si, C., Pedrycz, W., & Wang, W. (2020). Identifying vulnerabilities of SSL/TLS certificate verification in Android apps with static and dynamic analysis. Journal of Systems and Software, 167, 110609. ::: 這一篇論文對我要做的東西非常類似，雖然本質上不一樣但有很多的觀點以及解決方式是可以參照的
Introduction 這篇文章探討了在Android應用程式中SSL/TLS憑證驗證的弱點，並提出了一種名為DCDroid的工具來偵測這些弱點。作者結合靜態和動態分析，分析了來自Google Play和360app的2213個應用程式，發現其中有20.65%可能存在弱點。透過DCDroid在兩部Android智慧手機上執行這些應用程式，最終確認了11.07%的應用程式對MITM和釣魚攻擊存在真正的弱點。
Background SSL/TLS and Android 一般來說，正確的驗證憑證的步驟為
在憑證鏈中的所有憑證有無過期 憑證或憑證鏈中的根憑證由客戶端的憑證授權單位（CA）簽署 證書中的網域名稱與所連接的伺服器的網域名稱相符 但是基於一些原因(例如: 使用self-signed certificate/伺服器的root憑證不在手機的CA list中/糾正某些第三方庫的不安全實作)導致開發者會自行實做一個憑證驗證的方法，而這時候就有可能會產生一些漏洞發生，例如: :::warning"><meta name=author content><meta name=twitter:card content="summary"><meta name=twitter:title content="Identifying vulnerabilities of SSL/TLS certificate verification in Android apps with static and dynamic analysis :: SBK Hugo Site"><meta name=twitter:description content="Identifying vulnerabilities of SSL_TLS certificate verification in Android apps with static and dynamic analysis :::info Wang, Y., Xu, G., Liu, X., Mao, W., Si, C., Pedrycz, W., & Wang, W. (2020). Identifying vulnerabilities of SSL/TLS certificate verification in Android apps with static and dynamic analysis. Journal of Systems and Software, 167, 110609. ::: 這一篇論文對我要做的東西非常類似，雖然本質上不一樣但有很多的觀點以及解決方式是可以參照的
Introduction 這篇文章探討了在Android應用程式中SSL/TLS憑證驗證的弱點，並提出了一種名為DCDroid的工具來偵測這些弱點。作者結合靜態和動態分析，分析了來自Google Play和360app的2213個應用程式，發現其中有20.65%可能存在弱點。透過DCDroid在兩部Android智慧手機上執行這些應用程式，最終確認了11.07%的應用程式對MITM和釣魚攻擊存在真正的弱點。
Background SSL/TLS and Android 一般來說，正確的驗證憑證的步驟為
在憑證鏈中的所有憑證有無過期 憑證或憑證鏈中的根憑證由客戶端的憑證授權單位（CA）簽署 證書中的網域名稱與所連接的伺服器的網域名稱相符 但是基於一些原因(例如: 使用self-signed certificate/伺服器的root憑證不在手機的CA list中/糾正某些第三方庫的不安全實作)導致開發者會自行實做一個憑證驗證的方法，而這時候就有可能會產生一些漏洞發生，例如: :::warning"><meta property="og:url" content="https://bernie6401.github.io/survey-papers/android-+-security/identifying-vulnerabilities-of-ssl_tls-certificate-verification-in-android-apps-with-static-and-dynamic-analysis/index.html"><meta property="og:site_name" content="SBK Hugo Site"><meta property="og:title" content="Identifying vulnerabilities of SSL/TLS certificate verification in Android apps with static and dynamic analysis :: SBK Hugo Site"><meta property="og:description" content="Identifying vulnerabilities of SSL_TLS certificate verification in Android apps with static and dynamic analysis :::info Wang, Y., Xu, G., Liu, X., Mao, W., Si, C., Pedrycz, W., & Wang, W. (2020). Identifying vulnerabilities of SSL/TLS certificate verification in Android apps with static and dynamic analysis. Journal of Systems and Software, 167, 110609. ::: 這一篇論文對我要做的東西非常類似，雖然本質上不一樣但有很多的觀點以及解決方式是可以參照的
Introduction 這篇文章探討了在Android應用程式中SSL/TLS憑證驗證的弱點，並提出了一種名為DCDroid的工具來偵測這些弱點。作者結合靜態和動態分析，分析了來自Google Play和360app的2213個應用程式，發現其中有20.65%可能存在弱點。透過DCDroid在兩部Android智慧手機上執行這些應用程式，最終確認了11.07%的應用程式對MITM和釣魚攻擊存在真正的弱點。
Background SSL/TLS and Android 一般來說，正確的驗證憑證的步驟為
在憑證鏈中的所有憑證有無過期 憑證或憑證鏈中的根憑證由客戶端的憑證授權單位（CA）簽署 證書中的網域名稱與所連接的伺服器的網域名稱相符 但是基於一些原因(例如: 使用self-signed certificate/伺服器的root憑證不在手機的CA list中/糾正某些第三方庫的不安全實作)導致開發者會自行實做一個憑證驗證的方法，而這時候就有可能會產生一些漏洞發生，例如: :::warning"><meta property="og:locale" content="en_us"><meta property="og:type" content="article"><meta property="article:section" content="Survey Papers"><meta property="article:tag" content="Meeting Paper"><meta property="article:tag" content="NTU"><meta itemprop=name content="Identifying vulnerabilities of SSL/TLS certificate verification in Android apps with static and dynamic analysis :: SBK Hugo Site"><meta itemprop=description content="Identifying vulnerabilities of SSL_TLS certificate verification in Android apps with static and dynamic analysis :::info Wang, Y., Xu, G., Liu, X., Mao, W., Si, C., Pedrycz, W., & Wang, W. (2020). Identifying vulnerabilities of SSL/TLS certificate verification in Android apps with static and dynamic analysis. Journal of Systems and Software, 167, 110609. ::: 這一篇論文對我要做的東西非常類似，雖然本質上不一樣但有很多的觀點以及解決方式是可以參照的
Introduction 這篇文章探討了在Android應用程式中SSL/TLS憑證驗證的弱點，並提出了一種名為DCDroid的工具來偵測這些弱點。作者結合靜態和動態分析，分析了來自Google Play和360app的2213個應用程式，發現其中有20.65%可能存在弱點。透過DCDroid在兩部Android智慧手機上執行這些應用程式，最終確認了11.07%的應用程式對MITM和釣魚攻擊存在真正的弱點。
Background SSL/TLS and Android 一般來說，正確的驗證憑證的步驟為
在憑證鏈中的所有憑證有無過期 憑證或憑證鏈中的根憑證由客戶端的憑證授權單位（CA）簽署 證書中的網域名稱與所連接的伺服器的網域名稱相符 但是基於一些原因(例如: 使用self-signed certificate/伺服器的root憑證不在手機的CA list中/糾正某些第三方庫的不安全實作)導致開發者會自行實做一個憑證驗證的方法，而這時候就有可能會產生一些漏洞發生，例如: :::warning"><meta itemprop=wordCount content="514"><meta itemprop=keywords content="Meeting Paper,NTU"><title>Identifying vulnerabilities of SSL/TLS certificate verification in Android apps with static and dynamic analysis :: SBK Hugo Site</title>
<link href=/fonts/fontawesome/css/fontawesome-all.min.css?1743619851 rel=stylesheet media=print onload='this.media="all",this.onload=null'><noscript><link href=/fonts/fontawesome/css/fontawesome-all.min.css?1743619851 rel=stylesheet></noscript><link href=/css/perfect-scrollbar/perfect-scrollbar.min.css?1743619851 rel=stylesheet><link href=/css/theme.min.css?1743619851 rel=stylesheet><link href=/css/format-html.min.css?1743619851 rel=stylesheet id=R-format-style><link href=/css/auto-complete/auto-complete.min.css?1743619851 rel=stylesheet><script src=/js/auto-complete/auto-complete.min.js?1743619851 defer></script><script src=/js/lunr/lunr.min.js?1743619851 defer></script><script src=/js/lunr/lunr.stemmer.support.min.js?1743619851 defer></script><script src=/js/lunr/lunr.multi.min.js?1743619851 defer></script><script src=/js/lunr/lunr.en.min.js?1743619851 defer></script><script src=/js/search.min.js?1743619851 defer></script><script>window.relearn=window.relearn||{},window.relearn.min=`.min`,window.relearn.path="/survey-papers/android-&#43;-security/identifying-vulnerabilities-of-ssl_tls-certificate-verification-in-android-apps-with-static-and-dynamic-analysis/index.html",window.relearn.relBasePath="../../..",window.relearn.relBaseUri="../../..",window.relearn.absBaseUri="https://bernie6401.github.io",window.relearn.contentLangs=["en"],window.relearn.index_js_url="/searchindex.en.js?1743619851",window.relearn.disableAnchorCopy=!1,window.relearn.disableAnchorScrolling=!1,window.relearn.disableInlineCopyToClipboard=!1,window.relearn.enableBlockCodeWrap=!0,window.relearn.getItem=(e,t)=>e.getItem(t),window.relearn.setItem=(e,t,n)=>e.setItem(t,n),window.relearn.removeItem=(e,t)=>e.removeItem(t),window.relearn.themevariants=["auto"],window.relearn.customvariantname="my-custom-variant",window.relearn.changeVariant=function(e){var t=document.documentElement.dataset.rThemeVariant;window.relearn.setItem(window.localStorage,window.relearn.absBaseUri+"/variant",e),document.documentElement.dataset.rThemeVariant=e,t!=e&&(document.dispatchEvent(new CustomEvent("themeVariantLoaded",{detail:{variant:e,oldVariant:t}})),window.relearn.markVariant())},window.relearn.markVariant=function(){var e=window.relearn.getItem(window.localStorage,window.relearn.absBaseUri+"/variant");document.querySelectorAll(".R-variantswitcher select").forEach(t=>{t.value=e})},window.relearn.initVariant=function(){var e=window.relearn.getItem(window.localStorage,window.relearn.absBaseUri+"/variant")??"";e==window.relearn.customvariantname||(!e||!window.relearn.themevariants.includes(e))&&(e=window.relearn.themevariants[0],window.relearn.setItem(window.localStorage,window.relearn.absBaseUri+"/variant",e)),document.documentElement.dataset.rThemeVariant=e},window.relearn.initVariant(),window.relearn.markVariant(),window.T_Copy_to_clipboard=`Copy to clipboard`,window.T_Copied_to_clipboard=`Copied to clipboard!`,window.T_Copy_link_to_clipboard=`Copy link to clipboard`,window.T_Link_copied_to_clipboard=`Copied link to clipboard!`,window.T_Reset_view=`Reset view`,window.T_View_reset=`View reset!`,window.T_No_results_found=`No results found for "{0}"`,window.T_N_results_found=`{1} results found for "{0}"`</script></head><body class="mobile-support html" data-url=/survey-papers/android-&amp;#43;-security/identifying-vulnerabilities-of-ssl_tls-certificate-verification-in-android-apps-with-static-and-dynamic-analysis/index.html><div id=R-body class=default-animation><div id=R-body-overlay></div><nav id=R-topbar><div class=topbar-wrapper><div class=topbar-sidebar-divider></div><div class="topbar-area topbar-area-start" data-area=start><div class="topbar-button topbar-button-sidebar" data-content-empty=disable data-width-s=show data-width-m=hide data-width-l=hide><button class=topbar-control onclick=toggleNav() type=button title="Menu (CTRL+ALT+n)"><i class="fa-fw fas fa-bars"></i></button></div><div class="topbar-button topbar-button-toc" data-content-empty=hide data-width-s=show data-width-m=show data-width-l=show><button class=topbar-control onclick=toggleTopbarFlyout(this) type=button title="Table of Contents (CTRL+ALT+t)"><i class="fa-fw fas fa-list-alt"></i></button><div class=topbar-content><div class=topbar-content-wrapper><nav class=TableOfContents><ul><li><a href=#introduction>Introduction</a></li><li><a href=#background>Background</a></li><li><a href=#problem-statement>Problem Statement</a></li><li><a href=#proposed-method>Proposed Method</a><ul><li><a href=#如何定義潛在的易受攻擊代碼並觸發它們>如何定義潛在的易受攻擊代碼並觸發它們</a></li><li><a href=#如何模擬人類操作>如何模擬人類操作</a></li><li><a href=#如何高效運行-加速>如何高效運行-加速</a></li><li><a href=#如何有效運行>如何有效運行</a></li></ul></li><li><a href=#experiment>Experiment</a><ul><li><a href=#dataset>Dataset</a></li><li><a href=#static-analysis>Static Analysis</a></li><li><a href=#dynamic-analysis>Dynamic Analysis</a></li></ul></li><li><a href=#discusion>Discusion</a></li></ul></nav></div></div></div></div><ol class="topbar-breadcrumbs breadcrumbs highlightable" itemscope itemtype=http://schema.org/BreadcrumbList><li itemscope itemtype=https://schema.org/ListItem itemprop=itemListElement><a itemprop=item href=/index.html><span itemprop=name>SBK Hugo Site</span></a><meta itemprop=position content="1">&nbsp;>&nbsp;</li><li itemscope itemtype=https://schema.org/ListItem itemprop=itemListElement><a itemprop=item href=/survey-papers/index.html><span itemprop=name>Survey Papers</span></a><meta itemprop=position content="2">&nbsp;>&nbsp;</li><li itemscope itemtype=https://schema.org/ListItem itemprop=itemListElement><span itemprop=name>Identifying vulnerabilities of SSL/TLS certificate verification in Android apps with static and dynamic analysis</span><meta itemprop=position content="3"></li></ol><div class="topbar-area topbar-area-end" data-area=end><div class="topbar-button topbar-button-prev" data-content-empty=disable data-width-s=show data-width-m=show data-width-l=show><a class=topbar-control href=/survey-papers/crypto/how-to-securely-collaborate-on-data_-decentralized-threshold-he-and-secure-key-update---notes/index.html title="How to Securely Collaborate on Data: Decentralized Threshold HE and Secure Key Update - Notes (🡐)"><i class="fa-fw fas fa-chevron-left"></i></a></div><div class="topbar-button topbar-button-next" data-content-empty=disable data-width-s=show data-width-m=show data-width-l=show><a class=topbar-control href=/survey-papers/federated-learning/local-model-poisoning-attacks-to-byzantine-robust-federated-learning---notes/index.html title="Local Model Poisoning Attacks to Byzantine-Robust Federated Learning - Notes (🡒)"><i class="fa-fw fas fa-chevron-right"></i></a></div><div class="topbar-button topbar-button-more" data-content-empty=hide data-width-s=show data-width-m=show data-width-l=show><button class=topbar-control onclick=toggleTopbarFlyout(this) type=button title=More><i class="fa-fw fas fa-ellipsis-v"></i></button><div class=topbar-content><div class=topbar-content-wrapper><div class="topbar-area topbar-area-more" data-area=more></div></div></div></div></div></div></nav><div id=R-main-overlay></div><main id=R-body-inner class="highlightable survey-papers" tabindex=-1><div class=flex-block-wrapper><article class=default><header class=headline><div class="R-taxonomy taxonomy-tags cstyle tags" title=Tags style=--VARIABLE-TAGS-BG-color:var(--INTERNAL-TAG-BG-color)><ul><li><a class=term-link href=/tags/meeting-paper/index.html>Meeting Paper</a></li><li><a class=term-link href=/tags/ntu/index.html>NTU</a></li></ul></div></header><h1 id=identifying-vulnerabilities-of-ssltls-certificate-verification-in-android-apps-with-static-and-dynamic-analysis>Identifying vulnerabilities of SSL/TLS certificate verification in Android apps with static and dynamic analysis</h1><h1 id=identifying-vulnerabilities-of-ssl_tls-certificate-verification-in-android-apps-with-static-and-dynamic-analysis>Identifying vulnerabilities of SSL_TLS certificate verification in Android apps with static and dynamic analysis</h1><p>:::info
Wang, Y., Xu, G., Liu, X., Mao, W., Si, C., Pedrycz, W., & Wang, W. (2020). Identifying vulnerabilities of SSL/TLS certificate verification in Android apps with static and dynamic analysis. Journal of Systems and Software, 167, 110609.
:::
這一篇論文對我要做的東西非常類似，雖然本質上不一樣但有很多的觀點以及解決方式是可以參照的</p><h2 id=introduction>Introduction</h2><p>這篇文章探討了在Android應用程式中SSL/TLS憑證驗證的弱點，並提出了一種名為DCDroid的工具來偵測這些弱點。作者結合靜態和動態分析，分析了來自Google Play和360app的2213個應用程式，發現其中有20.65%可能存在弱點。透過DCDroid在兩部Android智慧手機上執行這些應用程式，最終確認了11.07%的應用程式對MITM和釣魚攻擊存在真正的弱點。</p><h2 id=background>Background</h2><ul><li><p>SSL/TLS and Android
一般來說，正確的驗證憑證的步驟為</p><ol><li>在憑證鏈中的所有憑證有無過期</li><li>憑證或憑證鏈中的根憑證由客戶端的憑證授權單位（CA）簽署</li><li>證書中的網域名稱與所連接的伺服器的網域名稱相符</li></ol><p>但是基於一些原因(例如: 使用self-signed certificate/伺服器的root憑證不在手機的CA list中/糾正某些第三方庫的不安全實作)導致開發者會自行實做一個憑證驗證的方法，而這時候就有可能會產生一些漏洞發生，例如:
:::warning</p><ol><li>信任具有 X509TrustManager 介面的所有證書(有關的說明可以參考<a href="https://developer.android.com/privacy-and-security/risks/unsafe-trustmanager?hl=zh-tw" rel=external target=_blank>官網</a>)</li><li>HostnameVerifier 未檢查Domain Name(有關的說明可以參考<a href="https://developer.android.com/privacy-and-security/risks/unsafe-hostname?hl=zh-tw" rel=external target=_blank>官網</a>)</li><li>使用setHostnameVerifier（透過使用ALLOW_ALL_HOSTNAME_VERIFIER）方法接受任何網域名稱(範例如<a href=https://blog.csdn.net/tiantianchuqiji/article/details/76639796 rel=external target=_blank>證書不安全解決HttpClient 如何忽略證書驗證 - ALLOW_ALL_HOSTNAME_VERIFIER</a>)</li><li>當WebView元件發生憑證驗證錯誤時，直接在onReceivedSslError()方法中呼叫proceed()方法可以忽略憑證驗證錯誤。
補充: 根據<a href=https://myoceane.fr/index.php/android-webview-without-https/ rel=external target=_blank>[Android] WebView without HTTPS</a><blockquote><p>在設定 webView 的時候需要設定 WebViewClient ,這個方法是重新調整當 SslError 時的反應方法,在 Android9.0 之後 onReceivedSslError 的預設方法是handler.cancel()，如此會將 WebView 變成空白頁，將handler.cancel()改成handler.proceed() 之後就可以成功顯示沒有 SSL 的網頁
:::</p></blockquote></li></ol></li></ul><h2 id=problem-statement>Problem Statement</h2><ol><li>如何定義潛在的易受攻擊代碼並觸發它們</li><li>如何模擬人類操作
作者有提出很多工具，例如MonkeyRunner、Appium、FlowDroi、DroidScope、Dynodroid、Smart Droid、Brahmastra<ol><li>MonkeyRunner: 它的執行沒有特殊用途，主要依賴於隨機點擊。因此，很難觸發易受攻擊的代碼</li><li>Appium: 可以使用特定的腳本來精確運行 UI 元素。但是，它沒有通用性，需要針對每個應用程式進行自定義。</li><li>FlowDroi、DroidScope: 可以跟蹤方法調用關係。但是，它們無法觸發動態漏洞</li><li>Dynodroid: 專注於處理自動輸入</li><li>Smart Droid、Brahmastra: 無法處理 Web UI</li></ol></li><li>如何高效運行
這個就和老師說的有關，在一個App的activity中，有很多是類似的UI elements，而這些類似的UI對應到的handler其實差不多甚至一樣，那這樣的話如果要進行測試只要測試一個就好</li><li>如何有效運行
意思是雖然proxy可以攔截所有流量，但是我們怎麼確認這個流量是來自我們要偵測的那個App所發出來的呢?背景程式中有很多其他的App也在發出package，要怎麼辨認呢?</li></ol><h2 id=proposed-method>Proposed Method</h2><p>整體的分析流程如下，首先給定一個App，然後先進行靜態分析，並且分析取得的smali code，用一開始定義的演算法以及漏洞方法，找到潛在的漏洞，並且把vulnerable activity給動態分析，實際安裝與執行後，利用MITM工具攔截流量，並使用VPNService捕獲智能手機上的流量。最後，我們通過比較智慧手機和攻擊工具之間的流量來確認那些真正易受攻擊的應用程式。
<a href=#R-image-c9191b01dbc138717e43729fe60714f3 class=lightbox-link><img alt=圖片 class="lazy lightbox figure-image" loading=lazy src=https://hackmd.io/_uploads/SkfW7I6SC.png style=height:auto;width:auto></a>
<a href=javascript:history.back(); class=lightbox-back id=R-image-c9191b01dbc138717e43729fe60714f3><img alt=圖片 class="lazy lightbox lightbox-image" loading=lazy src=https://hackmd.io/_uploads/SkfW7I6SC.png></a>
'</p><h3 id=如何定義潛在的易受攻擊代碼並觸發它們>如何定義潛在的易受攻擊代碼並觸發它們</h3><h4 id=如何定義vulnerable-method>如何定義vulnerable method</h4><ol><li>X509TrustManager: 如果開發者有擴充這個class，他就會實際的看==checkClientTrusted==和==checkServerTrusted==這兩個method，如果這兩個method只有<code>return void</code>這一行code，那就代表這個App信任具有X509TrustManager 介面的所有證書，那當然就是有問題的地方</li><li>HostNameVerifier: 先檢查HostNameVerifier有沒有被實作，如果有就往下檢查==verify== method，他直接查看這個方法如果第一行是const開頭，第二行直接return的話，就代表他沒有檢查Domain Name，也一樣是有問題的</li><li>X509HostnameVerifier: 先檢查X509TrustManager extend class的類別中是否有sget-object的指令。如果有，我們檢查它是否以 ==ALLOW_ALL_HOSTNAME_VERIFIER Lorg/apache/http/conn/ssl/X509Hostname Verifier== 結尾。如果還是成立，我們檢查下一指令是否為 ==-> setHostname Verifier (Lorg/apache/ http/n/ssl/X509Hostname Verifier);V== 。如果存在，我們就認為該方法有漏洞。</li><li>WebViewClient sslError: 先檢查程式有無擴充WebVieClient這個class，如果有就檢查==onReceivedSslError==這個方法，如果這個method只有兩個instructions，而且第一行是invoke-virtual開頭、Landroid/webkit/SslErrorHandler;->proceed()V結尾，另外第二行就直接return void的話，代表這個method是有問題的</li></ol><h4 id=如何判斷這些vulnerable-method會被觸發>如何判斷這些vulnerable method會被觸發</h4><ol><li>Vulnerable Method最後會被誰call到
這段演算法的目的是通過遍歷Method Call Graph，找到所有可能調用Vulnerable Method的入口點方法，這些入口點方法是應用啟動時首先執行的方法或初始化方法。這樣可以幫助開發者了解潛在的Vulnerable Method是如何被call的，在動態分析階段優先考慮這些entry point，以便執行它們。這個演算法的概念是，從vulnerable method的角度出發一直往上走(看誰有call到)，比方說A call B, B call C, C call vulnerable method v1，而因為A是最後一個和VM有關係的class，那就直接看A裡面的constructor，並且向剛剛一樣，不斷往上看誰call了這個class method，找到最後，如果有一個class constructor是沒有被app任何一個code所呼叫，代表他一定是被系統所呼叫，這樣的話這個constructor就是我們要找的entry point
演算法:<div class="highlight wrap-code" dir=auto><pre tabindex=0><code class="language-=" data-lang="=">Require: MCG : Method Call Graph,VM : Vulnerable Method 
Ensure: Result : Set of Entry Point Methods 
function FindFinalCaller ( MCG, VM ) 
    if method_callers of VM not null then 
        for each method_caller in method_callers do 
            FindFinalCaller(MCG, method_caller) 
        end for 
    else 
        for each method in class(method_callers) do 
            if method is class&#39; constructor and method is not in Result then 
                Result.append(method) 
                FindFinalCaller (MCG, method) 
            else method is in Result 
                return 
            end if 
        end for 
    end if 
end function</code></pre></div></li><li>取得Entry Activity: 建立Activity Call Graph(ACG)
這個psuedo code的主要目的是構建一個Activity Call Graph，識別從任意Activity到包含潛在Vulnerable View的Activity的所有可能路徑。這對於安全分析和優化應用程序的設計非常有用。通過這樣的Call Graph，開發者可以清晰地了解應用程序的Activity之間的跳轉關系，尤其是涉及到Vulnerable View的路徑，從而有針對性地進行安全防護和性能優化。一些複雜的事件（如Swipe和長按）會被忽略，因為它們不太可能觸發 HTTPS 連接
演算法:<div class="highlight wrap-code" dir=auto><pre tabindex=0><code class="language-=" data-lang="=">Input: AndroidManifest.xml potientalVulnerableViews
Output: ActivityCallGraph(ACG)
function BuildACG(potientalVulnerableViews, AndroidManifest.xml)
    ACG = φ
    for each views in potientalVulnerableViews do
        EntryActivity = findActivityByViewID(views.getId)
        ActivitySet = initActivity(AndroidManifest.xml)
        ACG = Fun(EntryActivity, AvtivitySet, ACG)
    end for
    return ACG
end function
function Fun(EntryActivity, AtivitySet, ACG)
    for each activity in ActivitySet do
        if activity == MainActivity then
            return ACG
        end if
        if activity jump to EntryActivity By method.Event(such as Button.click) then
            ACG ∪ (activity → EntryActivity)
            fun(activity, ActivitySet, ACG)
        end if
    end for
endfunction</code></pre></div></li></ol><h3 id=如何模擬人類操作>如何模擬人類操作</h3><p>UI自動化元件有三個任務:</p><ol><li>取得UI元素並操作它們</li><li>減少UI元素並確定優先級</li><li>運行App並管理UI狀態</li></ol><p>當應用程式進入一個Activity時，需要取得該Activity的每一個元素，並提取該元素的屬性，例如按鈕的文字、文字方塊的輸入形式等。根據所獲得的信息，系統創建適當的事件來操作元素，以便Activity可以正常地從一個元素跳到另一個元素。例如，為複選框建立選擇事件，為文字方塊建立輸入事件。為了實現這個目標，我們使用<a href=https://github.com/dtmilano/AndroidViewClient rel=external target=_blank>AndroidViewClient</a>來管理元件。它可以取得UI元素，為UI元素建立適當的事件並執行特定應用程式的動態操作</p><h3 id=如何高效運行-加速>如何高效運行-加速</h3><p>為了避免相似的view重複被執行，所以用了另外一個演算法找出類似的view，以及最多只取前四個
<a href=#R-image-e5069c40aed29b15b700f38b4fae9d8e class=lightbox-link><img alt="螢幕擷取畫面 2024-06-17 161914" class="lazy lightbox figure-image" loading=lazy src=https://hackmd.io/_uploads/B1A1zOTrA.png style=height:auto;width:auto></a>
<a href=javascript:history.back(); class=lightbox-back id=R-image-e5069c40aed29b15b700f38b4fae9d8e><img alt="螢幕擷取畫面 2024-06-17 161914" class="lazy lightbox lightbox-image" loading=lazy src=https://hackmd.io/_uploads/B1A1zOTrA.png></a>
如果一個元件繼承自同一個父元件，並且具有相同的屬性（例如相同的大小、顏色等），那麼我們就認為它們是相同的</p><div class="highlight wrap-code" dir=auto><pre tabindex=0><code class="language-=" data-lang="=">Require: Views 
Ensure: Set of Vulnerable Views 
function SimilarViewsFinder (Views) 
    for each view in Views do 
        viewSize=view.getSize(); 
        if viewSize in viewWithSameParentAndSize then 
            viewWithSameParentAndSize[viewSize].append(view); 
        else 
            for each exitView in viewWithSameParentAndSize do 
                if difference (exitView, view ) &lt; threshold then 
                    viewWithSameParentAndSize[exitView].append(view); 
                else 
                    viewWithSameParentAndSize[view].append(view); 
                end if 
            end for 
        end if 
    end for 
    for key in viewWithSameParentAndSize.keys do 
        if len (viewWithSameParentAndSize [ key ]) &lt; 4 then 
            potientalVulnerableViews[key].append(viewWithSameParentAndSize[key]); 
        else 
            potientalVulnerableViews[key].append(viewWithSameParentAndSize[key][1.4]); 
        end if 
    end for 
    return potientalVulnerableViews 
end function</code></pre></div><h3 id=如何有效運行>如何有效運行</h3><p>這就回到一開始的問題，要如何保證proxy所攔截到的流量是我們正在測試的App所發出去的，作者使用Android內建的VPNService解決這個問題
<a href=#R-image-c044d04270d708d3ee04a1fa44dc61ae class=lightbox-link><img alt=圖片 class="lazy lightbox figure-image" loading=lazy src=https://hackmd.io/_uploads/r1qzUdar0.png style=height:auto;width:auto></a>
<a href=javascript:history.back(); class=lightbox-back id=R-image-c044d04270d708d3ee04a1fa44dc61ae><img alt=圖片 class="lazy lightbox lightbox-image" loading=lazy src=https://hackmd.io/_uploads/r1qzUdar0.png></a></p><ol><li>App透過socket把資料送到NIC(network interface card，網卡)</li><li>NIC把所有的packet都送到虛擬網卡(Virtual NIC)</li><li>VPN打開<code>/dev/tun</code>並且讀取裡面的data，此時data可以儲存或是改變</li><li>最後，VPN將資料發送到NIC。VPN應用使用的socket必須顯式綁定到NIC，以避免data packet的無限迴圈</li></ol><p>方法是讀取<code>/proc/net/tcp</code>和<code>/proc/net/tcp6</code>檔案來取得PID的IP及其URL。使用UsageStatsManager class可以取得目前正在執行的應用程式的PID。 PackageManager class可以取得PID和app之間的對應關係。這樣我們就可以得到每個HTTPS流量和應用程式之間的對應關係。透過比較智慧型手機和MITM攻擊工具所獲得的HTTPS流量，可以確認存在漏洞的應用程式。我們開發了一款Android流量抓取工具來實現這個功能。</p><h2 id=experiment>Experiment</h2><h3 id=dataset>Dataset</h3><p>從360app和google play商店中分別於2018/12以及2016/06取得1253 apps和960 apps，特別說明，他們把超過100M的app刪除，因為大部分這些app都是複雜的遊戲程式，在動態測試時會頻繁的crash
<a href=#R-image-ac9b8d187aeba1955702e2765c4cf1bf class=lightbox-link><img alt=圖片 class="lazy lightbox figure-image" loading=lazy src=https://hackmd.io/_uploads/HkY1KOaHA.png style=height:auto;width:auto></a>
<a href=javascript:history.back(); class=lightbox-back id=R-image-ac9b8d187aeba1955702e2765c4cf1bf><img alt=圖片 class="lazy lightbox lightbox-image" loading=lazy src=https://hackmd.io/_uploads/HkY1KOaHA.png></a></p><h3 id=static-analysis>Static Analysis</h3><p>:::warning
這個table在設計上有誤，他把360app和google play下面的底線標錯了，360app應該是包含前面的count和他底下的percentage，而圖片上包含的count是屬於google play，至於google paly包含的count則是360app和google play兩者相加的結果
:::
靜態分析的結果如下，總共有30/2213(1.36%)的App無法disassembly，並且有 457 個 （20.65%） 應用程式具有潛在的易受攻擊代碼，這些應用程式被認為具有潛在的證書驗證漏洞。
<a href=#R-image-b1d2c99a1fd248bdfa2ac5c5c363bf05 class=lightbox-link><img alt=圖片 class="lazy lightbox figure-image" loading=lazy src="https://hackmd.io/_uploads/rJFitdaHA.png=500x" style=height:auto;width:auto></a>
<a href=javascript:history.back(); class=lightbox-back id=R-image-b1d2c99a1fd248bdfa2ac5c5c363bf05><img alt=圖片 class="lazy lightbox lightbox-image" loading=lazy src="https://hackmd.io/_uploads/rJFitdaHA.png=500x"></a>
作者把以上的結果和之前的工具AndroBugs, kingkong and appscan進行比較，結果如下，AndroBugs 在靜態檢測的檢測精度方面略優於DCDroid。但是，在沒有動態檢測的情況下，它會生成大量誤報。至於kingkong和appscan，DCDroid在靜態檢測的檢測精度方面更好。此外，他們無法檢測到 HostNameVerifier 漏洞。這兩個工具還包含許多誤報。因此，DCDroid 在靜態檢測階段並不是最好的。但是，DCDroid 的<strong>主要優點是我們可以動態運行應用程式並刪除誤報</strong>
![圖片](<a href=https://hackmd.io/_uploads/H1Rm6_prA.png rel=external target=_blank>https://hackmd.io/_uploads/H1Rm6_prA.png</a> =600x)</p><h3 id=dynamic-analysis>Dynamic Analysis</h3><p>在動態分析中，我們使用AndroidViewClient操作兩部 Android 智慧手機並運行應用程式。平均而言，每個應用程序花費 183 秒。動態檢測結果如表1所示。可以看出，來自 360app 和 Google Play 的 245 個應用被識別為存在證書驗證漏洞，占潛在漏洞代碼的 53.61%，佔所有應用的 11.07%。這表明我們數據集中有 11.07% 的應用存在證書驗證漏洞。從表中可以看出，360app中的證書驗證漏洞佔比為12.05%，Google Play中的證書驗證漏洞佔比為9.79%。360app中的易受攻擊的應用程式比Google Play中的應用程式更多。
![圖片](<a href=https://hackmd.io/_uploads/Sk8aK_TSA.png rel=external target=_blank>https://hackmd.io/_uploads/Sk8aK_TSA.png</a> =600x)</p><h2 id=discusion>Discusion</h2><ol><li>DCDroid這套工具是有效地，但仍存在局線性</li><li>在靜態分析中，判斷是vulnerable method的方式比較簡單粗暴，但是搞不好其實那些有複雜實作的method到最後也沒有安全的進行驗證工作，但這類的app，dcdroid是沒辦法分析出來的</li><li>在動態測試中，為了加速而把一些相似的view捨棄，但不能保證false negative的數量有多少</li></ol><footer class=footline></footer></article></div></main></div><aside id=R-sidebar class=default-animation><div id=R-header-topbar class=default-animation></div><div id=R-header-wrapper class=default-animation><div id=R-header class=default-animation><a id=R-logo class=R-default href=/index.html><div class=logo-title>SBK Hugo Site</div></a></div><search><form action=/search/index.html method=get><div class="searchbox default-animation"><button class=search-detail type=submit title="Search (CTRL+ALT+f)"><i class="fas fa-search"></i></button>
<label class=a11y-only for=R-search-by>Search</label>
<input data-search-input id=R-search-by name=search-by class=search-by type=search placeholder=Search...>
<button class=search-clear type=button data-search-clear title="Clear search"><i class="fas fa-times" title="Clear search"></i></button></div></form></search></div><div id=R-homelinks class="default-animation homelinks"><div class="R-menu-divider default-animation"><hr class=padding></div><div class="R-sidebarmenu R-shortcutmenu-homelinks"><ul class="space collapsible-menu"><li data-nav-id=/index.html><a class=padding href=/index.html><i class="fa-fw fas fa-home"></i> Home</a></li></ul></div><div class="R-menu-divider default-animation"><hr class=padding></div><div class="R-sidebarmenu R-shortcutmenu-headercontrols"><ul></ul></div><div class="R-menu-divider default-animation"><hr class=padding></div></div><div id=R-content-wrapper class=highlightable><div class="R-sidebarmenu R-shortcutmenu-main"><ul class="enlarge morespace collapsible-menu"><li data-nav-id=/books-notes/index.html><a class=padding href=/books-notes/index.html>Books Notes</a><ul id=R-subsections-0771445a148f63eb6cc1a9b7ad45a36a class=collapsible-menu></ul></li><li data-nav-id=/data-structure/index.html><a class=padding href=/data-structure/index.html>Data Structures</a><ul id=R-subsections-58892abc7cea06bf1839098c82b3eb4d class=collapsible-menu></ul></li><li data-nav-id=/job/index.html><a class=padding href=/job/index.html>Jobs</a><ul id=R-subsections-0fce2c1f4d6d23f49b605855a82f55aa class=collapsible-menu></ul></li><li data-nav-id=/knowledge/index.html><a class=padding href=/knowledge/index.html>Knowledges</a><ul id=R-subsections-0bdb754d722e03f187f2117c1ef8015d class=collapsible-menu></ul></li><li data-nav-id=/leetcode/index.html><a class=padding href=/leetcode/index.html>LeetCodes</a><ul id=R-subsections-76e85062179d09303530c47eb73fc667 class=collapsible-menu></ul></li><li data-nav-id=/problem-solutions/index.html><a class=padding href=/problem-solutions/index.html>Problem Solutions</a><ul id=R-subsections-4f9e0f3095337026c1723515d5409f89 class=collapsible-menu></ul></li><li data-nav-id=/security/index.html><a class=padding href=/security/index.html>Securities</a><ul id=R-subsections-66815ecaaecfc1c209e5637d03b258b2 class=collapsible-menu></ul></li><li data-nav-id=/side-project/index.html><a class=padding href=/side-project/index.html>Side Projects</a><ul id=R-subsections-3295de6e89859c4cf23a4292e734c881 class=collapsible-menu></ul></li><li class=parent data-nav-id=/survey-papers/index.html><a class=padding href=/survey-papers/index.html>Survey Papers</a><ul id=R-subsections-baa5a308e222e800d6e93248dad73a11 class=collapsible-menu><li data-nav-id=/survey-papers/android-+-security/a-mitm-based-penetration-test-efficiency-improvement-approach-for-traffic-encrypted-mobile-apps-of-power-industry/index.html><a class=padding href=/survey-papers/android-+-security/a-mitm-based-penetration-test-efficiency-improvement-approach-for-traffic-encrypted-mobile-apps-of-power-industry/index.html>A MITM Based Penetration Test Efficiency Improvement Approach for Traffic-Encrypted Mobile Apps of Power Industry</a></li><li data-nav-id=/survey-papers/android-+-security/a-mitmproxy-based-dynamic-vulnerability-detection-system-for-android-applications/index.html><a class=padding href=/survey-papers/android-+-security/a-mitmproxy-based-dynamic-vulnerability-detection-system-for-android-applications/index.html>A Mitmproxy-based Dynamic Vulnerability Detection System For Android Applications</a></li><li data-nav-id=/survey-papers/android-+-security/cross-site-scripting-attacks-on-android-hybrid-applications/index.html><a class=padding href=/survey-papers/android-+-security/cross-site-scripting-attacks-on-android-hybrid-applications/index.html>Cross-site Scripting Attacks on Android Hybrid Applications</a></li><li data-nav-id=/survey-papers/ml-dl-+-security/deepcase-semi-supervised-contextual-analysis-of-security-events---notes/index.html><a class=padding href=/survey-papers/ml-dl-+-security/deepcase-semi-supervised-contextual-analysis-of-security-events---notes/index.html>DEEPCASE Semi-Supervised Contextual Analysis of Security Events - Notes</a></li><li data-nav-id=/survey-papers/ml-dl-+-security/deeplog_-anomaly-detection-and-diagnosis-from-system-logs-through-deep-learning/index.html><a class=padding href=/survey-papers/ml-dl-+-security/deeplog_-anomaly-detection-and-diagnosis-from-system-logs-through-deep-learning/index.html>DeepLog: Anomaly Detection and Diagnosis from System Logs through Deep Learning</a></li><li data-nav-id=/survey-papers/federated-learning/eiffel_-ensuring-integrity-for-federated-learning---notes/index.html><a class=padding href=/survey-papers/federated-learning/eiffel_-ensuring-integrity-for-federated-learning---notes/index.html>EIFFeL: Ensuring Integrity For Federated Learning - Notes</a></li><li data-nav-id=/survey-papers/android-+-security/exploiting-ml-alg-for-efficient-detection-and-prevention-of-js-xss-attacks-in-android-based-hybrid-applications/index.html><a class=padding href=/survey-papers/android-+-security/exploiting-ml-alg-for-efficient-detection-and-prevention-of-js-xss-attacks-in-android-based-hybrid-applications/index.html>Exploiting ML ALG for Efficient Detection and Prevention of JS-XSS Attacks in Android Based Hybrid Applications</a></li><li data-nav-id=/survey-papers/android-+-security/gui-testing/fastbot_-a-multi-agent-model-based-test-generation-system/index.html><a class=padding href=/survey-papers/android-+-security/gui-testing/fastbot_-a-multi-agent-model-based-test-generation-system/index.html>Fastbot: A Multi-Agent Model-Based Test Generation System</a></li><li data-nav-id=/survey-papers/android-+-security/gui-testing/fastbot2_-reusable-automated-model-based-gui-testing-for-android-enhanced-by-reinforcement-learning/index.html><a class=padding href=/survey-papers/android-+-security/gui-testing/fastbot2_-reusable-automated-model-based-gui-testing-for-android-enhanced-by-reinforcement-learning/index.html>Fastbot2: Reusable Automated Model-based GUI Testing for Android Enhanced by Reinforcement Learning</a></li><li data-nav-id=/survey-papers/federated-learning/fedml-he---an-efficient-homomorphic-encryption-based-privacy-preserving-federated-learning-system---notes/index.html><a class=padding href=/survey-papers/federated-learning/fedml-he---an-efficient-homomorphic-encryption-based-privacy-preserving-federated-learning-system---notes/index.html>FedML-HE - An Efficient Homomorphic-Encryption-Based Privacy-Preserving Federated Learning System - Notes</a></li><li data-nav-id=/survey-papers/crypto/how-to-securely-collaborate-on-data_-decentralized-threshold-he-and-secure-key-update---notes/index.html><a class=padding href=/survey-papers/crypto/how-to-securely-collaborate-on-data_-decentralized-threshold-he-and-secure-key-update---notes/index.html>How to Securely Collaborate on Data: Decentralized Threshold HE and Secure Key Update - Notes</a></li><li class=active data-nav-id=/survey-papers/android-+-security/identifying-vulnerabilities-of-ssl_tls-certificate-verification-in-android-apps-with-static-and-dynamic-analysis/index.html><a class=padding href=/survey-papers/android-+-security/identifying-vulnerabilities-of-ssl_tls-certificate-verification-in-android-apps-with-static-and-dynamic-analysis/index.html>Identifying vulnerabilities of SSL/TLS certificate verification in Android apps with static and dynamic analysis</a></li><li data-nav-id=/survey-papers/federated-learning/local-model-poisoning-attacks-to-byzantine-robust-federated-learning---notes/index.html><a class=padding href=/survey-papers/federated-learning/local-model-poisoning-attacks-to-byzantine-robust-federated-learning---notes/index.html>Local Model Poisoning Attacks to Byzantine-Robust Federated Learning - Notes</a></li><li data-nav-id=/survey-papers/android-+-security/tool/pentest-tools-survey/index.html><a class=padding href=/survey-papers/android-+-security/tool/pentest-tools-survey/index.html>Pentest Tools Survey</a></li><li data-nav-id=/survey-papers/digital-currency/the-state-of-ethereum-smart-contracts-security_-vulnerabilities-countermeasures-and-tool-support---notes/index.html><a class=padding href=/survey-papers/digital-currency/the-state-of-ethereum-smart-contracts-security_-vulnerabilities-countermeasures-and-tool-support---notes/index.html>The State of Ethereum Smart Contracts Security: Vulnerabilities, Countermeasures, and Tool Support - Notes</a></li><li data-nav-id=/survey-papers/android-+-security/uncovering-intent-based-leak-of-sensitive-data-in-android-framework/index.html><a class=padding href=/survey-papers/android-+-security/uncovering-intent-based-leak-of-sensitive-data-in-android-framework/index.html>Uncovering Intent based Leak of Sensitive Data in Android Framework</a></li><li data-nav-id=/survey-papers/android-+-security/understanding-real-world-threats-to-deep-learning-models-in-android-apps/index.html><a class=padding href=/survey-papers/android-+-security/understanding-real-world-threats-to-deep-learning-models-in-android-apps/index.html>Understanding Real-world Threats to Deep Learning Models in Android Apps</a></li><li data-nav-id=/survey-papers/android-+-security/vaptai_-a-threat-model-for-vulnerability-assessment-and-pentesting-of-android-and-ios-mobile-banking-apps/index.html><a class=padding href=/survey-papers/android-+-security/vaptai_-a-threat-model-for-vulnerability-assessment-and-pentesting-of-android-and-ios-mobile-banking-apps/index.html>VAPTAi: A Threat Model for Vulnerability Assessment and Pentesting of Android and iOS Mobile Banking Apps</a></li><li data-nav-id=/survey-papers/android-+-security/wight_-wired-ghost-touch-attack-on-capacitive-touchscreens/index.html><a class=padding href=/survey-papers/android-+-security/wight_-wired-ghost-touch-attack-on-capacitive-touchscreens/index.html>WIGHT: Wired Ghost Touch Attack on Capacitive Touchscreens</a></li><li data-nav-id=/survey-papers/android-+-security/tool/%E6%9C%89%E9%97%9Cpentest%E4%BD%86%E8%B2%A2%E7%8D%BB%E5%BE%88%E7%88%9B%E7%9A%84%E4%B8%89%E7%AF%87%E8%AB%96%E6%96%87/index.html><a class=padding href=/survey-papers/android-+-security/tool/%E6%9C%89%E9%97%9Cpentest%E4%BD%86%E8%B2%A2%E7%8D%BB%E5%BE%88%E7%88%9B%E7%9A%84%E4%B8%89%E7%AF%87%E8%AB%96%E6%96%87/index.html>有關Pentest但貢獻很爛的三篇論文</a></li></ul></li><li data-nav-id=/terminology/index.html><a class=padding href=/terminology/index.html>Terminologies</a><ul id=R-subsections-a19bf87a9a9aaf0a4146b803a35492f8 class=collapsible-menu></ul></li><li data-nav-id=/toc/index.html><a class=padding href=/toc/index.html>TOCs</a><ul id=R-subsections-451d3779340ac1afa8683c0232808cbf class=collapsible-menu></ul></li><li data-nav-id=/tools/index.html><a class=padding href=/tools/index.html>Tools</a><ul id=R-subsections-bf1399820dde3dd110e03ace4147ff86 class=collapsible-menu></ul></li></ul></div><div class="R-sidebarmenu R-shortcutmenu-shortcuts"><ul class="space collapsible-menu"></ul></div><div id=R-footer-margin></div><div class="R-menu-divider default-animation"><hr class=padding></div><div class="R-sidebarmenu R-shortcutmenu-footercontrols"><ul></ul></div><div id=R-footer><p>Built with <a href=https://github.com/McShelby/hugo-theme-relearn title=love><i class="fas fa-heart"></i></a> by <a href=https://gohugo.io/>Hugo</a></p></div></div></aside><script src=/js/clipboard/clipboard.min.js?1743619851 defer></script><script src=/js/perfect-scrollbar/perfect-scrollbar.min.js?1743619851 defer></script><script src=/js/theme.min.js?1743619851 defer></script></body></html>