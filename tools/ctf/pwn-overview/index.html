<!doctype html><html lang=en-us dir=ltr><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content='
  PWN Overview
  #

:::spoiler TOC
[TOC]
:::

  Tools Cheat
  #


Commonly Used Commands
$ file {file path}
$ checksec {file path} # sudo apt-get install checksec
$ objdump -M intel -d {file path} | less
$ gdb {file path} # sudo apt-get install gdb
$ readelf -a {file path} | less # 查看所有資訊，包含section/file-header/program headers/symbol tables/等等
$ readelf -S {file path} # 只查看sections&#39; header
$ ldd {file path} # to check what libraries the file used

Command Used Tools / Plugin

gdb-peda
$ git clone https://github.com/longld/peda.git ~/peda
$ echo "source ~/peda/peda.py" >> ~/.gdbinit

radare2
$ git clone https://github.com/radare/radare2.git
$ sudo apt install build-essential # just for wsl
$ sudo ./radare2/sys/install.sh

Exploit DB - Shell Code：如果要寫shell code的話可以直接看exploit db上別人寫好的gadget，複製起來就可以用了，不過有時候也有可能會失敗，在確認其他東西都是正確的情況下，可以試看看別的，記得平台要選對
ROPgadget
$ sudo apt install python3-pip
$ sudo -H python3 -m pip install ROPgadget
$ ROPgadget --help

# For using
$ ROPgadget --binary {executed file} | grep &#39;pop rax.*ret&#39;
# Or
$ ROPgadget --binary {executed file} --only "pop|ret|syscall" > rop_gadget.txt
$ ROPgadget --binary {executed file} --only "pop|ret|syscall" --multibr > rop_gadget.txt # multibr是multi bransh允許多分支的gadget

# 取得特定string的gadget
$ ROPgadget --binary {executed file} --string "/bin/sh"

one_gadget
$ sudo apt install rubygems
$ sudo gem install one_gadget
$ one_gadget {libc file}

seccomp-tools
$ sudo apt install gcc ruby-dev
$ gem install seccomp-tools
$ seccomp-tools dump ./test

找glibc版本的online tool
libc-database search API Search
libc database search




  gdb
  #

:::spoiler 常用語法(cheat)'><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#343a40"><meta name=color-scheme content="light dark"><meta property="og:url" content="https://bernie6401.github.io/tools/ctf/pwn-overview/"><meta property="og:site_name" content="SBK Hugo Site"><meta property="og:title" content="PWN Overview"><meta property="og:description" content='PWN Overview # :::spoiler TOC [TOC] :::
Tools Cheat # Commonly Used Commands $ file {file path} $ checksec {file path} # sudo apt-get install checksec $ objdump -M intel -d {file path} | less $ gdb {file path} # sudo apt-get install gdb $ readelf -a {file path} | less # 查看所有資訊，包含section/file-header/program headers/symbol tables/等等 $ readelf -S {file path} # 只查看sections&#39; header $ ldd {file path} # to check what libraries the file used Command Used Tools / Plugin gdb-peda $ git clone https://github.com/longld/peda.git ~/peda $ echo "source ~/peda/peda.py" >> ~/.gdbinit radare2 $ git clone https://github.com/radare/radare2.git $ sudo apt install build-essential # just for wsl $ sudo ./radare2/sys/install.sh Exploit DB - Shell Code：如果要寫shell code的話可以直接看exploit db上別人寫好的gadget，複製起來就可以用了，不過有時候也有可能會失敗，在確認其他東西都是正確的情況下，可以試看看別的，記得平台要選對 ROPgadget $ sudo apt install python3-pip $ sudo -H python3 -m pip install ROPgadget $ ROPgadget --help # For using $ ROPgadget --binary {executed file} | grep &#39;pop rax.*ret&#39; # Or $ ROPgadget --binary {executed file} --only "pop|ret|syscall" > rop_gadget.txt $ ROPgadget --binary {executed file} --only "pop|ret|syscall" --multibr > rop_gadget.txt # multibr是multi bransh允許多分支的gadget # 取得特定string的gadget $ ROPgadget --binary {executed file} --string "/bin/sh" one_gadget $ sudo apt install rubygems $ sudo gem install one_gadget $ one_gadget {libc file} seccomp-tools $ sudo apt install gcc ruby-dev $ gem install seccomp-tools $ seccomp-tools dump ./test 找glibc版本的online tool libc-database search API Search libc database search gdb # :::spoiler 常用語法(cheat)'><meta property="og:locale" content="en_us"><meta property="og:type" content="article"><meta property="article:section" content="tools"><meta property="article:tag" content="PWN"><meta property="article:tag" content="CTF"><meta property="article:tag" content="Tools"><title>PWN Overview | SBK Hugo Site</title>
<link rel=icon href=/favicon.png><link rel=manifest href=/manifest.json><link rel=canonical href=https://bernie6401.github.io/tools/ctf/pwn-overview/><link rel=stylesheet href=/book.min.6c8b9d2a1fc95075ed7da46ca81060b39add8fff6741ac51259f768929281e2c.css integrity="sha256-bIudKh/JUHXtfaRsqBBgs5rdj/9nQaxRJZ92iSkoHiw=" crossorigin=anonymous><script defer src=/fuse.min.js></script><script defer src=/en.search.min.acdc41c8d39e6c69d70d8a23779875e0a3733fefead3e428d5344966bb12f562.js integrity="sha256-rNxByNOebGnXDYojd5h14KNzP+/q0+Qo1TRJZrsS9WI=" crossorigin=anonymous></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/><span>SBK Hugo Site</span></a></h2><div class="book-search hidden"><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><script>document.querySelector(".book-search").classList.remove("hidden")</script></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu></label><h3>PWN Overview</h3><label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#tools-cheat>Tools Cheat</a><ul><li><a href=#gdb>gdb</a></li><li><a href=#pwntools>pwntools</a></li><li><a href=#other>Other</a></li><li><a href=#寫binshx00的方法>寫/bin/sh\x00的方法</a></li><li><a href=#如何讓環境執行在指定的libc和loader中>如何讓環境執行在指定的libc和loader中</a></li></ul></li><li><a href=#stack-vulnerabilities>Stack Vulnerabilities</a><ul><li><a href=#checksec><code>checksec</code></a></li><li><a href=#bof-series>Bof Series</a></li><li><a href=#format-string-bug>Format String Bug</a></li><li><a href=#got-series>GOT Series</a></li><li><a href=#return-2-series>Return 2 Series</a></li></ul></li><li><a href=#heap-vulnerabilities>Heap Vulnerabilities</a><ul><li><a href=#background>Background</a></li><li><a href=#double-free>Double Free</a></li><li><a href=#used-after-free>Used After Free</a></li><li><a href=#tcache-poisoning>Tcache poisoning</a></li><li><a href=#overlapping-chunks>Overlapping chunks</a></li></ul></li><li><a href=#reference>Reference</a></li></ul></nav></aside></header><article class="markdown book-article"><h1 id=pwn-overview>PWN Overview
<a class=anchor href=#pwn-overview>#</a></h1><p>:::spoiler TOC
[TOC]
:::</p><h2 id=tools-cheat>Tools Cheat
<a class=anchor href=#tools-cheat>#</a></h2><ul><li>Commonly Used Commands<pre tabindex=0><code class=language-bash! data-lang=bash!>$ file {file path}
$ checksec {file path} # sudo apt-get install checksec
$ objdump -M intel -d {file path} | less
$ gdb {file path} # sudo apt-get install gdb
$ readelf -a {file path} | less # 查看所有資訊，包含section/file-header/program headers/symbol tables/等等
$ readelf -S {file path} # 只查看sections&#39; header
$ ldd {file path} # to check what libraries the file used
</code></pre></li><li>Command Used Tools / Plugin<ul><li><a href=https://github.com/longld/peda>gdb-peda</a><pre tabindex=0><code class=language-bash! data-lang=bash!>$ git clone https://github.com/longld/peda.git ~/peda
$ echo &#34;source ~/peda/peda.py&#34; &gt;&gt; ~/.gdbinit
</code></pre></li><li><a href=https://github.com/radareorg/radare2>radare2</a><pre tabindex=0><code class=language-bash! data-lang=bash!>$ git clone https://github.com/radare/radare2.git
$ sudo apt install build-essential # just for wsl
$ sudo ./radare2/sys/install.sh
</code></pre></li><li><a href=https://www.exploit-db.com/shellcodes>Exploit DB - Shell Code</a>：如果要寫shell code的話可以直接看exploit db上別人寫好的gadget，複製起來就可以用了，不過有時候也有可能會失敗，在確認其他東西都是正確的情況下，可以試看看別的，記得平台要選對</li><li><a href=https://github.com/JonathanSalwan/ROPgadget>ROPgadget</a><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ sudo apt install python3-pip
</span></span><span style=display:flex><span>$ sudo -H python3 -m pip install ROPgadget
</span></span><span style=display:flex><span>$ ROPgadget --help
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># For using</span>
</span></span><span style=display:flex><span>$ ROPgadget --binary <span style=color:#f92672>{</span>executed file<span style=color:#f92672>}</span> | grep <span style=color:#e6db74>&#39;pop rax.*ret&#39;</span>
</span></span><span style=display:flex><span><span style=color:#75715e># Or</span>
</span></span><span style=display:flex><span>$ ROPgadget --binary <span style=color:#f92672>{</span>executed file<span style=color:#f92672>}</span> --only <span style=color:#e6db74>&#34;pop|ret|syscall&#34;</span> &gt; rop_gadget.txt
</span></span><span style=display:flex><span>$ ROPgadget --binary <span style=color:#f92672>{</span>executed file<span style=color:#f92672>}</span> --only <span style=color:#e6db74>&#34;pop|ret|syscall&#34;</span> --multibr &gt; rop_gadget.txt <span style=color:#75715e># multibr是multi bransh允許多分支的gadget</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 取得特定string的gadget</span>
</span></span><span style=display:flex><span>$ ROPgadget --binary <span style=color:#f92672>{</span>executed file<span style=color:#f92672>}</span> --string <span style=color:#e6db74>&#34;/bin/sh&#34;</span>
</span></span></code></pre></div></li><li><a href=https://github.com/david942j/one_gadget>one_gadget</a><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ sudo apt install rubygems
</span></span><span style=display:flex><span>$ sudo gem install one_gadget
</span></span><span style=display:flex><span>$ one_gadget <span style=color:#f92672>{</span>libc file<span style=color:#f92672>}</span>
</span></span></code></pre></div></li><li>seccomp-tools<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ sudo apt install gcc ruby-dev
</span></span><span style=display:flex><span>$ gem install seccomp-tools
</span></span><span style=display:flex><span>$ seccomp-tools dump ./test
</span></span></code></pre></div></li><li>找glibc版本的online tool
<a href=https://libc.rip/>libc-database search API Search</a>
<a href="https://libc.blukat.me/?q=__libc_start_main_ret">libc database search</a></li></ul></li></ul><h3 id=gdb>gdb
<a class=anchor href=#gdb>#</a></h3><p>:::spoiler 常用語法(<a href=https://darkdust.net/files/GDB%20Cheat%20Sheet.pdf>cheat</a>)</p><ul><li>b: 設定中斷點<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e># break point</span>
</span></span><span style=display:flex><span><span style=color:#f92672>(</span>gdb<span style=color:#f92672>)</span> b main
</span></span><span style=display:flex><span><span style=color:#f92672>(</span>gdb<span style=color:#f92672>)</span> b *0x4896aa
</span></span></code></pre></div></li><li>r: 執行程式 # run <code>$ (gdb) r</code></li><li>c: 繼續執行 # continue <code>$ (gdb) c</code></li><li>si: 步入指令 # step instruction <code>$(gdb) si</code></li><li>ni: 步過指令 # next instruction <code>$ (gdb) ni</code></li><li>x: 顯示記憶體內容<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e># show the value stored in memory address</span>
</span></span><span style=display:flex><span><span style=color:#f92672>(</span>gdb<span style=color:#f92672>)</span> x/10gx 0x400686 <span style=color:#75715e># print 10 memory value from 0x400686</span>
</span></span><span style=display:flex><span><span style=color:#f92672>(</span>gdb<span style=color:#f92672>)</span> x/10gi 0x400686 <span style=color:#75715e># print 10 instruction from 0x400686</span>
</span></span><span style=display:flex><span><span style=color:#f92672>(</span>gdb<span style=color:#f92672>)</span> x/2gs 0x400686 <span style=color:#75715e># print 2 strings from 0x400686</span>
</span></span></code></pre></div></li><li>vmmap 查看address space # check memory permission and distribution <code>$ (gdb) vmmap</code></li><li>bt {number}: 查看call stack</li><li>b info: 查看目前設的break point</li><li>delete breakpoints 1: 刪除一號斷點</li><li>fin: 直接執行該function到結束</li><li>got: 直接查看GOT</li><li>canary: 直接查看canary存放的位置和value</li><li>heap (chunk|chunks|bins|arenas|set-arena)</li><li>j/jump {address}: 直接jmp到指定的位置，但要注意如果該位置之後沒有其他breakpoint就會直接執行下去 # jump <code>$ (gdb) j 0x4896aa</code></li><li>set {long}{address} = 0x61616161: 對特定的位址寫入值 # set memory / register value <code>$ (gdb) set $rax=0x5</code></li><li>p &{symbol}: print出特定的symbol</li><li>如果自己寫一個script讓gdb可以自己load的話可以用: <code>$ gdb -x {script name} {file name}</code>
script範例<pre tabindex=0><code>set LD_PRELOAD=/usr/src/glibc/glibc_dbg/libc.so.6
b main
r
</code></pre></li><li>heapinfo: 查看heap的狀態</li><li>heapb: 就是heap base的command，告訴我們目前的base address</li><li>.gdbinit
:::spoiler config<pre tabindex=0><code class=language-bash! data-lang=bash!>set disassembly-flavor intel

define gef
        source ~/.gdbinit-gef.py

        #### gef
        # gef setting
        gef config dereference.max_recursion 2
        gef config context.layout &#34;regs code args source memory stack trace&#34;
        gef config context.nb_lines_backtrace 3
        gef config context.redirect /dev/pts/2
end

define peda
        #source ~/peda/peda.py
        source ~/Pwngdb/pwngdb.py
        source ~/Pwngdb/angelheap/gdbinit.py

        define hook-run
        python
import angelheap
angelheap.init_angelheap()
end
        end
end
</code></pre>:::</li></ul><h3 id=pwntools>pwntools
<a class=anchor href=#pwntools>#</a></h3><ul><li>常用<pre tabindex=0><code class=language-python! data-lang=python!>raw_input()
p64(0x401111)
p32(0x401111)
r.recvline()
r.recvuntil(b&#39;test&#39;)
r.recv(6)
r.sendline(b&#39;test&#39;)
</code></pre></li><li>flat<pre tabindex=0><code class=language-python! data-lang=python!>payload = flat(
    pop_eax_ret, 0,
    pop_ebx_ret, 0xc
)
</code></pre></li><li>asm:<pre tabindex=0><code class=language-python! data-lang=python!>payload = asm(&#34;&#34;&#34;
    xor eax, eax
    xor ebx, ebx
&#34;&#34;&#34;)
</code></pre></li><li>context<pre tabindex=0><code class=language-python! data-lang=python!>context.arch = &#39;amd64&#39;
context.newline = b&#39;\r\n&#39; # for windows pe file
</code></pre></li><li>ELF
方便查看GOT或function的address<pre tabindex=0><code class=language-python! data-lang=python!>exe = ELF(&#39;./vuln&#39;)
log.info(&#34;main address: &#34; + hex(exe.symbols[&#39;main&#39;]))
log.info(&#34;pow GOT address: &#34; + hex(exe.got[&#39;pow&#39;]))
log.info(&#34;strcspn GOT address: &#34; + hex(exe.got[&#39;strcspn&#39;]))
</code></pre></li><li>shellcraft
pwntools中內建的一些assembly shell code</li></ul><h3 id=other>Other
<a class=anchor href=#other>#</a></h3><ul><li>objdump<pre tabindex=0><code class=language-bash! data-lang=bash!>$ objdump -M intel -d $binary | less
</code></pre></li><li>如果要寫shell code的話可以直接看exploit db上別人寫好的gadget，複製起來就可以用了，不過有時候也有可能會失敗，在確認其他東西都是正確的情況下，可以試看看別的，記得平台要選對
<a href=https://www.exploit-db.com/shellcodes>Exploit DB - Shell Code</a></li><li><a href=https://chromium.googlesource.com/chromiumos/docs/+/master/constants/syscalls.md#x86-32_bit>Linux System Call Table</a></li><li><a href=https://blog.rchapman.org/posts/Linux_System_Call_Table_for_x86_64/>Linux System Call Table for x86 64</a></li></ul><h3 id=寫binshx00的方法>寫/bin/sh\x00的方法
<a class=anchor href=#%e5%af%abbinshx00%e7%9a%84%e6%96%b9%e6%b3%95>#</a></h3><ul><li><a href=http://shell-storm.org/shellcode/index.html>Shellcode Cheat Sheet</a></li></ul><ol><li>如果是x86版本
建議直接寫在stack上，因為比較少int 0x80 ; ret的gadget可以用，那倒不如直接寫在script上然後計算esp或ebp的位置，一樣可以拿到儲存的位置</li><li>如果是x64版本
建議可以用system read的方式搭配syscall ret的ROP</li><li>如果是直接執行shell code
且shell code是可以直接讓我們輸入的話就直接參考exploit db的就好了
:::spoiler eg 1</li></ol><pre tabindex=0><code>push 0x0b
pop eax
push 0x0068732f
push 0x6e69622f
mov ebx, esp
int 0x80
</code></pre><p>:::
:::spoiler eg 2</p><pre tabindex=0><code>mov eax, 0x6e69622f
push eax
mov eax, 0x0068732f
push eax
xor eax, eax
xor ebx, ebx
xor ecx, ecx
xor edx, edx
mov eax, 0xb
lea ebx, DWORD PTR [esp]
int 0x80
</code></pre><p>:::
:::spoiler eg 3</p><pre tabindex=0><code>/*Put the syscall number of execve in eax*/
    xor eax, eax
    mov al, 0xb
    
    /*Put zero in ecx and edx*/
    xor ecx, ecx
    xor edx, edx
    
    /*Push &#34;/sh\x00&#34; on the stack*/
    xor ebx, ebx
    mov bl, 0x68
    shl ebx
    shl ebx
    shl ebx
    shl ebx
    shl ebx
    shl ebx
    shl ebx
    shl ebx
    shl ebx
    shl ebx
    shl ebx
    shl ebx
    shl ebx
    shl ebx
    shl ebx
    shl ebx
    mov bh, 0x73
    mov bl, 0x2f
    push ebx
    nop
    
    /*Push &#34;/bin&#34; on the stack*/
    mov bh, 0x6e
    mov bl, 0x69
    shl ebx
    shl ebx
    shl ebx
    shl ebx
    shl ebx
    shl ebx
    shl ebx
    shl ebx
    shl ebx
    shl ebx
    shl ebx
    shl ebx
    shl ebx
    shl ebx
    shl ebx
    shl ebx
    mov bh, 0x62
    mov bl, 0x2f
    push ebx
    nop
              
    /*Move the esp (that points to &#34;/bin/sh\x00&#34;) in ebx*/
    mov ebx, esp/*Syscall*/
    int 0x80
</code></pre><p>:::</p><h3 id=如何讓環境執行在指定的libc和loader中>如何讓環境執行在指定的libc和loader中
<a class=anchor href=#%e5%a6%82%e4%bd%95%e8%ae%93%e7%92%b0%e5%a2%83%e5%9f%b7%e8%a1%8c%e5%9c%a8%e6%8c%87%e5%ae%9a%e7%9a%84libc%e5%92%8cloader%e4%b8%ad>#</a></h3><p>如果不想要費事裝VM或wsl就可以直接用@ccccc提供的腳本，讓這支程式跑在和server一樣的環境，==所以要把對應環境的loader和libc載下來==，用法如下:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ python <span style=color:#f92672>{</span>script path<span style=color:#f92672>}</span> <span style=color:#f92672>{</span>new env loader path<span style=color:#f92672>}</span> <span style=color:#f92672>{</span>original elf file<span style=color:#f92672>}</span>
</span></span><span style=display:flex><span><span style=color:#75715e># e.g. python ./LD_PRELOAD.py ./ld-2.27.so ./vuln</span>
</span></span></code></pre></div><p>他會產生一個新的執行檔，名字是<code>V</code>，在pwntools寫的腳本也要改，用法如下</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>r <span style=color:#f92672>=</span> process(<span style=color:#e6db74>&#39;./V&#39;</span>,env<span style=color:#f92672>=</span>{<span style=color:#e6db74>&#34;LD_PRELOAD&#34;</span> : <span style=color:#e6db74>&#34;./libc-2.27.so&#34;</span>})
</span></span></code></pre></div><p>:::spoiler Script</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#e6db74>&#39;&#39;&#39;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>Copied and modified from https://www.cnblogs.com/0x636a/p/9157993.html
</span></span></span><span style=display:flex><span><span style=color:#e6db74>All credits ro original author
</span></span></span><span style=display:flex><span><span style=color:#e6db74>&#39;&#39;&#39;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>from</span> pwn <span style=color:#f92672>import</span> <span style=color:#f92672>*</span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> sys<span style=color:#f92672>,</span> os
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>change_ld</span>(binary, ld):
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;&#34;&#34;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    Force to use assigned new ld.so by changing the binary
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    &#34;&#34;&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#f92672>not</span> os<span style=color:#f92672>.</span>access(ld, os<span style=color:#f92672>.</span>R_OK): 
</span></span><span style=display:flex><span>        log<span style=color:#f92672>.</span>failure(<span style=color:#e6db74>&#34;Invalid path </span><span style=color:#e6db74>{}</span><span style=color:#e6db74> to ld&#34;</span><span style=color:#f92672>.</span>format(ld))
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>None</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#f92672>not</span> isinstance(binary, ELF):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#f92672>not</span> os<span style=color:#f92672>.</span>access(binary, os<span style=color:#f92672>.</span>R_OK): 
</span></span><span style=display:flex><span>            log<span style=color:#f92672>.</span>failure(<span style=color:#e6db74>&#34;Invalid path </span><span style=color:#e6db74>{}</span><span style=color:#e6db74> to binary&#34;</span><span style=color:#f92672>.</span>format(binary))
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>None</span>
</span></span><span style=display:flex><span>        binary <span style=color:#f92672>=</span> ELF(binary)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> segment <span style=color:#f92672>in</span> binary<span style=color:#f92672>.</span>segments:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> segment<span style=color:#f92672>.</span>header[<span style=color:#e6db74>&#39;p_type&#39;</span>] <span style=color:#f92672>==</span> <span style=color:#e6db74>&#39;PT_INTERP&#39;</span>:
</span></span><span style=display:flex><span>            size <span style=color:#f92672>=</span> segment<span style=color:#f92672>.</span>header[<span style=color:#e6db74>&#39;p_memsz&#39;</span>]
</span></span><span style=display:flex><span>            addr <span style=color:#f92672>=</span> segment<span style=color:#f92672>.</span>header[<span style=color:#e6db74>&#39;p_paddr&#39;</span>]
</span></span><span style=display:flex><span>            data <span style=color:#f92672>=</span> segment<span style=color:#f92672>.</span>data()
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> size <span style=color:#f92672>&lt;=</span> len(ld):
</span></span><span style=display:flex><span>                log<span style=color:#f92672>.</span>failure(<span style=color:#e6db74>&#34;Failed to change PT_INTERP from </span><span style=color:#e6db74>{}</span><span style=color:#e6db74> to </span><span style=color:#e6db74>{}</span><span style=color:#e6db74>&#34;</span><span style=color:#f92672>.</span>format(data, ld))
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>None</span>
</span></span><span style=display:flex><span>            binary<span style=color:#f92672>.</span>write(addr, ld<span style=color:#f92672>.</span>encode()<span style=color:#f92672>.</span>ljust(size, <span style=color:#e6db74>b</span><span style=color:#e6db74>&#39;</span><span style=color:#ae81ff>\0</span><span style=color:#e6db74>&#39;</span>))
</span></span><span style=display:flex><span>            path <span style=color:#f92672>=</span> binary<span style=color:#f92672>.</span>path<span style=color:#f92672>.</span>split(<span style=color:#e6db74>&#39;/&#39;</span>)[<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>][<span style=color:#ae81ff>0</span>]<span style=color:#f92672>.</span>upper()
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> os<span style=color:#f92672>.</span>access(path, os<span style=color:#f92672>.</span>F_OK): 
</span></span><span style=display:flex><span>                os<span style=color:#f92672>.</span>remove(path)
</span></span><span style=display:flex><span>                print(<span style=color:#e6db74>&#34;Removing exist file </span><span style=color:#e6db74>{}</span><span style=color:#e6db74>&#34;</span><span style=color:#f92672>.</span>format(path))
</span></span><span style=display:flex><span>            binary<span style=color:#f92672>.</span>save(path)    
</span></span><span style=display:flex><span>            os<span style=color:#f92672>.</span>chmod(path, <span style=color:#ae81ff>0b111000000</span>) <span style=color:#75715e>#rwx------</span>
</span></span><span style=display:flex><span>    print(<span style=color:#e6db74>&#34;PT_INTERP has changed from </span><span style=color:#e6db74>{}</span><span style=color:#e6db74> to </span><span style=color:#e6db74>{}</span><span style=color:#e6db74>. Using temp file </span><span style=color:#e6db74>{}</span><span style=color:#e6db74>&#34;</span><span style=color:#f92672>.</span>format(data, ld, path)) 
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> len(sys<span style=color:#f92672>.</span>argv)<span style=color:#f92672>!=</span><span style=color:#ae81ff>3</span>:
</span></span><span style=display:flex><span>    print(<span style=color:#e6db74>&#39;Usage : python3 LD_PRELOAD.py [ld] [bin]&#39;</span>)
</span></span><span style=display:flex><span>LD_PATH <span style=color:#f92672>=</span> sys<span style=color:#f92672>.</span>argv[<span style=color:#ae81ff>1</span>]
</span></span><span style=display:flex><span>BIN <span style=color:#f92672>=</span> sys<span style=color:#f92672>.</span>argv[<span style=color:#ae81ff>2</span>]
</span></span><span style=display:flex><span>change_ld(BIN, LD_PATH)
</span></span><span style=display:flex><span><span style=color:#75715e>###Execute file by &#39;LD_PRELOAD={target_libc} ./executable&#39;</span>
</span></span></code></pre></div><p>:::</p><ul><li>How to download libc file & loader
<a href=https://packages.ubuntu.com/>Ubuntu Packages Search</a>
<a href=https://ubuntu.pkgs.org/20.04/ubuntu-main-amd64/libc6_2.31-0ubuntu9_amd64.deb.html>libc6_2.31-0ubuntu9_amd64.deb</a></li></ul><h2 id=stack-vulnerabilities>Stack Vulnerabilities
<a class=anchor href=#stack-vulnerabilities>#</a></h2><h3 id=checksec><code>checksec</code>
<a class=anchor href=#checksec>#</a></h3><ul><li>No RELRO or Partial RELRO $\to$ ==GOT Hijacking(改寫GOT)==
:::spoiler
❖ No RELRO - link map和GOT都可寫(有lazy binding)
❖ Partial RELRO - link map不可寫，GOT可寫(有lazy binding)
❖ Full RELRO - link map和GOT都不可寫(事先把library的位置都先resolve完並寫在GOT上，再把GOT權限關掉，比較花時間但安全)
關閉指令：<code>-z norelro</code>
:::</li><li>Position Independent Executable(PIE) $\to$ ==BOF(ret2 series)==
:::spoiler
❖ 開啟時，data 段以及 code 段位址隨機化
❖ 關閉時，data 段以及 code 段位址固定
關閉指令：<code>-no-pie</code>
:::</li><li>NX (No eXecute, Data Execution Prevention, DEP) off $\to$ 基本上不能直接執行shellcode，但可以用==ROP==繞過
:::spoiler
❖ 可寫得不可執⾏，可執⾏的不可寫
關閉指令：<code>-zexecstack</code>
:::</li><li>ASLR (Address Space Layout Randomization)
:::spoiler
❖ 記憶體位址隨機變化
❖ 每次執⾏時，stack、heap、library 位置都不⼀樣
關閉指令: <code>sudo sh -c "echo 0 > /proc/sys/kernel/randomize_va_space"</code>
打開指令: <code>sudo sh -c "echo 2 > /proc/sys/kernel/randomize_va_space"</code>
:::</li><li>Stack Canary
關閉指令：<code>-fno-stack-protector</code></li></ul><h3 id=bof-series>Bof Series
<a class=anchor href=#bof-series>#</a></h3><ul><li>Overwrite sensitive data</li><li>Overwrite return address -><ul><li>Statically Link Binary: 可以直接試看看ROP chain(從binary本身找gadget)</li><li>Dynamically Link Binary: 看有沒有辦法leak出libc base address，再用ROP chain(從libc中找gadget)</li></ul></li><li>Canary<ul><li>Leak canary</li></ul></li><li>如果BoF的長度不夠的話，可以考慮用stack pivot的方式再搭配ROP chain: 範例可以參考<a href=https://hackmd.io/@SBK6401/SkpDfz4BT>Lab - Stack Pivot</a></li></ul><h3 id=format-string-bug>Format String Bug
<a class=anchor href=#format-string-bug>#</a></h3><ul><li>之前的Demo是利用format string達到==GOT hijack==</li><li>用法:<ul><li>%<strong>p</strong> - leak code / libc / stack address</li><li>%{<strong>任意值</strong>}c%<strong>k</strong>$(hhn|hn|n) - 寫<strong>任意值</strong>到第 <strong>k</strong> 個參數指向的位址</li><li>%<strong>X</strong>c - 印出 <strong>X</strong> 個字元</li><li><strong>k</strong>$ - 指定第 <strong>k</strong> 個參數</li><li>%(hhn|hn|n) - 將<strong>輸出的字元數</strong>以 1 / 2 / 4 bytes 寫到參數<strong>指向的位址</strong></li><li>若該值為 addr 可透過 %s 輸出該地址的 value</li></ul></li><li>Note:<ul><li>因為能控制寫入的⼤⼩與位址，因此也可以配合 partial overwrite 做 exploit</li><li>基本上不太會⽤ %k$n 此 format，因為⼀次寫入 4 bytes 會太多</li></ul></li></ul><h3 id=got-series>GOT Series
<a class=anchor href=#got-series>#</a></h3><ul><li>GOT hijacking</li><li>Ret2plt - 控制執⾏流程到 function@plt，也代表執⾏該 function (以 functionA 代稱)，詳細可以看<a href=https://hackmd.io/@SBK6401/SyAHQfQH6>0x32 Ret2Plt</a></li><li>Leak libc - functionA 在被解析後，GOT 會存放 functionA 的絕對位址，因此如果可以讀取 GOT，就能得到位於 library 當中的 address<ul><li>FunctionA 的絕對位址減去他在 library 當中的 offset，能得到 library base address，繞過 ASLR</li></ul></li><li>Ret2libc - 有了 library base address，也能加上其他 function 的 offset 來取得該<ul><li>function 在 library 中的位址 (以 functionB 代稱)藉由控制程式流程，讓程式跳到 functionB 上，意即執⾏此 functionB</li></ul></li></ul><h3 id=return-2-series>Return 2 Series
<a class=anchor href=#return-2-series>#</a></h3><ol><li>Return 2 Code
這是代表原本的source code就已經有寫好一個shell，只要改變RIP就可以跳過去
<strong>必要條件：PIE Off</strong></li><li>Return 2 Shell Code
代表我們要自己寫一個shell code在記憶體中，然後用RIP跳過去
<strong>必要條件：NX Off(要完全可讀可寫可執行)</strong>
作法就是先找到一塊rwx全開的地方，然後想辦法把shell code寫上去，接著控制RIP跳到該段拿到shell<ul><li>變形：就像<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup>和<sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup>一樣
可以先找到.bss section，然後開__libc_read function寫入<code>/bin/sh\x00</code>，之後再return到shell code的地方</li></ul></li><li>Return 2 libc</li></ol><h2 id=heap-vulnerabilities>Heap Vulnerabilities
<a class=anchor href=#heap-vulnerabilities>#</a></h2><h3 id=background>Background
<a class=anchor href=#background>#</a></h3><p>:::spoiler 解題關鍵
<img src=https://hackmd.io/_uploads/ByQ16zsrT.png alt=圖片></p><p><img src=https://hackmd.io/_uploads/ByCZaGiHa.png alt=圖片></p><p><img src=https://hackmd.io/_uploads/HkFM6MjHp.png alt=圖片></p><p><img src=https://hackmd.io/_uploads/rkUXpMoB6.png alt=圖片>
:::</p><h3 id=double-free>Double Free
<a class=anchor href=#double-free>#</a></h3><h3 id=used-after-free>Used After Free
<a class=anchor href=#used-after-free>#</a></h3><ul><li><a href=https://hackmd.io/@SBK6401/SJWc9v4Bp#%E5%A6%82%E4%BD%95%E7%94%A8UAF-leak-libc-address>UAF leak Libc address</a></li><li><a href=https://hackmd.io/@SBK6401/SJWc9v4Bp#%E5%A6%82%E4%BD%95%E7%94%A8UAF-leak-heap-address>UAF leak heap address</a></li><li>基本的練習可以看<a href=https://hackmd.io/@SBK6401/SyXdjA5r6>UAF++</a></li></ul><h3 id=tcache-poisoning>Tcache poisoning
<a class=anchor href=#tcache-poisoning>#</a></h3><p>使⽤ double free 讓 tcache 當中存在兩個相同的 chunk，並利⽤修改 fd的⽅式，將對應位址視為 chunk 分配給 user</p><ul><li>Tcache 拿 chunk 時並不會檢查 chunk size 是否合法，因此常會拿 __free_hook 寫 system</li><li>Protection 1 - 當釋放 chunk 時，如果 chunk + 8 (key) 位置的值與當前 heap 的&amp;tcache_struct 相等，則會遍歷所有 entry，檢查是否有相同的 chunk，確保沒有double free 的發⽣</li><li>Protection 2 - 當取出 chunk 時，會檢查對應⼤⼩的 counter 是否⼤於 0，如果是的話才會取出 tcache_struct 當中指向的第⼀塊 chunk</li><li>Bypass Protection 1 - 透過 UAF 或是 heap overflow，修改 chunk 的 key 欄位</li><li>Bypass Protection 2<ul><li>拿到 tcache_struct 的 chunk 後修改 counts 欄位成非 0 的值</li><li>多次 free 相同的 chunk</li></ul></li></ul><h3 id=overlapping-chunks>Overlapping chunks
<a class=anchor href=#overlapping-chunks>#</a></h3><p>簡單來說就是==修改chunk size==，讓 chunk 在被釋放時 trigger consolidation(當釋放記憶體時，若檢查到相鄰的 chunk 沒有被使⽤，會將其合併成⼀塊更⼤的 freed chunk)，使得正在使⽤的 chunk 與已經釋放的 chunk 有部分重疊，也就代表</p><ul><li>使⽤中的 chunk 可以更改 freed chunk 中的 fd、bk</li><li>freed chunk 在被分配時，會分配到與使⽤中的 chunk 相同的區塊，可以修改敏感資料</li></ul><h2 id=reference>Reference
<a class=anchor href=#reference>#</a></h2><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p><a href=https://hackmd.io/@SBK6401/SkxoLuwoh>Guessing Game 1</a>&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:2><p><a href=https://hackmd.io/@SBK6401/rysBjQfjs>Simple PWN - 0x12(Lab - rop++)</a>&#160;<a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#tools-cheat>Tools Cheat</a><ul><li><a href=#gdb>gdb</a></li><li><a href=#pwntools>pwntools</a></li><li><a href=#other>Other</a></li><li><a href=#寫binshx00的方法>寫/bin/sh\x00的方法</a></li><li><a href=#如何讓環境執行在指定的libc和loader中>如何讓環境執行在指定的libc和loader中</a></li></ul></li><li><a href=#stack-vulnerabilities>Stack Vulnerabilities</a><ul><li><a href=#checksec><code>checksec</code></a></li><li><a href=#bof-series>Bof Series</a></li><li><a href=#format-string-bug>Format String Bug</a></li><li><a href=#got-series>GOT Series</a></li><li><a href=#return-2-series>Return 2 Series</a></li></ul></li><li><a href=#heap-vulnerabilities>Heap Vulnerabilities</a><ul><li><a href=#background>Background</a></li><li><a href=#double-free>Double Free</a></li><li><a href=#used-after-free>Used After Free</a></li><li><a href=#tcache-poisoning>Tcache poisoning</a></li><li><a href=#overlapping-chunks>Overlapping chunks</a></li></ul></li><li><a href=#reference>Reference</a></li></ul></nav></div></aside></main></body></html>