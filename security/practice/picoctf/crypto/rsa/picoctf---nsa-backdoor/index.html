<!doctype html><html lang=en-us dir=ltr><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="
  PicoCTF - NSA Backdoor
  #


  tags: PicoCTF CTF Crypto
  #


  Background
  #

Baby Step Giant Step - BSGS

用来解决如下方程最小正整數解的
$A^x\equiv B(mod\ C)$，其中$0\le x\lt C$
如果$A\ge C, B\ge C$，那麼我們可以先取模，即$A% = C, B% = C$，所以在這裡我們只討論$0\le A, B\lt C$的情況。
普通的BSGS的步驟是這樣的：

首先確定$x$的下限是$0$，上限是$C$，我們令$M=\lceil C\rceil$
把$A^0~A^M\ mod\ C$的值存到一个Hash表裡面
把$(A^M)^0~(A^M)^M\ mod\ C$的值一一枚舉出來，每枚舉一個就在Hash表裡面尋找是否有一個$val$值滿足$val \cdot (A^M)^i\ mod\ C=B$，如果有則找到答案，否則繼續
最終答案就是$i\cdot M+val$的值對應的原來$A$的冪
上面是普通Baby Step Giant Step的步驟，比較簡單，只適用為素數的情況。如果為合數呢？

拓展的過程詳見全文

離散對數問題 - pohlig-hellman算法講解



需要注意的是，pohlig-hellman算法的覆雜度在一般情況下比BSGS高！
因此，使用pohlig-hellman的場合只能是較為特殊的情況，即:$p$是質數，且$p-1$包含的質因子較少&較小。


和BSGS算法一樣，pohlig-hellman算法也是用於解決離散對數問題（也有很多文獻提到是解決橢圓曲線之類的）。即給定$a,b,p$,求 $a^x \equiv b(mod\ p)$。"><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#343a40"><meta name=color-scheme content="light dark"><meta property="og:url" content="https://bernie6401.github.io/security/practice/picoctf/crypto/rsa/picoctf---nsa-backdoor/"><meta property="og:site_name" content="SBK Hugo Site"><meta property="og:title" content="PicoCTF - NSA Backdoor"><meta property="og:description" content="PicoCTF - NSA Backdoor # tags: PicoCTF CTF Crypto # Background # Baby Step Giant Step - BSGS
用来解决如下方程最小正整數解的 $A^x\equiv B(mod\ C)$，其中$0\le x\lt C$ 如果$A\ge C, B\ge C$，那麼我們可以先取模，即$A% = C, B% = C$，所以在這裡我們只討論$0\le A, B\lt C$的情況。 普通的BSGS的步驟是這樣的：
首先確定$x$的下限是$0$，上限是$C$，我們令$M=\lceil C\rceil$ 把$A^0~A^M\ mod\ C$的值存到一个Hash表裡面 把$(A^M)^0~(A^M)^M\ mod\ C$的值一一枚舉出來，每枚舉一個就在Hash表裡面尋找是否有一個$val$值滿足$val \cdot (A^M)^i\ mod\ C=B$，如果有則找到答案，否則繼續 最終答案就是$i\cdot M+val$的值對應的原來$A$的冪 上面是普通Baby Step Giant Step的步驟，比較簡單，只適用為素數的情況。如果為合數呢？ 拓展的過程詳見全文
離散對數問題 - pohlig-hellman算法講解
需要注意的是，pohlig-hellman算法的覆雜度在一般情況下比BSGS高！ 因此，使用pohlig-hellman的場合只能是較為特殊的情況，即:$p$是質數，且$p-1$包含的質因子較少&較小。
和BSGS算法一樣，pohlig-hellman算法也是用於解決離散對數問題（也有很多文獻提到是解決橢圓曲線之類的）。即給定$a,b,p$,求 $a^x \equiv b(mod\ p)$。"><meta property="og:locale" content="en_us"><meta property="og:type" content="article"><meta property="article:section" content="security"><meta property="article:tag" content="PicoCTF"><meta property="article:tag" content="CTF"><meta property="article:tag" content="Crypto"><title>PicoCTF - NSA Backdoor | SBK Hugo Site</title>
<link rel=icon href=/favicon.png><link rel=manifest href=/manifest.json><link rel=canonical href=https://bernie6401.github.io/security/practice/picoctf/crypto/rsa/picoctf---nsa-backdoor/><link rel=stylesheet href=/book.min.6c8b9d2a1fc95075ed7da46ca81060b39add8fff6741ac51259f768929281e2c.css integrity="sha256-bIudKh/JUHXtfaRsqBBgs5rdj/9nQaxRJZ92iSkoHiw=" crossorigin=anonymous><script defer src=/fuse.min.js></script><script defer src=/en.search.min.acdc41c8d39e6c69d70d8a23779875e0a3733fefead3e428d5344966bb12f562.js integrity="sha256-rNxByNOebGnXDYojd5h14KNzP+/q0+Qo1TRJZrsS9WI=" crossorigin=anonymous></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/><span>SBK Hugo Site</span></a></h2><div class="book-search hidden"><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><script>document.querySelector(".book-search").classList.remove("hidden")</script></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu></label><h3>PicoCTF - NSA Backdoor</h3><label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><ul><li></li></ul></li><li><a href=#background>Background</a></li><li><a href=#source-code>Source code</a></li><li><a href=#recon>Recon</a></li><li><a href=#exploit---pohlig-hellmansagemath>Exploit - Pohlig-Hellman(SageMath)</a></li><li><a href=#reference>Reference</a></li></ul></nav></aside></header><article class="markdown book-article"><h1 id=picoctf---nsa-backdoor>PicoCTF - NSA Backdoor
<a class=anchor href=#picoctf---nsa-backdoor>#</a></h1><h6 id=tags-picoctf-ctf-crypto>tags: <code>PicoCTF</code> <code>CTF</code> <code>Crypto</code>
<a class=anchor href=#tags-picoctf-ctf-crypto>#</a></h6><h2 id=background>Background
<a class=anchor href=#background>#</a></h2><p><a href=https://blog.csdn.net/ACdreamers/article/details/8579511>Baby Step Giant Step - BSGS</a></p><blockquote><p>用来解决如下方程最小正整數解的
$A^x\equiv B(mod\ C)$，其中$0\le x\lt C$
如果$A\ge C, B\ge C$，那麼我們可以先取模，即$A% = C, B% = C$，所以在這裡我們只討論$0\le A, B\lt C$的情況。
普通的BSGS的步驟是這樣的：</p><ol><li>首先確定$x$的下限是$0$，上限是$C$，我們令$M=\lceil C\rceil$</li><li>把$A^0~A^M\ mod\ C$的值存到一个Hash表裡面</li><li>把$(A^M)^0~(A^M)^M\ mod\ C$的值一一枚舉出來，每枚舉一個就在Hash表裡面尋找是否有一個$val$值滿足$val \cdot (A^M)^i\ mod\ C=B$，如果有則找到答案，否則繼續</li><li>最終答案就是$i\cdot M+val$的值對應的原來$A$的冪
上面是普通Baby Step Giant Step的步驟，比較簡單，只適用為素數的情況。如果為合數呢？</li></ol></blockquote><p>拓展的過程詳見全文</p><hr><p><a href=https://blog.csdn.net/oampamp1/article/details/104061969>離散對數問題 - pohlig-hellman算法講解</a></p><blockquote><ol><li><p>需要注意的是，pohlig-hellman算法的覆雜度在一般情況下比BSGS高！
因此，使用pohlig-hellman的場合只能是較為特殊的情況，即:$p$是質數，且$p-1$包含的質因子較少&較小。</p></li><li><p>和BSGS算法一樣，pohlig-hellman算法也是用於解決離散對數問題（也有很多文獻提到是解決橢圓曲線之類的）。即給定$a,b,p$,求 $a^x \equiv b(mod\ p)$。</p></li><li><p>歐拉定理: 若$(a,p)=1$，那麽$a^{φ(p)} \equiv1(mod\ p)······(*)$
證明略。</p></li><li><p>費馬小定理: 如果$p$是質數，那$φ(p)=p-1$。</p></li><li><p>對於$a^x\equiv b(mod\ p)$，記其原根為$g$，則$a=g^{a_i},b=g^{b_i}$(原根的次冪可以在[1,p-1]中一一對應，故$a_i,b_i$必定存在)，即$g^{a_ix}\equiv g^{b_i}(mod\ p)$，所以$a_ix\equiv b_i(mod\ p-1)$，(因為$g^{p-1}\equiv 1(mod\ p)$，$p−1$是最小循環節，即階)，故利用egcd求出$x$即可。，於是我們的問題就變成了如何求$a_i,b_i$。</p></li></ol></blockquote><p>之後詳細的步驟詳見原文</p><h2 id=source-code>Source code
<a class=anchor href=#source-code>#</a></h2><ul><li>output.txt<pre tabindex=0><code>n = 98a3425eee4016a2592706867127e6c52ab2cf8077806f5626095e3afadc73cb4d0e747c5b9bf6234242e9578b12aba5e391e04a5cd2730f6e45d9f0758fb69eb32e0070b9efd3470f6571a8443bae63cd16efcb3e945dc3da1ce46993be4c8b4467ffb4e0525428bb8673ba144b0d36d1c34fe87307d68439070da27a8809551aa6cdf55c39c79bb7b6b7b9c26b45ef79f6c1ebf68033e4beab2d24df66f69dfb7f54d70d3b477fc7b67592cb029dfe6341c591c34a127f84b33626cd117707b69d1ed55f1773e3ba8d26b76f2db95e85de14a6aa1ff3de7fa23ce9f7ebd0e6c18c2fef4bbff47b6bd632d2d767aab7d35bf4d8577e50556626096704f0c425
c = 8788542cefd7490c9282c06b8d24280d56c6706b996bdf580290cdf2cb90e45efd2ce185fc07d2b916c24b0512d38ca14de0ee608a9d6003f258859bbbed97dad15c1d07410a34fd55cd8305eb43418d38f1ca6e024725b97fd9da701a39c23fe55a13d43b4bf9a3d9ebb44d7fe67bd60beffc29ec27bb4baf05ec5b250bfa68360df0d1379c066297a7878e59d27e68cf6a0da90755450827623e54e4f3d9f280fef53c7620d58decfbd10dd64e9d1d5507b5460603c58f5be70c82e2a8e613d730a950caea4c4389c5fc0521f8207ead5fb26c04eb6d0486fd6fe8d015fdabbda00139b42163acc86ffb30c12988058c6247344c42b8f3cdc984c06f4276f8
</code></pre></li><li><code>gen.py</code>
:::spoiler Source Code<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#75715e>#!/usr/bin/python</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>from</span> binascii <span style=color:#f92672>import</span> hexlify
</span></span><span style=display:flex><span><span style=color:#f92672>from</span> gmpy2 <span style=color:#f92672>import</span> <span style=color:#f92672>*</span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> math
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> os
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> sys
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> sys<span style=color:#f92672>.</span>version_info <span style=color:#f92672>&lt;</span> (<span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>9</span>):
</span></span><span style=display:flex><span>    math<span style=color:#f92672>.</span>gcd <span style=color:#f92672>=</span> gcd
</span></span><span style=display:flex><span>    math<span style=color:#f92672>.</span>lcm <span style=color:#f92672>=</span> lcm
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>_DEBUG <span style=color:#f92672>=</span> <span style=color:#66d9ef>False</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>FLAG  <span style=color:#f92672>=</span> open(<span style=color:#e6db74>&#39;flag.txt&#39;</span>)<span style=color:#f92672>.</span>read()<span style=color:#f92672>.</span>strip()
</span></span><span style=display:flex><span>FLAG  <span style=color:#f92672>=</span> mpz(hexlify(FLAG<span style=color:#f92672>.</span>encode()), <span style=color:#ae81ff>16</span>)
</span></span><span style=display:flex><span>SEED  <span style=color:#f92672>=</span> mpz(hexlify(os<span style=color:#f92672>.</span>urandom(<span style=color:#ae81ff>32</span>))<span style=color:#f92672>.</span>decode(), <span style=color:#ae81ff>16</span>)
</span></span><span style=display:flex><span>STATE <span style=color:#f92672>=</span> random_state(SEED)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>get_prime</span>(state, bits):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> next_prime(mpz_urandomb(state, bits) <span style=color:#f92672>|</span> (<span style=color:#ae81ff>1</span> <span style=color:#f92672>&lt;&lt;</span> (bits <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>)))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>get_smooth_prime</span>(state, bits, smoothness<span style=color:#f92672>=</span><span style=color:#ae81ff>16</span>):
</span></span><span style=display:flex><span>    p <span style=color:#f92672>=</span> mpz(<span style=color:#ae81ff>2</span>)
</span></span><span style=display:flex><span>    p_factors <span style=color:#f92672>=</span> [p]
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> p<span style=color:#f92672>.</span>bit_length() <span style=color:#f92672>&lt;</span> bits <span style=color:#f92672>-</span> <span style=color:#ae81ff>2</span> <span style=color:#f92672>*</span> smoothness:
</span></span><span style=display:flex><span>        factor <span style=color:#f92672>=</span> get_prime(state, smoothness)
</span></span><span style=display:flex><span>        p_factors<span style=color:#f92672>.</span>append(factor)
</span></span><span style=display:flex><span>        p <span style=color:#f92672>*=</span> factor
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    bitcnt <span style=color:#f92672>=</span> (bits <span style=color:#f92672>-</span> p<span style=color:#f92672>.</span>bit_length()) <span style=color:#f92672>//</span> <span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> <span style=color:#66d9ef>True</span>:
</span></span><span style=display:flex><span>        prime1 <span style=color:#f92672>=</span> get_prime(state, bitcnt)
</span></span><span style=display:flex><span>        prime2 <span style=color:#f92672>=</span> get_prime(state, bitcnt)
</span></span><span style=display:flex><span>        tmpp <span style=color:#f92672>=</span> p <span style=color:#f92672>*</span> prime1 <span style=color:#f92672>*</span> prime2
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> tmpp<span style=color:#f92672>.</span>bit_length() <span style=color:#f92672>&lt;</span> bits:
</span></span><span style=display:flex><span>            bitcnt <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>continue</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> tmpp<span style=color:#f92672>.</span>bit_length() <span style=color:#f92672>&gt;</span> bits:
</span></span><span style=display:flex><span>            bitcnt <span style=color:#f92672>-=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>continue</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> is_prime(tmpp <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>):
</span></span><span style=display:flex><span>            p_factors<span style=color:#f92672>.</span>append(prime1)
</span></span><span style=display:flex><span>            p_factors<span style=color:#f92672>.</span>append(prime2)
</span></span><span style=display:flex><span>            p <span style=color:#f92672>=</span> tmpp <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>break</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    p_factors<span style=color:#f92672>.</span>sort()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> (p, p_factors)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>while</span> <span style=color:#66d9ef>True</span>:
</span></span><span style=display:flex><span>    p, p_factors <span style=color:#f92672>=</span> get_smooth_prime(STATE, <span style=color:#ae81ff>1024</span>, <span style=color:#ae81ff>16</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> len(p_factors) <span style=color:#f92672>!=</span> len(set(p_factors)):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>continue</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># Smoothness should be different or some might encounter issues.</span>
</span></span><span style=display:flex><span>    q, q_factors <span style=color:#f92672>=</span> get_smooth_prime(STATE, <span style=color:#ae81ff>1024</span>, <span style=color:#ae81ff>17</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> len(q_factors) <span style=color:#f92672>==</span> len(set(q_factors)):
</span></span><span style=display:flex><span>        factors <span style=color:#f92672>=</span> p_factors <span style=color:#f92672>+</span> q_factors
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>break</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> _DEBUG:
</span></span><span style=display:flex><span>    <span style=color:#f92672>import</span> sys
</span></span><span style=display:flex><span>    sys<span style=color:#f92672>.</span>stderr<span style=color:#f92672>.</span>write(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#39;p = </span><span style=color:#e6db74>{</span>p<span style=color:#f92672>.</span>digits(<span style=color:#ae81ff>16</span>)<span style=color:#e6db74>}</span><span style=color:#ae81ff>\n\n</span><span style=color:#e6db74>&#39;</span>)
</span></span><span style=display:flex><span>    sys<span style=color:#f92672>.</span>stderr<span style=color:#f92672>.</span>write(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#39;p_factors = [</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#39;</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> factor <span style=color:#f92672>in</span> p_factors:
</span></span><span style=display:flex><span>        sys<span style=color:#f92672>.</span>stderr<span style=color:#f92672>.</span>write(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#39;    </span><span style=color:#e6db74>{</span>factor<span style=color:#f92672>.</span>digits(<span style=color:#ae81ff>16</span>)<span style=color:#e6db74>}</span><span style=color:#e6db74>,</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#39;</span>)
</span></span><span style=display:flex><span>    sys<span style=color:#f92672>.</span>stderr<span style=color:#f92672>.</span>write(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#39;]</span><span style=color:#ae81ff>\n\n</span><span style=color:#e6db74>&#39;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    sys<span style=color:#f92672>.</span>stderr<span style=color:#f92672>.</span>write(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#39;q = </span><span style=color:#e6db74>{</span>q<span style=color:#f92672>.</span>digits(<span style=color:#ae81ff>16</span>)<span style=color:#e6db74>}</span><span style=color:#ae81ff>\n\n</span><span style=color:#e6db74>&#39;</span>)
</span></span><span style=display:flex><span>    sys<span style=color:#f92672>.</span>stderr<span style=color:#f92672>.</span>write(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#39;q_factors = [</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#39;</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> factor <span style=color:#f92672>in</span> q_factors:
</span></span><span style=display:flex><span>        sys<span style=color:#f92672>.</span>stderr<span style=color:#f92672>.</span>write(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#39;    </span><span style=color:#e6db74>{</span>factor<span style=color:#f92672>.</span>digits(<span style=color:#ae81ff>16</span>)<span style=color:#e6db74>}</span><span style=color:#e6db74>,</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#39;</span>)
</span></span><span style=display:flex><span>    sys<span style=color:#f92672>.</span>stderr<span style=color:#f92672>.</span>write(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#39;]</span><span style=color:#ae81ff>\n\n</span><span style=color:#e6db74>&#39;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>n <span style=color:#f92672>=</span> p <span style=color:#f92672>*</span> q
</span></span><span style=display:flex><span>c <span style=color:#f92672>=</span> pow(<span style=color:#ae81ff>3</span>, FLAG, n)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>print(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#39;n = </span><span style=color:#e6db74>{</span>n<span style=color:#f92672>.</span>digits(<span style=color:#ae81ff>16</span>)<span style=color:#e6db74>}</span><span style=color:#e6db74>&#39;</span>)
</span></span><span style=display:flex><span>print(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#39;c = </span><span style=color:#e6db74>{</span>c<span style=color:#f92672>.</span>digits(<span style=color:#ae81ff>16</span>)<span style=color:#e6db74>}</span><span style=color:#e6db74>&#39;</span>)
</span></span></code></pre></div>:::</li></ul><h2 id=recon>Recon
<a class=anchor href=#recon>#</a></h2><p>這一題有點難，應該說觀念很簡單，我也有想到但不知道怎麼實作，簡單來說就是解discrete log的問題，總而言之，這一題和<a href=https://hackmd.io/@SBK6401/HyTTXZnPh>Very Smooth</a>幾乎一樣，差別在於他把flag當成exponent，i.e. $c=3^{flag}\ mod\ n$，並且提供$n, c$，所以我們要解出flag為多少</p><h2 id=exploit---pohlig-hellmansagemath>Exploit - Pohlig-Hellman(SageMath)
<a class=anchor href=#exploit---pohlig-hellmansagemath>#</a></h2><ol><li>Factor $p$ and $q$<ol><li>Method 1<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>from</span> gmpy2 <span style=color:#f92672>import</span> <span style=color:#f92672>*</span>
</span></span><span style=display:flex><span><span style=color:#f92672>from</span> Crypto.Util.number <span style=color:#f92672>import</span> long_to_bytes
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>a <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span>n <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span>N <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;98a3425eee4016a2592706867127e6c52ab2cf8077806f5626095e3afadc73cb4d0e747c5b9bf6234242e9578b12aba5e391e04a5cd2730f6e45d9f0758fb69eb32e0070b9efd3470f6571a8443bae63cd16efcb3e945dc3da1ce46993be4c8b4467ffb4e0525428bb8673ba144b0d36d1c34fe87307d68439070da27a8809551aa6cdf55c39c79bb7b6b7b9c26b45ef79f6c1ebf68033e4beab2d24df66f69dfb7f54d70d3b477fc7b67592cb029dfe6341c591c34a127f84b33626cd117707b69d1ed55f1773e3ba8d26b76f2db95e85de14a6aa1ff3de7fa23ce9f7ebd0e6c18c2fef4bbff47b6bd632d2d767aab7d35bf4d8577e50556626096704f0c425&#34;</span>
</span></span><span style=display:flex><span>c <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;8788542cefd7490c9282c06b8d24280d56c6706b996bdf580290cdf2cb90e45efd2ce185fc07d2b916c24b0512d38ca14de0ee608a9d6003f258859bbbed97dad15c1d07410a34fd55cd8305eb43418d38f1ca6e024725b97fd9da701a39c23fe55a13d43b4bf9a3d9ebb44d7fe67bd60beffc29ec27bb4baf05ec5b250bfa68360df0d1379c066297a7878e59d27e68cf6a0da90755450827623e54e4f3d9f280fef53c7620d58decfbd10dd64e9d1d5507b5460603c58f5be70c82e2a8e613d730a950caea4c4389c5fc0521f8207ead5fb26c04eb6d0486fd6fe8d015fdabbda00139b42163acc86ffb30c12988058c6247344c42b8f3cdc984c06f4276f8&#34;</span>
</span></span><span style=display:flex><span>c <span style=color:#f92672>=</span> int(c, <span style=color:#ae81ff>16</span>)
</span></span><span style=display:flex><span>N <span style=color:#f92672>=</span> int(N, <span style=color:#ae81ff>16</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>while</span> <span style=color:#66d9ef>True</span>:
</span></span><span style=display:flex><span>    a <span style=color:#f92672>=</span> powmod(a, n, N)
</span></span><span style=display:flex><span>    res <span style=color:#f92672>=</span> gcd(a<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>, N)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> res <span style=color:#f92672>!=</span> <span style=color:#ae81ff>1</span> <span style=color:#f92672>and</span> res <span style=color:#f92672>!=</span> N:
</span></span><span style=display:flex><span>        q <span style=color:#f92672>=</span> N <span style=color:#f92672>//</span> res
</span></span><span style=display:flex><span>        print(<span style=color:#e6db74>&#34;q = </span><span style=color:#e6db74>{}</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>p = </span><span style=color:#e6db74>{}</span><span style=color:#e6db74>&#34;</span><span style=color:#f92672>.</span>format(q, res))
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>break</span>
</span></span><span style=display:flex><span>    n <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>
</span></span></code></pre></div></li><li>Method 2<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>import</span> primefac
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>n <span style=color:#f92672>=</span> <span style=color:#ae81ff>0xd63c7cb032ae4d3a43ecec4999cfa8f8b49aa9c14374e60f3beeb437233e44f988a73101f9b20ffb56454350b1c9032c136142220ded059876ccfde992551db46c27f122cacdd38c86acb844032f8600515aa6ccb7a1d1ac62d04b51b752476d2d6ee9f22d0f933bebdd833a71fd30510479fcc7ba0afb1d4b0a1622cdc2a48341010dffdcfc8d9af45959fb30b692dc2c9e181ac6bcd6a701326e3707fb19b7f9dfe1c522c68f9b0d229d384be1e1c58f72f8df60ca5172a341a7ee81428a064beedd6af7b89cc6079f2b6d3717f0d29330f0a70acca05bf67ab60c2e5cb0b86bfca2c9b8d50d79d24371432a1efb243f3c5f15b377ccc51f6e69bfbf5ecc61</span>
</span></span><span style=display:flex><span>c <span style=color:#f92672>=</span> <span style=color:#ae81ff>0x51099773fd2aafd5f84dfe649acbb3558797f58bdc643ac6ee6f0a6fa30031767966316201c36be69241d9d05d0bd181ced13809f57b0c0594f6b29ac74bc7906dae70a2808799feddc71cf5b28401100e5e7e0324b9d8b56e540c725fa4ef87b9e8d0f901630da5f7f181f6d5b4cdc00d5f5c3457674abcb0d0c173f381b92bdfb143c595f024b98b9900410d502c87dfc1633796d640cb5f780fa4b6f0414fb51e34700d9096caf07b36f4dcd3bb5a2d126f60d3a802959d6fadf18f4970756f3099e14fa6386513fb8e6cdda80fdc1c32a10f6cdb197857caf1d7abf3812e3d9dcda106fa87bac382d3e6fc216c55da02a0c45a482550acb2f58bea2cfa03</span>
</span></span><span style=display:flex><span>q <span style=color:#f92672>=</span> primefac<span style=color:#f92672>.</span>pollard_pm1(n)
</span></span><span style=display:flex><span>p <span style=color:#f92672>=</span> n<span style=color:#f92672>//</span>q
</span></span><span style=display:flex><span>print(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#39;p = </span><span style=color:#e6db74>{</span>p<span style=color:#e6db74>}</span><span style=color:#e6db74>&#39;</span>)
</span></span><span style=display:flex><span>print(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#39;q = </span><span style=color:#e6db74>{</span>q<span style=color:#e6db74>}</span><span style=color:#e6db74>&#39;</span>)
</span></span></code></pre></div></li></ol></li><li>Use <a href=https://sagecell.sagemath.org/>SageMath</a> to address Discrete Log Problem<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>p <span style=color:#f92672>=</span> <span style=color:#ae81ff>117635180960139721127318189832610714114593440637486157582828661167364276581210599344857316369131977790468647533227778603367761815400416396281259234299247850289710613080530669849409358755399675041263469367135430665518150110493389671646158566214130516002949975036799297119111385228596853422400303735447298026283</span>
</span></span><span style=display:flex><span>q <span style=color:#f92672>=</span> <span style=color:#ae81ff>163800729847029979711295941089800020300275211671661376396219775666688832353701752860857691086339595920419175562271802936423756228938551439950541873798393442729921516031775531740506399414675546114663346731428381174638773512946351966471041847661507898143967764453261943807056370639171597924004988320983393199599</span>
</span></span><span style=display:flex><span>c <span style=color:#f92672>=</span> <span style=color:#ae81ff>0x8788542cefd7490c9282c06b8d24280d56c6706b996bdf580290cdf2cb90e45efd2ce185fc07d2b916c24b0512d38ca14de0ee608a9d6003f258859bbbed97dad15c1d07410a34fd55cd8305eb43418d38f1ca6e024725b97fd9da701a39c23fe55a13d43b4bf9a3d9ebb44d7fe67bd60beffc29ec27bb4baf05ec5b250bfa68360df0d1379c066297a7878e59d27e68cf6a0da90755450827623e54e4f3d9f280fef53c7620d58decfbd10dd64e9d1d5507b5460603c58f5be70c82e2a8e613d730a950caea4c4389c5fc0521f8207ead5fb26c04eb6d0486fd6fe8d015fdabbda00139b42163acc86ffb30c12988058c6247344c42b8f3cdc984c06f4276f8</span>
</span></span><span style=display:flex><span>g <span style=color:#f92672>=</span> Mod(<span style=color:#ae81ff>3</span>,p)
</span></span><span style=display:flex><span>m <span style=color:#f92672>=</span> discrete_log(c,g)
</span></span><span style=display:flex><span>print(hex(m))
</span></span><span style=display:flex><span>g2 <span style=color:#f92672>=</span> Mod(<span style=color:#ae81ff>3</span>,q)
</span></span><span style=display:flex><span>m2 <span style=color:#f92672>=</span> discrete_log(c,g2)
</span></span><span style=display:flex><span>print(m2)
</span></span><span style=display:flex><span>print(hex(m2)[<span style=color:#ae81ff>2</span>:])
</span></span></code></pre></div><ul><li>Output<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>0x7069636f4354467b6233773472335f30665f63306d7030733174335f6d3064756c315f39396633383833377d
</span></span><span style=display:flex><span><span style=color:#ae81ff>4028375274964940959020413024799108535910958820283330112174774258028392431441247073675773191542213151242109</span>
</span></span><span style=display:flex><span>7069636f4354467b6233773472335f30665f63306d7030733174335f6d3064756c315f39396633383833377d
</span></span></code></pre></div></li></ul></li></ol><p>Flag: <code>picoCTF{b3w4r3_0f_c0mp0s1t3_m0dul1_99f38837}</code></p><h2 id=reference>Reference
<a class=anchor href=#reference>#</a></h2><p><a href=https://youtu.be/pARmkuMg5tk>pico2022 nsa backdoor</a></p></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><ul><li></li></ul></li><li><a href=#background>Background</a></li><li><a href=#source-code>Source code</a></li><li><a href=#recon>Recon</a></li><li><a href=#exploit---pohlig-hellmansagemath>Exploit - Pohlig-Hellman(SageMath)</a></li><li><a href=#reference>Reference</a></li></ul></nav></div></aside></main></body></html>