<!doctype html><html lang=en-us dir=ltr><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="
  NTU Operating System Project 3
  #


  tags: NTU_OS Operating System NachOS Memory Management
  #

[TOC]

  Description First
  #

I used the code from Project2 directly and obtained the correct value, 1 and 7220, by the command ./nachos -e ../test/sort -e ../test/matmult respectively. After debugging a while, I knew what&rsquo;s the matter. In project2, I set const unsigned int NumPhysPages = 256; so that it can handle huge computing resource. In order to address this project, we must change it back to 32."><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#343a40"><meta name=color-scheme content="light dark"><meta property="og:url" content="https://bernie6401.github.io/security/course/ntu-os/ntu-operating-system-project-3/"><meta property="og:site_name" content="SBK Hugo Site"><meta property="og:title" content="NTU Operating System Project 3"><meta property="og:description" content="NTU Operating System Project 3 # tags: NTU_OS Operating System NachOS Memory Management # [TOC]
Description First # I used the code from Project2 directly and obtained the correct value, 1 and 7220, by the command ./nachos -e ../test/sort -e ../test/matmult respectively. After debugging a while, I knew what’s the matter. In project2, I set const unsigned int NumPhysPages = 256; so that it can handle huge computing resource. In order to address this project, we must change it back to 32."><meta property="og:locale" content="en_us"><meta property="og:type" content="article"><meta property="article:section" content="security"><meta property="article:tag" content="NTU_OS"><meta property="article:tag" content="NTU"><title>NTU Operating System Project 3 | SBK Hugo Site</title>
<link rel=icon href=/favicon.png><link rel=manifest href=/manifest.json><link rel=canonical href=https://bernie6401.github.io/security/course/ntu-os/ntu-operating-system-project-3/><link rel=stylesheet href=/book.min.6c8b9d2a1fc95075ed7da46ca81060b39add8fff6741ac51259f768929281e2c.css integrity="sha256-bIudKh/JUHXtfaRsqBBgs5rdj/9nQaxRJZ92iSkoHiw=" crossorigin=anonymous><script defer src=/fuse.min.js></script><script defer src=/en.search.min.acdc41c8d39e6c69d70d8a23779875e0a3733fefead3e428d5344966bb12f562.js integrity="sha256-rNxByNOebGnXDYojd5h14KNzP+/q0+Qo1TRJZrsS9WI=" crossorigin=anonymous></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/><span>SBK Hugo Site</span></a></h2><div class="book-search hidden"><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><script>document.querySelector(".book-search").classList.remove("hidden")</script></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu></label><h3>NTU Operating System Project 3</h3><label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><ul><li></li></ul></li><li><a href=#description-first>Description First</a></li><li><a href=#motivation>Motivation</a></li><li><a href=#implementation>Implementation</a></li><li><a href=#result>Result</a></li><li><a href=#reference>Reference</a></li></ul></nav></aside></header><article class="markdown book-article"><h1 id=ntu-operating-system-project-3>NTU Operating System Project 3
<a class=anchor href=#ntu-operating-system-project-3>#</a></h1><h6 id=tags-ntu_os-operating-system-nachos-memory-management>tags: <code>NTU_OS</code> <code>Operating System</code> <code>NachOS</code> <code>Memory Management</code>
<a class=anchor href=#tags-ntu_os-operating-system-nachos-memory-management>#</a></h6><p>[TOC]</p><h2 id=description-first>Description First
<a class=anchor href=#description-first>#</a></h2><p>I used the code from <code>Project2</code> directly and obtained the correct value, 1 and 7220, by the command <code>./nachos -e ../test/sort -e ../test/matmult</code> respectively. After debugging a while, I knew what&rsquo;s the matter. In <code>project2</code>, I set <code>const unsigned int NumPhysPages = 256;</code> so that it can handle huge computing resource. In order to address this project, we must change it back to 32.</p><h2 id=motivation>Motivation
<a class=anchor href=#motivation>#</a></h2><ul><li>Normally speaking, if you follow the command <code>./nachos -e ../test/matmult</code> and <code>./nachos -e ../test/sort</code> in <code>Project2</code>, you&rsquo;ll get<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>Total threads number is <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>Thread ../test/sort is executing.
</span></span><span style=display:flex><span>Assertion failed: line <span style=color:#ae81ff>118</span> file ../userprog/addrspace.cc
</span></span><span style=display:flex><span>Aborted <span style=color:#f92672>(</span>core dumped<span style=color:#f92672>)</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>Total threads number is <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>Thread ../test/matmult is executing.
</span></span><span style=display:flex><span>Assertion failed: line <span style=color:#ae81ff>118</span> file ../userprog/addrspace.cc
</span></span><span style=display:flex><span>Aborted <span style=color:#f92672>(</span>core dumped<span style=color:#f92672>)</span>
</span></span></code></pre></div></li><li>Our goal is to obtain the correct outcome <code>1</code> and <code>7220</code> from <code>/test/sort</code> and <code>/test/matmult</code> respectively that shown as below<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ ./nachos -e ../test/sort -e ../test/matmult
</span></span><span style=display:flex><span>Total threads number is <span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span>Thread ../test/sort is executing.
</span></span><span style=display:flex><span>Thread ../test/matmult is executing.
</span></span><span style=display:flex><span><span style=color:#66d9ef>return</span> value:7220
</span></span><span style=display:flex><span><span style=color:#66d9ef>return</span> value:1
</span></span><span style=display:flex><span>No threads ready or runnable, and no pending interrupts.
</span></span><span style=display:flex><span>Assuming the program completed.
</span></span><span style=display:flex><span>Machine halting!
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Ticks: total 43818400, idle 40, system 4381880, user <span style=color:#ae81ff>39436480</span>
</span></span><span style=display:flex><span>Disk I/O: reads 0, writes <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>Console I/O: reads 0, writes <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>Paging: faults <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>Network I/O: packets received 0, sent <span style=color:#ae81ff>0</span>
</span></span></code></pre></div></li><li>Now, let&rsquo;s try to analyze the problem. NachOS has physical memory limitation, so that it cannot handle the program that needs huge memory resource such as <code>sort.c</code> and <code>matmult.c</code>. Thus, we can utilize <strong><code>Demand Paging</code></strong> to address it → <strong>realize a virtual memory if the main memory has no space</strong><blockquote><p>When the space in main memory is enough, pages will be stored in main memory. If the space is insufficient, the pages and data will swap out. When there is valid space, i.e. the space is released, and the data is needed, the pages and data will then swap in main memory. The scheduling method of the page replacement algorithm is implemented by LRU(Least Recently Used). - by <a href=https://raw.githubusercontent.com/wangssuming/nachos-NTU/master/r07945029_Nachos3/r07945029_report.pdf>wangssuming</a></p></blockquote></li></ul><h2 id=implementation>Implementation
<a class=anchor href=#implementation>#</a></h2><ul><li><p><strong><code>/code/userprog/userkernel.h</code></strong>
create a new <code>SynchDisk</code> called <code>SwapDisk</code> and replace <code>debugUserProg</code> from private to public</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>UserProgKernel</span> <span style=color:#f92672>:</span> <span style=color:#66d9ef>public</span> ThreadedKernel
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>        ...
</span></span><span style=display:flex><span>        <span style=color:#75715e>/*-----------------------Homework for Memory Management------------------------*/</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Create a new SynchDisk called SwapDisk to simulate the secondary storage
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        SynchDisk <span style=color:#f92672>*</span>SwapDisk;     <span style=color:#75715e>// SwapDisk saves pages if main memory is not enough
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>bool</span> debugUserProg;		<span style=color:#75715e>// single step user program
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>/*-----------------------Homework for Memory Management------------------------*/</span>
</span></span><span style=display:flex><span>        Machine <span style=color:#f92672>*</span>machine;
</span></span><span style=display:flex><span>        FileSystem <span style=color:#f92672>*</span>fileSystem;
</span></span><span style=display:flex><span>        ...
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>        ...
</span></span><span style=display:flex><span>        <span style=color:#75715e>/*-----------------------Homework for Memory Management------------------------*/</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// No longer needed for HW3
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>//bool debugUserProg;		// single step user program
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>/*-----------------------Homework for Memory Management------------------------*/</span>
</span></span><span style=display:flex><span>        Thread<span style=color:#f92672>*</span> t[<span style=color:#ae81ff>10</span>];
</span></span><span style=display:flex><span>        ...
</span></span><span style=display:flex><span>};
</span></span></code></pre></div></li><li><p><strong><code>/code/userprog/userkernel.cc</code></strong>
Initialize <code>SwapDisk</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>void</span> UserProgKernel<span style=color:#f92672>::</span>Initialize()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#75715e>/*-----------------------Homework for Memory Management------------------------*/</span>
</span></span><span style=display:flex><span>    ThreadedKernel<span style=color:#f92672>::</span>Initialize(RR);
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Initialized SwapDisk
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    machine <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Machine(debugUserProg);
</span></span><span style=display:flex><span>    fileSystem <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> FileSystem();
</span></span><span style=display:flex><span>    SwapDisk <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> SynchDisk(<span style=color:#e6db74>&#34;New SwapDisk&#34;</span>);<span style=color:#75715e>// Swap disk for virtual memory
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>#ifdef FILESYS
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        synchDisk <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> SynchDisk(<span style=color:#e6db74>&#34;New SynchDisk&#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#75715e>#endif </span><span style=color:#75715e>// FILESYS
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>/*-----------------------Homework for Memory Management------------------------*/</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> UserProgKernel<span style=color:#f92672>::</span>Initialize(SchedulerType type)<span style=color:#75715e>//
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>{
</span></span><span style=display:flex><span>    ...
</span></span><span style=display:flex><span>    <span style=color:#75715e>/*-----------------------Homework for Memory Management------------------------*/</span>
</span></span><span style=display:flex><span>    SwapDisk <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> SynchDisk(<span style=color:#e6db74>&#34;New SwapDisk&#34;</span>);<span style=color:#75715e>// Swap disk for virtual memory
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>/*-----------------------Homework for Memory Management------------------------*/</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>#ifdef FILESYS
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    ...
</span></span><span style=display:flex><span>};
</span></span></code></pre></div></li><li><p><strong><code>/code/machine/machine.h</code></strong>
Defined lots of variable in <code>Machine</code> class contained <code>UsedPhyPage</code> to record whether the physical memory is used or not, <code>UsedVirtualPage</code> to record whether the virtual memory is used or not, etc.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Instruction</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Interrupt</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Machine</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>        ...
</span></span><span style=display:flex><span>        TranslationEntry <span style=color:#f92672>*</span>pageTable;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>int</span> pageTableSize;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>bool</span> <span style=color:#a6e22e>ReadMem</span>(<span style=color:#66d9ef>int</span> addr, <span style=color:#66d9ef>int</span> size, <span style=color:#66d9ef>int</span><span style=color:#f92672>*</span> value);
</span></span><span style=display:flex><span>        <span style=color:#75715e>/*-----------------------Homework for Memory Management------------------------*/</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>bool</span> UsedPhyPage[NumPhysPages]; <span style=color:#75715e>//record the pages in the main memory
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>bool</span> UsedVirtualPage[NumPhysPages]; <span style=color:#75715e>//record the pages in the virtual memory
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>int</span> ID_number; <span style=color:#75715e>// machine ID
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>int</span> PhyPageInfo[NumPhysPages]; <span style=color:#75715e>//record physical page info (ID)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        TranslationEntry <span style=color:#f92672>*</span>main_tab[NumPhysPages]; <span style=color:#75715e>// pagetable
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>/*-----------------------Homework for Memory Management------------------------*/</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>        ...
</span></span><span style=display:flex><span>};
</span></span></code></pre></div></li><li><p><strong><code>/code/userprog/addrspace.cc</code></strong></p><ul><li><p>In line <font color=#FF0000><code>45</code></font></p><blockquote><p>Since we are handling virtual memory, the ASSERT to guarantee the number of pages does not exceed the number of physical pages in main memory in <code>/code/userprog/addrspace.cc</code> is no longer needed. - by <a href=https://github.com/pai4451/OS2020/tree/main/project3>pai445</a></p></blockquote></li><li><p>The <code>for</code> loop in line <font color=#FF0000><code>79</code></font> is used to find an available page for current process. The <code>while</code> loop in line <font color=#FF0000><code>82</code></font> is as similar as <code>project2</code> that used variable <code>j</code> to find free memory page.</p><blockquote><p>There are two different cases in the following. When the <strong>main memory still have empty frame</strong>, then we can put the page into the main memory and update the information to the page table. This step is achieved by the function <strong><code>ReadAt</code></strong>. The other case will be the <strong>main memory is fulled</strong>. Then we have check the available virtual memory space by the similar while loop and write the page in to <code>SwapDisk</code> by the <code>WriteSector</code> function. - by <a href=https://github.com/pai4451/OS2020/tree/main/project3>pai445</a></p></blockquote></li><li><p><code>Execute</code> function in line <font color=#FF0000><code>135</code></font> and <code>SaveState</code> in line <font color=#FF0000><code>147</code></font>
We use a flag, <code>pageTable_is_load</code>, defined in <code>/code/userprog/addrspace.h</code> to check whether the page table is successfully loaded to make the context-switch work.</p></li></ul><pre tabindex=0><code class="language-cpp=1" data-lang="cpp=1">#define PAGE_OCCU true
#define PAGE_FREE false
/*-----------------------Homework for Memory Management------------------------*/
// There&#39;s no longer needed in HW3
// bool AddrSpace::PhyPageStatus[NumPhysPages] = {PAGE_FREE};
// int AddrSpace::NumFreePages = NumPhysPages;
/*-----------------------Homework for Memory Management------------------------*/
AddrSpace::AddrSpace()
{
    /*-----------------------Homework for Memory Management------------------------*/
    ID=(kernel-&gt;machine-&gt;ID_number)++;
    kernel-&gt;machine-&gt;ID_number=(kernel-&gt;machine-&gt;ID_number)++;
    /*-----------------------Homework for Memory Management------------------------*/
    ...
}

AddrSpace::~AddrSpace()
{
    // Free the physical page that this program used
    /*-----------------------Homework for Memory Management------------------------*/
    // No longer needed for HW3
    // for(int i = 0; i &lt; numPages; i++)
    // {
    //     AddrSpace::PhyPageStatus[pageTable[i].physicalPage] = PAGE_FREE;
    //     AddrSpace::NumFreePages++;
    // }
    /*-----------------------Homework for Memory Management------------------------*/
    delete pageTable;
}

bool AddrSpace::Load(char *fileName) 
{
    OpenFile *executable = kernel-&gt;fileSystem-&gt;Open(fileName);
    NoffHeader noffH;
    unsigned int size;

    /*-----------------------Homework for Memory Management------------------------*/
    unsigned int tmp;
    /*-----------------------Homework for Memory Management------------------------*/
    ...
    size = numPages * PageSize;

    /*-----------------------Homework for Memory Management------------------------*/
    /* For HW3 is no longer needed  */
    // ASSERT(numPages &lt;= NumPhysPages);	// check we&#39;re not trying
                                                // to run anything too big --
                                                // at least until we have
                                                // virtual memory

    // Allocate
    pageTable = new TranslationEntry[numPages];
    // No longer needed for HW3
    /*for(unsigned int i = 0, idx = 0; i &lt; numPages; i++)
    {
        pageTable[i].virtualPage = i;
        while(idx &lt; NumPhysPages &amp;&amp; AddrSpace::PhyPageStatus[idx] == PAGE_OCCU) idx++;
        AddrSpace::PhyPageStatus[idx] = PAGE_OCCU;
        AddrSpace::NumFreePages--;
        // Clean the page that&#39;ll be used soon
        bzero(&amp;kernel-&gt;machine-&gt;mainMemory[idx * PageSize], PageSize);
        pageTable[i].physicalPage = idx;
        pageTable[i].valid = true;
        pageTable[i].use = false;
        pageTable[i].dirty = false;
        pageTable[i].readOnly = false;
    }*/
    /*-----------------------Homework for Memory Management------------------------*/

    DEBUG(dbgAddr, &#34;Initializing address space: &#34; &lt;&lt; numPages &lt;&lt; &#34;, &#34; &lt;&lt; size);
    if (noffH.code.size &gt; 0)
    {
        /*-----------------------Homework for Multithread------------------------*/;
        // For HW3 is no longer needed
        // DEBUG(dbgAddr, &#34;Initializing code segment.&#34;);
        // DEBUG(dbgAddr, noffH.code.virtualAddr &lt;&lt; &#34;, &#34; &lt;&lt; noffH.code.size)
        // executable-&gt;ReadAt(&amp;(kernel-&gt;machine-&gt;mainMemory[pageTable[noffH.code.virtualAddr/PageSize].physicalPage * PageSize + (noffH.code.virtualAddr%PageSize)]), noffH.code.size, noffH.code.inFileAddr);
        // executable-&gt;ReadAt(&amp;(kernel-&gt;machine-&gt;mainMemory[noffH.code.virtualAddr]), noffH.code.size, noffH.code.inFileAddr);

        for(unsigned int j=0,i=0;i &lt; numPages ;i++)
        {
            j=0;
            while(kernel-&gt;machine-&gt;UsedPhyPage[j]!=FALSE&amp;&amp;j&lt;NumPhysPages){j++;}

            // main memory is enough, put the page to main memory
            if(j&lt;NumPhysPages)
            {   
                kernel-&gt;machine-&gt;UsedPhyPage[j]=TRUE;
                kernel-&gt;machine-&gt;PhyPageInfo[j]=ID;
                kernel-&gt;machine-&gt;main_tab[j]=&amp;pageTable[i];
                pageTable[i].physicalPage = j;
                pageTable[i].valid = TRUE;
                pageTable[i].use = FALSE;
                pageTable[i].dirty = FALSE;
                pageTable[i].readOnly = FALSE;
                pageTable[i].ID =ID;
                pageTable[i].LRU_counter++; // LRU counter when save in memory
                executable-&gt;ReadAt(&amp;(kernel-&gt;machine-&gt;mainMemory[j*PageSize]),PageSize, noffH.code.inFileAddr+(i*PageSize));
            }
            // main memory is not enough, use virtual memory
            else
            { 
                char *buffer;
                buffer = new char[PageSize];
                tmp=0;
                while(kernel-&gt;machine-&gt;UsedVirtualPage[tmp]!=FALSE){tmp++;}
                kernel-&gt;machine-&gt;UsedVirtualPage[tmp]=true;
                pageTable[i].virtualPage=tmp; //record the virtual page we save 
                pageTable[i].valid = FALSE; //not load in main memory
                pageTable[i].use = FALSE;
                pageTable[i].dirty = FALSE;
                pageTable[i].readOnly = FALSE;
                pageTable[i].ID =ID;
                executable-&gt;ReadAt(buffer,PageSize, noffH.code.inFileAddr+(i*PageSize));
                kernel-&gt;SwapDisk-&gt;WriteSector(tmp,buffer); // write in virtual memory (SwapDisk)
            }
        }
        /*-----------------------Homework for Memory Management------------------------*/
    }
    /*-----------------------Homework for Memory Management------------------------*/
    if (noffH.initData.size &gt; 0)
    {
        // For HW1, it&#39;s needed, but not in HW3
        // DEBUG(dbgAddr, &#34;Initializing data segment.&#34;);
        // DEBUG(dbgAddr, noffH.initData.virtualAddr &lt;&lt; &#34;, &#34; &lt;&lt; noffH.initData.size);
        // executable-&gt;ReadAt(&amp;(kernel-&gt;machine-&gt;mainMemory[pageTable[noffH.initData.virtualAddr/PageSize].physicalPage * PageSize + (noffH.code.virtualAddr%PageSize)]), noffH.initData.size, noffH.initData.inFileAddr);

        // For HW3, it&#39;s needed, but not in HW1
        executable-&gt;ReadAt(&amp;(kernel-&gt;machine-&gt;mainMemory[noffH.initData.virtualAddr]),noffH.initData.size, noffH.initData.inFileAddr);
    }
    /*-----------------------Homework for Memory Management------------------------*/

    delete executable;      // close file
    return TRUE;            // success
}
void AddrSpace::Execute(char *fileName) 
{
    /*-----------------------Homework for Memory Management------------------------*/
    pageTable_is_load=FALSE;
    /*-----------------------Homework for Memory Management------------------------*/
    if (!Load(fileName))
    ...
    /*-----------------------Homework for Memory Management------------------------*/
    pageTable_is_load=TRUE;
    /*-----------------------Homework for Memory Management------------------------*/
    ...
}
void AddrSpace::SaveState() 
{
    /*-----------------------Homework for Memory Management------------------------*/
    if(pageTable_is_load)
    {
        pageTable=kernel-&gt;machine-&gt;pageTable;
        numPages=kernel-&gt;machine-&gt;pageTableSize;
    }
    /*-----------------------Homework for Memory Management------------------------*/
}
</code></pre></li><li><p><strong><code>/code/userprog/addrspace.h</code></strong>
Defined variable <code>ID</code> and <code>pageTable_is_load</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>AddrSpace</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>        ...
</span></span><span style=display:flex><span>        <span style=color:#75715e>/*-----------------------Homework for Memory Management------------------------*/</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> ID;
</span></span><span style=display:flex><span>        <span style=color:#75715e>/*-----------------------Homework for Memory Management------------------------*/</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>        ...
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>int</span> NumFreePages;
</span></span><span style=display:flex><span>        <span style=color:#75715e>/*-----------------------Homework for Memory Management------------------------*/</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>bool</span> pageTable_is_load;
</span></span><span style=display:flex><span>        <span style=color:#75715e>/*-----------------------Homework for Memory Management------------------------*/</span>
</span></span><span style=display:flex><span>};
</span></span></code></pre></div></li></ul><hr><p>Now, the OS can implement that swap the data from main memory to virtual memory when main memory is full. For the following step, we have to implement page replacement algorithms, Least Recently Used (<code>LRU</code>).</p><ul><li><p><strong><code>/code/machine/translate.h</code></strong></p><blockquote><p>We implement by a hardware counter <code>LRU_counter</code> in <code>/code/machine/traslate.h</code>. - by <a href=https://github.com/pai4451/OS2020/tree/main/project3>pai445</a></p></blockquote><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>TranslationEntry</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>        ...
</span></span><span style=display:flex><span>        <span style=color:#75715e>/*-----------------------Homework for Memory Management------------------------*/</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> LRU_counter;    <span style=color:#75715e>// counter for LRU
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>int</span> ID;             <span style=color:#75715e>// page table ID
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>/*-----------------------Homework for Memory Management------------------------*/</span>
</span></span><span style=display:flex><span>};
</span></span></code></pre></div></li><li><p><strong><code>/code/machine/translate.cc</code></strong></p><blockquote><p>First, we check the valid-invalid bit of the page table. If is not valid, it means the page is not in the main memory. Hence, we need to load from the secondary storage. There are two cases that may happen. First, if there are some empty frame in the main memory, then we can just load the page into it. The other case is that the main memory is fulled. In this cases, we create two buffers and runs least recently used (LRU) algorithm to find the victim. The ReadSector and WriteSector are used to read/write the temporarily saved pages found by the LRU algorithm. The victim is pull out from the main memory, and then swapped by our page into the corresponding frame. The page table will be updated correspondingly in both cases. In our implementation, LRU will perform linear search on LRU_counter to find the least recently used page. - by <a href=https://github.com/pai4451/OS2020/tree/main/project3>pai445</a></p></blockquote><ul><li>In previous TA&rsquo;s Project documentation, we used <code>kernel->swap->WriteSector</code> and <code>kernel->swap->ReadSector</code> to store the virtual memory from hard disk(<code>swap</code> is a object of <code>SynchDisk</code>)
Therefore, in line <font color=#FF0000><code>34-35</code></font>, we used <code>ReadSector</code> to read <code>pageTable[vpn].virtualPage</code> and store into the buffer. Then use <code>bcopy</code> function to move byte sequence from <code>src</code>→<code>buffer</code> to <code>dest</code>→<code>&amp;mainMemory[j*PageSize]</code> with <code>size=PageSize</code> only if the main memory is sufficient. <font color=#FF0000><strong>Reference[1]</strong></font></li><li>In line <font color=#FF0000><code>63-66</code></font>. If the main memory is full, then we used <code>LRU</code> algorithm to find the least recently used memory and switch to disk and replace an desired data to main memory. That is, <code>memory section was found by LRU algorithm</code>→<code>buffer1</code>→<code>virtual memory</code> and <code>desired memory section stored in virtual memory</code>→<code>buffer2</code>→<code>main memory</code></li></ul><pre tabindex=0><code class="language-cpp=1" data-lang="cpp=1">ExceptionType Machine::Translate(int virtAddr, int* physAddr, int size, bool writing)
{
    unsigned int pageFrame;
    /*-----------------------Homework for Memory Management------------------------*/
    int victim;///find the page victim
    unsigned int j;
    /*-----------------------Homework for Memory Management------------------------*/
    DEBUG(dbgAddr, &#34;\tTranslate &#34; &lt;&lt; virtAddr &lt;&lt; (writing ? &#34; , write&#34; : &#34; , read&#34;));
    ...
    if (tlb == NULL)
    {		// =&gt; page table =&gt; vpn is index into table
        if (vpn &gt;= pageTableSize){...}
        else if (!pageTable[vpn].valid)
        {
            /*-----------------------Homework for Memory Management------------------------*/
            // For HW3, these two lines are no longer needed
            // DEBUG(dbgAddr, &#34;Invalid virtual page # &#34; &lt;&lt; virtAddr);
            // return PageFaultException;
            kernel-&gt;stats-&gt;numPageFaults++; // page fault
            j=0;
            while(kernel-&gt;machine-&gt;UsedPhyPage[j]!=FALSE&amp;&amp;j&lt;NumPhysPages){j++;}
            // load the page into the main memory if the main memory is not full  
            if(j&lt;NumPhysPages)
            {
                char *buffer; //temporary save page 
                buffer = new char[PageSize];
                kernel-&gt;machine-&gt;UsedPhyPage[j]=TRUE;
                kernel-&gt;machine-&gt;PhyPageInfo[j]=pageTable[vpn].ID;
                kernel-&gt;machine-&gt;main_tab[j]=&amp;pageTable[vpn];
                pageTable[vpn].physicalPage = j;
                pageTable[vpn].valid = TRUE;
                pageTable[vpn].LRU_counter++; // counter for LRU

                kernel-&gt;SwapDisk-&gt;ReadSector(pageTable[vpn].virtualPage, buffer);
                bcopy(buffer,&amp;mainMemory[j*PageSize],PageSize);
            }
            // main memory is full, page replacement
            else
            {
                char *buffer1;
                char *buffer2;
                buffer1 = new char[PageSize];
                buffer2 = new char[PageSize];
                //Random
                victim = (rand()%32);

                //LRU
                int min = pageTable[0].LRU_counter;
                victim=0;
                for(int index=0;index&lt;32;index++)
                {
                    if(min &gt; pageTable[index].LRU_counter)
                    {
                        min = pageTable[index].LRU_counter;
                        victim = index;
                    }
                }
                pageTable[victim].LRU_counter++;  

                //printf(&#34;Number %d page is swapped out\n&#34;,victim);

                // perform page replacement, write victim frame to disk, read desired frame to memory
                bcopy(&amp;mainMemory[victim*PageSize],buffer1,PageSize);
                kernel-&gt;SwapDisk-&gt;ReadSector(pageTable[vpn].virtualPage, buffer2);
                bcopy(buffer2,&amp;mainMemory[victim*PageSize],PageSize);
                kernel-&gt;SwapDisk-&gt;WriteSector(pageTable[vpn].virtualPage,buffer1);

                main_tab[victim]-&gt;virtualPage=pageTable[vpn].virtualPage;
                main_tab[victim]-&gt;valid=FALSE;

                //save the page into the main memory

                pageTable[vpn].valid = TRUE;
                pageTable[vpn].physicalPage=victim;
                kernel-&gt;machine-&gt;PhyPageInfo[victim]=pageTable[vpn].ID;
                main_tab[victim]=&amp;pageTable[vpn];
                //printf(&#34;Page replacement finish\n&#34;);
            }
            /*-----------------------Homework for Memory Management------------------------*/
        }
        entry = &amp;pageTable[vpn];
    }
    ...
}   
</code></pre></li></ul><h2 id=result>Result
<a class=anchor href=#result>#</a></h2><p><strong><code>./nachos -e ../test/sort</code></strong>
<img src=https://imgur.com/C06Bto8.png alt="result of sort">
<strong><code>./nachos -e ../test/matmult</code></strong>
<img src=https://imgur.com/LSu6qHu.png alt="result of matmult">
<strong><code>./nachos -e ../test/matmult -e ../test/sort</code></strong>
<img src=https://imgur.com/3TTnCoa.png alt="result of matmult and sort"></p><h2 id=reference>Reference
<a class=anchor href=#reference>#</a></h2><ul><li><a href=https://github.com/pai4451/OS2020>github/pai4451</a></li><li><a href=https://github.com/wangssuming/nachos-NTU>github/wangssuming</a></li><li><a href=https://man7.org/linux/man-pages/man3/bcopy.3.html>[1]</a> Supplementary Note for <code>bcopy</code></li></ul></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><ul><li></li></ul></li><li><a href=#description-first>Description First</a></li><li><a href=#motivation>Motivation</a></li><li><a href=#implementation>Implementation</a></li><li><a href=#result>Result</a></li><li><a href=#reference>Reference</a></li></ul></nav></div></aside></main></body></html>