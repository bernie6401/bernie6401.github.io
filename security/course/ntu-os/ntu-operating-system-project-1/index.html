<!doctype html><html lang=en-us dir=ltr><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content='
  NTU Operating System Project 1
  #


  tags: NTU_OS Operating System NachOS Thread Management
  #

:::spoiler
[TOC]
:::

  How to parse this project
  #


You can research userkernel.cc file first. UserProgKernel will parse the command line and store the file you want to execute in execfile variable which defined at userkernel.h.

Then you&rsquo;ll find something interesting.

ForkExecute(Thread *t)
{t->space->Execute(t->getName());}
// space and getName() are defined at thread.h
// Execute is defined at addrspace.h

This is what we&rsquo;ve learned on lecture that it&rsquo;ll clone a child process and execute the same program as parent process just like a multi-thread.
Next, you can observe Run() function

void
UserProgKernel::Run()
{
	cout << "Total threads number is " << execfileNum << endl;
	for (int n=1;n<=execfileNum;n++)
	{
		t[n] = new Thread(execfile[n]);
		t[n]->space = new AddrSpace();
		t[n]->Fork((VoidFunctionPtr) &amp;ForkExecute, (void *)t[n]);
		cout << "Thread " << execfile[n] << " is executing." << endl;
	}
	ThreadedKernel::Run();
}

Review a very simple concept: Process Representation in Linux

// Represented by the C structure task_struct
pid t pid; /* process identifier */
long state; /* state of the process */
unsigned int time slice /* scheduling information */
struct task struct *parent; /* this process’s parent */
struct list head children; /* this process’s children */
struct files struct *files; /* list of open files */
struct mm struct *mm; /* address space of this process */

Another related concept is Process Creation

Address space

Child duplicate of parent
Child has a program loaded into it


UNIX examples

fork() system call creates new process
exec() system call used after a fork() to replace the process’ memory space with a new program





After reviewing the concept above, we can continue to answer next question(Please follow the next section -> Q2)


  Project Q&amp;A
  #


Q1: Why the result is not congruent with expected?

Because OS has multi-thread concept like the code above and it&rsquo;ll fork child process. When more than 1 process be executed simultaneously without any precondition, it&rsquo;ll happend what we unexpected. And the precondition or you can say the real problem in this case is context switching which is the progress between preocesses switching by CPU.


Q2: How to solve the issue?(You can include some code and explain it)

According to the previous question, NachOS didn&rsquo;t manage memory for executing multi program and this&rsquo;ll cause the current program&rsquo;s page overlap to the others running program.
Thus, we have to revise these two program and let the program&rsquo;s virtual memory map to the real memory that no one used.
code/userprog/addrspace.cc
code/userprog/addrspace.h




Add the code in addrspace.cc at the beginning to stored the usage of all physical pages and stored how many free pages can be used now.'><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#343a40"><meta name=color-scheme content="light dark"><meta property="og:url" content="https://bernie6401.github.io/security/course/ntu-os/ntu-operating-system-project-1/"><meta property="og:site_name" content="SBK Hugo Site"><meta property="og:title" content="NTU Operating System Project 1"><meta property="og:description" content='NTU Operating System Project 1 # tags: NTU_OS Operating System NachOS Thread Management # :::spoiler [TOC] :::
How to parse this project # You can research userkernel.cc file first. UserProgKernel will parse the command line and store the file you want to execute in execfile variable which defined at userkernel.h. Then you’ll find something interesting. ForkExecute(Thread *t) {t->space->Execute(t->getName());} // space and getName() are defined at thread.h // Execute is defined at addrspace.h This is what we’ve learned on lecture that it’ll clone a child process and execute the same program as parent process just like a multi-thread. Next, you can observe Run() function void UserProgKernel::Run() { cout << "Total threads number is " << execfileNum << endl; for (int n=1;n<=execfileNum;n++) { t[n] = new Thread(execfile[n]); t[n]->space = new AddrSpace(); t[n]->Fork((VoidFunctionPtr) &amp;ForkExecute, (void *)t[n]); cout << "Thread " << execfile[n] << " is executing." << endl; } ThreadedKernel::Run(); } Review a very simple concept: Process Representation in Linux // Represented by the C structure task_struct pid t pid; /* process identifier */ long state; /* state of the process */ unsigned int time slice /* scheduling information */ struct task struct *parent; /* this process’s parent */ struct list head children; /* this process’s children */ struct files struct *files; /* list of open files */ struct mm struct *mm; /* address space of this process */ Another related concept is Process Creation Address space Child duplicate of parent Child has a program loaded into it UNIX examples fork() system call creates new process exec() system call used after a fork() to replace the process’ memory space with a new program After reviewing the concept above, we can continue to answer next question(Please follow the next section -> Q2) Project Q&amp;A # Q1: Why the result is not congruent with expected? Because OS has multi-thread concept like the code above and it’ll fork child process. When more than 1 process be executed simultaneously without any precondition, it’ll happend what we unexpected. And the precondition or you can say the real problem in this case is context switching which is the progress between preocesses switching by CPU. Q2: How to solve the issue?(You can include some code and explain it) According to the previous question, NachOS didn’t manage memory for executing multi program and this’ll cause the current program’s page overlap to the others running program. Thus, we have to revise these two program and let the program’s virtual memory map to the real memory that no one used. code/userprog/addrspace.cc code/userprog/addrspace.h Add the code in addrspace.cc at the beginning to stored the usage of all physical pages and stored how many free pages can be used now.'><meta property="og:locale" content="en_us"><meta property="og:type" content="article"><meta property="article:section" content="security"><meta property="article:tag" content="NTU_OS"><meta property="article:tag" content="NTU"><title>NTU Operating System Project 1 | SBK Hugo Site</title>
<link rel=icon href=/favicon.png><link rel=manifest href=/manifest.json><link rel=canonical href=https://bernie6401.github.io/security/course/ntu-os/ntu-operating-system-project-1/><link rel=stylesheet href=/book.min.6c8b9d2a1fc95075ed7da46ca81060b39add8fff6741ac51259f768929281e2c.css integrity="sha256-bIudKh/JUHXtfaRsqBBgs5rdj/9nQaxRJZ92iSkoHiw=" crossorigin=anonymous><script defer src=/fuse.min.js></script><script defer src=/en.search.min.acdc41c8d39e6c69d70d8a23779875e0a3733fefead3e428d5344966bb12f562.js integrity="sha256-rNxByNOebGnXDYojd5h14KNzP+/q0+Qo1TRJZrsS9WI=" crossorigin=anonymous></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/><span>SBK Hugo Site</span></a></h2><div class="book-search hidden"><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><script>document.querySelector(".book-search").classList.remove("hidden")</script></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu></label><h3>NTU Operating System Project 1</h3><label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><ul><li></li></ul></li><li><a href=#how-to-parse-this-project>How to parse this project</a></li><li><a href=#project-qa>Project Q&amp;A</a></li><li><a href=#reference>Reference</a></li></ul></nav></aside></header><article class="markdown book-article"><h1 id=ntu-operating-system-project-1>NTU Operating System Project 1
<a class=anchor href=#ntu-operating-system-project-1>#</a></h1><h6 id=tags-ntu_os-operating-system-nachos-thread-management>tags: <code>NTU_OS</code> <code>Operating System</code> <code>NachOS</code> <code>Thread Management</code>
<a class=anchor href=#tags-ntu_os-operating-system-nachos-thread-management>#</a></h6><p>:::spoiler
[TOC]
:::</p><h2 id=how-to-parse-this-project>How to parse this project
<a class=anchor href=#how-to-parse-this-project>#</a></h2><ul><li>You can research userkernel.cc file first. UserProgKernel will parse the command line and store the file you want to execute in execfile variable which defined at userkernel.h.
<img src=https://imgur.com/n73Z19F.png alt="parse command line"></li><li>Then you&rsquo;ll find something interesting.</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span>ForkExecute(Thread <span style=color:#f92672>*</span>t)
</span></span><span style=display:flex><span>{t<span style=color:#f92672>-&gt;</span>space<span style=color:#f92672>-&gt;</span>Execute(t<span style=color:#f92672>-&gt;</span>getName());}
</span></span><span style=display:flex><span><span style=color:#75715e>// space and getName() are defined at thread.h
</span></span></span><span style=display:flex><span><span style=color:#75715e>// Execute is defined at addrspace.h
</span></span></span></code></pre></div><ul><li>This is what we&rsquo;ve learned on lecture that it&rsquo;ll clone a child process and execute the same program as parent process just like a multi-thread.</li><li>Next, you can observe Run() function</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#66d9ef>void</span>
</span></span><span style=display:flex><span>UserProgKernel<span style=color:#f92672>::</span>Run()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;Total threads number is &#34;</span> <span style=color:#f92672>&lt;&lt;</span> execfileNum <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> n<span style=color:#f92672>=</span><span style=color:#ae81ff>1</span>;n<span style=color:#f92672>&lt;=</span>execfileNum;n<span style=color:#f92672>++</span>)
</span></span><span style=display:flex><span>	{
</span></span><span style=display:flex><span>		t[n] <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Thread(execfile[n]);
</span></span><span style=display:flex><span>		t[n]<span style=color:#f92672>-&gt;</span>space <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> AddrSpace();
</span></span><span style=display:flex><span>		t[n]<span style=color:#f92672>-&gt;</span>Fork((VoidFunctionPtr) <span style=color:#f92672>&amp;</span>ForkExecute, (<span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>)t[n]);
</span></span><span style=display:flex><span>		cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;Thread &#34;</span> <span style=color:#f92672>&lt;&lt;</span> execfile[n] <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34; is executing.&#34;</span> <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	ThreadedKernel<span style=color:#f92672>::</span>Run();
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>Review a very simple concept: Process Representation in Linux</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#75715e>// Represented by the C structure task_struct
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>pid t pid; <span style=color:#75715e>/* process identifier */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>long</span> state; <span style=color:#75715e>/* state of the process */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>int</span> time slice <span style=color:#75715e>/* scheduling information */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>task</span> <span style=color:#66d9ef>struct</span> <span style=color:#960050;background-color:#1e0010>*</span><span style=color:#a6e22e>parent</span>; <span style=color:#75715e>/* this process’s parent */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>list</span> head children; <span style=color:#75715e>/* this process’s children */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>files</span> <span style=color:#66d9ef>struct</span> <span style=color:#960050;background-color:#1e0010>*</span><span style=color:#a6e22e>files</span>; <span style=color:#75715e>/* list of open files */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>mm</span> <span style=color:#66d9ef>struct</span> <span style=color:#960050;background-color:#1e0010>*</span><span style=color:#a6e22e>mm</span>; <span style=color:#75715e>/* address space of this process */</span>
</span></span></code></pre></div><ul><li>Another related concept is <strong>Process Creation</strong><ul><li>Address space<ul><li>Child duplicate of parent</li><li>Child has a program loaded into it</li></ul></li><li>UNIX examples<ul><li>fork() system call creates new process</li><li>exec() system call used after a fork() to replace the process’ memory space with a new program
<img src=https://imgur.com/ClBK9bA.png alt="process creation"></li></ul></li></ul></li><li>After reviewing the concept above, we can continue to answer next question(Please follow the next section -> Q2)</li></ul><h2 id=project-qa>Project Q&amp;A
<a class=anchor href=#project-qa>#</a></h2><ul><li>Q1: Why the result is not congruent with expected?<ul><li>Because OS has multi-thread concept like the code above and it&rsquo;ll fork child process. When more than 1 process be executed simultaneously without any precondition, it&rsquo;ll happend what we unexpected. And the precondition or you can say the real problem in this case is context switching which is the progress between preocesses switching by CPU.</li></ul></li><li>Q2: How to solve the issue?(You can include some code and explain it)<ul><li>According to the previous question, NachOS didn&rsquo;t manage memory for executing multi program and this&rsquo;ll cause the current program&rsquo;s page overlap to the others running program.</li><li>Thus, we have to revise these two program and let the program&rsquo;s virtual memory map to the real memory that no one used.<pre tabindex=0><code>code/userprog/addrspace.cc
code/userprog/addrspace.h
</code></pre></li></ul><ol><li><p>Add the code in addrspace.cc at the beginning to stored the usage of all physical pages and stored how many free pages can be used now.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#75715e>#define PAGE_OCCU true
</span></span></span><span style=display:flex><span><span style=color:#75715e>#define PAGE_FREE false
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>bool</span> AddrSpace<span style=color:#f92672>::</span>PhyPageStatus[NumPhysPages] <span style=color:#f92672>=</span> {PAGE_FREE};
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> AddrSpace<span style=color:#f92672>::</span>NumFreePages <span style=color:#f92672>=</span> NumPhysPages;
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>AddrSpace</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    ...
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>        ...
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>bool</span> PhyPageStatus[NumPhysPages]; <span style=color:#75715e>//stored the usage of all physical pages
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>int</span> NumFreePages; <span style=color:#75715e>//stored how many free pages can be used now
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div></li><li><p>Take off unnecessary mapping</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span>AddrSpace<span style=color:#f92672>::</span>AddrSpace()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li><li><p>Allocate Physical Pages - Revise at addrspace.cc AddrSpace::Load function</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#75715e>// SBK: Verify if there is enough space page
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>ASSERT(numPages <span style=color:#f92672>&lt;=</span> NumPhysPages);		<span style=color:#75715e>// check we&#39;re not trying to run anything too big -- at least until we have virtual memory
</span></span></span><span style=display:flex><span><span style=color:#75715e>// Allocate
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>pageTable <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> TranslationEntry[numPages];
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>, idx <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> numPages; i<span style=color:#f92672>++</span>)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    pageTable[i].virtualPage <span style=color:#f92672>=</span> i;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span>(idx <span style=color:#f92672>&lt;</span> NumPhysPages <span style=color:#f92672>&amp;&amp;</span> AddrSpace<span style=color:#f92672>::</span>PhyPageStatus[idx] <span style=color:#f92672>==</span> PAGE_OCCU) idx<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>    AddrSpace<span style=color:#f92672>::</span>PhyPageStatus[idx] <span style=color:#f92672>=</span> PAGE_OCCU;
</span></span><span style=display:flex><span>    AddrSpace<span style=color:#f92672>::</span>NumFreePages<span style=color:#f92672>--</span>;
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Clean the page that&#39;ll be used soon
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    bzero(<span style=color:#f92672>&amp;</span>kernel<span style=color:#f92672>-&gt;</span>machine<span style=color:#f92672>-&gt;</span>mainMemory[idx <span style=color:#f92672>*</span> PageSize], PageSize);
</span></span><span style=display:flex><span>    pageTable[i].physicalPage <span style=color:#f92672>=</span> idx;
</span></span><span style=display:flex><span>    pageTable[i].valid <span style=color:#f92672>=</span> true;
</span></span><span style=display:flex><span>    pageTable[i].use <span style=color:#f92672>=</span> false;
</span></span><span style=display:flex><span>    pageTable[i].dirty <span style=color:#f92672>=</span> false;
</span></span><span style=display:flex><span>    pageTable[i].readOnly <span style=color:#f92672>=</span> false;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li><li><p>Change Reading Position - Revise at addrspace.cc AddrSpace::Load function</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#75715e>// then, copy in the code and data segments into memory
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>if</span> (noffH.code.size <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    DEBUG(dbgAddr, <span style=color:#e6db74>&#34;Initializing code segment.&#34;</span>);
</span></span><span style=display:flex><span>    DEBUG(dbgAddr, noffH.code.virtualAddr <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;, &#34;</span> <span style=color:#f92672>&lt;&lt;</span> noffH.code.size);
</span></span><span style=display:flex><span>    executable<span style=color:#f92672>-&gt;</span>ReadAt(<span style=color:#f92672>&amp;</span>(kernel<span style=color:#f92672>-&gt;</span>machine<span style=color:#f92672>-&gt;</span>mainMemory[pageTable[noffH.code.virtualAddr<span style=color:#f92672>/</span>PageSize].physicalPage <span style=color:#f92672>*</span> PageSize <span style=color:#f92672>+</span> (noffH.code.virtualAddr<span style=color:#f92672>%</span>PageSize)]), noffH.code.size, noffH.code.inFileAddr);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> (noffH.initData.size <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    DEBUG(dbgAddr, <span style=color:#e6db74>&#34;Initializing data segment.&#34;</span>);
</span></span><span style=display:flex><span>    DEBUG(dbgAddr, noffH.initData.virtualAddr <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;, &#34;</span> <span style=color:#f92672>&lt;&lt;</span> noffH.initData.size);
</span></span><span style=display:flex><span>    executable<span style=color:#f92672>-&gt;</span>ReadAt(<span style=color:#f92672>&amp;</span>(kernel<span style=color:#f92672>-&gt;</span>machine<span style=color:#f92672>-&gt;</span>mainMemory[pageTable[noffH.initData.virtualAddr<span style=color:#f92672>/</span>PageSize].physicalPage <span style=color:#f92672>*</span> PageSize <span style=color:#f92672>+</span> (noffH.code.virtualAddr<span style=color:#f92672>%</span>PageSize)]), noffH.initData.size, noffH.initData.inFileAddr);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>When the process is loaded in memory, we must fill in the physicalPage corresponding to pageTable[]. We used linear time to search the first free page and fill it in.
When load it successfully, we can start to execute then we must compute the entry point which is main memory address.
First, computing which pages(i-th page) and times <code>PageSize</code> equals <strong>page base</strong>.
Second, <strong>page offset</strong> is <code>code.address % PageSize</code>
Finally, <code>the entry point = page base + page offset</code></p></li><li><p>Free Physical Pages</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#75715e>// Free the physical page that this program used
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> numPages; i<span style=color:#f92672>++</span>)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    AddrSpace<span style=color:#f92672>::</span>PhyPageStatus[pageTable[i].physicalPage] <span style=color:#f92672>=</span> PAGE_FREE;
</span></span><span style=display:flex><span>    AddrSpace<span style=color:#f92672>::</span>NumFreePages<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>delete</span> pageTable;
</span></span></code></pre></div></li></ol></li><li>Q3: Experiment result
*<img src=https://imgur.com/JpvtWbW.png alt="experiment result"></li><li>Q4: Discussion
■ The most difficaulty that I encountered is previewing most of the background knowledge to complete this project. Most of these knowlege have not been taught yet, so I must be self-learning.</li></ul><h2 id=reference>Reference
<a class=anchor href=#reference>#</a></h2><ul><li><a href=http://blog.terrynini.tw/tw/OS-NachOS-HW1/>page1</a></li><li><a href=https://morris821028.github.io/2014/05/24/lesson/hw-nachos4/>page2</a></li></ul></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><ul><li></li></ul></li><li><a href=#how-to-parse-this-project>How to parse this project</a></li><li><a href=#project-qa>Project Q&amp;A</a></li><li><a href=#reference>Reference</a></li></ul></nav></div></aside></main></body></html>