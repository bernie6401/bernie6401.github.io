<!doctype html><html lang=en-us dir=ltr><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="
  NTU Operating System Review Notes
  #


  tags: NTU_OS Operating System
  #

[TOC]

  Ch 6 Synchronization
  #


  Process communication
  #



  Race condition
  #

就是Project1提到的共享記憶體的問題，導致multi-thread執行的結果會完全錯誤

解決策略

Disable interrupt
process在對shared memory進行變數存取之前，先disable interrupt，直到完成此次存取後才enable，這樣的話這段時間，CPU就不會被其他processes搶走(preempted)
Critical section design
必須滿足三個criteria

Mutual exclusion: 在任何時間點，最多只允許一個process在他自己的CS內活動，不可同時有多個process在各自的CS內活動
Progress: 如果有人想進去CS，遲早進的去
Bounded waiting: 在一定時間內一定進的去


架構圖

spinlock
busy waiting




  Critical section design的方法
  #


Software solution

兩個processes

Peterson&rsquo;s solution: 有turn和flag兩個變數，分別代表目前的token在誰手上(turn)，以及表示有無意願進入CS(flag)


N個processes

Bakery&rsquo;s ALG: 就是領號碼牌，號碼最小的人優先，若同時有多人持有相同的號碼牌，則以PID最小的優先




Hardware 指令支援
OS提出了mutex lock的概念，並用acquire()和release()的方法實踐
Semaphore

一種可以解決CS design和processes synchronization problem的data type，會提供兩個atomic operations: wait(s)和signal(s)
wait(s): while(s<=0) {do nothing;}s--;
signal(s): s++
簡單來說，s就是看現在可以使用的資源有多少(例如有多少台printer)，如果資源被分出去一個，s就減一，如果都沒有資源了，就一直等待，直到有人釋放資源，釋放資源的時候，s就會加一，所以和前面提到的mutex lock幾乎一樣，wait(s)就是acquire()，而signal(s)就是release()
Semaphore的種類

有使用busy-waiting: spinlock semaphore:其實就是上面說的mutex lock和正常semaphore的概念
沒有使用busy-waiting: Non-Busy-Waiting semaphore: 看講義




Monitor
用來解決synchronization problem的高階資料結構
其實就是物件導向的方式，利用private、initialization等方式，創造monitor這個class object


  Message Passing技術
  #

"><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#343a40"><meta name=color-scheme content="light dark"><meta property="og:url" content="https://bernie6401.github.io/security/course/ntu-os/ntu-operating-system-review-notes/"><meta property="og:site_name" content="SBK Hugo Site"><meta property="og:title" content="NTU Operating System Review Notes"><meta property="og:description" content="NTU Operating System Review Notes # tags: NTU_OS Operating System # [TOC]
Ch 6 Synchronization # Process communication # Race condition # 就是Project1提到的共享記憶體的問題，導致multi-thread執行的結果會完全錯誤
解決策略 Disable interrupt process在對shared memory進行變數存取之前，先disable interrupt，直到完成此次存取後才enable，這樣的話這段時間，CPU就不會被其他processes搶走(preempted) Critical section design 必須滿足三個criteria Mutual exclusion: 在任何時間點，最多只允許一個process在他自己的CS內活動，不可同時有多個process在各自的CS內活動 Progress: 如果有人想進去CS，遲早進的去 Bounded waiting: 在一定時間內一定進的去 架構圖 spinlock busy waiting Critical section design的方法 # Software solution 兩個processes Peterson’s solution: 有turn和flag兩個變數，分別代表目前的token在誰手上(turn)，以及表示有無意願進入CS(flag) N個processes Bakery’s ALG: 就是領號碼牌，號碼最小的人優先，若同時有多人持有相同的號碼牌，則以PID最小的優先 Hardware 指令支援 OS提出了mutex lock的概念，並用acquire()和release()的方法實踐 Semaphore 一種可以解決CS design和processes synchronization problem的data type，會提供兩個atomic operations: wait(s)和signal(s) wait(s): while(s<=0) {do nothing;}s--; signal(s): s++ 簡單來說，s就是看現在可以使用的資源有多少(例如有多少台printer)，如果資源被分出去一個，s就減一，如果都沒有資源了，就一直等待，直到有人釋放資源，釋放資源的時候，s就會加一，所以和前面提到的mutex lock幾乎一樣，wait(s)就是acquire()，而signal(s)就是release() Semaphore的種類 有使用busy-waiting: spinlock semaphore:其實就是上面說的mutex lock和正常semaphore的概念 沒有使用busy-waiting: Non-Busy-Waiting semaphore: 看講義 Monitor 用來解決synchronization problem的高階資料結構 其實就是物件導向的方式，利用private、initialization等方式，創造monitor這個class object Message Passing技術 #"><meta property="og:locale" content="en_us"><meta property="og:type" content="article"><meta property="article:section" content="security"><meta property="article:tag" content="NTU_OS"><meta property="article:tag" content="NTU"><title>NTU Operating System Review Notes | SBK Hugo Site</title>
<link rel=icon href=/favicon.png><link rel=manifest href=/manifest.json><link rel=canonical href=https://bernie6401.github.io/security/course/ntu-os/ntu-operating-system-review-notes/><link rel=stylesheet href=/book.min.6c8b9d2a1fc95075ed7da46ca81060b39add8fff6741ac51259f768929281e2c.css integrity="sha256-bIudKh/JUHXtfaRsqBBgs5rdj/9nQaxRJZ92iSkoHiw=" crossorigin=anonymous><script defer src=/fuse.min.js></script><script defer src=/en.search.min.acdc41c8d39e6c69d70d8a23779875e0a3733fefead3e428d5344966bb12f562.js integrity="sha256-rNxByNOebGnXDYojd5h14KNzP+/q0+Qo1TRJZrsS9WI=" crossorigin=anonymous></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/><span>SBK Hugo Site</span></a></h2><div class="book-search hidden"><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><script>document.querySelector(".book-search").classList.remove("hidden")</script></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu></label><h3>NTU Operating System Review Notes</h3><label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><ul><li></li></ul></li><li><a href=#ch-6-synchronization>Ch 6 Synchronization</a><ul><li><a href=#process-communication>Process communication</a></li></ul></li><li><a href=#ch-7-deadlock>Ch 7 Deadlock</a><ul><li><a href=#形成deadlock的必要條件>形成deadlock的必要條件</a></li><li><a href=#處理方式>處理方式</a></li></ul></li><li><a href=#ch-8-memory-management-strategies>Ch 8 Memory Management Strategies</a><ul><li><a href=#contiguous-memory-management>Contiguous Memory Management</a></li><li><a href=#external--internal-fragmentation>External & Internal Fragmentation</a></li><li><a href=#page-memory-management>Page memory Management</a></li><li><a href=#segment-memory-management>Segment Memory Management</a></li></ul></li><li><a href=#ch-9-virtual-memory-management>Ch 9 Virtual-Memory Management</a><ul><li><a href=#demand-paging>Demand Paging</a></li><li><a href=#page-fault處理>Page fault處理</a></li><li><a href=#effective-memory-access-time計算>Effective memory access time計算</a></li><li><a href=#page-replacement>Page Replacement</a></li><li><a href=#thrashing及解決方法>Thrashing及解決方法</a></li></ul></li><li><a href=#超重要的總結><strong>超重要的總結</strong></a></li></ul></nav></aside></header><article class="markdown book-article"><h1 id=ntu-operating-system-review-notes>NTU Operating System Review Notes
<a class=anchor href=#ntu-operating-system-review-notes>#</a></h1><h6 id=tags-ntu_os-operating-system>tags: <code>NTU_OS</code> <code>Operating System</code>
<a class=anchor href=#tags-ntu_os-operating-system>#</a></h6><p>[TOC]</p><h2 id=ch-6-synchronization>Ch 6 Synchronization
<a class=anchor href=#ch-6-synchronization>#</a></h2><h3 id=process-communication>Process communication
<a class=anchor href=#process-communication>#</a></h3><p><img src=https://imgur.com/zQM1oNq.png alt></p><h4 id=race-condition>Race condition
<a class=anchor href=#race-condition>#</a></h4><p>就是Project1提到的共享記憶體的問題，導致multi-thread執行的結果會完全錯誤</p><ul><li>解決策略<ul><li>Disable interrupt
process在對shared memory進行變數存取之前，先disable interrupt，直到完成此次存取後才enable，這樣的話這段時間，CPU就不會被其他processes搶走(preempted)</li><li>Critical section design
必須滿足三個criteria<ul><li>Mutual exclusion: 在任何時間點，最多只允許一個process在他自己的CS內活動，不可同時有多個process在各自的CS內活動</li><li>Progress: 如果有人想進去CS，遲早進的去</li><li>Bounded waiting: 在一定時間內一定進的去</li></ul></li><li>架構圖
<img src=https://imgur.com/q1iDFSC.png alt></li><li>spinlock</li><li>busy waiting</li></ul></li></ul><h4 id=critical-section-design的方法>Critical section design的方法
<a class=anchor href=#critical-section-design%e7%9a%84%e6%96%b9%e6%b3%95>#</a></h4><ul><li>Software solution<ul><li>兩個processes<ul><li>Peterson&rsquo;s solution: 有turn和flag兩個變數，分別代表目前的token在誰手上(turn)，以及表示有無意願進入CS(flag)</li></ul></li><li>N個processes<ul><li>Bakery&rsquo;s ALG: 就是領號碼牌，號碼最小的人優先，若同時有多人持有相同的號碼牌，則以PID最小的優先</li></ul></li></ul></li><li>Hardware 指令支援</li><li>OS提出了mutex lock的概念，並用acquire()和release()的方法實踐</li><li>Semaphore<ul><li>一種可以解決CS design和processes synchronization problem的data type，會提供兩個atomic operations: wait(s)和signal(s)</li><li>wait(s): <code>while(s&lt;=0) {do nothing;}s--;</code></li><li>signal(s): <code>s++</code></li><li>簡單來說，s就是看現在可以使用的資源有多少(例如有多少台printer)，如果資源被分出去一個，s就減一，如果都沒有資源了，就一直等待，直到有人釋放資源，釋放資源的時候，s就會加一，所以和前面提到的mutex lock幾乎一樣，wait(s)就是acquire()，而signal(s)就是release()</li><li>Semaphore的種類<ul><li>有使用busy-waiting: spinlock semaphore:其實就是上面說的mutex lock和正常semaphore的概念</li><li>沒有使用busy-waiting: Non-Busy-Waiting semaphore: 看講義</li></ul></li></ul></li><li>Monitor
用來解決synchronization problem的高階資料結構
其實就是物件導向的方式，利用private、initialization等方式，創造monitor這個class object</li></ul><h4 id=message-passing技術>Message Passing技術
<a class=anchor href=#message-passing%e6%8a%80%e8%a1%93>#</a></h4><p><img src=https://imgur.com/W7uTjET.png alt></p><ul><li>Direct communication<ul><li>Symmetric: 其實就是TCP的方式</li><li>Asymmetric: 就是UDP的方式</li></ul></li><li>Indirect communication
Sender和receiver是透過shared mailbox建立溝通管道</li></ul><h2 id=ch-7-deadlock>Ch 7 Deadlock
<a class=anchor href=#ch-7-deadlock>#</a></h2><h3 id=形成deadlock的必要條件>形成deadlock的必要條件
<a class=anchor href=#%e5%bd%a2%e6%88%90deadlock%e7%9a%84%e5%bf%85%e8%a6%81%e6%a2%9d%e4%bb%b6>#</a></h3><ul><li>Mutual exclusion
在任何時間點，此類型的資源最多只允許一個process使用，不可多個processes同時持有使用</li><li>Hold & wait
持有部分資源，且又在等待其他Process身上的資源</li><li>No preemption
process不能任意剝奪其他process正在持有的資源，給自己用，要等到對方用完並release後才可以用</li><li>Circular waiting</li></ul><h3 id=處理方式>處理方式
<a class=anchor href=#%e8%99%95%e7%90%86%e6%96%b9%e5%bc%8f>#</a></h3><ul><li>Deadlock Prevention
讓必要的四個條件其中一個不成立即可<ul><li>破除mutual exclusion: 辦不到，因為此性質是大多數資源與生俱來的性質，所以無法破除</li><li>破除Hold & wait:<ul><li>法一: 除非此process能夠一次得到所需的所有資源，否則不能持有資源</li><li>法二: 允許process先持有部分資源，但是一旦process要提出其他資源的申請之前，必須要釋放出所持有的全部資源才可提出申請</li></ul></li><li>破除No preemption: 改為preemptive就可以了</li></ul></li><li>Deadlock Avoidance(Banker&rsquo;s ALG)
就是看提出申請之後，用banker&rsquo;s alg.看有沒有一組逃生通道(safe state)，若有則核准申請</li><li>Deadlock Detection & Recovery<ul><li>Recovery<ul><li>Kill process in the deadlock<ul><li>All process: 成本太高</li><li>先kill一個，再用detection檢查有沒有deadlock，若還有就再repeat，cost很高</li></ul></li><li>Resources preemptive: 選擇一些lower priority的victim process，強行把資源搶過來，再紀錄這些victim是哪些，cost很高</li></ul></li></ul></li><li>ignore deadlock</li></ul><h2 id=ch-8-memory-management-strategies>Ch 8 Memory Management Strategies
<a class=anchor href=#ch-8-memory-management-strategies>#</a></h2><h3 id=contiguous-memory-management>Contiguous Memory Management
<a class=anchor href=#contiguous-memory-management>#</a></h3><p>連續性配置: process必須占用一個連續的記憶體空間，OS用link-list的方式管理free memory block</p><h4 id=配置方法>配置方法
<a class=anchor href=#%e9%85%8d%e7%bd%ae%e6%96%b9%e6%b3%95>#</a></h4><p><img src=https://imgur.com/RSE8mst.png alt></p><ul><li>First-Fit
尋找第一個能容納process的hole</li><li>Best-Fit
尋找size夠小但仍能塞入process的hole，問題是這樣還是有可能會有hole，而這些hole，其他process大機率也是不能用(因為太小了)</li><li>Worst-Fit
找最大的那個hole</li></ul><h3 id=external--internal-fragmentation>External & Internal Fragmentation
<a class=anchor href=#external--internal-fragmentation>#</a></h3><h4 id=external-fragmentation>External Fragmentation
<a class=anchor href=#external-fragmentation>#</a></h4><ul><li>在連續性的配置策略下，全部的hole size加總<strong>大於</strong>要放入的process，但是卻沒有一個hole能夠容納此process就是外部碎裂
<img src=https://imgur.com/yAzl5ty.png alt></li><li>How to solve?<ul><li>compaction的技術(搬移)</li><li>Page Memory management(採取非連續性的配置策略)</li><li>提供多套的base / limit registers for the code section and data section of a process，降低外碎的機率</li></ul></li></ul><h4 id=internal-fragmentation>Internal Fragmentation
<a class=anchor href=#internal-fragmentation>#</a></h4><ul><li>配置給process的空間超過process需求大小，兩者之間的差值就是內部碎裂，這個概念比較直觀，就像前面說的，這樣的hole，對於其他process來說，大機率也是不能用的，形成浪費</li></ul><h3 id=page-memory-management>Page memory Management
<a class=anchor href=#page-memory-management>#</a></h3><p><img src=https://imgur.com/9qCCfyJ.png alt></p><ul><li>優點：沒有external fragmentation，可支援virtual memory的實施</li><li>缺點：有internal fragmentation</li><li><font color=FF0000>利用register或memory或TLB來存取page table</font>
<img src=https://imgur.com/EsOE41W.png alt></li><li>Effective memory access time公式(P is TLB hit ratio)
$P*(TLB time+memory access time) + (1-P)<em>(TLBtime+2</em>memory access time)$</li><li>Page Table Too large solution<ul><li>Hierarchical paging
<img src=https://imgur.com/IUk4mig.png alt></li><li>Hashing page table
<img src=https://imgur.com/luC3A3o.png alt></li><li>Inverted page table
以physical memory為記錄對象，若physical memory有n個frames，則Inverted page table就有n個entry，每個entry紀錄此frame是存放哪個process的哪個page
<img src=https://imgur.com/VYnsfwi.png alt></li></ul></li></ul><h3 id=segment-memory-management>Segment Memory Management
<a class=anchor href=#segment-memory-management>#</a></h3><p>其實就是以原始的logical memory中的每一個segmentation為一單位，當然每一個section的大小都不一樣(例如：code segment/data segment/stack segment等)，並分配到練續性的physical memory(單一一個segment，segment之間不一定要連續)
Kernel會替每個process建立一個segment table，並記錄每個segment的base和limit
<img src=https://imgur.com/7PmNPTl.png alt>
<img src=https://imgur.com/pRkWwOa.png alt></p><p><img src=https://imgur.com/rLgPK6W.png alt></p><h2 id=ch-9-virtual-memory-management>Ch 9 Virtual-Memory Management
<a class=anchor href=#ch-9-virtual-memory-management>#</a></h2><p>主要目的：允許process size在大於free physical memory space的情況下，仍能讓process執行，主要的概念是，我只把一些要用到的部分(目前需要的資源，比方說程式片段或是data)從disk存取到physical memory中，這樣就可以了，如果現在要用的page不在physical memory中，就再從disk中讀取近來</p><h3 id=demand-paging>Demand Paging
<a class=anchor href=#demand-paging>#</a></h3><p>是建立在page memory management的基礎上，為了達到上述的要求，需要在page table中新增一個bit，用來表達此page有沒有在physical memory中
<img src=https://imgur.com/FRTWkX2.png alt></p><h3 id=page-fault處理>Page fault處理
<a class=anchor href=#page-fault%e8%99%95%e7%90%86>#</a></h3><p><img src=https://imgur.com/yPid5OG.png alt></p><h3 id=effective-memory-access-time計算>Effective memory access time計算
<a class=anchor href=#effective-memory-access-time%e8%a8%88%e7%ae%97>#</a></h3><p><img src=https://imgur.com/LYe7SjL.png alt></p><h3 id=page-replacement>Page Replacement
<a class=anchor href=#page-replacement>#</a></h3><p>當page fault發生，且physical memory已經沒有多餘的free frame時，就要做page replacement，也就是找一個苦主，寫回去disk，並把要存取的部分放到memory中</p><ul><li>FIFO: 最早仔入的page就要成為victim page</li><li>OPT(optimal): 會依據未來長期不會用到的page當作victim page</li><li>LRU: 最近不常使用的page就是victim page<ul><li>Counter(假的LRU)</li><li>Stack(真的LRU)</li></ul></li><li>LRU近似作法
此作法會在page table中再增加一個新的bit，表示從上一次page fault到此次page fault中間有無被用過<ul><li>Second chance: 簡單來說，就是從某一個page往下開始找，如果此page的reference bit是1，則變成零，如果原本就是零則當作victim page</li></ul></li><li>LFU & MFU
Lease frequently used & Most frequently used
選擇使用次數最少/多的page當作victim page</li><li>Page buffering
系統保留一個free frame(私房錢)</li></ul><h3 id=thrashing及解決方法>Thrashing及解決方法
<a class=anchor href=#thrashing%e5%8f%8a%e8%a7%a3%e6%b1%ba%e6%96%b9%e6%b3%95>#</a></h3><ol><li>CPU utilization急速下降</li><li>I/O-device 異常忙碌</li><li>Process花在page fault的處理時間遠大於正常執行時間
以上三點滿足就是thrashing
當process分配到的frame數量不足時，則process會經常page fault，需要做page replacement</li></ol><ul><li>How to solve?<ul><li>Decrease multi-programming</li><li>利用page fault frequency控制機制，來限制thrashing
<img src=https://imgur.com/zKC7oCb.png alt></li><li>利用working set model技術，來預估各個process在不同執行時期所需要的frame數量
<img src=https://imgur.com/WXEYCcb.png alt></li></ul></li></ul><h2 id=超重要的總結><strong>超重要的總結</strong>
<a class=anchor href=#%e8%b6%85%e9%87%8d%e8%a6%81%e7%9a%84%e7%b8%bd%e7%b5%90>#</a></h2><p><img src=https://imgur.com/3UQ1OZU.png alt></p></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><ul><li></li></ul></li><li><a href=#ch-6-synchronization>Ch 6 Synchronization</a><ul><li><a href=#process-communication>Process communication</a></li></ul></li><li><a href=#ch-7-deadlock>Ch 7 Deadlock</a><ul><li><a href=#形成deadlock的必要條件>形成deadlock的必要條件</a></li><li><a href=#處理方式>處理方式</a></li></ul></li><li><a href=#ch-8-memory-management-strategies>Ch 8 Memory Management Strategies</a><ul><li><a href=#contiguous-memory-management>Contiguous Memory Management</a></li><li><a href=#external--internal-fragmentation>External & Internal Fragmentation</a></li><li><a href=#page-memory-management>Page memory Management</a></li><li><a href=#segment-memory-management>Segment Memory Management</a></li></ul></li><li><a href=#ch-9-virtual-memory-management>Ch 9 Virtual-Memory Management</a><ul><li><a href=#demand-paging>Demand Paging</a></li><li><a href=#page-fault處理>Page fault處理</a></li><li><a href=#effective-memory-access-time計算>Effective memory access time計算</a></li><li><a href=#page-replacement>Page Replacement</a></li><li><a href=#thrashing及解決方法>Thrashing及解決方法</a></li></ul></li><li><a href=#超重要的總結><strong>超重要的總結</strong></a></li></ul></nav></div></aside></main></body></html>