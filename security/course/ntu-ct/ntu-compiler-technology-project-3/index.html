<!doctype html><html lang=en-us dir=ltr><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content='
  NTU Compiler Technology Project 3
  #


  tags: NTU_CT NTU Compiler Techonology of Programming Language YACC Lex
  #

[TOC]

  Objective
  #


The main task for this project is to revise src/parser.y and generate parser file properly to compile test code in test folder.
And then use Graphviz command to visualize the structure of these test code


  How to run?
  #


Just use make to compile all files in /src. Though you&rsquo;ll get a lots of warning shown as below, you can ignore them and obtain the target file parser.
bison -v -d parser.y
parser.y: warning: 1 shift/reduce conflict [-Wconflicts-sr]
flex lexer.l
gcc -g -c alloc.c
gcc -g -c parser.tab.c
parser.tab.c: In function ‘yyparse’:
parser.tab.c:2565:7: warning: implicit declaration of function ‘yyerror’; did you mean ‘yyerrok’? [-Wimplicit-function-declaration]
       yyerror (YY_("syntax error"));
       ^~~~~~~
       yyerrok
parser.y: At top level:
parser.y:825:3: warning: data definition has no type or storage class
   yydebug = 1;
   ^~~~~~~
parser.y:825:3: warning: type defaults to ‘int’ in declaration of ‘yydebug’ [-Wimplicit-int]
parser.y:827:1: warning: return type defaults to ‘int’ [-Wimplicit-int]
 main (argc, argv)
 ^~~~
parser.y: In function ‘main’:
parser.y:834:5: warning: implicit declaration of function ‘printGV’; did you mean ‘printf’? [-Wimplicit-function-declaration]
     printGV(prog, NULL);
     ^~~~~~~
     printf
gcc -g -c functions.c
gcc -g -o parser parser.tab.o alloc.o functions.o -lfl

Use parser to compile all files in /test folder and you will get AST_Graph.gv in /test folder.
/src
./parser ../test/control.c
dot -Tpng -o ../test/control.png ../test/AST_Graph.gv
./parser ../test/decl.c
dot -Tpng -o ../test/decl.png ../test/AST_Graph.gv
./parser ../test/expr.c
dot -Tpng -o ../test/expr.png ../test/AST_Graph.gv
./parser ../test/func.c
dot -Tpng -o ../test/func.png ../test/AST_Graph.gv

Note that in parser.y, I set yydebug = 1 so that we can see the debug message from parser
#ifdef YYDEBUG
    yydebug = 1;
#endif



  For TA
  #


I changed a little bit functions.c that will generate AST_Graph.gv at test/ folder.

void printGV(AST_NODE *root, char* fileName)
{
    if (fileName == NULL) {
        fileName = "../test/AST_Graph.gv";
    }
    ...
}

  Analysis
  #


You can see the relationship between structure map and test code by yourself.
control.c
int main()
{
    int i;
    int p;
    int k, j;
    for (i=0; i<9; i=i+1) {
            /* empty */
    }
    for (i=0, p=4+4; i<9; i=i+1, p=i) {
        write("test");
    }
    for (;;) {
        /*empty*/
    }
    while (1) {
    }
    while (2) {
        write("haha");
        write("wow");
    }
    if (k == j) {
        write("first");
    }
    if (k == j) {
        write("first");
    } else if (j == k) {
        write("second");
    } else {
        write("third");
    }
}

decl.c
typedef float GFLOAT;
int main() {
    typedef int INT, INT2, INT3;
    typedef float FLOAT;
    typedef void VOID;
    typedef void VOID2, VOID3;
    INT f[3][3*3-(4+2)/2];
    FLOAT f2;
}

expr.c
int fn1() {
    return 1;
}
float fn3() {
    return 1.0;
}
int fn4(int a, int b) {
    return 1;
}
int expr(int a, int b, int c, int d,
        float fa, float fb, float fc) {
    int i, j, k, l;
    float fi = 1.0, fj = 2.0, fk = 3.0, fl = 4.0;

    fi = 1.2*fi + -fj * (fl - fk * fn3());
    fi = -fn3() -(-(-(4)));
    fi = !fn3() -(!(!(4)));
    i = !fn1();
    i = 1 < 2;
    i = 1 > 2;
    i = 1 >= 2;
    i = 1 <= 2;
    i = 1 != 2;
    i = 1 == 2;
    i = fn4(1+3*4*fn4(2,3), 3);
    return 1;
}
int main() {
}

func.c
int fn1() {
    int ABC = 5;
    return ABC+5;
}
void fn2() {
}
void fn3(int a, int b[3][4]) {
}
int main() {
    int b[4][4];
    fn1();
    fn2();
    fn3(2, b);
}



  Reference
  #

Github example
Simple intro of yacc & lex
Simple intro of Graphviz
A GUIDE TO LEX & YACC from TA
大推：以lex/yacc實作算式計算機'><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#343a40"><meta name=color-scheme content="light dark"><meta property="og:url" content="https://bernie6401.github.io/security/course/ntu-ct/ntu-compiler-technology-project-3/"><meta property="og:site_name" content="SBK Hugo Site"><meta property="og:title" content="NTU Compiler Technology Project 3"><meta property="og:description" content='NTU Compiler Technology Project 3 # tags: NTU_CT NTU Compiler Techonology of Programming Language YACC Lex # [TOC]
Objective # The main task for this project is to revise src/parser.y and generate parser file properly to compile test code in test folder. And then use Graphviz command to visualize the structure of these test code How to run? # Just use make to compile all files in /src. Though you’ll get a lots of warning shown as below, you can ignore them and obtain the target file parser. bison -v -d parser.y parser.y: warning: 1 shift/reduce conflict [-Wconflicts-sr] flex lexer.l gcc -g -c alloc.c gcc -g -c parser.tab.c parser.tab.c: In function ‘yyparse’: parser.tab.c:2565:7: warning: implicit declaration of function ‘yyerror’; did you mean ‘yyerrok’? [-Wimplicit-function-declaration] yyerror (YY_("syntax error")); ^~~~~~~ yyerrok parser.y: At top level: parser.y:825:3: warning: data definition has no type or storage class yydebug = 1; ^~~~~~~ parser.y:825:3: warning: type defaults to ‘int’ in declaration of ‘yydebug’ [-Wimplicit-int] parser.y:827:1: warning: return type defaults to ‘int’ [-Wimplicit-int] main (argc, argv) ^~~~ parser.y: In function ‘main’: parser.y:834:5: warning: implicit declaration of function ‘printGV’; did you mean ‘printf’? [-Wimplicit-function-declaration] printGV(prog, NULL); ^~~~~~~ printf gcc -g -c functions.c gcc -g -o parser parser.tab.o alloc.o functions.o -lfl Use parser to compile all files in /test folder and you will get AST_Graph.gv in /test folder. /src ./parser ../test/control.c dot -Tpng -o ../test/control.png ../test/AST_Graph.gv ./parser ../test/decl.c dot -Tpng -o ../test/decl.png ../test/AST_Graph.gv ./parser ../test/expr.c dot -Tpng -o ../test/expr.png ../test/AST_Graph.gv ./parser ../test/func.c dot -Tpng -o ../test/func.png ../test/AST_Graph.gv Note that in parser.y, I set yydebug = 1 so that we can see the debug message from parser #ifdef YYDEBUG yydebug = 1; #endif For TA # I changed a little bit functions.c that will generate AST_Graph.gv at test/ folder. void printGV(AST_NODE *root, char* fileName) { if (fileName == NULL) { fileName = "../test/AST_Graph.gv"; } ... } Analysis # You can see the relationship between structure map and test code by yourself. control.c int main() { int i; int p; int k, j; for (i=0; i<9; i=i+1) { /* empty */ } for (i=0, p=4+4; i<9; i=i+1, p=i) { write("test"); } for (;;) { /*empty*/ } while (1) { } while (2) { write("haha"); write("wow"); } if (k == j) { write("first"); } if (k == j) { write("first"); } else if (j == k) { write("second"); } else { write("third"); } } decl.c typedef float GFLOAT; int main() { typedef int INT, INT2, INT3; typedef float FLOAT; typedef void VOID; typedef void VOID2, VOID3; INT f[3][3*3-(4+2)/2]; FLOAT f2; } expr.c int fn1() { return 1; } float fn3() { return 1.0; } int fn4(int a, int b) { return 1; } int expr(int a, int b, int c, int d, float fa, float fb, float fc) { int i, j, k, l; float fi = 1.0, fj = 2.0, fk = 3.0, fl = 4.0; fi = 1.2*fi + -fj * (fl - fk * fn3()); fi = -fn3() -(-(-(4))); fi = !fn3() -(!(!(4))); i = !fn1(); i = 1 < 2; i = 1 > 2; i = 1 >= 2; i = 1 <= 2; i = 1 != 2; i = 1 == 2; i = fn4(1+3*4*fn4(2,3), 3); return 1; } int main() { } func.c int fn1() { int ABC = 5; return ABC+5; } void fn2() { } void fn3(int a, int b[3][4]) { } int main() { int b[4][4]; fn1(); fn2(); fn3(2, b); } Reference # Github example Simple intro of yacc & lex Simple intro of Graphviz A GUIDE TO LEX & YACC from TA 大推：以lex/yacc實作算式計算機'><meta property="og:locale" content="en_us"><meta property="og:type" content="article"><meta property="article:section" content="security"><meta property="article:tag" content="NTU_CT"><meta property="article:tag" content="NTU"><title>NTU Compiler Technology Project 3 | SBK Hugo Site</title>
<link rel=icon href=/favicon.png><link rel=manifest href=/manifest.json><link rel=canonical href=https://bernie6401.github.io/security/course/ntu-ct/ntu-compiler-technology-project-3/><link rel=stylesheet href=/book.min.6c8b9d2a1fc95075ed7da46ca81060b39add8fff6741ac51259f768929281e2c.css integrity="sha256-bIudKh/JUHXtfaRsqBBgs5rdj/9nQaxRJZ92iSkoHiw=" crossorigin=anonymous><script defer src=/fuse.min.js></script><script defer src=/en.search.min.acdc41c8d39e6c69d70d8a23779875e0a3733fefead3e428d5344966bb12f562.js integrity="sha256-rNxByNOebGnXDYojd5h14KNzP+/q0+Qo1TRJZrsS9WI=" crossorigin=anonymous></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/><span>SBK Hugo Site</span></a></h2><div class="book-search hidden"><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><script>document.querySelector(".book-search").classList.remove("hidden")</script></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu></label><h3>NTU Compiler Technology Project 3</h3><label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><ul><li></li></ul></li><li><a href=#objective>Objective</a></li><li><a href=#how-to-run>How to run?</a></li><li><a href=#for-ta>For TA</a></li><li><a href=#analysis>Analysis</a></li><li><a href=#reference>Reference</a></li></ul></nav></aside></header><article class="markdown book-article"><h1 id=ntu-compiler-technology-project-3>NTU Compiler Technology Project 3
<a class=anchor href=#ntu-compiler-technology-project-3>#</a></h1><h6 id=tags-ntu_ct-ntu-compiler-techonology-of-programming-language-yacc-lex>tags: <code>NTU_CT</code> <code>NTU</code> <code>Compiler Techonology of Programming Language</code> <code>YACC</code> <code>Lex</code>
<a class=anchor href=#tags-ntu_ct-ntu-compiler-techonology-of-programming-language-yacc-lex>#</a></h6><p>[TOC]</p><h2 id=objective>Objective
<a class=anchor href=#objective>#</a></h2><ul><li>The main task for this project is to revise <code>src/parser.y</code> and generate <code>parser</code> file properly to compile test code in <code>test</code> folder.</li><li>And then use <code>Graphviz</code> command to visualize the structure of these test code</li></ul><h2 id=how-to-run>How to run?
<a class=anchor href=#how-to-run>#</a></h2><ul><li>Just use <code>make</code> to compile all files in <code>/src</code>. Though you&rsquo;ll get a lots of warning shown as below, you can ignore them and obtain the target file <code>parser</code>.<pre tabindex=0><code class="language-bash=" data-lang="bash=">bison -v -d parser.y
parser.y: warning: 1 shift/reduce conflict [-Wconflicts-sr]
flex lexer.l
gcc -g -c alloc.c
gcc -g -c parser.tab.c
parser.tab.c: In function ‘yyparse’:
parser.tab.c:2565:7: warning: implicit declaration of function ‘yyerror’; did you mean ‘yyerrok’? [-Wimplicit-function-declaration]
       yyerror (YY_(&#34;syntax error&#34;));
       ^~~~~~~
       yyerrok
parser.y: At top level:
parser.y:825:3: warning: data definition has no type or storage class
   yydebug = 1;
   ^~~~~~~
parser.y:825:3: warning: type defaults to ‘int’ in declaration of ‘yydebug’ [-Wimplicit-int]
parser.y:827:1: warning: return type defaults to ‘int’ [-Wimplicit-int]
 main (argc, argv)
 ^~~~
parser.y: In function ‘main’:
parser.y:834:5: warning: implicit declaration of function ‘printGV’; did you mean ‘printf’? [-Wimplicit-function-declaration]
     printGV(prog, NULL);
     ^~~~~~~
     printf
gcc -g -c functions.c
gcc -g -o parser parser.tab.o alloc.o functions.o -lfl
</code></pre></li><li>Use parser to compile all files in <code>/test</code> folder and you will get <code>AST_Graph.gv</code> in <strong><code>/test</code></strong> folder.
<strong><code>/src</code></strong><pre tabindex=0><code class="language-bash=" data-lang="bash=">./parser ../test/control.c
dot -Tpng -o ../test/control.png ../test/AST_Graph.gv
./parser ../test/decl.c
dot -Tpng -o ../test/decl.png ../test/AST_Graph.gv
./parser ../test/expr.c
dot -Tpng -o ../test/expr.png ../test/AST_Graph.gv
./parser ../test/func.c
dot -Tpng -o ../test/func.png ../test/AST_Graph.gv
</code></pre></li><li>Note that in <code>parser.y</code>, I set <code>yydebug = 1</code> so that we can see the debug message from parser<pre tabindex=0><code class="language-cpp=821" data-lang="cpp=821">#ifdef YYDEBUG
    yydebug = 1;
#endif
</code></pre></li></ul><h2 id=for-ta>For TA
<a class=anchor href=#for-ta>#</a></h2><ul><li>I changed a little bit <code>functions.c</code> that will generate <code>AST_Graph.gv</code> at <code>test/</code> folder.</li></ul><pre tabindex=0><code class="language-cpp=150" data-lang="cpp=150">void printGV(AST_NODE *root, char* fileName)
{
    if (fileName == NULL) {
        fileName = &#34;../test/AST_Graph.gv&#34;;
    }
    ...
}
</code></pre><h2 id=analysis>Analysis
<a class=anchor href=#analysis>#</a></h2><ul><li>You can see the relationship between structure map and test code by yourself.</li><li><strong>control.c</strong><pre tabindex=0><code class="language-cpp=" data-lang="cpp=">int main()
{
    int i;
    int p;
    int k, j;
    for (i=0; i&lt;9; i=i+1) {
            /* empty */
    }
    for (i=0, p=4+4; i&lt;9; i=i+1, p=i) {
        write(&#34;test&#34;);
    }
    for (;;) {
        /*empty*/
    }
    while (1) {
    }
    while (2) {
        write(&#34;haha&#34;);
        write(&#34;wow&#34;);
    }
    if (k == j) {
        write(&#34;first&#34;);
    }
    if (k == j) {
        write(&#34;first&#34;);
    } else if (j == k) {
        write(&#34;second&#34;);
    } else {
        write(&#34;third&#34;);
    }
}
</code></pre><img src=https://imgur.com/4zTAsML.png alt="graphviz of control.c"></li><li><strong>decl.c</strong><pre tabindex=0><code class="language-cpp=" data-lang="cpp=">typedef float GFLOAT;
int main() {
    typedef int INT, INT2, INT3;
    typedef float FLOAT;
    typedef void VOID;
    typedef void VOID2, VOID3;
    INT f[3][3*3-(4+2)/2];
    FLOAT f2;
}
</code></pre><img src=https://imgur.com/6KWV4IT.png alt="graphviz of decl.c"></li><li><strong>expr.c</strong><pre tabindex=0><code class="language-cpp=" data-lang="cpp=">int fn1() {
    return 1;
}
float fn3() {
    return 1.0;
}
int fn4(int a, int b) {
    return 1;
}
int expr(int a, int b, int c, int d,
        float fa, float fb, float fc) {
    int i, j, k, l;
    float fi = 1.0, fj = 2.0, fk = 3.0, fl = 4.0;

    fi = 1.2*fi + -fj * (fl - fk * fn3());
    fi = -fn3() -(-(-(4)));
    fi = !fn3() -(!(!(4)));
    i = !fn1();
    i = 1 &lt; 2;
    i = 1 &gt; 2;
    i = 1 &gt;= 2;
    i = 1 &lt;= 2;
    i = 1 != 2;
    i = 1 == 2;
    i = fn4(1+3*4*fn4(2,3), 3);
    return 1;
}
int main() {
}
</code></pre><img src=https://imgur.com/7a6OyJA.png alt="graphviz of expr.c"></li><li><strong>func.c</strong><pre tabindex=0><code class="language-cpp=" data-lang="cpp=">int fn1() {
    int ABC = 5;
    return ABC+5;
}
void fn2() {
}
void fn3(int a, int b[3][4]) {
}
int main() {
    int b[4][4];
    fn1();
    fn2();
    fn3(2, b);
}
</code></pre><img src=https://imgur.com/BvW5b2U.png alt="graphviz of func.c"></li></ul><h2 id=reference>Reference
<a class=anchor href=#reference>#</a></h2><p><a href=https://github.com/liuxt/Compiler/blob/master/hw3>Github example</a>
<a href="https://bluelove1968.pixnet.net/blog/post/222285652?utm_source=PIXNET&amp;utm_medium=Blog_CollectionEXP_login">Simple intro of yacc & lex</a>
<a href="https://www.netadmin.com.tw/netadmin/zh-tw/technology/122966CB664D4A17ABAAD11FC2AA887C?page=3">Simple intro of Graphviz</a>
<a href=https://arcb.csc.ncsu.edu/~mueller/codeopt/codeopt00/y_man.pdf>A GUIDE TO LEX & YACC from TA</a>
大推：<a href=https://good-ed.blogspot.com/2010/04/lexyacc.html>以lex/yacc實作算式計算機</a></p></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><ul><li></li></ul></li><li><a href=#objective>Objective</a></li><li><a href=#how-to-run>How to run?</a></li><li><a href=#for-ta>For TA</a></li><li><a href=#analysis>Analysis</a></li><li><a href=#reference>Reference</a></li></ul></nav></div></aside></main></body></html>