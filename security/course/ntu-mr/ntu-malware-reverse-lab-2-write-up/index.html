<!doctype html><html lang=en-us dir=ltr><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="
  NTU Malware Reverse Lab 2 write up
  #


  tags: NTU_MR Malware Reverse Engineering and Analysis NTU
  #


  
      
          Name
          何秉學
          StuID
          R11921A16
      
  
  
  


  Analyze the malware 1 found in the file Lab13-02.zip -> Lab13-02.exe, generate &lsquo;yourself&rsquo; write ups (with screenshots) and answer the follow questions :
  #

1.1 Using dynamic analysis, determine what this malware creates.
Ans:

According to reference, you can also use procmon(Process Monitor) to monitor the whole progress after executing this file. The progress of first iteration is shown as below

Then use PEiD to check if the file has shell or not. And refer to the result as below, it seems has not shell, so that we can use IDA directly.

I used IDA to analyze this executable file and observe that it&rsquo;ll execute sub_401851 function every 10 seconds. And when I execute it in VM, it&rsquo;ll create a temp file name temp00XXXXXX.
int __cdecl main(int argc, const char **argv, const char **envp)
{
  while ( 1 )
  {
    Sleep(5000u);
    sub_401851();
    Sleep(5000u);
  }
}


1.2 Use static techniques such as an xor search, FindCrypt2, KANAL, and the IDA Entropy Plugin to look for potential encoding. What do you find?(Install findcrypt and IDA Entropy plugin can refer to Appendix 1, 2)
Ans:"><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#343a40"><meta name=color-scheme content="light dark"><meta property="og:url" content="https://bernie6401.github.io/security/course/ntu-mr/ntu-malware-reverse-lab-2-write-up/"><meta property="og:site_name" content="SBK Hugo Site"><meta property="og:title" content="NTU Malware Reverse Lab 2 write up"><meta property="og:description" content="NTU Malware Reverse Lab 2 write up # tags: NTU_MR Malware Reverse Engineering and Analysis NTU # Name 何秉學 StuID R11921A16 Analyze the malware 1 found in the file Lab13-02.zip -> Lab13-02.exe, generate ‘yourself’ write ups (with screenshots) and answer the follow questions : # 1.1 Using dynamic analysis, determine what this malware creates. Ans:
According to reference, you can also use procmon(Process Monitor) to monitor the whole progress after executing this file. The progress of first iteration is shown as below Then use PEiD to check if the file has shell or not. And refer to the result as below, it seems has not shell, so that we can use IDA directly. I used IDA to analyze this executable file and observe that it’ll execute sub_401851 function every 10 seconds. And when I execute it in VM, it’ll create a temp file name temp00XXXXXX. int __cdecl main(int argc, const char **argv, const char **envp) { while ( 1 ) { Sleep(5000u); sub_401851(); Sleep(5000u); } } 1.2 Use static techniques such as an xor search, FindCrypt2, KANAL, and the IDA Entropy Plugin to look for potential encoding. What do you find?(Install findcrypt and IDA Entropy plugin can refer to Appendix 1, 2) Ans:"><meta property="og:locale" content="en_us"><meta property="og:type" content="article"><meta property="article:section" content="security"><meta property="article:tag" content="NTU_MR"><meta property="article:tag" content="Malware Reverse Engineering and Analysis"><meta property="article:tag" content="NTU"><title>NTU Malware Reverse Lab 2 write up | SBK Hugo Site</title>
<link rel=icon href=/favicon.png><link rel=manifest href=/manifest.json><link rel=canonical href=https://bernie6401.github.io/security/course/ntu-mr/ntu-malware-reverse-lab-2-write-up/><link rel=stylesheet href=/book.min.6c8b9d2a1fc95075ed7da46ca81060b39add8fff6741ac51259f768929281e2c.css integrity="sha256-bIudKh/JUHXtfaRsqBBgs5rdj/9nQaxRJZ92iSkoHiw=" crossorigin=anonymous><script defer src=/fuse.min.js></script><script defer src=/en.search.min.acdc41c8d39e6c69d70d8a23779875e0a3733fefead3e428d5344966bb12f562.js integrity="sha256-rNxByNOebGnXDYojd5h14KNzP+/q0+Qo1TRJZrsS9WI=" crossorigin=anonymous></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/><span>SBK Hugo Site</span></a></h2><div class="book-search hidden"><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><script>document.querySelector(".book-search").classList.remove("hidden")</script></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu></label><h3>NTU Malware Reverse Lab 2 write up</h3><label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><ul><li></li></ul></li><li><a href=#analyze-the-malware-1-found-in-the-file-lab13-02zip---lab13-02exe-generate-yourself-write-ups-with-screenshots-and-answer-the-follow-questions->Analyze the malware 1 found in the file Lab13-02.zip -> Lab13-02.exe, generate &lsquo;yourself&rsquo; write ups (with screenshots) and answer the follow questions :</a></li><li><a href=#analyze-the-roboauth-sample-23-roboauthexezip---roboauthexe>Analyze the RoboAuth sample 2,3: RoboAuth.exe.zip -> RoboAuth.exe</a></li><li><a href=#appendix>Appendix</a></li><li><a href=#reference>Reference</a></li></ul></nav></aside></header><article class="markdown book-article"><h1 id=ntu-malware-reverse-lab-2-write-up>NTU Malware Reverse Lab 2 write up
<a class=anchor href=#ntu-malware-reverse-lab-2-write-up>#</a></h1><h6 id=tags-ntu_mr-malware-reverse-engineering-and-analysis-ntu>tags: <code>NTU_MR</code> <code>Malware Reverse Engineering and Analysis</code> <code>NTU</code>
<a class=anchor href=#tags-ntu_mr-malware-reverse-engineering-and-analysis-ntu>#</a></h6><table><thead><tr><th>Name</th><th>何秉學</th><th>StuID</th><th>R11921A16</th></tr></thead><tbody></tbody></table><h2 id=analyze-the-malware-1-found-in-the-file-lab13-02zip---lab13-02exe-generate-yourself-write-ups-with-screenshots-and-answer-the-follow-questions->Analyze the malware 1 found in the file Lab13-02.zip -> Lab13-02.exe, generate &lsquo;yourself&rsquo; write ups (with screenshots) and answer the follow questions :
<a class=anchor href=#analyze-the-malware-1-found-in-the-file-lab13-02zip---lab13-02exe-generate-yourself-write-ups-with-screenshots-and-answer-the-follow-questions->#</a></h2><p>1.1 Using dynamic analysis, determine what this malware creates.
Ans:</p><ul><li>According to <a href=https://blog.csdn.net/m1287578441/article/details/125185048>reference</a>, you can also use procmon(Process Monitor) to monitor the whole progress after executing this file. The progress of first iteration is shown as below
<img src=https://imgur.com/tCr29ps.png alt="result from process monitor">
Then use PEiD to check if the file has shell or not. And refer to the result as below, it seems has not shell, so that we can use IDA directly.
<img src=https://imgur.com/Bpcnm1c.png alt="result from PEiD"></li><li>I used IDA to analyze this executable file and observe that it&rsquo;ll execute sub_401851 function every 10 seconds. And when I execute it in VM, it&rsquo;ll create a temp file name temp00XXXXXX.<pre tabindex=0><code class="language-cpp=" data-lang="cpp=">int __cdecl main(int argc, const char **argv, const char **envp)
{
  while ( 1 )
  {
    Sleep(5000u);
    sub_401851();
    Sleep(5000u);
  }
}
</code></pre></li></ul><p>1.2 Use static techniques such as an xor search, FindCrypt2, KANAL, and the IDA Entropy Plugin to look for potential encoding. What do you find?<strong>(Install findcrypt and IDA Entropy plugin can refer to Appendix 1, 2)</strong>
Ans:</p><ul><li>Refer to <a href=https://blog.csdn.net/m1287578441/article/details/125185048>[4]</a>, I used KANAL, a plugin in PEiD, to examine whether it has been crypto or not. Apparently, it has not crypto signature.
<img src=https://imgur.com/2SqNRsX.png alt="result from KANAL"></li><li>Used another plugin in IDA, Findcrypt, to check if the file has been crypted and it seems that has not been crypted.
<img src=https://imgur.com/u4rhVnc.png alt="result from Findcrypt plugin"></li><li>Used text search in search icon
<img src=https://imgur.com/9azY9y6.png alt="use text search">
You can see that there&rsquo;re 12 xor result used by 0x00401739 and one used by 0x0040128D. Especially, 4 of the xor instructions did not belong to any function.
<img src=https://imgur.com/hroQHZU.png alt="result of text search"></li><li>So, check out the structure of main function and sub_401851 and renamed the sub-function by <a href=https://osandamalith.com/2017/05/08/lab-13-02-analysis/>[1]</a>.
<img src=https://imgur.com/O5H206n.png alt><pre tabindex=0><code class="language-assembly=" data-lang="assembly=">.text:00401851 ; =============== S U B R O U T I N E =======================================
.text:00401851
.text:00401851 ; Attributes: bp-based frame
.text:00401851
.text:00401851 sub_401851      proc near               ; CODE XREF: _main+2D↓p
.text:00401851
.text:00401851 FileName        = byte ptr -20Ch
.text:00401851 hMem            = dword ptr -0Ch
.text:00401851 nNumberOfBytesToWrite= dword ptr -8
.text:00401851 var_4           = dword ptr -4
.text:00401851
.text:00401851                 push    ebp
.text:00401852                 mov     ebp, esp
.text:00401854                 sub     esp, 20Ch
.text:0040185A                 mov     [ebp+hMem], 0
.text:00401861                 mov     [ebp+nNumberOfBytesToWrite], 0
.text:00401868                 lea     eax, [ebp+nNumberOfBytesToWrite]
.text:0040186B                 push    eax
.text:0040186C                 lea     ecx, [ebp+hMem]
.text:0040186F                 push    ecx
.text:00401870                 call    Take_Screenshot
.text:00401875                 add     esp, 8
.text:00401878                 mov     edx, [ebp+nNumberOfBytesToWrite]
.text:0040187B                 push    edx
.text:0040187C                 mov     eax, [ebp+hMem]
.text:0040187F                 push    eax
.text:00401880                 call    Encode_Func
.text:00401885                 add     esp, 8
.text:00401888                 call    ds:GetTickCount
.text:0040188E                 mov     [ebp+var_4], eax
.text:00401891                 mov     ecx, [ebp+var_4]
.text:00401894                 push    ecx
.text:00401895                 push    offset aTemp08x ; &#34;temp%08x&#34;
.text:0040189A                 lea     edx, [ebp+FileName]
.text:004018A0                 push    edx             ; char *
.text:004018A1                 call    _sprintf
.text:004018A6                 add     esp, 0Ch
.text:004018A9                 lea     eax, [ebp+FileName]
.text:004018AF                 push    eax             ; lpFileName
.text:004018B0                 mov     ecx, [ebp+nNumberOfBytesToWrite]
.text:004018B3                 push    ecx             ; nNumberOfBytesToWrite
.text:004018B4                 mov     edx, [ebp+hMem]
.text:004018B7                 push    edx             ; lpBuffer
.text:004018B8                 call    Write_File
.text:004018BD                 add     esp, 0Ch
.text:004018C0                 mov     eax, [ebp+hMem]
.text:004018C3                 push    eax             ; hMem
.text:004018C4                 call    ds:GlobalUnlock
.text:004018CA                 mov     ecx, [ebp+hMem]
.text:004018CD                 push    ecx             ; hMem
.text:004018CE                 call    ds:GlobalFree
.text:004018D4                 mov     esp, ebp
.text:004018D6                 pop     ebp
.text:004018D7                 retn
.text:004018D7 sub_401851      endp
</code></pre></li><li>Used IDA Entropy plugin to check the file and it seems has nothing unusual. The config is as <a href=https://blog.csdn.net/m1287578441/article/details/125185048>[4]</a>
<img src=https://imgur.com/UbtMW7e.png alt="result of IDA Entropy"></li></ul><p>1.3 Based on your answer to question 1, which imported function would be a good prospect for finding the encoding functions?
Ans:
As reference <a href=https://osandamalith.com/2017/05/08/lab-13-02-analysis/>[1]</a>, we can see what sub-function did. And as <a href=https://github.com/SafeEval/practical-malware-analysis/blob/master/exercises/lab-13-2.md>[2]</a> said, we can start at WriteFile to trace back and to find encoding function, because most of the process will encode the file right before WriteFile funtion.</p><pre tabindex=0><code class="language-cpp=" data-lang="cpp=">HGLOBAL sub_401851()
{
  CHAR FileName; // [esp+0h] [ebp-20Ch]
  HGLOBAL hMem; // [esp+200h] [ebp-Ch]
  DWORD nNumberOfBytesToWrite; // [esp+204h] [ebp-8h]
  DWORD v4; // [esp+208h] [ebp-4h]

  hMem = 0;
  nNumberOfBytesToWrite = 0;
  Take_Screenshot(&amp;hMem, &amp;nNumberOfBytesToWrite);
  Encode_Func((int)hMem, nNumberOfBytesToWrite);
  v4 = GetTickCount();
  sprintf(&amp;FileName, aTemp08x, v4);
  Write_File(hMem, nNumberOfBytesToWrite, &amp;FileName);
  GlobalUnlock(hMem);
  return GlobalFree(hMem);
}
</code></pre><p>1.4 Where is the encoding function in the disassembly?
Ans:</p><ul><li><p>After accessing to sub_401851(), we can analyze these function clearly, such as sub_401070(Take_Screenshot), sub_40181F(Encode_Func), sub_401000(WriteFile). Especially speaking, we can find an API named <code>GetTickCout</code>. Refer to <a href=https://learn.microsoft.com/en-us/windows/win32/api/sysinfoapi/nf-sysinfoapi-gettickcount>[5]</a>:</p><blockquote><p>Retrieves the number of milliseconds that have elapsed since the system was started, up to 49.7 days.</p><p>The return value is the number of milliseconds that have elapsed since the system was started</p></blockquote><p>This seems to be related to file name.</p></li><li><p>Now, we can check sub_401070 first</p><pre tabindex=0><code class="language-cpp=" data-lang="cpp=">void *__cdecl Take_Screenshot(void **a1, _DWORD *a2)
{
  SIZE_T dwBytes; // ST2C_4
  HGLOBAL hMem; // ST24_4
  void *result; // eax
  char pv; // [esp+Ch] [ebp-6Ch]
  LONG v6; // [esp+10h] [ebp-68h]
  UINT cLines; // [esp+14h] [ebp-64h]
  HGLOBAL v8; // [esp+24h] [ebp-54h]
  void *v9; // [esp+28h] [ebp-50h]
  HDC hdc; // [esp+2Ch] [ebp-4Ch]
  struct tagBITMAPINFO bmi; // [esp+30h] [ebp-48h]
  int v12; // [esp+5Ch] [ebp-1Ch]
  HGDIOBJ h; // [esp+60h] [ebp-18h]
  __int16 v14; // [esp+64h] [ebp-14h]
  SIZE_T v15; // [esp+66h] [ebp-12h]
  int v16; // [esp+6Eh] [ebp-Ah]
  int cy; // [esp+74h] [ebp-4h]

  v12 = GetSystemMetrics(0);
  cy = GetSystemMetrics(1);
  hWnd = GetDesktopWindow();
  hDC = GetDC(hWnd);
  hdc = CreateCompatibleDC(hDC);
  h = CreateCompatibleBitmap(hDC, v12, cy);
  SelectObject(hdc, h);
  BitBlt(hdc, 0, 0, v12, cy, hDC, 0, 0, 0xCC0020u);
  GetObjectA(h, 24, &amp;pv);
  bmi.bmiHeader.biSize = 40;
  bmi.bmiHeader.biWidth = v6;
  bmi.bmiHeader.biHeight = cLines;
  bmi.bmiHeader.biPlanes = 1;
  bmi.bmiHeader.biBitCount = 32;
  bmi.bmiHeader.biCompression = 0;
  bmi.bmiHeader.biSizeImage = 0;
  bmi.bmiHeader.biXPelsPerMeter = 0;
  bmi.bmiHeader.biYPelsPerMeter = 0;
  bmi.bmiHeader.biClrUsed = 0;
  bmi.bmiHeader.biClrImportant = 0;
  dwBytes = cLines * 4 * ((32 * v6 + 31) / 32);
  hMem = GlobalAlloc(0x42u, cLines * 4 * ((32 * v6 + 31) / 32));
  bmi.bmiColors[0] = (RGBQUAD)GlobalLock(hMem);
  GetDIBits(hDC, (HBITMAP)h, 0, cLines, *(LPVOID *)bmi.bmiColors, &amp;bmi, 0);
  v16 = 54;
  v15 = dwBytes + 54;
  v14 = 19778;
  v8 = GlobalAlloc(0x42u, dwBytes + 54);
  v9 = GlobalLock(v8);
  memcpy(v9, &amp;v14, 0xEu);
  memcpy((char *)v9 + 14, &amp;bmi, 0x28u);
  memcpy((char *)v9 + 54, *(const void **)bmi.bmiColors, dwBytes);
  GlobalUnlock(hMem);
  GlobalFree(hMem);
  ReleaseDC(hWnd, hDC);
  DeleteDC(hdc);
  DeleteObject(h);
  result = v9;
  *a1 = v9;
  *a2 = dwBytes + 54;
  return result;
}
</code></pre><p>In line 22, refer to <a href=https://learn.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-getdesktopwindow>[6]</a></p><blockquote><p>Retrieves a handle to the desktop window. The desktop window covers the entire screen. The desktop window is the area on top of which other windows are painted.</p><p>The return value is a handle to the desktop window.</p></blockquote><p>These codes aim to take a screenshot on your monitor.</p></li><li><p>Check sub_40181F()</p><pre tabindex=0><code class="language-cpp=" data-lang="cpp=">int __cdecl Encode_Func(int a1, int a2)
{
  char v3; // [esp+0h] [ebp-44h]

  memset(&amp;v3, 0, 0x44u);
  return sub_401739(&amp;v3, (_DWORD *)a1, (int *)a1, a2);
}
</code></pre><p>And sub_401739()</p><pre tabindex=0><code class="language-cpp=" data-lang="cpp=">int __cdecl sub_401739(_DWORD *a1, _DWORD *a2, int *a3, unsigned int a4)
{
  int result; // eax
  unsigned int i; // [esp+0h] [ebp-4h]

  for ( i = 0; i &lt; a4; i += 16 )
  {
    sub_4012DD(a1);
    *a3 = (a1[3] &lt;&lt; 16) ^ (a1[5] &gt;&gt; 16) ^ *a1 ^ *a2;
    a3[1] = (a1[5] &lt;&lt; 16) ^ (a1[7] &gt;&gt; 16) ^ a1[2] ^ a2[1];
    a3[2] = (a1[7] &lt;&lt; 16) ^ (a1[1] &gt;&gt; 16) ^ a1[4] ^ a2[2];
    a3[3] = (a1[1] &lt;&lt; 16) ^ (a1[3] &gt;&gt; 16) ^ a1[6] ^ a2[3];
    a2 += 4;
    a3 += 4;
    result = i + 16;
  }
  return result;
}
</code></pre><p>It used a lot of bit wise XOR and shift after sub_4012DD(a1).</p></li></ul><p>1.5 Trace from the encoding function to the source of the encoded content. What is the content?
Ans:
The answer is shown as above.</p><p>1.6 Can you find the algorithm used for encoding? If not, how can you decode the content?
Ans:
The answer is shown as Q1.4.</p><p>1.7 Using instrumentation, can you recover the original source of one of the encoded files?
Ans:</p><ul><li>Survey many website, I still can not handle Immunity Debugger. The website is as below
<a href=https://www.twblogs.net/a/5b8292662b717766a1e8ea90>開始寫Immunity Debugger PyCommand</a>
<a href=https://www.cnblogs.com/blacksunny/p/7238863.html>Immunity Debugger简介</a>
<a href=https://www.796t.com/content/1546289126.html>Python筆記&mdash;Immunity Debugger</a></li><li>So, I can not return the encrypted bmp files to original image that can be visualized. Instead, I used x64dbg to revise encode function that will not allow to be accessed. Then we can get a bmp file that haven&rsquo;t encrypted.
<img src=https://imgur.com/h5JAufy.png alt="x64dbg result">
Adding the bmp extension, we get a desktop screenshot image properly.
<img src=https://imgur.com/RBW1m4t.png alt="original image"></li></ul><h2 id=analyze-the-roboauth-sample-23-roboauthexezip---roboauthexe>Analyze the RoboAuth sample 2,3: RoboAuth.exe.zip -> RoboAuth.exe
<a class=anchor href=#analyze-the-roboauth-sample-23-roboauthexezip---roboauthexe>#</a></h2><p>Answer how to resolve the password 1 and password 2 (as shown in below), then generate &lsquo;yourself&rsquo; write ups (with screenshots).</p><ul><li>Step 1:<ul><li>First of all, we used x32dbg to analyze RoboAuth.exe and search some useful string such as <strong><code>You Passed level1!</code></strong> at 0x00401B75. And set the break point at 0x00401B6C(call strcmp). But, I can not recognized the answer like the <a href="https://www.youtube.com/watch?v=Eu8Hfo0JQy8&amp;ab_channel=0x01E6">write up video</a>. So, I used Ollydbg like the video and it showed the compare string right beside the memory window. ↦ <strong><code>r0b0RUlez!</code></strong>
<img src=https://imgur.com/UzEXKRY.png alt="ollydbg result">
<img src=https://imgur.com/1Mjz6Ku.png alt="string in ollydbg"></li></ul></li><li>Step 2<ul><li>After entering the password, we can continue to step over(press F8) and it&rsquo;ll call 0x004015EA at 0x00401B88.</li><li>Now, you can see an ASCII string above that show <code>"You win. Congratulations!"</code></li><li>Set the break point at and enter random string as second password. Then step into(press F7) the function 0x00401547.</li></ul></li><li>Step 3<ul><li>Observe the following code first.<pre tabindex=0><code class="language-assembly=" data-lang="assembly=">Address   Hex dump                              Command                   
00401547  /$  55                                PUSH EBP
00401548  |.  89E5                              MOV EBP,ESP
0040154A  |.  EB 22                             JMP SHORT 0040156E
0040154C  |&gt;  8B45 08                           /MOV EAX,DWORD PTR SS:[ARG.1]
0040154F  |.  0FB610                            |MOVZX EDX,BYTE PTR DS:[EAX]
00401552  |.  8B45 0C                           |MOV EAX,DWORD PTR SS:[ARG.2]
00401555  |.  0FB600                            |MOVZX EAX,BYTE PTR DS:[EAX]
00401558  |.  83F0 02                           |XOR EAX,00000002
0040155B  |.  38C2                              |CMP DL,AL
0040155D  |.  74 07                             |JE SHORT 00401566
0040155F  |.  B8 01000000                       |MOV EAX,1
00401564  |.  EB 17                             |JMP SHORT 0040157D
00401566  |&gt;  8345 08 01                        |ADD DWORD PTR SS:[ARG.1],1
0040156A  |.  8345 0C 01                        |ADD DWORD PTR SS:[ARG.2],1
0040156E  |&gt;  8B45 0C                           |MOV EAX,DWORD PTR SS:[ARG.2]
00401571  |.  0FB600                            |MOVZX EAX,BYTE PTR DS:[EAX]
00401574  |.  3C 02                             |CMP AL,2
00401576  |.^ 75 D4                             \JNE SHORT 0040154C
00401578  |.  B8 00000000                       MOV EAX,0
0040157D  |&gt;  5D                                POP EBP
0040157E  \.  C3                                RETN
</code></pre>You can see <code>MOVZX EDX,BYTE PTR DS:[EAX]</code> in line 6 and <code>MOVZX EDX,BYTE PTR DS:[EAX]</code> in line 7. In line 6, EAX stored the character you entered.
<img src=https://imgur.com/XHGfkJL.png alt="result of register in line 6">
And in line 7, it stored a whole new value <code>0x0060FDBC</code>. Try to trace it in dump.
<img src=https://imgur.com/isxNCEN.png alt="result of register in line 7">
You can see ASCII characters <code>u1nnf2lg</code>. Then observe the following code, you&rsquo;ll see it execute a XOR operation with 0x00000002. And then compare every single character to the real password, that is <code>u1nnf2lg xor 2</code>.
<img src=https://imgur.com/hVMYMSa.png alt="value in dump"></li></ul></li><li>Step 4<ul><li>So, if we want to know what the real password is, we just need to XOR by hand or use some code that <a href=https://github.com/SafeEval/practical-malware-analysis/blob/master/exercises/lab-13-2.md>[2]</a> provided.</li><li>The result of the real password is shown as below. ↦ <strong><code>w3lld0ne</code></strong>
<img src=https://imgur.com/3YLDv6d.png alt="2nd real password of lab 2"></li></ul></li></ul><p>The flag in this question is <strong><font color=RED><code>r0b0RUlez!_w3lld0ne</code></font></strong>.</p><h2 id=appendix>Appendix
<a class=anchor href=#appendix>#</a></h2><ol><li>Install findcrypt-yara
Install <a href=https://www.python.org/downloads/windows/>python 2.7</a> ↦ add python and python/script to environment variable ↦ follow <a href=https://blog.csdn.net/qq_43504939/article/details/102329762>findcrypt-yara IDA的一个插件安装</a> and <a href=https://blog.csdn.net/weixin_45055269/article/details/107660165>IDA7.0安装findcrypt插件</a><ul><li><a href=https://www.cnblogs.com/Fightingbirds/p/13840265.html>Error handler</a></li><li><a href="https://web.archive.org/web/20190720195601/http://www.microsoft.com/en-us/download/confirmation.aspx?id=44266">Alternative link for Microsoft Visual C++ Compiler for Python 2.7</a></li></ul></li><li>Install IDA Entropy Plugin
<a href=https://www.aldeid.com/wiki/IDA-Pro/plugins/ida-entropy-plugin>Description</a>
<a href=https://github.com/danigargu/IDAtropy>Install</a> ↦ Install repo. and untar it(Must choose python2 version) ↦ place the .py file to plugin folder ↦ use pip to install matplotlib ↦ restart IDA</li><li>Something related to Immunity Debugger<ul><li><a href=https://lonelysec.com/%E9%9B%B6%E5%9F%BA%E7%A4%8E%E5%AD%B8%E7%A0%B4%E8%A7%A3-%E7%AC%AC%E4%B8%89%E9%9B%86/>Example of immunity debugger</a></li><li><a href=https://wizardforcel.gitbooks.io/grey-hat-python/content/19.html>Immunity Debugger Installation</a></li><li><a href=https://bbs.pediy.com/thread-176851.htm>Extra info.?!</a></li></ul></li></ol><h2 id=reference>Reference
<a class=anchor href=#reference>#</a></h2><ul><li><p>Lab 1
<a href=https://osandamalith.com/2017/05/08/lab-13-02-analysis/>Lab 13-02 Analysis</a>
<a href=https://github.com/SafeEval/practical-malware-analysis/blob/master/exercises/lab-13-2.md>practical-malware-analysis</a>
<a href=http://www.dcs.fmph.uniba.sk/zri/6.prednaska/tools/PEiD/plugins/kanal.htm>KANAL - Krypto Analyzer for PEiD</a>
<a href=https://blog.csdn.net/m1287578441/article/details/125185048>分析恶意代码文件Lab13-02.exe</a>
<a href=https://learn.microsoft.com/en-us/windows/win32/api/sysinfoapi/nf-sysinfoapi-gettickcount>GetTickCount</a>
<a href=https://learn.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-getdesktopwindow>GetDesktopWindow</a>
<a href=https://lonelysec.com/%E9%9B%B6%E5%9F%BA%E7%A4%8E%E5%AD%B8%E7%A0%B4%E8%A7%A3-%E7%AC%AC%E4%B8%89%E9%9B%86/>Example of immunity debugger</a>
<a href=https://wizardforcel.gitbooks.io/grey-hat-python/content/19.html>Immunity Debugger Installation</a>
<a href=https://bbs.pediy.com/thread-176851.htm>Extra info.?!</a></p></li><li><p>Lab 2
<a href="https://www.youtube.com/watch?v=Eu8Hfo0JQy8&amp;ab_channel=0x01E6">lab2 write up video</a></p></li></ul></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><ul><li></li></ul></li><li><a href=#analyze-the-malware-1-found-in-the-file-lab13-02zip---lab13-02exe-generate-yourself-write-ups-with-screenshots-and-answer-the-follow-questions->Analyze the malware 1 found in the file Lab13-02.zip -> Lab13-02.exe, generate &lsquo;yourself&rsquo; write ups (with screenshots) and answer the follow questions :</a></li><li><a href=#analyze-the-roboauth-sample-23-roboauthexezip---roboauthexe>Analyze the RoboAuth sample 2,3: RoboAuth.exe.zip -> RoboAuth.exe</a></li><li><a href=#appendix>Appendix</a></li><li><a href=#reference>Reference</a></li></ul></nav></div></aside></main></body></html>