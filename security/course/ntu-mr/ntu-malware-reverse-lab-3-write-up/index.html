<!doctype html><html lang=en-us dir=ltr><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content='
  NTU Malware Reverse Lab 3 write up
  #


  tags: NTU_MR Malware Reverse Engineering and Analysis NTU
  #

[TOC]

  
      
          Name
          何秉學
          StuID
          R11921A16
      
  
  
  


  Review Packing and Unpacking
  #


How does packing and unpacking work?
作者會把原本的code section和data section，放在UPX1，並且用unpacking stub(裡面存放解殼的程式)，把UPX1的內容一點一點的還原回UPX0(也就是空區段)，並跳回正常程式的執行進入點(original entry point, OEP)，最後跳回去的動作叫做Tail Jump或Long Jump，另外，多長的jump才是長，可能要依照經驗值判斷，或是直接跳過去後分析程式在幹嘛

實際上執行脫殼的時候，除了OEP的重建外，還需要重建Imports，這兩者都處理好後才算是脫殼完成
當分析脫殼執行到如下圖這樣的情況時，就離終點不遠了，也就是jmp的地址離目前的程式很遠，且之後的程式有很多空指令或垃圾byte，此為UXP殼的特徵

可以用PEiD這個工具(或是用Entropy之類的，但是不一定準確)判斷樣本有沒有加殼，或是加了甚麼殼，上圖是沒有加殼的一般程式，下圖是加了UPX的加殼程式


若是要處理Import Table Reconstruction，可以用OllyDump、ImpRec或是Scylla這些工具來進行，在Practice中是用Scylla演示(且可以搭配x32dbg或x64dbg進行)
老師有說在Long Jump之前會搭配pop instruction，這可能可以當作解析OEP的線索
Tail Jump，不一定是用jmp，也可以是call instruction；另外，跳轉的地址也不一定是一個明確的地址，也可能用暫存器存起來，這部分可以注意一下


  Practice - upx_exercise.exe
  #


  Observation
  #


First things first, we can observe the file by executing it directly. Obviously, you should enter correct CTF key by analyzing.



  Unpacking
  #


  Static analysis - IDA Pro
  #


You are not allowed to disassembly by doing nothing, because it was packed by UPX. Therefore, our objective is to unpack it and try to analyze it original code to get the CTF Flag.



  Dynamic analysis - x32dbg
  #


In UPX-based packing, it has a feature that in order to not let the data be flushed during unpacking, it must store all data to the stack by using pushad instruction.

Then, you&rsquo;ll see a lot of jmp instruction to unpack the original code.

Scrolling down the code, you&rsquo;ll see a popad instruction at 0x0134AEDE , a jmp instruction at 0x010EAEEC, and a lots of null instruction which all three are satisfied all features that UPX-based packing method has.
It&rsquo;ll restore all data that stored in stack and jump to upx_exercise.134244D.

Set the break-point and press run button in x32dbg, then press step into button to observe the code.
Now, the code has already unpacked, then we can use Scylla to do Import Reconstruction.


Press IAT Autosearch(Import Address Table) button to search and then press Get Imports button. Finally, you will get all imports that this file used, and Scylla will help you to rebuild it.

Press Dump button to get IAT file.

Press Fix Dump and choose the file what we dump to reconnect the IAT and this file. You&rsquo;ll see the log said Import Rebuild success and you&rsquo;ll get a new file named upx_exercise_dump_SCY.exe that repaired by Scylla.



  Analyze
  #


  Re-static analysis - IDA Pro
  #


Used IDA to reanalyze the unpacking file.
Used string searching to find the string nope that appear in your cmd.

Used cross reference to find which part has used it.


The main part is shown as below
...
sub_E01EB0(std::cin, &amp;Memory);
LOBYTE(v116) = 1;
MEMORY[0] = 0;
v96 = 0xFCC1D3C4;
v97 = 0xD8D2C8DE;
v98 = 0xD8D3E8E0;
v99 = 0xD8C2EFB0;
v100 = 0xC2ECB3C1;
v101 = 0xB3EBE1D8;
v102 = 0xD5F3D8BE;
v103 = 0xB3EFD8DE;
v104 = 0xF5C2E3D5;
v105 = 0xFAD6D6D8;
v64 = 1;
HIBYTE(v95) = 1;
v65 = 0;
v93 = 0;
while ( v65 < 40 )
{
    v66 = (char *)&amp;Memory;
    if ( v111 >= 16 )
        v66 = (char *)Memory;
    v67 = v66[v65] ^ 0x87;
    v68 = *((unsigned __int8 *)&amp;v96 + v65);
    v94 = 0;
    if ( v67 != v68 )
        v64 = v94;
    HIBYTE(v95) = v64;
    v93 = ++v65;
}
v69 = "Congratz?!";
if ( !v64 )
    v69 = "Nope!";
...

From v96 to v105, it stored 40 bytes and it seems do something in while loop 40 times. In addition, v67 = v66[v65] ^ 0x87; this line used xor instruction that seems a encrypt part. And then it compared &amp;v96 + v65 and v67 that encrypt the string what you input.
If all the strings you input after process xor to 0x87 are strictly the same with v96 to v105, then it&rsquo;ll print Congratz?!, otherwise, print Nope.
Used online_xor to get v96 to v105 encrypted strings.

And then used online_hex2ascii to get the CTF Flag.

The answer is **CTF{YOU_goT_7hE_F4kE_fl49_tRY_h4RdEr_QQ}**, though it is not a real answer.

Note that, the demo from TA is finished, therefore, I still don&rsquo;t know the real flag is.




  Homework - upx_Revil.exe
  #


  Static Analysis Observation
  #


Use IDA to analyze this sample and obviously packed sample

Use the skill above then you can answer the question easily.


  Homework - custom_packer_Revil.exe
  #


  Static Analysis Observation - DetectItEasy
  #



Though I used the tool, DetectItEasy to check if this sample was packed or not, the answer is not quite explicit.
'><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#343a40"><meta name=color-scheme content="light dark"><meta property="og:url" content="https://bernie6401.github.io/security/course/ntu-mr/ntu-malware-reverse-lab-3-write-up/"><meta property="og:site_name" content="SBK Hugo Site"><meta property="og:title" content="NTU Malware Reverse Lab 3 write up"><meta property="og:description" content='NTU Malware Reverse Lab 3 write up # tags: NTU_MR Malware Reverse Engineering and Analysis NTU # [TOC]
Name 何秉學 StuID R11921A16 Review Packing and Unpacking # How does packing and unpacking work? 作者會把原本的code section和data section，放在UPX1，並且用unpacking stub(裡面存放解殼的程式)，把UPX1的內容一點一點的還原回UPX0(也就是空區段)，並跳回正常程式的執行進入點(original entry point, OEP)，最後跳回去的動作叫做Tail Jump或Long Jump，另外，多長的jump才是長，可能要依照經驗值判斷，或是直接跳過去後分析程式在幹嘛 實際上執行脫殼的時候，除了OEP的重建外，還需要重建Imports，這兩者都處理好後才算是脫殼完成 當分析脫殼執行到如下圖這樣的情況時，就離終點不遠了，也就是jmp的地址離目前的程式很遠，且之後的程式有很多空指令或垃圾byte，此為UXP殼的特徵 可以用PEiD這個工具(或是用Entropy之類的，但是不一定準確)判斷樣本有沒有加殼，或是加了甚麼殼，上圖是沒有加殼的一般程式，下圖是加了UPX的加殼程式 若是要處理Import Table Reconstruction，可以用OllyDump、ImpRec或是Scylla這些工具來進行，在Practice中是用Scylla演示(且可以搭配x32dbg或x64dbg進行) 老師有說在Long Jump之前會搭配pop instruction，這可能可以當作解析OEP的線索 Tail Jump，不一定是用jmp，也可以是call instruction；另外，跳轉的地址也不一定是一個明確的地址，也可能用暫存器存起來，這部分可以注意一下 Practice - upx_exercise.exe # Observation # First things first, we can observe the file by executing it directly. Obviously, you should enter correct CTF key by analyzing. Unpacking # Static analysis - IDA Pro # You are not allowed to disassembly by doing nothing, because it was packed by UPX. Therefore, our objective is to unpack it and try to analyze it original code to get the CTF Flag. Dynamic analysis - x32dbg # In UPX-based packing, it has a feature that in order to not let the data be flushed during unpacking, it must store all data to the stack by using pushad instruction. Then, you’ll see a lot of jmp instruction to unpack the original code. Scrolling down the code, you’ll see a popad instruction at 0x0134AEDE , a jmp instruction at 0x010EAEEC, and a lots of null instruction which all three are satisfied all features that UPX-based packing method has. It’ll restore all data that stored in stack and jump to upx_exercise.134244D. Set the break-point and press run button in x32dbg, then press step into button to observe the code. Now, the code has already unpacked, then we can use Scylla to do Import Reconstruction. Press IAT Autosearch(Import Address Table) button to search and then press Get Imports button. Finally, you will get all imports that this file used, and Scylla will help you to rebuild it. Press Dump button to get IAT file. Press Fix Dump and choose the file what we dump to reconnect the IAT and this file. You’ll see the log said Import Rebuild success and you’ll get a new file named upx_exercise_dump_SCY.exe that repaired by Scylla. Analyze # Re-static analysis - IDA Pro # Used IDA to reanalyze the unpacking file. Used string searching to find the string nope that appear in your cmd. Used cross reference to find which part has used it. The main part is shown as below ... sub_E01EB0(std::cin, &amp;Memory); LOBYTE(v116) = 1; MEMORY[0] = 0; v96 = 0xFCC1D3C4; v97 = 0xD8D2C8DE; v98 = 0xD8D3E8E0; v99 = 0xD8C2EFB0; v100 = 0xC2ECB3C1; v101 = 0xB3EBE1D8; v102 = 0xD5F3D8BE; v103 = 0xB3EFD8DE; v104 = 0xF5C2E3D5; v105 = 0xFAD6D6D8; v64 = 1; HIBYTE(v95) = 1; v65 = 0; v93 = 0; while ( v65 < 40 ) { v66 = (char *)&amp;Memory; if ( v111 >= 16 ) v66 = (char *)Memory; v67 = v66[v65] ^ 0x87; v68 = *((unsigned __int8 *)&amp;v96 + v65); v94 = 0; if ( v67 != v68 ) v64 = v94; HIBYTE(v95) = v64; v93 = ++v65; } v69 = "Congratz?!"; if ( !v64 ) v69 = "Nope!"; ... From v96 to v105, it stored 40 bytes and it seems do something in while loop 40 times. In addition, v67 = v66[v65] ^ 0x87; this line used xor instruction that seems a encrypt part. And then it compared &amp;v96 + v65 and v67 that encrypt the string what you input. If all the strings you input after process xor to 0x87 are strictly the same with v96 to v105, then it’ll print Congratz?!, otherwise, print Nope. Used online_xor to get v96 to v105 encrypted strings. And then used online_hex2ascii to get the CTF Flag. The answer is **CTF{YOU_goT_7hE_F4kE_fl49_tRY_h4RdEr_QQ}**, though it is not a real answer. Note that, the demo from TA is finished, therefore, I still don’t know the real flag is. Homework - upx_Revil.exe # Static Analysis Observation # Use IDA to analyze this sample and obviously packed sample Use the skill above then you can answer the question easily. Homework - custom_packer_Revil.exe # Static Analysis Observation - DetectItEasy # Though I used the tool, DetectItEasy to check if this sample was packed or not, the answer is not quite explicit.'><meta property="og:locale" content="en_us"><meta property="og:type" content="article"><meta property="article:section" content="security"><meta property="article:tag" content="NTU_MR"><meta property="article:tag" content="Malware Reverse Engineering and Analysis"><meta property="article:tag" content="NTU"><title>NTU Malware Reverse Lab 3 write up | SBK Hugo Site</title>
<link rel=icon href=/favicon.png><link rel=manifest href=/manifest.json><link rel=canonical href=https://bernie6401.github.io/security/course/ntu-mr/ntu-malware-reverse-lab-3-write-up/><link rel=stylesheet href=/book.min.6c8b9d2a1fc95075ed7da46ca81060b39add8fff6741ac51259f768929281e2c.css integrity="sha256-bIudKh/JUHXtfaRsqBBgs5rdj/9nQaxRJZ92iSkoHiw=" crossorigin=anonymous><script defer src=/fuse.min.js></script><script defer src=/en.search.min.acdc41c8d39e6c69d70d8a23779875e0a3733fefead3e428d5344966bb12f562.js integrity="sha256-rNxByNOebGnXDYojd5h14KNzP+/q0+Qo1TRJZrsS9WI=" crossorigin=anonymous></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/><span>SBK Hugo Site</span></a></h2><div class="book-search hidden"><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><script>document.querySelector(".book-search").classList.remove("hidden")</script></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu></label><h3>NTU Malware Reverse Lab 3 write up</h3><label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><ul><li></li></ul></li><li><a href=#review-packing-and-unpacking>Review Packing and Unpacking</a></li><li><a href=#practice---upx_exerciseexe>Practice - <code>upx_exercise.exe</code></a><ul><li><a href=#observation>Observation</a></li><li><a href=#unpacking>Unpacking</a></li><li><a href=#analyze>Analyze</a></li></ul></li><li><a href=#homework---upx_revilexe>Homework - <code>upx_Revil.exe</code></a><ul><li><a href=#static-analysis-observation>Static Analysis Observation</a></li></ul></li><li><a href=#homework---custom_packer_revilexe>Homework - <code>custom_packer_Revil.exe</code></a><ul><li><a href=#static-analysis-observation---detectiteasy>Static Analysis Observation - <code>DetectItEasy</code></a></li><li><a href=#analyze--find-oep>Analyze & Find <code>OEP</code></a></li></ul></li><li><a href=#homework>Homework</a></li></ul></nav></aside></header><article class="markdown book-article"><h1 id=ntu-malware-reverse-lab-3-write-up>NTU Malware Reverse Lab 3 write up
<a class=anchor href=#ntu-malware-reverse-lab-3-write-up>#</a></h1><h6 id=tags-ntu_mr-malware-reverse-engineering-and-analysis-ntu>tags: <code>NTU_MR</code> <code>Malware Reverse Engineering and Analysis</code> <code>NTU</code>
<a class=anchor href=#tags-ntu_mr-malware-reverse-engineering-and-analysis-ntu>#</a></h6><p>[TOC]</p><table><thead><tr><th>Name</th><th>何秉學</th><th>StuID</th><th>R11921A16</th></tr></thead><tbody></tbody></table><h2 id=review-packing-and-unpacking>Review Packing and Unpacking
<a class=anchor href=#review-packing-and-unpacking>#</a></h2><ul><li>How does packing and unpacking work?
作者會把原本的code section和data section，放在UPX1，並且用unpacking stub(裡面存放解殼的程式)，把UPX1的內容一點一點的還原回UPX0(也就是空區段)，並跳回正常程式的執行進入點(original entry point, <code>OEP</code>)，最後跳回去的動作叫做<code>Tail Jump</code>或<code>Long Jump</code>，另外，多長的jump才是長，可能要依照經驗值判斷，或是直接跳過去後分析程式在幹嘛
<img src=https://imgur.com/TdhA1Tz.png alt></li><li>實際上執行脫殼的時候，除了<code>OEP</code>的重建外，還需要重建<code>Imports</code>，這兩者都處理好後才算是脫殼完成</li><li>當分析脫殼執行到如下圖這樣的情況時，就離終點不遠了，也就是<code>jmp</code>的地址離目前的程式很遠，且之後的程式有很多空指令或垃圾<code>byte</code>，<font color=FF0000><strong>此為<code>UXP</code>殼的特徵</strong></font>
<img src=https://imgur.com/KUbYRWa.png alt></li><li>可以用<code>PEiD</code>這個工具(或是用<code>Entropy</code>之類的，但是不一定準確)判斷樣本有沒有加殼，或是加了甚麼殼，上圖是沒有加殼的一般程式，下圖是加了<code>UPX</code>的加殼程式
<img src=https://imgur.com/T0sFBc6.png alt>
<img src=https://imgur.com/9hDQtVr.png alt></li><li>若是要處理<code>Import Table Reconstruction</code>，可以用<code>OllyDump</code>、<code>ImpRec</code>或是<code>Scylla</code>這些工具來進行，在<code>Practice</code>中是用<code>Scylla</code>演示(且可以搭配<code>x32dbg</code>或<code>x64dbg</code>進行)</li><li>老師有說在<code>Long Jump</code>之前會搭配<code>pop</code> instruction，這可能可以當作解析<code>OEP</code>的線索</li><li><code>Tail Jump</code>，不一定是用<code>jmp</code>，也可以是<code>call</code> instruction；另外，跳轉的地址也不一定是一個明確的地址，也可能用暫存器存起來，這部分可以注意一下</li></ul><h2 id=practice---upx_exerciseexe>Practice - <code>upx_exercise.exe</code>
<a class=anchor href=#practice---upx_exerciseexe>#</a></h2><h3 id=observation>Observation
<a class=anchor href=#observation>#</a></h3><ul><li>First things first, we can observe the file by executing it directly. Obviously, you should enter correct <code>CTF</code> key by analyzing.
<img src=https://imgur.com/RcXtqnV.png alt></li></ul><h3 id=unpacking>Unpacking
<a class=anchor href=#unpacking>#</a></h3><h4 id=static-analysis---ida-pro>Static analysis - <code>IDA Pro</code>
<a class=anchor href=#static-analysis---ida-pro>#</a></h4><ul><li>You are not allowed to disassembly by doing nothing, because it was packed by <code>UPX</code>. Therefore, our objective is to unpack it and try to analyze it original code to get the <code>CTF Flag</code>.
<img src=https://imgur.com/CkqgK9U.png alt></li></ul><h4 id=dynamic-analysis---x32dbg>Dynamic analysis - <code>x32dbg</code>
<a class=anchor href=#dynamic-analysis---x32dbg>#</a></h4><ul><li>In <code>UPX-based</code> packing, it has a feature that in order to not let the data be flushed during unpacking, it must store all data to the stack by using <font color=FF0000><code>pushad</code></font> instruction.
<img src=https://imgur.com/lgZWxPL.png alt></li><li>Then, you&rsquo;ll see a lot of <code>jmp</code> instruction to unpack the original code.
<img src=https://imgur.com/W0Bj1dq.png alt></li><li>Scrolling down the code, you&rsquo;ll see a <font color=FF0000><code>popad</code></font> instruction at <code>0x0134AEDE</code> , a <font color=FF0000><code>jmp</code></font> instruction at <code>0x010EAEEC</code>, and a lots of <code>null</code> instruction which all three are satisfied all features that <code>UPX-based</code> packing method has.
It&rsquo;ll restore all data that stored in stack and jump to <code>upx_exercise.134244D</code>.
<img src=https://imgur.com/vRJFQdU.png alt></li><li>Set the break-point and press <code>run</code> button in <code>x32dbg</code>, then press <code>step into</code> button to observe the code.</li><li>Now, the code has already unpacked, then we can use <font color=FF0000><strong><code>Scylla</code></strong></font> to do <code>Import Reconstruction</code>.
<img src=https://imgur.com/Tjn207G.png alt>
<img src=https://imgur.com/YBbISuc.png alt></li><li>Press <code>IAT Autosearch</code>(Import Address Table) button to search and then press <code>Get Imports</code> button. Finally, you will get all imports that this file used, and <code>Scylla</code> will help you to rebuild it.
<img src=https://imgur.com/yUzV49b.png alt>
Press <code>Dump</code> button to get <code>IAT</code> file.
<img src=https://imgur.com/6RkqgO4.png alt></li><li>Press <code>Fix Dump</code> and choose the file what we dump to reconnect the <code>IAT</code> and this file. You&rsquo;ll see the log said <code>Import Rebuild success</code> and you&rsquo;ll get a new file named <code>upx_exercise_dump_SCY.exe</code> that repaired by <code>Scylla</code>.
<img src=https://imgur.com/CIJEKcY.png alt></li></ul><h3 id=analyze>Analyze
<a class=anchor href=#analyze>#</a></h3><h4 id=re-static-analysis---ida-pro>Re-static analysis - <code>IDA Pro</code>
<a class=anchor href=#re-static-analysis---ida-pro>#</a></h4><ul><li>Used <code>IDA</code> to reanalyze the unpacking file.</li><li>Used string searching to find the string <code>nope</code> that appear in your <code>cmd</code>.
<img src=https://imgur.com/OeInenc.png alt></li><li>Used cross reference to find which part has used it.
<img src=https://imgur.com/o7xwDFE.png alt>
<img src=https://imgur.com/zvQqq0u.png alt></li><li>The main part is shown as below<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>...
</span></span><span style=display:flex><span>sub_E01EB0(std<span style=color:#f92672>::</span>cin, <span style=color:#f92672>&amp;</span>Memory);
</span></span><span style=display:flex><span>LOBYTE(v116) <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>MEMORY[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>v96 <span style=color:#f92672>=</span> <span style=color:#ae81ff>0xFCC1D3C4</span>;
</span></span><span style=display:flex><span>v97 <span style=color:#f92672>=</span> <span style=color:#ae81ff>0xD8D2C8DE</span>;
</span></span><span style=display:flex><span>v98 <span style=color:#f92672>=</span> <span style=color:#ae81ff>0xD8D3E8E0</span>;
</span></span><span style=display:flex><span>v99 <span style=color:#f92672>=</span> <span style=color:#ae81ff>0xD8C2EFB0</span>;
</span></span><span style=display:flex><span>v100 <span style=color:#f92672>=</span> <span style=color:#ae81ff>0xC2ECB3C1</span>;
</span></span><span style=display:flex><span>v101 <span style=color:#f92672>=</span> <span style=color:#ae81ff>0xB3EBE1D8</span>;
</span></span><span style=display:flex><span>v102 <span style=color:#f92672>=</span> <span style=color:#ae81ff>0xD5F3D8BE</span>;
</span></span><span style=display:flex><span>v103 <span style=color:#f92672>=</span> <span style=color:#ae81ff>0xB3EFD8DE</span>;
</span></span><span style=display:flex><span>v104 <span style=color:#f92672>=</span> <span style=color:#ae81ff>0xF5C2E3D5</span>;
</span></span><span style=display:flex><span>v105 <span style=color:#f92672>=</span> <span style=color:#ae81ff>0xFAD6D6D8</span>;
</span></span><span style=display:flex><span>v64 <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>HIBYTE(v95) <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>v65 <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>v93 <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>while</span> ( v65 <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>40</span> )
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    v66 <span style=color:#f92672>=</span> (<span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>)<span style=color:#f92672>&amp;</span>Memory;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> ( v111 <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>16</span> )
</span></span><span style=display:flex><span>        v66 <span style=color:#f92672>=</span> (<span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>)Memory;
</span></span><span style=display:flex><span>    v67 <span style=color:#f92672>=</span> v66[v65] <span style=color:#f92672>^</span> <span style=color:#ae81ff>0x87</span>;
</span></span><span style=display:flex><span>    v68 <span style=color:#f92672>=</span> <span style=color:#f92672>*</span>((<span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>__int8</span> <span style=color:#f92672>*</span>)<span style=color:#f92672>&amp;</span>v96 <span style=color:#f92672>+</span> v65);
</span></span><span style=display:flex><span>    v94 <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> ( v67 <span style=color:#f92672>!=</span> v68 )
</span></span><span style=display:flex><span>        v64 <span style=color:#f92672>=</span> v94;
</span></span><span style=display:flex><span>    HIBYTE(v95) <span style=color:#f92672>=</span> v64;
</span></span><span style=display:flex><span>    v93 <span style=color:#f92672>=</span> <span style=color:#f92672>++</span>v65;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>v69 <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;Congratz?!&#34;</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> ( <span style=color:#f92672>!</span>v64 )
</span></span><span style=display:flex><span>    v69 <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;Nope!&#34;</span>;
</span></span><span style=display:flex><span>...
</span></span></code></pre></div></li><li>From <code>v96</code> to <code>v105</code>, it stored 40 bytes and it seems do something in while loop 40 times. In addition, <code>v67 = v66[v65] ^ 0x87;</code> this line used <code>xor</code> instruction that seems a encrypt part. And then it compared <code>&amp;v96 + v65</code> and <code>v67</code> that encrypt the string what you input.</li><li>If all the strings you input after process <code>xor</code> to <code>0x87</code> are strictly the same with <code>v96</code> to <code>v105</code>, then it&rsquo;ll print <code>Congratz?!</code>, otherwise, print <code>Nope</code>.</li><li>Used <a href=https://xor.pw/#>online_xor</a> to get <code>v96</code> to <code>v105</code> encrypted strings.
<img src=https://imgur.com/5CkTwXn.png alt>
And then used <a href>online_hex2ascii</a> to get the <code>CTF Flag</code>.
<img src=https://imgur.com/BHA0PDT.png alt></li><li>The answer is <font color=FF0000><code>**CTF{YOU_goT_7hE_F4kE_fl49_tRY_h4RdEr_QQ}**</code></font>, though it is not a real answer.<ul><li>Note that, the demo from TA is finished, therefore, I still don&rsquo;t know the real flag is.</li></ul></li></ul><h2 id=homework---upx_revilexe>Homework - <code>upx_Revil.exe</code>
<a class=anchor href=#homework---upx_revilexe>#</a></h2><h3 id=static-analysis-observation>Static Analysis Observation
<a class=anchor href=#static-analysis-observation>#</a></h3><ul><li>Use <code>IDA</code> to analyze this sample and obviously packed sample
<img src=https://imgur.com/uzVMd5r.png alt></li><li>Use the skill above then you can answer the question easily.</li></ul><h2 id=homework---custom_packer_revilexe>Homework - <code>custom_packer_Revil.exe</code>
<a class=anchor href=#homework---custom_packer_revilexe>#</a></h2><h3 id=static-analysis-observation---detectiteasy>Static Analysis Observation - <code>DetectItEasy</code>
<a class=anchor href=#static-analysis-observation---detectiteasy>#</a></h3><ul><li><p>Though I used the tool, <code>DetectItEasy</code> to check if this sample was packed or not, the answer is not quite explicit.
<img src=https://imgur.com/Efv46o8.png alt></p></li><li><p>Through the write up made by <a href=https://github.com/securityjoes/conferences/tree/main/Confidence%202022/watch_out_and_just_skip_the_packer>Security Joe</a>, it&rsquo;s not a simple <code>UPX</code> sample.</p><blockquote><p>This packer can be classified as a <font color=FF0000>hybrid packer</font> because during its execution it injects several pieces of <code>shellcode</code> to finally replace the complete memory image of the PE. A diagram that explains this kind of packer is shown below.</p></blockquote><pre tabindex=0><code class=language-! data-lang=!>This kind of packer will do a self injection in its own memory space.Basically, it&#39;ll allocate or creating a new memory section in the same process and it can write shellcode or complete PE files to execute.
</code></pre></li><li><p>Basically, it&rsquo;s going to read the encrypted content, and gonna save or gonna copy that to the new section(the <font color=FFAA00>yellow</font> block)
<img src=https://user-images.githubusercontent.com/8562692/172320227-0bb75da9-2ec3-4276-ba5d-5544668b50f0.png alt></p></li></ul><h3 id=analyze--find-oep>Analyze & Find <code>OEP</code>
<a class=anchor href=#analyze--find-oep>#</a></h3><ol><li>Finding first injected <code>shellcode</code> (<code>LocalAlloc</code>)</li></ol><ul><li>Set the break point at <code>0x00404DB6</code> and step into this line
<img src=https://imgur.com/z6JFF9C.png alt></li><li>And you&rsquo;ll find the module that you are analyzing is <code>kernel32.dll</code>.
<img src=https://imgur.com/anxCj4G.png alt></li><li>This is not what we care, so we press the button(<code>Execute till return</code>) to skip this module.
<img src=https://imgur.com/awQDSUW.png alt>
And then step into this operation to go back to the custom packer REvil from windows library.</li><li>Follow the memory address in dump
<img src=https://imgur.com/eatiw0X.png alt>
Then continue to execute the code, you will see there are 3 nested loop. Please pay attention to the dump. When I finish the loop, the dump memory is different(Fig.2).
<img src=https://imgur.com/pARISgf.png alt>
<img src=https://imgur.com/oCy70c4.png alt>
These loops are aim to moving the <code>shellcode</code> to memory section, just as the same what we talked about before.</li><li>While you are continuing to execute forward, you can see the dump memory has changed at <code>0x00404E38</code>.
<img src=https://imgur.com/LVKPdMZ.png alt>
* Note that you can dump these memory to a new file by right click and select <code>Follow in Memory Map</code>, and then right click again then choose <font color=FF0000><code>Dump memory to File</code></font>
* Note that the file you dump is actually a <code>shellcode</code>. How to know?</li></ul><ol start=2><li>Finding second injected <code>shellcode</code> (<code>VirtualAlloc</code>)</li></ol><ul><li>Find the expression by pressing <code>Ctrl+G</code> and type <code>VirtualAlloc</code>.
<img src=https://imgur.com/UBEXcBO.png alt>
Set the break point at the first line and do the same thing above. Pressing <code>Execute till return</code> and check the memory by right click <code>EAX</code> and choose <code>Follow in Dump</code>.
<img src=https://imgur.com/QjXxqKH.png alt>
Finally, press <code>step into</code> to return</li><li>Like the same outcome above. While you are continuing to execute, you&rsquo;ll notice that memory have changed when you step over <code>0x02B95269</code>.
<img src=https://imgur.com/YRUQQo4.png alt>
* Note that this is 2nd <code>shellcode</code> that can check in disassembler.
<img src=https://imgur.com/4xGJ9Xv.png alt></li><li>And obviously, <code>0x02B9527D</code> is the 2nd tail jump that will jump to <font color=00BFFF>blue</font> <code>shellcode</code> block from <font color=FFCC00>yellow</font> <code>shellcode</code> block.
<img src=https://imgur.com/S6RsiQr.png alt></li><li>You can see that the jumping address is quite different with current address(the following image is not my actually circumstances)
<img src=https://imgur.com/qqNNPJU.png alt></li></ul><ol start=3><li>Payload decryption (<code>VirtualAlloc</code>)</li></ol><ul><li>In this section, it&rsquo;ll use <code>VirtualAlloc</code> again. So, we just press <code>Run</code> button to get in there. And follow the instruction above.
<img src=https://imgur.com/yrbpTEs.png alt></li><li>Go back → Follow <code>EAX</code> address in dump → Step into → You&rsquo;ll see 3 nested loop again → Set break point → Run → The memory changed in dump again(<font color=FF0000>this is our payload in memory</font>)
<img src=https://imgur.com/GRTJw51.png alt></li><li>Dump these code in a new file like above.
<img src=https://imgur.com/efIF2Xy.png alt></li></ul><ol start=4><li>Code substitution (<code>VirtualProtect</code>)</li></ol><ul><li><p>In this section, it&rsquo;ll use <code>VirtualProtect</code> <code>API</code>, so that we just follow the instruction above.</p></li><li><p>Find <code>VirtualProtect</code> by <code>Ctrl+G</code> → Set break point and press <code>Run</code> button</p><p><strong>Interesting things</strong>
Check out <a href=https://learn.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-virtualprotect>the page</a> talking about <code>VirtualProtect</code>.</p><blockquote><p>Changes the protection on a region of committed pages in the virtual address space of the calling process.
To change the access protection of any process, use the VirtualProtectEx function.</p></blockquote><p>And you can especiallly take a look at</p><blockquote><p>[in] flNewProtect
The memory protection option. This parameter can be one of the memory protection constants.</p></blockquote><p>Follow <a href=https://learn.microsoft.com/en-us/windows/win32/Memory/memory-protection-constants>the page</a>, you can notice that 0x40 is <font color=FF0000><strong><code>PAGE_EXECUTE_READWRITE</code></strong></font></p><p>You can see the whole parameters about <code>VirtualProtect</code> in <code>stdcall</code>.
<img src=https://imgur.com/yCwYFRP.png alt>
<strong>They want to modify the original section(replace)</strong></p></li><li><p>Continue the instruction mentioned above: go back → step into</p></li></ul><ol start=5><li>Finding the &ldquo;Tail jump&rdquo;</li></ol><ul><li>Scrolling~~ down and find a looooog jump at <code>0x001C091E</code> and step into.
<img src=https://imgur.com/93t3EUR.png alt></li></ul><ol start=6><li>Finding the <code>OEP</code>
<code>0x00404161</code> is your <code>OEP</code>
<img src=https://imgur.com/eMoPuUe.png alt></li></ol><h2 id=homework>Homework
<a class=anchor href=#homework>#</a></h2><ol><li><p>Analyze the malware found in the file <code>workshop_samples.zip</code> -> <code>upx_REvil.exe</code>, generate &lsquo;yourself&rsquo; <code>writeups</code> (with screenshots) and answer the follow questions:
1.1 Where is the memory address of the <strong>tail jump</strong>?
Ans:
When you see the machine instruction <code>popad</code>, the tail jump address is <font color=FF0000><code>0x00283F8C</code></font>
<img src=https://imgur.com/WhnF265.png alt>
1.2 Where is the <strong><code>OEP</code></strong> of the packed sample?
Ans:
The <strong><code>OEP</code></strong> address is <font color=FF0000><code>0x00264161</code></font></p></li><li><p>Analyze the malware found in the file <code>workshop_samples.zip</code> -> <code>custom_packer_REvil.exe</code>, generate &lsquo;yourself&rsquo; <code>writeups</code> (with screenshots) and answer the follow questions:
2.1 Where is the memory address of the <strong>tail jump</strong>?
Ans:
Scrolling~~ down and find a looooog jump at <code>0x001C091E</code> and step into.
<img src=https://imgur.com/93t3EUR.png alt>
2.2 Where is the <strong><code>OEP</code></strong> of the packed sample?
Ans:
<font color=FF0000><code>0x00404161</code></font> is your <code>OEP</code>
<img src=https://imgur.com/eMoPuUe.png alt></p></li></ol></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><ul><li></li></ul></li><li><a href=#review-packing-and-unpacking>Review Packing and Unpacking</a></li><li><a href=#practice---upx_exerciseexe>Practice - <code>upx_exercise.exe</code></a><ul><li><a href=#observation>Observation</a></li><li><a href=#unpacking>Unpacking</a></li><li><a href=#analyze>Analyze</a></li></ul></li><li><a href=#homework---upx_revilexe>Homework - <code>upx_Revil.exe</code></a><ul><li><a href=#static-analysis-observation>Static Analysis Observation</a></li></ul></li><li><a href=#homework---custom_packer_revilexe>Homework - <code>custom_packer_Revil.exe</code></a><ul><li><a href=#static-analysis-observation---detectiteasy>Static Analysis Observation - <code>DetectItEasy</code></a></li><li><a href=#analyze--find-oep>Analyze & Find <code>OEP</code></a></li></ul></li><li><a href=#homework>Homework</a></li></ul></nav></div></aside></main></body></html>