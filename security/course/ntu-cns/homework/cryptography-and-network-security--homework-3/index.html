<!doctype html><html lang=en-us dir=ltr><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="
  Cryptography and Network Security – Homework 3
  #



  tags: NTUCNS
  #

:::spoiler TOC
[TOC]
:::

  1. DDoS
  #


  1)
  #



Hint: You can use I/O Graphs to find the time that the flow starts to burst. Then you can find the first packet near there.


Ans: Using I/O graph in Statistic/I/O Graphs in wireshark, then you can figure out the whole trend of this network flow.
:::spoiler Result Screenshot

:::
Also, you can set the different scale of the graph and figure out the attack time precisely. I set the Interval=100ms and find the increasing time at 24.8s which is No.55862 packet shown as below.
:::spoiler Result Screenshot

:::
Thus, the attack time should be at 24.945277 and the victim is 192.168.232.95
:::spoiler Result Screenshot

:::"><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#343a40"><meta name=color-scheme content="light dark"><meta property="og:url" content="https://bernie6401.github.io/security/course/ntu-cns/homework/cryptography-and-network-security--homework-3/"><meta property="og:site_name" content="SBK Hugo Site"><meta property="og:title" content="Cryptography and Network Security – Homework 3"><meta property="og:description" content="Cryptography and Network Security – Homework 3 # tags: NTUCNS # :::spoiler TOC [TOC] :::
1. DDoS # 1) # Hint: You can use I/O Graphs to find the time that the flow starts to burst. Then you can find the first packet near there.
Ans: Using I/O graph in Statistic/I/O Graphs in wireshark, then you can figure out the whole trend of this network flow. :::spoiler Result Screenshot ::: Also, you can set the different scale of the graph and figure out the attack time precisely. I set the Interval=100ms and find the increasing time at 24.8s which is No.55862 packet shown as below. :::spoiler Result Screenshot ::: Thus, the attack time should be at 24.945277 and the victim is 192.168.232.95 :::spoiler Result Screenshot :::"><meta property="og:locale" content="en_us"><meta property="og:type" content="article"><meta property="article:section" content="security"><meta property="article:tag" content="NTUCNS"><meta property="article:tag" content="NTU"><title>Cryptography and Network Security – Homework 3 | SBK Hugo Site</title>
<link rel=icon href=/favicon.png><link rel=manifest href=/manifest.json><link rel=canonical href=https://bernie6401.github.io/security/course/ntu-cns/homework/cryptography-and-network-security--homework-3/><link rel=stylesheet href=/book.min.6c8b9d2a1fc95075ed7da46ca81060b39add8fff6741ac51259f768929281e2c.css integrity="sha256-bIudKh/JUHXtfaRsqBBgs5rdj/9nQaxRJZ92iSkoHiw=" crossorigin=anonymous><script defer src=/fuse.min.js></script><script defer src=/en.search.min.acdc41c8d39e6c69d70d8a23779875e0a3733fefead3e428d5344966bb12f562.js integrity="sha256-rNxByNOebGnXDYojd5h14KNzP+/q0+Qo1TRJZrsS9WI=" crossorigin=anonymous></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/><span>SBK Hugo Site</span></a></h2><div class="book-search hidden"><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><script>document.querySelector(".book-search").classList.remove("hidden")</script></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu></label><h3>Cryptography and Network Security – Homework 3</h3><label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><ul><li></li></ul></li><li><a href=#1-ddos>1. DDoS</a><ul><li><a href=#1>1)</a></li><li><a href=#2>2)</a></li><li><a href=#3>3)</a></li><li><a href=#4>4)</a></li><li><a href=#5>5)</a></li><li><a href=#6>6)</a></li></ul></li><li><a href=#2-smart-contract>2. Smart Contract</a></li><li><a href=#3-web-authentication>3. Web Authentication</a><ul><li><a href=#a>a)</a></li><li><a href=#b>b)</a></li><li><a href=#c>c)</a></li><li><a href=#d>d)</a></li><li><a href=#e>e)</a></li><li><a href=#f>f)</a></li></ul></li><li><a href=#4-accumulator>4. Accumulator</a><ul><li><a href=#a-1>a)</a></li><li><a href=#b-really-thx-for-r11944034-許智翔-for-inspiration>b) Really thx for R11944034 許智翔 for inspiration</a></li><li><a href=#c-1>c)</a></li><li><a href=#d-1>d)</a></li></ul></li><li><a href=#reference>Reference</a><ul><li><a href=#1-ddos-1>1. DDoS</a></li><li><a href=#3-web-authentication-1>3. Web Authentication</a></li><li><a href=#4-accumulator-1>4. Accumulator</a></li></ul></li></ul></nav></aside></header><article class="markdown book-article"><h1 id=cryptography-and-network-security--homework-3>Cryptography and Network Security – Homework 3
<a class=anchor href=#cryptography-and-network-security--homework-3>#</a></h1><p><a href=https://hackmd.io/JO7xByQgQWK67eU0goHMeA><img src=https://hackmd.io/JO7xByQgQWK67eU0goHMeA/badge alt=hackmd-github-sync-badge></a></p><h6 id=tags-ntucns>tags: <code>NTUCNS</code>
<a class=anchor href=#tags-ntucns>#</a></h6><p>:::spoiler TOC
[TOC]
:::</p><h2 id=1-ddos>1. DDoS
<a class=anchor href=#1-ddos>#</a></h2><h3 id=1>1)
<a class=anchor href=#1>#</a></h3><ul><li><p>Hint: You can use I/O Graphs to find the time that the flow starts to burst. Then you can find the first packet near there.</p></li><li><p>Ans: Using I/O graph in <code>Statistic/I/O Graphs</code> in wireshark, then you can figure out the whole trend of this network flow.
:::spoiler Result Screenshot
<img src=https://hackmd.io/_uploads/rJk-LueL3.jpg alt>
:::
Also, you can set the different scale of the graph and figure out the attack time precisely. I set the <code>Interval=100ms</code> and find the increasing time at <code>24.8s</code> which is <code>No.55862</code> packet shown as below.
:::spoiler Result Screenshot
<img src=https://hackmd.io/_uploads/ryG7POxL2.png alt>
:::
Thus, the attack time should be at <font color=FF0000><code>24.945277</code></font> and the victim is <font color=FF0000><code>192.168.232.95</code></font>
:::spoiler Result Screenshot
<img src=https://hackmd.io/_uploads/Syurtue8h.png alt>
:::</p><p>:::info
Note: You can observe that how many packets of each address received or transmitted in <code>Statistic/Endpoints</code>. You can note that the address <code>192.168.232.95</code> has received tons of packets.
:::spoiler Result Screenshot
<img src=https://hackmd.io/_uploads/BJ6r9dgI3.png alt>
:::</p></li></ul><h3 id=2>2)
<a class=anchor href=#2>#</a></h3><ul><li>Hint: How to find attack packets if you know the victim?</li><li>Ans: The protocol that the attack exploit is <font color=FF0000><code>UDP</code></font>. Maybe this is a <code>UDP</code> flood attack. And the size of an attack packet should be <font color=FF0000>$482$</font> bytes.</li><li>Note: You can set the filter <code>ip.dst==192.168.232.95 && udp</code> and observe the flow and packets.
:::spoiler Result Screenshot
<img src=https://hackmd.io/_uploads/HJ4hkte8n.png alt>
:::</li></ul><h3 id=3>3)
<a class=anchor href=#3>#</a></h3><ul><li>Ans:</li></ul><h3 id=4>4)
<a class=anchor href=#4>#</a></h3><ul><li><p>Background: this DDoS attack using NTP protocol to amplify the packets to achieve the attack.</p><blockquote><p>NTP 放大 DoS 攻擊利用響應遠程 monlist 請求的網絡時間協議（NTP）服務器。 monlist 函數返回與服務器交互的所有設備的列表，在某些情況下最多達 600 個列表。 攻擊者可以偽造來自目標 IP 地址的請求，並且漏洞服務器將為每個發送的請求返回非常大的響應 - by <a href=https://cloud.tencent.com/developer/article/2182801>Kali Linux網絡掃描秘籍第六章拒絕服務(二)</a>
:::spoiler Background
<img src=https://hackmd.io/_uploads/BkX8K9eL2.png alt>
:::</p></blockquote></li><li><p>Hint: You can find some useful statistics in <code>IPv4 Statistics</code>.</p></li><li><p>Ans: In <code>IPv4 Statistics</code>, we can note the several victims receive most of the packets. $\to$ <font color=FF0000><code>192.168.232.80</code>, <code>192.168.232.10</code>, <code>192.168.232.95</code></font>
:::spoiler Result Screenshot
<img src=https://hackmd.io/_uploads/B1W9QcgIn.png alt></p><p><img src=https://hackmd.io/_uploads/SyBgw5xLh.png alt>
:::</p><ul><li><code>192.168.232.80</code>: 28320 packets received</li><li><code>192.168.232.10</code>: 26870 packets received</li><li><code>192.168.232.95</code>: 23327 packets received</li><li>3 major amplifiers: <font color=FF0000><code>34.93.220.190</code>, <code>128.111.19.188</code>, <code>129.236.255.8</code></font></li></ul></li></ul><h3 id=5>5)
<a class=anchor href=#5>#</a></h3><ul><li>Background:<blockquote><p>NTP 放大 DoS 攻擊利用響應遠程 monlist 請求的網絡時間協議（NTP）服務器。 monlist 函數返回與服務器交互的所有設備的列表，在某些情況下最多達 600 個列表。 攻擊者可以偽造來自目標 IP 地址的請求，並且漏洞服務器將為每個發送的請求返回非常大的響應 - by <a href=https://cloud.tencent.com/developer/article/2182801>Kali Linux網絡掃描秘籍第六章拒絕服務(二)</a></p><p>NTP放大攻擊：網路時間協定(Network Time Protocol, NTP)是一種允許主機之間透過封包交換進行系統時間同步之網路協定。但在NTP協定中，有一個monlist指令，當NTP伺服器收到monlist請求後，會回傳多筆近期與之通訊的列表，該列表最高限制為600筆。而攻擊者便可利用此機制，以偽裝之IP位址寄送monlist請求給NTP伺服器，則NTP伺服器便會將至多600筆之數據傳送給遭攻擊者偽冒的IP位址，導致遭偽冒之受害主機因一次大量的數據傳輸，造成其網路頻寬無法負荷，致使受害伺服器無法正常提供服務。此種攻擊之放大係數為556.9，為所有DDoS放大攻擊中放大倍率次高者。 - by <a href=https://www.twcert.org.tw/tw/cp-157-6408-e0c62-1.html>分散式阻斷服務攻擊(DDoS)趨勢與防護</a></p></blockquote></li><li>Hint: You can use <code>nmap</code> or <code>ntpdc</code> to send a monlist query.</li><li>Ans:<ol><li><p>Determine if the remote server is running NTP service
I tried 9 IP(3 IP from previous question + 6 IPs provided from TAs)
Note: <code>-sU</code> option can be used to specify <font color=FF0000>UDP</font>, then the <code>-p</code> option can be used to specify the port
:::spoiler Command Result</p><pre tabindex=0><code class=language-bash! data-lang=bash!>$ sudo nmap -sU 128.111.19.188 -p 123
Starting Nmap 7.80 ( https://nmap.org ) at 2023-05-28 22:01 CST
Nmap scan report for cms28.physics.ucsb.edu (128.111.19.188)
Host is up (0.15s latency).

PORT    STATE  SERVICE
123/udp closed ntp

Nmap done: 1 IP address (1 host up) scanned in 0.92 seconds
$ sudo nmap -sU 34.93.220.190 -p 123
Starting Nmap 7.80 ( https://nmap.org ) at 2023-05-28 23:32 CST
Note: Host seems down. If it is really up, but blocking our ping probes, try -Pn
Nmap done: 1 IP address (0 hosts up) scanned in 3.21 seconds
$ sudo nmap -sU 129.236.255.89 -p 123
Starting Nmap 7.80 ( https://nmap.org ) at 2023-05-28 23:32 CST
Note: Host seems down. If it is really up, but blocking our ping probes, try -Pn
Nmap done: 1 IP address (0 hosts up) scanned in 3.16 seconds
$ sudo nmap -sU 142.44.162.188 -p 123
Starting Nmap 7.80 ( https://nmap.org ) at 2023-05-28 23:34 CST
Nmap scan report for 188.ip-142-44-162.net (142.44.162.188)
Host is up (0.19s latency).

PORT    STATE SERVICE
123/udp open  ntp

Nmap done: 1 IP address (1 host up) scanned in 1.06 seconds
sudo nmap -sU 91.121.132.146 -p 123
Starting Nmap 7.80 ( https://nmap.org ) at 2023-05-28 23:35 CST
Nmap scan report for ns3002114.ip-91-121-132.eu (91.121.132.146)
Host is up (0.28s latency).

PORT    STATE SERVICE
123/udp open  ntp

Nmap done: 1 IP address (1 host up) scanned in 1.59 seconds
$ sudo nmap -sU 82.65.72.200 -p 123
Starting Nmap 7.80 ( https://nmap.org ) at 2023-05-28 23:35 CST
Nmap scan report for 82-65-72-200.subs.proxad.net (82.65.72.200)
Host is up (0.26s latency).

PORT    STATE SERVICE
123/udp open  ntp

Nmap done: 1 IP address (1 host up) scanned in 1.40 seconds
$ sudo nmap -sU 81.23.0.110 -p 123
Starting Nmap 7.80 ( https://nmap.org ) at 2023-05-28 23:35 CST
Nmap scan report for clients-0.23.81.110.misp.ru (81.23.0.110)
Host is up (0.29s latency).

PORT    STATE         SERVICE
123/udp open|filtered ntp

Nmap done: 1 IP address (1 host up) scanned in 5.57 seconds
$ sudo nmap -sU 72.76.155.29 -p 123
Starting Nmap 7.80 ( https://nmap.org ) at 2023-05-28 23:36 CST
Nmap scan report for static-72-76-155-29.nwrknj.fios.verizon.net (72.76.155.29)
Host is up (0.21s latency).

PORT    STATE SERVICE
123/udp open  ntp

Nmap done: 1 IP address (1 host up) scanned in 1.17 seconds
$ sudo nmap -sU 61.216.81.26 -p 123
Starting Nmap 7.80 ( https://nmap.org ) at 2023-05-28 23:37 CST
Nmap scan report for 61-216-81-26.hinet-ip.hinet.net (61.216.81.26)
Host is up (0.017s latency).

PORT    STATE         SERVICE
123/udp open|filtered ntp

Nmap done: 1 IP address (1 host up) scanned in 0.55 seconds
</code></pre><p>:::
Final Result:
34.93.220.190 $\to$ down
128.111.19.188 $\to$ closed
129.236.255.89 $\to$ down
142.44.162.188 $\to$ open
91.121.132.146 $\to$ open
82.65.72.200 $\to$ open
81.23.0.110 $\to$ open|filtered
72.76.155.29 $\to$ open
61.216.81.26 $\to$ open|filtered</p></li><li><p>Determine if NTP service can be used for amplification attacks
:::spoiler Command Result</p><pre tabindex=0><code class=language-bash! data-lang=bash!>$ ntpdc -n -c monlist 34.93.220.190
34.93.220.190: timed out, nothing received
***Request timed out
$ ntpdc -n -c monlist 128.111.19.188
ntpdc: read: Connection refused
$ ntpdc -n -c monlist 129.236.255.89
129.236.255.89: timed out, nothing received
***Request timed out
$ ntpdc -n -c monlist 142.44.162.188
remote address          port local address      count m ver rstr avgint  lstint
===============================================================================
213.251.128.249          123 142.44.162.188         1 4 4      0    373     373
54.39.23.64              123 142.44.162.188         1 4 4      0    429     429
105.187.151.14         59585 142.44.162.188         1 3 2      0    784     784
...
$ ntpdc -n -c monlist 91.121.132.146
91.121.132.146: timed out with incomplete data
***Response from server was incomplete
$ ntpdc -n -c monlist 82.65.72.200
82.65.72.200: timed out with incomplete data
***Response from server was incomplete
$ ntpdc -n -c monlist 81.23.0.110
81.23.0.110: timed out with incomplete data
***Response from server was incomplete
$ ntpdc -n -c monlist 72.76.155.29
72.76.155.29: timed out with incomplete data
***Response from server was incomplete
$ ntpdc -n -c monlist 61.216.81.26
61.216.81.26: timed out, nothing received
***Request timed out
</code></pre><p>:::
In this moment the final result:
34.93.220.190 $\to$ timed out
128.111.19.188 $\to$ Connection refused
129.236.255.89 $\to$ timed out
142.44.162.188 $\to$ <font color=FF0000>Success</font>
91.121.132.146 $\to$ incomplete
82.65.72.200 $\to$ incomplete
81.23.0.110 $\to$ incomplete
72.76.155.29 $\to$ incomplete
61.216.81.26 $\to$ timed out</p></li><li><p>Record the network flow and compute the amplification factor
In my network situation and remote server circumstances, I received 100 packets with $482\ bytes*100\ packets=48200\ bytes$ from NTP server so the amplification factor is just <font color=FF0000>$48200/234 \cong 206$</font> directly (234 is transmit packet size).
:::spoiler Result Screenshot
<img src=https://hackmd.io/_uploads/SyUpW5-8h.png alt>
:::</p></li></ol></li></ul><h3 id=6>6)
<a class=anchor href=#6>#</a></h3><ul><li>Ans 1:<ul><li>Implement rate limiting to restrict the number of UDP packets from a single source IP.</li><li>Use traffic filtering mechanisms like ACLs or firewalls to block malicious UDP traffic.</li><li>Deploy IPS/IDS systems to automatically block or mitigate the attack.</li><li>Enable flow monitoring to detect abnormal traffic patterns.</li></ul></li><li>Ans 2:<ul><li>Deploy firewalls and routers with robust security features.</li><li>Use IDS/IPS systems to detect and block malicious UDP traffic.</li><li>Implement traffic shaping and QoS to prioritize legitimate traffic.</li><li>Consider using specialized DDoS mitigation services.</li><li>Monitor network traffic for signs of UDP flood attacks.</li><li>Keep network infrastructure and security measures up to date.</li></ul></li></ul><h2 id=2-smart-contract>2. Smart Contract
<a class=anchor href=#2-smart-contract>#</a></h2><p>(SKIP&mldr;)</p><h2 id=3-web-authentication>3. Web Authentication
<a class=anchor href=#3-web-authentication>#</a></h2><h3 id=a>a)
<a class=anchor href=#a>#</a></h3><p>Username: <code>CNS-user</code>
Password: <code>CNS-password</code></p><ol><li><p>Basic Authentication
How to deploy your service? You can refer to <a href="https://www.youtube.com/watch?v=G1EVWLjwvrE&amp;ab_channel=TechieBlogging">this video</a> and remember to set the extra command <code>pip install flask-httpauth</code> to install other library.
:::spoiler Example Screenshot
<img src=https://hackmd.io/_uploads/Sko6ZheD2.png alt>
:::
:::spoiler Whole Script</p><pre tabindex=0><code class="language-python=" data-lang="python=">from flask import Flask
from flask_httpauth import HTTPBasicAuth

app = Flask(__name__)
auth = HTTPBasicAuth()

users = {
    &#34;CNS-user&#34;: &#34;CNS-password&#34;,
}

@auth.verify_password
def verify_password(username, password):
    if username in users and password == users[username]:
        return username

@app.route(&#39;/&#39;)
@auth.login_required
def index():
    return &#34;Hello, {}!&#34;.format(auth.current_user())

if __name__ == &#39;__main__&#39;:
    app.run(port=8880)
</code></pre><p>:::
Flag: <code>CNS{H77P_4U7h_r0CK2}</code></p></li><li><p>Cookie-Based Authentication
:::spoiler Description</p><blockquote><p>In this subtask, you will implement cookie-based authentication.
First, I will perform &lsquo;POST /&rsquo;, which contains two fields: &lsquo;username&rsquo; and &lsquo;password&rsquo;, in application/x-www-form-urlencoded format.
Then I will execute &lsquo;GET /&rsquo;, which will contain the cookies returned in the previous POST request.
:::
:::spoiler Whole Script</p></blockquote><pre tabindex=0><code class="language-python=" data-lang="python=">from flask import Flask, request, redirect, render_template, make_response
import hashlib

app = Flask(__name__)
app.secret_key = &#39;your_secret_key&#39;

users = {
    &#39;CNS-user&#39;: {
        &#39;password&#39;: &#39;CNS-password&#39;
    },
}

@app.route(&#39;/&#39;, methods=[&#34;GET&#34;, &#39;POST&#39;])
def login():
    if request.method == &#39;POST&#39;:
        username = request.form[&#34;username&#34;]
        password = request.form[&#39;password&#39;]
        print(username, password)

        if username in users and users[username][&#39;password&#39;] == password:
            response = make_response(redirect(&#39;/&#39;))
            response.set_cookie(&#39;username&#39;, hashlib.sha256(password.encode()).hexdigest())
            return response, 200
        return &#39;Invalid username or password!&#39;, 401

    elif request.method == &#34;GET&#34; and request.cookies.get(&#34;username&#34;) == hashlib.sha256(b&#39;CNS-password&#39;).hexdigest():
        return &#34;Success&#34;, 200

    elif request.method == &#34;GET&#34; and request.cookies.get(&#34;username&#34;) != hashlib.sha256(b&#39;CNS-password&#39;).hexdigest():
        if request.cookies.get(&#34;username&#34;) != None:
            return &#34;Unsuccess&#34;, 401
        else:
            return &#34;Hello&#34;, 401


if __name__ == &#39;__main__&#39;:
    app.run(host=&#34;127.0.0.1&#34;, port=7777, debug=True)
</code></pre><p>:::
Flag: <code>CNS{CooK135_4R3_d3L1c1ou2}</code></p></li><li><p>JWT-Based
:::spoiler Description</p><blockquote><p>In this subtask, you will implement JWT-based authentication.
First, I will execute &lsquo;POST /&rsquo;, which contains two fields: &lsquo;username&rsquo; and &lsquo;password&rsquo;, in application/x-www-form-urlencoded format.
Your service should output the token directly in the HTTP response body.
Then I will execute &lsquo;GET /&rsquo; with the token.
:::</p></blockquote></li></ol><h3 id=b>b)
<a class=anchor href=#b>#</a></h3><ul><li>Basic HTTP Authentication:<ul><li>Pros:
Simple to implement and widely supported by browsers and servers.
No additional server-side storage required, as the credentials are sent with each request.</li><li>Cons:
The credentials are sent with every request, which can increase the risk if the connection is not secured with HTTPS.
The password is base64-encoded, which is not a secure encryption method. It can be easily decoded if intercepted.</li><li>Basic HTTP Authentication is a simple and widely supported method, but it has security limitations. Sending credentials with each request can be risky, especially if the connection is not secured. Additionally, base64 encoding doesn&rsquo;t provide encryption, making it vulnerable to interception.</li></ul></li><li>Cookie-based Authentication:<ul><li>Pros:
Stateless on the server side. The server doesn&rsquo;t need to store user sessions as the session ID is included with each request.
Session ID is stored on the client-side, making it less vulnerable to interception.</li><li>Cons:
Requires server-side storage or a session management system to handle session IDs securely.
Vulnerable to session hijacking if proper security measures like session expiration and secure cookie flags are not implemented.</li><li>Cookie-based Authentication is more secure than Basic Authentication as the session ID is stored on the client-side. However, it requires server-side storage or session management systems. If proper security measures are not implemented, session hijacking attacks can occur.</li></ul></li><li>JWT-based Authentication:<ul><li>Pros:
Stateless on the server side. The server doesn&rsquo;t need to store session data as all required information is encoded in the JWT.
Enables easy scalability and interoperability, as JWTs can be used across multiple services or distributed systems.
Allows for fine-grained control by including user-related data (claims) within the token.</li><li>Cons:
The server needs to maintain the secret key securely to prevent unauthorized JWT issuance or tampering.
If a JWT is compromised, it remains valid until its expiration time, as tokens are self-contained and don&rsquo;t require round-trips to the server for validation.</li><li>JWT-based Authentication is a stateless and scalable method, making it suitable for distributed systems. It allows for fine-grained control and doesn&rsquo;t require server-side storage. However, the server needs to securely manage the secret key. If a JWT is compromised, it remains valid until expiration.</li></ul></li></ul><h3 id=c>c)
<a class=anchor href=#c>#</a></h3><h4 id=recon>Recon
<a class=anchor href=#recon>#</a></h4><p>Alice implemented a great web service that uses the <code>JWT</code> stored in the cookie to authenticate users. So, we can access the token as below:</p><ul><li>Header: <code>{"alg":"RS256","typ":"JWT"}</code></li><li>Payload: <code>{"username":"guest","flag1":"CNS{JW7_15_N07_a_900d_PLACE_70_H1DE_5ecrE75}","exp":1686041128}</code></li><li>:::spoiler Signature with base64 encode:
<code>Wz1mXQiYh3OvEdrQ2y1nWTwAbNs7HE1rjBQ8HBv9DhFLax9im4J4CQqS-vXymyuLJGXnrq18b4HlurRwjoIo1036ecsHM_dQfkkUZm9NqhYMmRwl1DRjQx7RvH4FccBIXhhOBu2Jzw3pSHfILFmMUqg26weWiu4f-gE3u5by0ylMqfIwZtG-J-VLA9QFSth9vobjM610MNIuTPQODH9r8Cy1cpttZ2QPuHfPMPARF11kIIJ-ebDXnV6t1I7FB6Nv4-Mk3JUsBOKBRMVh1eiZ2_3Xx4YzNUfZb5LQzCMcjsMpHWoV1WvIEEMW5SXAVOCbCyRUhcVtqXVI_VodM_hnKA</code>
:::</li><li>Flag 1: Just hide in cookie and use <code>base64</code> online decoder, you&rsquo;ll obtain <code>CNS{JW7_15_N07_a_900d_PLACE_70_H1DE_5ecrE75}</code></li></ul><h4 id=exp-for-another-flag>Exp for another flag
<a class=anchor href=#exp-for-another-flag>#</a></h4><p>The description said another flag is hidden in the account with the username <code>admin</code>. Thus, we can tamper the token that used different algorithm to sign the payload.</p><ul><li>Problem 1:
If we have to used another algorithm like <code>HS256</code>, we need RSA public key to sing the payload. What is public key(n, e) in this token?</li><li>Problem 2:
How to generate <code>.pem</code> file?</li><li>Problem 3:
How to implement <code>JWT</code> signature to sign the payload?</li></ul><hr><ol><li><p>Find the <code>N</code> and <code>e</code> of RSA public key
We note that every time your refresh the web page, the tokens are quite different because of different expired time.
So, how can we used these plaintext and signature pair to construct original <code>N</code>
$$
\downarrow\
m_1^e \equiv c_1\ (mod\ N)\
m_2^e \equiv c_2\ (mod\ N)\
m_3^e \equiv c_3\ (mod\ N)\
\downarrow\
m_1^e - c_1\ = \alpha N\
m_2^e - c_2\ = \beta N\
m_3^e - c_3\ = \gamma N
$$
Thus, we can find $N$ using $gcd(αN, βN, γN)=N$. Note that the large number calculation can use <font color=FF0000><code>gmpy2</code></font> library.</p><p>:::danger
Remember the work flow of signature in RSA: You can refer <a href=https://pycryptodome.readthedocs.io/en/latest/src/signature/pkcs1_v1_5.html>this page</a>
The work flow is <code>b'hello'</code>$\to$do hash by <code>sha256</code>$\to$do padding by<code>pkcs#1v1.5</code>$\to$ then sign$\to$ciphertext</p><p>Note 2 From TA: PKCS v1.5 padding 在encryption與signature的操作不太一樣喔，有 random bytes的是encryption，詳細可以參考<a href=https://www.rfc-editor.org/rfc/rfc3447#section-9.2>spec</a>
:::
:::spoiler Exp Script</p><pre tabindex=0><code class="language-python=" data-lang="python=">import base64
import gmpy2
from Crypto.Signature import pkcs1_15
from Crypto.Hash import SHA256
from base64 import urlsafe_b64encode, urlsafe_b64decode
import jwt
from Crypto.PublicKey import RSA

&#39;&#39;&#39;
Compute RSA Public Key - (N, e)
&#39;&#39;&#39;
def initialize(message, c_or_m):
    if c_or_m == &#39;c&#39;:
        return gmpy2.mpz(int(base64.urlsafe_b64decode(message).hex(), 16))
    elif c_or_m == &#39;m&#39;:
        return gmpy2.mpz(int(pkcs1_15._EMSA_PKCS1_V1_5_ENCODE(SHA256.new(message.encode()), 256).hex(), 16))

ciphertext = {
    0 : &#34;AMpJDyvv2burdO35LvbtykwdhCOItlRv0pyvE3WB7ysDqrpmy0ZbIJfkvddHLBMTLad9jgz9DV9B_Y4aPNIAs6_QibK22BoPMwmbhE_qw88rMjpf5Ph-SmmuTb51VLz4gO9QEX03AekBD5VHYHttuyln4AJdZ8y0-VUCvlyi_lEDqmRPpCnCUN1tuK6KcnKVa0IfaB1kTKzBFEFtL3oPrC9Qtp5bkYxrPXslhYhlCHRDjL_TrGn_A5g5CwONHFNczVNRig5oSyY6XV49vAJrxWMUeNKXkU49JLgGYF01tQvRDPi7m7gtTVjhQLVTV_-qkYuVbGr2bgx2PhSheA2Xcg==&#34;,
    1 : &#34;R8QnOGx9aBt7Hjh6wXG3JmqhutNB7a7oCNWZvVUg4bhtdVWpG1WyehCczOnBs-uLcZnXg4AO6ppf4Qt2p70s7dCKsSv3YJ2L_BBXFWjlgSmNlfxTznGgMY49_0l8hmSB4A1TRbIrxLmncZmmHiTt7Fm-sUNqCl097myfu-54sMNunZktpNrQfj9PYrQuDf2HmEfw-7uDGQPThSl0vjTBQDW3adnRZOKtQ1n-xDucEVy5twxS6Tn8LNs25xn7u2ts8qFrVHFe_WlihBmZgGjmgjvkbhcKinQ3uLFx5XRw_kpQ1yjN9NMZcELV_XeGLExuRIS4TundCGYLuDIp8NKLhQ==&#34;,
    2 : &#34;BfwxVR2DBeti1TdWm37Mj9V6hYOz-tdTisf7Lu98tz-jQgHWDUkM0RDzjUYha6wH7ZCqXGn8Les4Lk-k5zbpT_flEtu6e_w5wEKJbm2-i6OeZxZLiXLP0aOs-sSVmkdcRR-3tGWSuA6SL4VQokZUTv-4Td5FrurU6NKi6ZuwSWk8F5O6MIBi7Boncv6SnWtH93GsHCeXlVmQKvSWH0dPJDS00UwvtNSQ9moF0zhuBWIZqhjS89VWwWt5LJnbtzkEGSM5MxYsk-F8xKntwO9oiPYWeK-mo9JvGg6RnM5Poanzzbmcdw055X1wseBS2Pbv1pPEN0g6mHKuRQoc7slWEA==&#34;,
    3 : &#34;M74GetHK2cRPuaB9HFrXYhMX8iAaQmyEOCC2xIGaYDTgZ0EfbcyST5acMfHmlLZ4ylsCVzIc3uoRWHnKo-KTTn4ECCWpdAzbzKvlpxurm4zF1b1oAfsnw7Mdv68XR1X7FEpnGT2FnXJNTbhEOwc2Bb8qgy8lYVXhIKuL-0734JWjs9V4V3UnC2TBcXfwRR1xddeXzEYoyGAm_vIY9T051jTT0OljDruQhIDH1kPTuBrJNXuedDlIc9BXZzPcBsKPdRhFb7EET8C-UheTwDM8tLAykWNcegf0-VVqP92bC80scJEgKV7HHtPU6nh7FA0_i49QSMndRsFB_96RjdTSQA==&#34;
}

plaintext = {
    0 : &#34;eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6Imd1ZXN0IiwiZmxhZzEiOiJDTlN7Slc3XzE1X04wN19hXzkwMGRfUExBQ0VfNzBfSDFERV81ZWNyRTc1fSIsImV4cCI6MTY4NjU4Mzc1OX0&#34;,
    1 : &#34;eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6Imd1ZXN0IiwiZmxhZzEiOiJDTlN7Slc3XzE1X04wN19hXzkwMGRfUExBQ0VfNzBfSDFERV81ZWNyRTc1fSIsImV4cCI6MTY4NjU4MzgwNX0&#34;,
    2 : &#34;eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6Imd1ZXN0IiwiZmxhZzEiOiJDTlN7Slc3XzE1X04wN19hXzkwMGRfUExBQ0VfNzBfSDFERV81ZWNyRTc1fSIsImV4cCI6MTY4NjU4Mzg1MH0&#34;,
    3 : &#34;eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6Imd1ZXN0IiwiZmxhZzEiOiJDTlN7Slc3XzE1X04wN19hXzkwMGRfUExBQ0VfNzBfSDFERV81ZWNyRTc1fSIsImV4cCI6MTY4NjU4Mzg4Mn0&#34;
}

c = {}
m = {}
for i in range(4):
    c[i] = initialize(ciphertext[i], &#39;c&#39;)
    m[i] = initialize(plaintext[i], &#39;m&#39;)


e = gmpy2.mpz(65537) # The default parameter in openssl
a_N = c[0]**e - m[0]
b_N = c[1]**e - m[1]
c_N = c[2]**e - m[2]

n = gmpy2.gcd(a_N, b_N, c_N)
</code></pre><p>:::</p></li><li><p>Generate <code>public-key.pem</code> file
Now, we know what <code>N</code> is, so we can generate a <code>.pem</code> file with properly format. According to <a href=https://stackoverflow.com/questions/76458680/how-can-i-generate-rsa-public-key-with-specified-n-and-e-parameter-by-using-open>this page</a>, the script is show as below:
:::spoiler Whole script</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>from</span> Crypto.PublicKey <span style=color:#f92672>import</span> RSA
</span></span><span style=display:flex><span>n <span style=color:#f92672>=</span> <span style=color:#ae81ff>0x8ffcd5ae700b26f96316817101f254071b082b209196371eabf52d9a5e80eb64d5f4c4a1533e147f3c27b7e941622c25db41f21f502f6fd94d4b994b9448d824f24d27845da8cf5f8e10ddd1ac05ef54c490aaa7ac028efafe205d0633c62cd72ff3f874497a67c5458adaec91be0859e82a300f345ecd007115b9cb653e6b9ba670ea61e31b4b4b13bcba8cb324777e751c6b9fe531f5c6d61dd459674e57d08c03e1202f66b835220d097a9429fa5dcc22f8fbf80ddb1bb0b59ad98d4b462619ec3642ea1f6fdb7420b9602b4a8c4f66aaa0932b36d7ab4102392cd71803076acf2947cd253ea5580a0c1228ddd7647ef3d6e7c43f3d5d9654cf0d47d390d1</span>
</span></span><span style=display:flex><span>e <span style=color:#f92672>=</span> <span style=color:#ae81ff>0x10001</span>
</span></span><span style=display:flex><span>key_params <span style=color:#f92672>=</span> (n, e)
</span></span><span style=display:flex><span>key <span style=color:#f92672>=</span> RSA<span style=color:#f92672>.</span>construct(key_params)
</span></span><span style=display:flex><span>f <span style=color:#f92672>=</span> open(<span style=color:#e6db74>&#39;./rsa-public-key.pem&#39;</span>, <span style=color:#e6db74>&#39;w&#39;</span>)
</span></span><span style=display:flex><span>f<span style=color:#f92672>.</span>write(key<span style=color:#f92672>.</span>exportKey()<span style=color:#f92672>.</span>decode())
</span></span><span style=display:flex><span>f<span style=color:#f92672>.</span>close()
</span></span></code></pre></div><p>:::</p></li><li><p>Implement <code>JWT</code> to sign the payload by using public key
<font color=FF0000>Note that you must make sure that the public key has a new line symbol at the end of the file</font>
:::spoiler Whole Script</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>import</span> jwt
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> hashlib
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> hmac
</span></span><span style=display:flex><span>key <span style=color:#f92672>=</span> <span style=color:#e6db74>b</span><span style=color:#e6db74>&#34;-----BEGIN PUBLIC KEY-----</span><span style=color:#ae81ff>\n\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span><span style=color:#e6db74>MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAj/zVrnALJvljFoFxAfJU</span><span style=color:#ae81ff>\n\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span><span style=color:#e6db74>BxsIKyCRljceq/Utml6A62TV9MShUz4Ufzwnt+lBYiwl20HyH1Avb9lNS5lLlEjY</span><span style=color:#ae81ff>\n\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span><span style=color:#e6db74>JPJNJ4RdqM9fjhDd0awF71TEkKqnrAKO+v4gXQYzxizXL/P4dEl6Z8VFitrskb4I</span><span style=color:#ae81ff>\n\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span><span style=color:#e6db74>WegqMA80Xs0AcRW5y2U+a5umcOph4xtLSxO8uoyzJHd+dRxrn+Ux9cbWHdRZZ05X</span><span style=color:#ae81ff>\n\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span><span style=color:#e6db74>0IwD4SAvZrg1Ig0JepQp+l3MIvj7+A3bG7C1mtmNS0YmGew2Quofb9t0ILlgK0qM</span><span style=color:#ae81ff>\n\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span><span style=color:#e6db74>T2aqoJMrNterQQI5LNcYAwdqzylHzSU+pVgKDBIo3ddkfvPW58Q/PV2WVM8NR9OQ</span><span style=color:#ae81ff>\n\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span><span style=color:#e6db74>0QIDAQAB</span><span style=color:#ae81ff>\n\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span><span style=color:#e6db74>-----END PUBLIC KEY-----</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>
</span></span><span style=display:flex><span>header <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;{&#34;alg&#34;: &#34;HS256&#34;, &#34;typ&#34;: &#34;JWT&#34;}&#39;</span>
</span></span><span style=display:flex><span>payload <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;{&#34;username&#34;:&#34;admin&#34;,&#34;flag1&#34;:&#34;CNS</span><span style=color:#e6db74>{JW7_15_N07_a_900d_PLACE_70_H1DE_5ecrE75}</span><span style=color:#e6db74>&#34;,&#34;exp&#34;:1786583759}&#39;</span>
</span></span><span style=display:flex><span>header <span style=color:#f92672>=</span> base64<span style=color:#f92672>.</span>urlsafe_b64encode(bytes(header, <span style=color:#e6db74>&#34;utf-8&#34;</span>))<span style=color:#f92672>.</span>decode()<span style=color:#f92672>.</span>replace(<span style=color:#e6db74>&#34;=&#34;</span>, <span style=color:#e6db74>&#34;&#34;</span>)<span style=color:#f92672>.</span>encode()
</span></span><span style=display:flex><span>payload <span style=color:#f92672>=</span> base64<span style=color:#f92672>.</span>urlsafe_b64encode(bytes(payload, <span style=color:#e6db74>&#34;utf-8&#34;</span>))<span style=color:#f92672>.</span>decode()<span style=color:#f92672>.</span>replace(<span style=color:#e6db74>&#34;=&#34;</span>, <span style=color:#e6db74>&#34;&#34;</span>)<span style=color:#f92672>.</span>encode()
</span></span><span style=display:flex><span>sig <span style=color:#f92672>=</span> hmac<span style=color:#f92672>.</span>new(key, header <span style=color:#f92672>+</span> <span style=color:#e6db74>b</span><span style=color:#e6db74>&#39;.&#39;</span> <span style=color:#f92672>+</span> payload, hashlib<span style=color:#f92672>.</span>sha256)<span style=color:#f92672>.</span>digest()<span style=color:#f92672>.</span>strip()
</span></span><span style=display:flex><span>sig <span style=color:#f92672>=</span> base64<span style=color:#f92672>.</span>urlsafe_b64encode(sig)<span style=color:#f92672>.</span>decode()<span style=color:#f92672>.</span>replace(<span style=color:#e6db74>&#34;=&#34;</span>, <span style=color:#e6db74>&#34;&#34;</span>)
</span></span><span style=display:flex><span>jwt <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;</span><span style=color:#e6db74>{}</span><span style=color:#e6db74>.</span><span style=color:#e6db74>{}</span><span style=color:#e6db74>.</span><span style=color:#e6db74>{}</span><span style=color:#e6db74>&#39;</span><span style=color:#f92672>.</span>format(header<span style=color:#f92672>.</span>decode(), payload<span style=color:#f92672>.</span>decode(), sig)
</span></span><span style=display:flex><span>print(jwt)
</span></span></code></pre></div><p>:::</p></li><li><p>Then replace the web page original token and you&rsquo;ll get the flag
Note that the expire time in payload should be careful.</p></li></ol><ul><li>Flag 2: <code>CNS{4L9_15_un7Ru573d_u53r_1nPU7}</code></li></ul><h3 id=d>d)
<a class=anchor href=#d>#</a></h3><ul><li>Just follow the <a href=https://github.com/pyauth/pyotp/tree/develop>library code</a>
:::spoiler Script Code<pre tabindex=0><code class=language-python! data-lang=python!>&#39;&#39;&#39;
Implement TOTP
&#39;&#39;&#39;
import calendar
import datetime
import hashlib
import time
from typing import Any, Optional, Union
import unicodedata
from hmac import compare_digest
from typing import Dict, Optional, Union
from urllib.parse import quote, urlencode, urlparse
import base64
import hmac


class OTP(object):
    def __init__(
        self,
        s: str,
        digits: int = 6,
        digest: Any = hashlib.sha1,
        name: Optional[str] = None,
        issuer: Optional[str] = None,
    ) -&gt; None:
        self.digits = digits
        if digits &gt; 10:
            raise ValueError(&#34;digits must be no greater than 10&#34;)
        self.digest = digest
        self.secret = s
        self.name = name or &#34;Secret&#34;
        self.issuer = issuer

    def generate_otp(self, input: int) -&gt; str:
        if input &lt; 0:
            raise ValueError(&#34;input must be positive integer&#34;)
        hasher = hmac.new(self.byte_secret(), self.int_to_bytestring(input), self.digest)
        hmac_hash = bytearray(hasher.digest())
        offset = hmac_hash[-1] &amp; 0xF
        code = (
            (hmac_hash[offset] &amp; 0x7F) &lt;&lt; 24
            | (hmac_hash[offset + 1] &amp; 0xFF) &lt;&lt; 16
            | (hmac_hash[offset + 2] &amp; 0xFF) &lt;&lt; 8
            | (hmac_hash[offset + 3] &amp; 0xFF)
        )
        str_code = str(10_000_000_000 + (code % 10**self.digits))
        return str_code[-self.digits :]

    def byte_secret(self) -&gt; bytes:
        secret = self.secret
        missing_padding = len(secret) % 8
        if missing_padding != 0:
            secret += &#34;=&#34; * (8 - missing_padding)
        return base64.b32decode(secret, casefold=True)

    @staticmethod
    def int_to_bytestring(i: int, padding: int = 8) -&gt; bytes:
        result = bytearray()
        while i != 0:
            result.append(i &amp; 0xFF)
            i &gt;&gt;= 8
        return bytes(bytearray(reversed(result)).rjust(padding, b&#34;\0&#34;))


class TOTP(OTP):
    def __init__( self, s: str, digits: int = 6, digest: Any = None, name: Optional[str] = None, issuer: Optional[str] = None, interval: int = 30 ) -&gt; None:
        if digest is None:
            digest = hashlib.sha1

        self.interval = interval
        super().__init__(s=s, digits=digits, digest=digest, name=name, issuer=issuer)

    def now(self) -&gt; str:
        return self.generate_otp(self.timecode(datetime.datetime.now()))

    def timecode(self, for_time: datetime.datetime) -&gt; int:
        if for_time.tzinfo:
            return int(calendar.timegm(for_time.utctimetuple()) / self.interval)
        else:
            return int(time.mktime(for_time.timetuple()) / self.interval)


&#39;&#39;&#39;
Using TOTP solve problem
&#39;&#39;&#39;
import pyotp
import time
from pwn import *


def TOTP_new(shared_secret):
    totp = TOTP(shared_secret)
    return totp.now()

def TOTP_old(shared_secret):
    totp = pyotp.TOTP(shared_secret)
    return totp.now()

test = &#34;5VZG4WBEPL3NLPG7QTLDLD3EWOM37IDE&#34;
print(TOTP_new(test))
print(TOTP_old(test))

# r = remote(&#34;cns.csie.org&#34;, 17504)
# context.arch = &#39;amd64&#39;
# r.recvline()

# for i in range(128):
#     key = r.recvline().strip().split()[-1].decode()
#     r.sendline(TOTP_new(key).encode())


# r.interactive()
</code></pre>:::
Flag: <code>CNS{2FA_15_9R347_y0U_5H0Uld_h4v3_0N3}</code></li></ul><h3 id=e>e)
<a class=anchor href=#e>#</a></h3><ul><li>Hint 1: There are strings in the cookie that look like hashes, what could they be?</li><li>Hint 2: If you failed to figure out what hint 1 means, here’s another method. It’s the era of Machine Learning. Even babies know what Convolutional Neural Network is.</li><li>Hint 3: What are some common ways to get the user’s IP when the web service is behind a reverse proxy? Are these common practices secure?</li></ul><h4 id=recon-and-hint>Recon and Hint
<a class=anchor href=#recon-and-hint>#</a></h4><ul><li>From the hint and description, we know that our goal is to brute force this login authentication with <font color=FF0000>captcha challenge</font> and <font color=FF0000>rate limitations(3 attempts)</font>.</li><li>As the <a href=https://xxgblog.com/2018/10/12/x-forwarded-for-header-trick/>reference here</a>, we can bypass the rate limitation.</li><li>As the hint above, we have 2 types attack, <code>CNN recognition</code>, <code>replay attack</code>, and I choose <code>replay attack</code>, btw.
The replay attack is just fit the same cookie and captcha parameter at each attack, then we can bypass this captcha.</li></ul><h4 id=how-to-exploit>How to exploit?
<a class=anchor href=#how-to-exploit>#</a></h4><ol><li>Access <code>http://cns.csie.org:17505</code> in Burp Suite
Intercept the packet and send to <font color=FF0000>Intruder</font></li><li>Generate variety IP<pre tabindex=0><code class=language-python! data-lang=python!>f = open(&#34;./Gen_IP.txt&#34;, &#34;w&#34;)

for i in range(256):
    for j in range(256):
        f.write(&#34;140.112.&#34;+str(i)+&#34;.&#34;+str(j)+&#34;\n&#34;)

f.close()
</code></pre></li><li>wget password payload<pre tabindex=0><code class=language-bash! data-lang=bash!>$ wget https://raw.githubusercontent.com/danielmiessler/SecLists/master/Passwords/xato-net-10-million-passwords-10000.txt
</code></pre></li><li>Set Payload & Start Attack<ul><li>Use <font color=FF0000><code>Pitchfork</code></font> as your attack type
:::spoiler Screenshot
<img src=https://hackmd.io/_uploads/rkQvwz1v2.png alt>
<img src=https://hackmd.io/_uploads/BknuPG1wh.png alt>
<img src=https://hackmd.io/_uploads/SkKtPG1P2.png alt>
:::
Password: <code>everett</code>
Flag: <code>CNS{8Ru73_f0Rc3_Pr3v3n710N_C4n_83_C0mPl1c473d}</code></li></ul></li></ol><h3 id=f>f)
<a class=anchor href=#f>#</a></h3><p>One modern authentication method is the FIDO2 security key. This is a physical device that can be used to sign in to web-based applications and Windows 10 devices with your Azure AD account without entering a username or password. It is based on the open standards of FIDO2, which include the WebAuthn protocol and the Client to Authentication Protocol (CTAP).</p><p>The FIDO2 security key works by generating a public-private key pair for each account that you register with it. The private key is stored securely on the device, and the public key is sent to the service provider (such as Azure AD) along with a randomly generated attestation certificate that proves the authenticity of the device. When you sign in with the FIDO2 security key, the service provider sends a nonce (a random number) to the device, which signs it with the private key and sends it back. The service provider then verifies the signature using the public key and grants access.</p><p>The FIDO2 security key method is better than traditional methods such as passwords or tokens for several reasons:</p><p>It is more secure, as it prevents phishing, replay, and man-in-the-middle attacks. The private key never leaves the device, and the attestation certificate prevents spoofing or cloning of the device.
It is more convenient, as it does not require remembering or typing passwords or codes. The user only needs to insert the device and provide a second factor such as a fingerprint or a PIN.
It is more scalable, as it can work across thousands of accounts and services that support FIDO2 without sharing any secrets.</p><h2 id=4-accumulator>4. Accumulator
<a class=anchor href=#4-accumulator>#</a></h2><h3 id=a-1>a)
<a class=anchor href=#a-1>#</a></h3><ul><li>Just following the TODO hint and complete the each sub-function
:::spoiler Exp<pre tabindex=0><code class="language-python=" data-lang="python=">from Crypto.Util.number import getPrime, isPrime, GCD, bytes_to_long, long_to_bytes, inverse
from random import randrange
from hashlib import sha256
import numpy as np

class RSA_Accumulator:
    def __init__(self, Nbits):
        self.Setup(Nbits)       # Run Trusted Setup to get the N of a RSA group
        self.memberSet = []     # The memberSet S

    def Setup(self, Nbits):
        &#39;&#39;&#39;
        Set up the RSA Group and generate a generator g.
        * RSA Accumulator needs trusted setup from third-party.
          -&gt; The factor of N should not be known by anyone.
        &#39;&#39;&#39;
        self.N = getPrime((Nbits+1)//2) * getPrime((Nbits+1)//2)
        self.N = 118166153201091422745075581047834754808656318506582059918250736240527000218333900890558674423046670734337546875938786060887854493354320062840519232300439946274194598991584933262120097035915944139948564721903245872873636662231635587182627311074335128195338000702520696618456950964940369684997735067088270882537

        g = randrange(1,self.N)
        while (GCD(g, self.N) != 1 or g == 1):
            g = randrange(1,self.N)        
        self.g = g
        self.g = 102051368806489104968940135232506917072685495379367570526809603586735868728055130832450576227989175359207682641748992283183781107769793076159733250007462779341283086743497222627311279686407991735966924383065162712675112994555587377787405876645776970439432770422301055215461963444317007474211864224999189899243

    @staticmethod
    def HashToPrime(content):
        &#39;&#39;&#39;
        Hash a content to Prime domain.
        The content must be encoded in bytes.
        &#39;&#39;&#39;
        def PrimeTest(p):
            return isPrime(p) and p &gt; 2

        def H(_y):
            return bytes_to_long(sha256(_y).digest())

        y = H(content)
        while not PrimeTest(y):
            y = H(long_to_bytes(y))

        return y

    def add(self, content):
        &#39;&#39;&#39;
        Add an content to memberSet
        &#39;&#39;&#39;
        s = self.HashToPrime(content)
        self.memberSet.append(s)

    def Digest(self):
        &#39;&#39;&#39;
        Digest all the contents in memberSet.
        &#39;&#39;&#39;
        digest = self.g
        # TODO: Digest all the elements in memberSet.
        #       Hint: digest = g ^ ( product of &#34;all the primes in memberSet&#34;  )
        for i in self.memberSet:
            digest = pow(digest, i, self.N)

        return digest

    def MembershipProof(self, content):
        m = self.HashToPrime(content)
        if m not in self.memberSet: raise ValueError

        proof = self.g
        # TODO: Make a membership proof for m.
        #       Hint: proof = g ^ ( product of &#34;all the primes in memberSet except for m&#34; )
        for i in self.memberSet:
            if m != i:
                proof = pow(proof, i, self.N)

        return proof

    def MembershipVerification(self, N, content, d, proof) -&gt; bool:
        m = self.HashToPrime(content)
        # TODO: Verify the membership proof of m.
        #       Hint: Check &#34;proof ^ m == d&#34;

        return True if pow(proof, m, self.N) == d else False


    def NonMembershipProof(self, content):
        m = self.HashToPrime(content)
        if m in self.memberSet: raise ValueError

        # TODO: Make a non-membership proof for m.
        #       Hint: let delta = product of &#34;all the primes in memberSet except for m.
        #             find (a, b) satisfy a * m + b * delta = 1 
        #             proof = (g^a, b)
        #             p.s. since gcd(m, delta) == 1, you can use xgcd(Extended Euclidean algorithm) to find (a, b)
        def extended_gcd(a, b):
            if a == 0:
                return b, 0, 1
            else:
                gcd, x, y = extended_gcd(b % a, a)
                return gcd, y - (b // a) * x, x

        delta = 1
        for i in self.memberSet:
            delta *= i

        gcd, a, b = extended_gcd(m, delta)
        result = pow(self.g, a, N)
        return (result, b)

    def NonMembershipVerification(self, N, content, d, proof, g):
        m = self.HashToPrime(content)
        # TODO: Verify the non-membership proof of m.
        #       Hint: Check &#34;(g^a)^m * digest^b == g^(a*m + b*delta) == g&#34;

        second_power = pow(d, proof[1], N)
        return (pow(proof[0], m, N) * second_power) % N == g

if __name__ == &#34;__main__&#34;:

    A = RSA_Accumulator(1024)
    A.add(b&#34;Hello!&#34;)
    A.add(b&#34;Test!&#34;)
    A.add(b&#34;CNS&#34;)
    A.add(b&#34;accumulatorrrrrr&#34;)

    d = A.Digest()
    N = A.N
    g = A.g
    proof = A.MembershipProof(b&#34;accumulatorrrrrr&#34;)
    if A.MembershipVerification(N, b&#34;accumulatorrrrrr&#34;, d, proof):
        print( &#34;&#39;accumulatorrrrrr&#39; is in the set.&#34; )
    else:
        print( &#34;The proof is wrong.&#34; )

    proof = A.NonMembershipProof(b&#34;QAQ&#34;)
    if A.NonMembershipVerification(N, b&#34;QAQ&#34;, d, proof, g):
        print( &#34;&#39;QAQ&#39; is not in the set.&#34; )
    else:
        print( &#34;The proof is wrong.&#34; )
</code></pre>:::</li></ul><h3 id=b-really-thx-for-r11944034-許智翔-for-inspiration>b) Really thx for R11944034 許智翔 for inspiration
<a class=anchor href=#b-really-thx-for-r11944034-%e8%a8%b1%e6%99%ba%e7%bf%94-for-inspiration>#</a></h3><ul><li>Goal: We have to construct a fake member $m&rsquo; \notin S$</li><li>We know:
$$
p=g^{\prod \limits_{s \in S/{m&rsquo;}}S}=g^{\prod \limits_{s \in S}S}=d
$$</li><li>:+1:If we used normal $p$ and normal $m \in S$:
$$
p^m=g^{\prod \limits_{s \in S/{m}}S*m}=g^{\prod \limits_{s \in S}S}=d
$$</li><li>:-1:If we used normal $p$ and new message $m&rsquo;$:
$$
p^{m&rsquo;}=g^{\prod \limits_{s \in S}S \cdot m&rsquo;}=d^{m&rsquo;} \neq d
$$</li><li>:+1:If we used fake proof $p&rsquo;$ and new message $m&rsquo;$:
$$
{p&rsquo;}^{m&rsquo;}=d^{{{m&rsquo;}}^{-1} *m&rsquo;}=d
$$</li><li>We can control proof $p&rsquo;$ and new message $m&rsquo;$, so we need to construct fake proof $p&rsquo;$
$$
p&rsquo; \equiv d^{{m&rsquo;}^{-1}}\ (mod\ N) \equiv p^{{m&rsquo;}^{-1}\ (mod\ \varphi(N))}\ (mod\ N)\ -\ Euler\ Theorem
$$
:::info
To achieve this attack, one condition must be met: We have to compute $\varphi (n)$, so we need the private key of RSA
:::
Then we can use any member that&rsquo;s not in member set but still can pass the verification.
:::spoiler Whole Script</li></ul><pre tabindex=0><code class="language-python=" data-lang="python=">from pwn import *
from accumulator import RSA_Accumulator
from Crypto.Util.number import inverse


r = remote(&#39;cns.csie.org&#39;, 4001)
context.arch = &#39;amd64&#39;


p = 0xfe7fa2d93be7396c7172a7186f4e561949f53e436a7ed65da22786637b7e76081f65b972be84ea612787a07878c1bf9454edf81059f84158efe34b4207f96d71
q = 0xb76082ea921f3d4729e59d765ff014ad745b6421f1bacc359417e0c2a1aaa318bd96ba0f6476e09bd1db72fa4dfc7fa5aa0ee1bef7bc4f268fb42673e539d3b1
def bad_setup():
    acc = RSA_Accumulator(1024)
    acc.N = p * q
    acc.g = 0xa8ccac65582e3accb0e246c4d79b9d054e85e086b6d5c48df6f79bf60ad4c77d797ba7fdba0b0a83071f16e427bff7d7d7ab768d4694f90a5eef5278201f8848221b998a7f5322a66f9eac87d5d4f801a2af3fa7a983f9678732b6b16b40c2e2b8e5612e9834f2e64b0aa91f91c479113b0d263dc81572f5b5d367d4911008cd
    
    acc.add(b&#34;Member0&#34;)
    acc.add(b&#34;Member1&#34;)
    acc.add(b&#34;Member2&#34;)
    digest = acc.Digest()
    return acc, digest

for i in range(4):
    r.recvline()

phi = (p-1)*(q-1)

acc, digest = bad_setup()
message = b&#34;Member3&#34;    # A new member that is not in member set
m = acc.HashToPrime(message)
inv_m = inverse(m, phi)
proof_new = pow(digest, inv_m, acc.N)   # Construct a fake proof

r.sendline(b&#39;0&#39;)
r.sendline(message)
r.sendline(str(proof_new).encode())

r.interactive()
</code></pre><p>:::
Flag: <code>cns{ph4k3_m3m83r5H1p!}</code></p><h3 id=c-1>c)
<a class=anchor href=#c-1>#</a></h3><p>Like the previous question mentioned, we&rsquo;d like to give a fake proof that can pass the verification process even the member is not in member set.</p><ul><li>We know that if $gcd(m,\ delta)=1$, then we can find coefficient $a$ and $b$ so that $a\cdot m+b\cdot delta=1$:
$$
delta={\prod \limits_{s \in S}s}
$$</li><li>:+1:If we used normal $p$ and normal $m \in S$:
$$
(g^a)^m\cdot d^b=g^{a\cdot m}\cdot g^{b\cdot ({\prod \limits_{s \in S}s})}=g^{a\cdot m+b\cdot ({\prod \limits_{s \in S}s})}=g
$$</li><li>:-1:If we used normal $proof=(g^a, b)$ and new message $m&rsquo;$:
You can not find $a$ and $b$ to fit $a\cdot m+b\cdot delta=1$</li><li>:+1:If we used fake proof $proof&rsquo;=(g^{a&rsquo;}, b&rsquo;)$ and new message $m&rsquo;$:
If $a&rsquo;=m^{-1}, b=0$
$$
(g^{a&rsquo;})^m\cdot d^b=g^{m^{-1}\cdot m}\cdot g^{b\cdot ({\prod \limits_{s \in S}s})}=g^{1+0}=g
$$
:::spoiler Whole Script</li></ul><pre tabindex=0><code class="language-python=" data-lang="python=">from pwn import *
from accumulator import RSA_Accumulator
from Crypto.Util.number import inverse


r = remote(&#39;cns.csie.org&#39;, 4001)
context.arch = &#39;amd64&#39;


p = 0xfe7fa2d93be7396c7172a7186f4e561949f53e436a7ed65da22786637b7e76081f65b972be84ea612787a07878c1bf9454edf81059f84158efe34b4207f96d71
q = 0xb76082ea921f3d4729e59d765ff014ad745b6421f1bacc359417e0c2a1aaa318bd96ba0f6476e09bd1db72fa4dfc7fa5aa0ee1bef7bc4f268fb42673e539d3b1
def bad_setup():
    acc = RSA_Accumulator(1024)
    acc.N = p * q
    acc.g = 0xa8ccac65582e3accb0e246c4d79b9d054e85e086b6d5c48df6f79bf60ad4c77d797ba7fdba0b0a83071f16e427bff7d7d7ab768d4694f90a5eef5278201f8848221b998a7f5322a66f9eac87d5d4f801a2af3fa7a983f9678732b6b16b40c2e2b8e5612e9834f2e64b0aa91f91c479113b0d263dc81572f5b5d367d4911008cd
    
    acc.add(b&#34;Member0&#34;)
    acc.add(b&#34;Member1&#34;)
    acc.add(b&#34;Member2&#34;)
    digest = acc.Digest()
    return acc, digest

for i in range(4):
    r.recvline()

phi = (p-1)*(q-1)

acc, digest = bad_setup()

message = b&#34;Member0&#34;    # A old member that is in member set
proof_fake = acc.NonMembershipProof(message)
m = acc.HashToPrime(message)

&#39;&#39;&#39;
Construct fake proof
&#39;&#39;&#39;
a = inverse(m, phi)
delta = 1
for i in acc.memberSet:
    delta *= i
b = inverse(delta, phi)
g_a = pow(acc.g, a, acc.N)


r.sendline(b&#39;1&#39;)
r.sendline(message)
r.sendline(str(g_a).encode())
r.sendline(b&#39;0&#39;)

r.interactive()
</code></pre><p>:::
Flag: <code>cns{N0N_n0n_m3M83RSh1p!}</code></p><h3 id=d-1>d)
<a class=anchor href=#d-1>#</a></h3><p>(Skip)</p><h2 id=reference>Reference
<a class=anchor href=#reference>#</a></h2><h3 id=1-ddos-1>1. DDoS
<a class=anchor href=#1-ddos-1>#</a></h3><ul><li><a href=https://security.tencent.com/index.php/blog/msg/3>使用Wireshark分析並發現DDoS攻擊</a></li><li><a href=https://cloud.tencent.com/developer/article/2182801>Kali Linux網絡掃描秘籍第六章拒絕服務(二)</a></li><li><a href=https://www.cloudflare.com/zh-tw/learning/ddos/ntp-amplification-ddos-attack/>NTP放大DDoS攻擊</a></li><li><a href=https://www.twcert.org.tw/tw/cp-157-6408-e0c62-1.html>分散式阻斷服務攻擊(DDoS)趨勢與防護</a></li></ul><h3 id=3-web-authentication-1>3. Web Authentication
<a class=anchor href=#3-web-authentication-1>#</a></h3><h4 id=basic-authentication>Basic Authentication
<a class=anchor href=#basic-authentication>#</a></h4><ul><li><a href="https://www.youtube.com/watch?v=G1EVWLjwvrE&amp;ab_channel=TechieBlogging">How To Create Flask Web App In Digital Ocean Using App Deployment</a></li><li><a href=https://pythonexamples.org/python-flask-read-form-data-from-request/>Python Flask – Read Form Data from Request</a></li></ul><h4 id=cookie-based-authentication>Cookie-Based Authentication
<a class=anchor href=#cookie-based-authentication>#</a></h4><ul><li><a href=https://pythonbasics.org/flask-cookies/>Get and set cookies with Flask</a></li><li><a href=https://pythonexamples.org/python-flask-read-form-data-from-request/>Python Flask – Read Form Data from Request</a></li></ul><h4 id=jwt-based>JWT-Based
<a class=anchor href=#jwt-based>#</a></h4><ul><li><a href=https://medium.com/%e9%ba%a5%e5%85%8b%e7%9a%84%e5%8d%8a%e8%b7%af%e5%87%ba%e5%ae%b6%e7%ad%86%e8%a8%98/%e7%ad%86%e8%a8%98-%e9%80%8f%e9%81%8e-jwt-%e5%af%a6%e4%bd%9c%e9%a9%97%e8%ad%89%e6%a9%9f%e5%88%b6-2e64d72594f8>[筆記] 透過 JWT 實作驗證機制</a></li><li><a href=https://medium.com/%e4%bc%81%e9%b5%9d%e4%b9%9f%e6%87%82%e7%a8%8b%e5%bc%8f%e8%a8%ad%e8%a8%88/jwt-json-web-token-%e5%8e%9f%e7%90%86%e4%bb%8b%e7%b4%b9-74abfafad7ba>JWT(JSON Web Token) — 原理介紹</a></li><li><a href=https://jwt.io/>JSON Web Tokens Encoder/Decoder</a></li></ul><h4 id=3c>3.C
<a class=anchor href=#3c>#</a></h4><ul><li><a href=https://kexue.fm/archives/3026>在Python中使用GMP（gmpy2）</a></li><li><a href=https://blog.csdn.net/qq_38463737/article/details/117637783>binascii.Error: Incorrect padding</a></li><li><a href=https://stackoverflow.com/questions/70762719/problem-in-run-code-gives-error-non-base32-digit-found>problem in run code gives Error: Non-base32 digit found</a></li><li><a href=https://github.com/pyauth/pyotp/tree/develop>pyauth/pyotp</a></li><li><a href=https://ithelp.ithome.com.tw/articles/10231212>Week12 - 要在不同Server間驗證JWT好麻煩嗎？RS256提供你一種簡單的選擇 - JWT篇 [Server的終局之戰系列]</a></li><li><a href=https://stackoverflow.com/questions/75461879/bytes-object-has-no-attribute-oid>&lsquo;bytes&rsquo; object has no attribute &lsquo;oid&rsquo;</a></li><li><a href=https://www.rfc-editor.org/rfc/rfc3447#section-9.2>EMSA-PKCS1-v1_5 Specification</a></li><li><a href=https://github.com/pycrypto/pycrypto/blob/master/lib/Crypto/Signature/PKCS1_v1_5.py>EMSA_PKCS1_V1_5_ENCODE Implementation</a></li><li><a href=https://pycryptodome.readthedocs.io/en/latest/src/public_key/rsa.html#Crypto.PublicKey.RSA.construct>Generate PEM file with specified RSA parameter</a></li><li><a href=https://stackoverflow.com/questions/76458680/how-can-i-generate-rsa-public-key-with-specified-n-and-e-parameter-by-using-open>How can I generate rsa public key with specified n and e parameter by using openssl?</a></li><li><a href=https://stackoverflow.com/questions/74063656/how-can-i-generate-jwt-token-using-hmac-how-is-the-signature-created>How can I generate JWT token using HMAC? How is the signature created?</a></li><li><a href=https://security.stackexchange.com/questions/187265/jwt-encoding-using-hmac-with-asymmetric-key-as-secret>JWT encoding using HMAC with asymmetric key as secret</a></li></ul><h4 id=3e>3.E
<a class=anchor href=#3e>#</a></h4><ul><li><a href=https://xxgblog.com/2018/10/12/x-forwarded-for-header-trick/>X-Forwarded-For</a></li><li><a href=https://ithelp.ithome.com.tw/articles/10245914>Intruder帳密暴力破解與列舉FUZZING找漏洞的好幫手</a></li><li><a href=https://ithelp.ithome.com.tw/articles/10246457>Intruder Attack type & Payloads - 擁有千種姿態的攻擊模式</a></li></ul><h3 id=4-accumulator-1>4. Accumulator
<a class=anchor href=#4-accumulator-1>#</a></h3><ul><li><a href=https://antonassocareer.medium.com/%e6%b7%ba%e8%ab%87-rsa-accumulator-%e8%88%87stateless-client-a75f00ad388e>淺談 RSA Accumulator</a></li><li><a href=https://youtu.be/fm8L6k1lu8E>歐拉定理的介紹</a></li><li><a href=https://youtu.be/CNQeixKoclU>歐拉函數的觀察</a></li><li><a href=https://youtu.be/DzzBZwjjSrY>歐拉函數的計算法</a></li><li><a href=https://youtu.be/P8VjTGAQQUo>歐拉定理的論證</a></li></ul></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><ul><li></li></ul></li><li><a href=#1-ddos>1. DDoS</a><ul><li><a href=#1>1)</a></li><li><a href=#2>2)</a></li><li><a href=#3>3)</a></li><li><a href=#4>4)</a></li><li><a href=#5>5)</a></li><li><a href=#6>6)</a></li></ul></li><li><a href=#2-smart-contract>2. Smart Contract</a></li><li><a href=#3-web-authentication>3. Web Authentication</a><ul><li><a href=#a>a)</a></li><li><a href=#b>b)</a></li><li><a href=#c>c)</a></li><li><a href=#d>d)</a></li><li><a href=#e>e)</a></li><li><a href=#f>f)</a></li></ul></li><li><a href=#4-accumulator>4. Accumulator</a><ul><li><a href=#a-1>a)</a></li><li><a href=#b-really-thx-for-r11944034-許智翔-for-inspiration>b) Really thx for R11944034 許智翔 for inspiration</a></li><li><a href=#c-1>c)</a></li><li><a href=#d-1>d)</a></li></ul></li><li><a href=#reference>Reference</a><ul><li><a href=#1-ddos-1>1. DDoS</a></li><li><a href=#3-web-authentication-1>3. Web Authentication</a></li><li><a href=#4-accumulator-1>4. Accumulator</a></li></ul></li></ul></nav></div></aside></main></body></html>