<!doctype html><html lang=en-us dir=ltr><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="
  Simple Reverse - 0x30(2023 HW - Evil FlagChecker)
  #


  Background
  #

Anti Disassembly - 這一部分可以看一下碩一修的malware reverse的anti disassembly的修復(就是d和c的交錯使用)
Anti Debugging - 首推scylla hide

  Source code
  #

:::spoiler IDA main
int __cdecl main(int argc, const char **argv, const char **envp)
{
  DWORD TickCount; // [esp+0h] [ebp-14h]
  unsigned int v5; // [esp+8h] [ebp-Ch]

  TickCount = GetTickCount();
  Sleep(120000u);
  v5 = GetTickCount() - TickCount;
  if ( v5 < 119950 || v5 > 120050 )
    ExitProcess(0);
  ((void (*)(void))loc_401AE0)();
  return 0;
}
:::
:::spoiler IDA loc_401AE0
.text:00401AE0 loc_401AE0:                             ; CODE XREF: _main:loc_4014AB↑p
.text:00401AE0 push    ebp
.text:00401AE1 mov     ebp, esp
.text:00401AE3 lea     esi, aHelloHacker               ; &#34;Hello Hacker&#34;
.text:00401AE9 mov     al, 48h ; 'H'
.text:00401AEB cmp     [esi], al
.text:00401AED jz      short loc_401AF0
.text:00401AED
.text:00401AED ; ---------------------------------------------------------------------------
.text:00401AEF db 0E8h
.text:00401AF0 ; ---------------------------------------------------------------------------
.text:00401AF0
.text:00401AF0 loc_401AF0:                             ; CODE XREF: .text:00401AED↑j
.text:00401AF0 nop     word ptr [eax+eax+00000000h]
.text:00401AF9 jmp     short loc_401B01
.text:00401AF9
.text:00401AF9 ; ---------------------------------------------------------------------------
.text:00401AFB db  48h ; H
.text:00401AFC db  65h ; e
.text:00401AFD db  6Ch ; l
.text:00401AFE db  6Ch ; l
.text:00401AFF db  6Fh ; o
.text:00401B00 db    0
.text:00401B01 ; ---------------------------------------------------------------------------
.text:00401B01
.text:00401B01 loc_401B01:                             ; CODE XREF: .text:00401AF9↑j
.text:00401B01 jmp     short loc_401B0E
.text:00401B01
.text:00401B01 ; ---------------------------------------------------------------------------
.text:00401B03 db 0E8h
.text:00401B04 db  66h ; f
.text:00401B05 db  0Fh
.text:00401B06 db  1Fh
.text:00401B07 db  84h
.text:00401B08 db    0
.text:00401B09 db    0
.text:00401B0A db    0
.text:00401B0B db    0
.text:00401B0C byte_401B0C db 0
.text:00401B0D db 0E8h
.text:00401B0E ; ---------------------------------------------------------------------------
.text:00401B0E
.text:00401B0E loc_401B0E:                             ; CODE XREF: .text:loc_401B01↑j
.text:00401B0E jz      short loc_401B13
.text:00401B0E
.text:00401B10 jnz     short loc_401B13
.text:00401B10
.text:00401B10 ; ---------------------------------------------------------------------------
.text:00401B12 db 0E8h
.text:00401B13 ; ---------------------------------------------------------------------------
.text:00401B13
.text:00401B13 loc_401B13:                             ; CODE XREF: .text:loc_401B0E↑j
.text:00401B13                                         ; .text:00401B10↑j
.text:00401B13 push    1
.text:00401B15 jmp     sub_401220
:::
:::spoiler IDA notify_debugger"><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#343a40"><meta name=color-scheme content="light dark"><meta property="og:url" content="https://bernie6401.github.io/security/course/ntu-cs/reverse/simple-reverse---0x302023-hw---evil-flagchecker/"><meta property="og:site_name" content="SBK Hugo Site"><meta property="og:title" content="Simple Reverse - 0x30(2023 HW - Evil FlagChecker)"><meta property="og:description" content="Simple Reverse - 0x30(2023 HW - Evil FlagChecker) # Background # Anti Disassembly - 這一部分可以看一下碩一修的malware reverse的anti disassembly的修復(就是d和c的交錯使用) Anti Debugging - 首推scylla hide
Source code # :::spoiler IDA main
int __cdecl main(int argc, const char **argv, const char **envp) { DWORD TickCount; // [esp+0h] [ebp-14h] unsigned int v5; // [esp+8h] [ebp-Ch] TickCount = GetTickCount(); Sleep(120000u); v5 = GetTickCount() - TickCount; if ( v5 < 119950 || v5 > 120050 ) ExitProcess(0); ((void (*)(void))loc_401AE0)(); return 0; } ::: :::spoiler IDA loc_401AE0
.text:00401AE0 loc_401AE0: ; CODE XREF: _main:loc_4014AB↑p .text:00401AE0 push ebp .text:00401AE1 mov ebp, esp .text:00401AE3 lea esi, aHelloHacker ; &#34;Hello Hacker&#34; .text:00401AE9 mov al, 48h ; 'H' .text:00401AEB cmp [esi], al .text:00401AED jz short loc_401AF0 .text:00401AED .text:00401AED ; --------------------------------------------------------------------------- .text:00401AEF db 0E8h .text:00401AF0 ; --------------------------------------------------------------------------- .text:00401AF0 .text:00401AF0 loc_401AF0: ; CODE XREF: .text:00401AED↑j .text:00401AF0 nop word ptr [eax+eax+00000000h] .text:00401AF9 jmp short loc_401B01 .text:00401AF9 .text:00401AF9 ; --------------------------------------------------------------------------- .text:00401AFB db 48h ; H .text:00401AFC db 65h ; e .text:00401AFD db 6Ch ; l .text:00401AFE db 6Ch ; l .text:00401AFF db 6Fh ; o .text:00401B00 db 0 .text:00401B01 ; --------------------------------------------------------------------------- .text:00401B01 .text:00401B01 loc_401B01: ; CODE XREF: .text:00401AF9↑j .text:00401B01 jmp short loc_401B0E .text:00401B01 .text:00401B01 ; --------------------------------------------------------------------------- .text:00401B03 db 0E8h .text:00401B04 db 66h ; f .text:00401B05 db 0Fh .text:00401B06 db 1Fh .text:00401B07 db 84h .text:00401B08 db 0 .text:00401B09 db 0 .text:00401B0A db 0 .text:00401B0B db 0 .text:00401B0C byte_401B0C db 0 .text:00401B0D db 0E8h .text:00401B0E ; --------------------------------------------------------------------------- .text:00401B0E .text:00401B0E loc_401B0E: ; CODE XREF: .text:loc_401B01↑j .text:00401B0E jz short loc_401B13 .text:00401B0E .text:00401B10 jnz short loc_401B13 .text:00401B10 .text:00401B10 ; --------------------------------------------------------------------------- .text:00401B12 db 0E8h .text:00401B13 ; --------------------------------------------------------------------------- .text:00401B13 .text:00401B13 loc_401B13: ; CODE XREF: .text:loc_401B0E↑j .text:00401B13 ; .text:00401B10↑j .text:00401B13 push 1 .text:00401B15 jmp sub_401220 ::: :::spoiler IDA notify_debugger"><meta property="og:locale" content="en_us"><meta property="og:type" content="article"><meta property="article:section" content="security"><meta property="article:tag" content="Eductf"><meta property="article:tag" content="CTF"><meta property="article:tag" content="Reverse"><title>Simple Reverse - 0x30(2023 HW - Evil FlagChecker) | SBK Hugo Site</title>
<link rel=icon href=/favicon.png><link rel=manifest href=/manifest.json><link rel=canonical href=https://bernie6401.github.io/security/course/ntu-cs/reverse/simple-reverse---0x302023-hw---evil-flagchecker/><link rel=stylesheet href=/book.min.6c8b9d2a1fc95075ed7da46ca81060b39add8fff6741ac51259f768929281e2c.css integrity="sha256-bIudKh/JUHXtfaRsqBBgs5rdj/9nQaxRJZ92iSkoHiw=" crossorigin=anonymous><script defer src=/fuse.min.js></script><script defer src=/en.search.min.acdc41c8d39e6c69d70d8a23779875e0a3733fefead3e428d5344966bb12f562.js integrity="sha256-rNxByNOebGnXDYojd5h14KNzP+/q0+Qo1TRJZrsS9WI=" crossorigin=anonymous></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/><span>SBK Hugo Site</span></a></h2><div class="book-search hidden"><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><script>document.querySelector(".book-search").classList.remove("hidden")</script></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu></label><h3>Simple Reverse - 0x30(2023 HW - Evil FlagChecker)</h3><label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#background>Background</a></li><li><a href=#source-code>Source code</a></li><li><a href=#recon>Recon</a></li><li><a href=#exploit>Exploit</a></li></ul></nav></aside></header><article class="markdown book-article"><h1 id=simple-reverse---0x302023-hw---evil-flagchecker>Simple Reverse - 0x30(2023 HW - Evil FlagChecker)
<a class=anchor href=#simple-reverse---0x302023-hw---evil-flagchecker>#</a></h1><h2 id=background>Background
<a class=anchor href=#background>#</a></h2><p>Anti Disassembly - 這一部分可以看一下碩一修的malware reverse的anti disassembly的修復(就是d和c的交錯使用)
Anti Debugging - 首推scylla hide</p><h2 id=source-code>Source code
<a class=anchor href=#source-code>#</a></h2><p>:::spoiler IDA main</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#66d9ef>__cdecl</span> <span style=color:#a6e22e>main</span>(<span style=color:#66d9ef>int</span> argc, <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>**</span>argv, <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>**</span>envp)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  DWORD TickCount; <span style=color:#75715e>// [esp+0h] [ebp-14h]
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>int</span> v5; <span style=color:#75715e>// [esp+8h] [ebp-Ch]
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>  TickCount <span style=color:#f92672>=</span> GetTickCount();
</span></span><span style=display:flex><span>  Sleep(<span style=color:#ae81ff>120000u</span>);
</span></span><span style=display:flex><span>  v5 <span style=color:#f92672>=</span> GetTickCount() <span style=color:#f92672>-</span> TickCount;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> ( v5 <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>119950</span> <span style=color:#f92672>||</span> v5 <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>120050</span> )
</span></span><span style=display:flex><span>    ExitProcess(<span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>  ((<span style=color:#66d9ef>void</span> (<span style=color:#f92672>*</span>)(<span style=color:#66d9ef>void</span>))loc_401AE0)();
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>:::
:::spoiler IDA loc_401AE0</p><pre tabindex=0><code>.text:00401AE0 loc_401AE0:                             ; CODE XREF: _main:loc_4014AB↑p
.text:00401AE0 push    ebp
.text:00401AE1 mov     ebp, esp
.text:00401AE3 lea     esi, aHelloHacker               ; &#34;Hello Hacker&#34;
.text:00401AE9 mov     al, 48h ; &#39;H&#39;
.text:00401AEB cmp     [esi], al
.text:00401AED jz      short loc_401AF0
.text:00401AED
.text:00401AED ; ---------------------------------------------------------------------------
.text:00401AEF db 0E8h
.text:00401AF0 ; ---------------------------------------------------------------------------
.text:00401AF0
.text:00401AF0 loc_401AF0:                             ; CODE XREF: .text:00401AED↑j
.text:00401AF0 nop     word ptr [eax+eax+00000000h]
.text:00401AF9 jmp     short loc_401B01
.text:00401AF9
.text:00401AF9 ; ---------------------------------------------------------------------------
.text:00401AFB db  48h ; H
.text:00401AFC db  65h ; e
.text:00401AFD db  6Ch ; l
.text:00401AFE db  6Ch ; l
.text:00401AFF db  6Fh ; o
.text:00401B00 db    0
.text:00401B01 ; ---------------------------------------------------------------------------
.text:00401B01
.text:00401B01 loc_401B01:                             ; CODE XREF: .text:00401AF9↑j
.text:00401B01 jmp     short loc_401B0E
.text:00401B01
.text:00401B01 ; ---------------------------------------------------------------------------
.text:00401B03 db 0E8h
.text:00401B04 db  66h ; f
.text:00401B05 db  0Fh
.text:00401B06 db  1Fh
.text:00401B07 db  84h
.text:00401B08 db    0
.text:00401B09 db    0
.text:00401B0A db    0
.text:00401B0B db    0
.text:00401B0C byte_401B0C db 0
.text:00401B0D db 0E8h
.text:00401B0E ; ---------------------------------------------------------------------------
.text:00401B0E
.text:00401B0E loc_401B0E:                             ; CODE XREF: .text:loc_401B01↑j
.text:00401B0E jz      short loc_401B13
.text:00401B0E
.text:00401B10 jnz     short loc_401B13
.text:00401B10
.text:00401B10 ; ---------------------------------------------------------------------------
.text:00401B12 db 0E8h
.text:00401B13 ; ---------------------------------------------------------------------------
.text:00401B13
.text:00401B13 loc_401B13:                             ; CODE XREF: .text:loc_401B0E↑j
.text:00401B13                                         ; .text:00401B10↑j
.text:00401B13 push    1
.text:00401B15 jmp     sub_401220
</code></pre><p>:::
:::spoiler IDA notify_debugger</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#66d9ef>__cdecl</span> __noreturn <span style=color:#a6e22e>notify_debugger</span>()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> ( IsDebuggerPresent() )
</span></span><span style=display:flex><span>    ExitProcess(<span style=color:#ae81ff>1u</span>);
</span></span><span style=display:flex><span>  __debugbreak();
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>:::
:::spoiler IDA sub_401220</p><pre tabindex=0><code>.text:00401220 sub_401220 proc near                    ; CODE XREF: .text:00401B15↓j
.text:00401220
.text:00401220 ms_exc= CPPEH_RECORD ptr -18h
.text:00401220
.text:00401220 push    ebp
.text:00401221 mov     ebp, esp
.text:00401223 push    0FFFFFFFEh
.text:00401225 push    offset stru_403B40
.text:0040122A push    offset ?notify_debugger@@YAXABUtagEXCEPTION_VISUALCPP_DEBUG_INFO@@@Z_SEH
.text:0040122F mov     eax, large fs:0
.text:00401235 push    eax
.text:00401236 sub     esp, 8
.text:00401239 push    ebx
.text:0040123A push    esi
.text:0040123B push    edi
.text:0040123C mov     eax, ___security_cookie
.text:00401241 xor     [ebp+ms_exc.registration.ScopeTable], eax
.text:00401244 xor     eax, ebp
.text:00401246 push    eax
.text:00401247 lea     eax, [ebp+ms_exc.registration]
.text:0040124A mov     large fs:0, eax
.text:00401250 mov     [ebp+ms_exc.old_esp], esp
.text:00401253 mov     [ebp+ms_exc.registration.TryLevel], 0
.text:0040125A call    sub_401170
.text:0040125A
.text:0040125F ; ---------------------------------------------------------------------------
.text:0040125F test    al, al
.text:00401261 jz      short loc_40126B
.text:00401261
.text:00401263 push    1                               ; uExitCode
.text:00401265 call    ds:ExitProcess
.text:00401265
.text:0040126B ; ---------------------------------------------------------------------------
.text:0040126B
.text:0040126B loc_40126B:                             ; CODE XREF: sub_401220+41↑j
.text:0040126B int     3                               ; Trap to Debugger
.text:0040126B
.text:0040126C ; ---------------------------------------------------------------------------
.text:0040126C jmp     short loc_40127C
.text:0040126C
.text:0040126E ; ---------------------------------------------------------------------------
.text:0040126E
.text:0040126E loc_40126E:                             ; DATA XREF: .rdata:stru_403B40↓o
.text:0040126E mov     eax, 1
.text:00401273 retn
.text:00401273
.text:00401274 ; ---------------------------------------------------------------------------
.text:00401274
.text:00401274 loc_401274:                             ; DATA XREF: .rdata:stru_403B40↓o
.text:00401274 mov     esp, [ebp+ms_exc.old_esp]
.text:00401277 call    ?notify_debugger@@YAXABUtagEXCEPTION_VISUALCPP_DEBUG_INFO@@@Z ; notify_debugger(tagEXCEPTION_VISUALCPP_DEBUG_INFO const &amp;)
.text:00401277
.text:0040127C ; ---------------------------------------------------------------------------
.text:0040127C
.text:0040127C loc_40127C:                             ; CODE XREF: sub_401220+4C↑j
.text:0040127C mov     [ebp+ms_exc.registration.TryLevel], 0FFFFFFFEh
.text:00401283 mov     ecx, [ebp+ms_exc.registration.Next]
.text:00401286 mov     large fs:0, ecx
.text:0040128D pop     ecx
.text:0040128E pop     edi
.text:0040128F pop     esi
.text:00401290 pop     ebx
.text:00401291 mov     esp, ebp
.text:00401293 pop     ebp
.text:00401294 retn
.text:00401294
.text:00401294 sub_401220 endp
</code></pre><p>:::
:::spoiler IDA sub_401170</p><pre tabindex=0><code>.text:00401170 sub_401170 proc near                    ; CODE XREF: sub_401220+3A↓p
.text:00401170
.text:00401170 var_1= byte ptr -1
.text:00401170
.text:00401170 push    ebp
.text:00401171 mov     ebp, esp
.text:00401173 push    ecx
.text:00401174 mov     [ebp+var_1], 1
.text:00401178 push    offset TopLevelExceptionFilter  ; lpTopLevelExceptionFilter
.text:0040117D call    ds:SetUnhandledExceptionFilter
.text:0040117D
.text:00401183 ; ---------------------------------------------------------------------------
.text:00401183 int     3                               ; Trap to Debugger
.text:00401183
.text:00401183 sub_401170 endp
.text:00401183
.text:00401184 ; ---------------------------------------------------------------------------
.text:00401184 jmp     short loc_40118A
.text:00401184
.text:00401186 ; ---------------------------------------------------------------------------
.text:00401186 mov     byte ptr [ebp-1], 0
.text:00401186
.text:0040118A
.text:0040118A loc_40118A:                             ; CODE XREF: .text:00401184↑j
.text:0040118A mov     al, [ebp-1]
.text:0040118D mov     esp, ebp
.text:0040118F pop     ebp
.text:00401190 retn
.text:00401190
.text:00401190 ; ---------------------------------------------------------------------------
.text:00401191 align 10h
.text:004011A0
.text:004011A0 ; =============== S U B R O U T I N E =======================================
.text:004011A0
.text:004011A0 ; Attributes: library function noreturn static bp-based frame
.text:004011A0
.text:004011A0 ; void __cdecl __noreturn notify_debugger()
.text:004011A0 ?notify_debugger@@YAXABUtagEXCEPTION_VISUALCPP_DEBUG_INFO@@@Z proc near
.text:004011A0                                         ; CODE XREF: sub_401220+57↓p
.text:004011A0
.text:004011A0 ms_exc= CPPEH_RECORD ptr -18h
.text:004011A0
.text:004011A0 ; FUNCTION CHUNK AT .text:00401206 SIZE 0000000E BYTES
.text:004011A0
.text:004011A0 push    ebp
.text:004011A1 mov     ebp, esp
.text:004011A3 push    0FFFFFFFEh
.text:004011A5 push    offset stru_403B20
.text:004011AA push    offset ?notify_debugger@@YAXABUtagEXCEPTION_VISUALCPP_DEBUG_INFO@@@Z_SEH
.text:004011AF mov     eax, large fs:0
.text:004011B5 push    eax
.text:004011B6 sub     esp, 8
.text:004011B9 push    ebx
.text:004011BA push    esi
.text:004011BB push    edi
.text:004011BC mov     eax, ___security_cookie
.text:004011C1 xor     [ebp+ms_exc.registration.ScopeTable], eax
.text:004011C4 xor     eax, ebp
.text:004011C6 push    eax
.text:004011C7 lea     eax, [ebp+ms_exc.registration]
.text:004011CA mov     large fs:0, eax
.text:004011D0 mov     [ebp+ms_exc.old_esp], esp
.text:004011D3 mov     [ebp+ms_exc.registration.TryLevel], 0
.text:004011DA call    ds:IsDebuggerPresent
.text:004011DA
.text:004011E0 test    eax, eax
.text:004011E2 jz      short loc_4011EC
.text:004011E2
.text:004011E4 push    1                               ; uExitCode
.text:004011E6 call    ds:ExitProcess
.text:004011E6
.text:004011EC ; ---------------------------------------------------------------------------
.text:004011EC
.text:004011EC loc_4011EC:                             ; CODE XREF: notify_debugger(tagEXCEPTION_VISUALCPP_DEBUG_INFO const &amp;)+42↑j
.text:004011EC int     3                               ; Trap to Debugger
.text:004011EC
.text:004011EC ?notify_debugger@@YAXABUtagEXCEPTION_VISUALCPP_DEBUG_INFO@@@Z endp
.text:004011EC
.text:004011ED ; ---------------------------------------------------------------------------
.text:004011ED mov     dword ptr [ebp-4], 0FFFFFFFEh
.text:004011F4 mov     ecx, [ebp-10h]
.text:004011F7 mov     large fs:0, ecx
.text:004011FE pop     ecx
.text:004011FF pop     edi
.text:00401200 pop     esi
.text:00401201 pop     ebx
.text:00401202 mov     esp, ebp
.text:00401204 pop     ebp
.text:00401205 retn
.text:00401205
.text:00401206 ; ---------------------------------------------------------------------------
.text:00401206 ; START OF FUNCTION CHUNK FOR notify_debugger(tagEXCEPTION_VISUALCPP_DEBUG_INFO const &amp;)
.text:00401206
.text:00401206 loc_401206:                             ; DATA XREF: .rdata:stru_403B20↓o
.text:00401206 mov     eax, 1
.text:0040120B retn
.text:0040120B
.text:0040120C ; ---------------------------------------------------------------------------
.text:0040120C
.text:0040120C loc_40120C:                             ; DATA XREF: .rdata:stru_403B20↓o
.text:0040120C mov     esp, [ebp+ms_exc.old_esp]
.text:0040120F call    InputFlag_Check
</code></pre><p>:::
:::spoiler IDA InputFlag_Check</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>void</span> __noreturn <span style=color:#a6e22e>InputFlag_Check</span>()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  flag_info flag_info; <span style=color:#75715e>// [esp+0h] [ebp-408h] BYREF
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>  printf(flag_info.Hello, flag_info.nonono);
</span></span><span style=display:flex><span>  memset(<span style=color:#f92672>&amp;</span>flag_info, <span style=color:#ae81ff>0</span>, <span style=color:#66d9ef>sizeof</span>(flag_info));
</span></span><span style=display:flex><span>  scanf(std<span style=color:#f92672>::</span>cin, (<span style=color:#66d9ef>int</span>)<span style=color:#f92672>&amp;</span>flag_info);
</span></span><span style=display:flex><span>  check((<span style=color:#66d9ef>int</span>)<span style=color:#f92672>&amp;</span>flag_info, strlen((<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>)<span style=color:#f92672>&amp;</span>flag_info));
</span></span><span style=display:flex><span>  printf(flag_info.Hello, flag_info.nonono);
</span></span><span style=display:flex><span>  ExitProcess(<span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>:::
:::spoiler IDA check</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#66d9ef>__fastcall</span> <span style=color:#a6e22e>check</span>(<span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>input, <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>int</span> len)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>int</span> iv; <span style=color:#75715e>// ebx
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>int</span> block; <span style=color:#75715e>// edi
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>int</span> mem_addr_gap; <span style=color:#75715e>// ecx
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>__int8</span> cipher; <span style=color:#75715e>// cl
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>input_cipher_cp; <span style=color:#75715e>// ecx
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>cipher_flag_cp; <span style=color:#75715e>// edx
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>bool</span> v9; <span style=color:#75715e>// cf
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>int</span> i; <span style=color:#75715e>// esi
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>int</span> dot; <span style=color:#75715e>// [esp+0h] [ebp-41Ch]
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>int</span> new_line; <span style=color:#75715e>// [esp+4h] [ebp-418h]
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>int</span> mem_addr_gap_cp; <span style=color:#75715e>// [esp+Ch] [ebp-410h]
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>char</span> output[<span style=color:#ae81ff>1028</span>]; <span style=color:#75715e>// [esp+10h] [ebp-40Ch] BYREF
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>  iv <span style=color:#f92672>=</span> <span style=color:#ae81ff>0xE0C92EAB</span>;
</span></span><span style=display:flex><span>  memset(output, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0x400u</span>);
</span></span><span style=display:flex><span>  block <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> ( len )
</span></span><span style=display:flex><span>  {
</span></span><span style=display:flex><span>    mem_addr_gap <span style=color:#f92672>=</span> input <span style=color:#f92672>-</span> output;              <span style=color:#75715e>// v5代表我們輸入的flag的位址和他memset的位址的差距，從這支檔案為例就是0x418
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    mem_addr_gap_cp <span style=color:#f92672>=</span> input <span style=color:#f92672>-</span> output;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>do</span>
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>      cipher <span style=color:#f92672>=</span> iv <span style=color:#f92672>^</span> output[block <span style=color:#f92672>+</span> mem_addr_gap];
</span></span><span style=display:flex><span>      output[block] <span style=color:#f92672>=</span> cipher;
</span></span><span style=display:flex><span>      iv <span style=color:#f92672>=</span> len <span style=color:#f92672>+</span> (cipher <span style=color:#f92672>^</span> __ROR4__(iv, <span style=color:#ae81ff>3</span>)) <span style=color:#f92672>-</span> block;
</span></span><span style=display:flex><span>      Sleep(<span style=color:#ae81ff>1000u</span>);
</span></span><span style=display:flex><span>      printf(dot, new_line);
</span></span><span style=display:flex><span>      mem_addr_gap <span style=color:#f92672>=</span> mem_addr_gap_cp;
</span></span><span style=display:flex><span>      <span style=color:#f92672>++</span>block;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> ( block <span style=color:#f92672>&lt;</span> len );
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  printf(dot, new_line);
</span></span><span style=display:flex><span>  input_cipher_cp <span style=color:#f92672>=</span> output;
</span></span><span style=display:flex><span>  cipher_flag_cp <span style=color:#f92672>=</span> cipher_flag;
</span></span><span style=display:flex><span>  v9 <span style=color:#f92672>=</span> len <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>4</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>for</span> ( i <span style=color:#f92672>=</span> len <span style=color:#f92672>-</span> <span style=color:#ae81ff>4</span>; <span style=color:#f92672>!</span>v9; i <span style=color:#f92672>-=</span> <span style=color:#ae81ff>4</span> )
</span></span><span style=display:flex><span>  {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> ( <span style=color:#f92672>*</span>(_DWORD <span style=color:#f92672>*</span>)input_cipher_cp <span style=color:#f92672>!=</span> <span style=color:#f92672>*</span>(_DWORD <span style=color:#f92672>*</span>)cipher_flag_cp )
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>    input_cipher_cp <span style=color:#f92672>+=</span> <span style=color:#ae81ff>4</span>;
</span></span><span style=display:flex><span>    cipher_flag_cp <span style=color:#f92672>+=</span> <span style=color:#ae81ff>4</span>;
</span></span><span style=display:flex><span>    v9 <span style=color:#f92672>=</span> i <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>4</span>;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>:::</p><h2 id=recon>Recon
<a class=anchor href=#recon>#</a></h2><p>這一題沒有那麼難，難的是怎麼用工具寫出來，本來想要直接用z3或angr直接噴出來，但是不知道為啥就完全沒有奇蹟發生，所以還是硬幹</p><p>首先，先用ida看主要的流程，會發現有很多jmp系列的位址都跑掉了，此時就要修復，就是data(d)和code( c)之間交錯使用，並且把那些奇怪的data byte換成nop，修把patch好的部分，就會呈現上面的source code這樣</p><ol><li>一樣由上而下，首先會先進到sleep睡眠兩分鐘，並且判斷進到下一行的時候，時間是否在範圍內，這也是time based的anti debugging手法，這部分可以動態直接patch掉
:::spoiler Patch Sleep Function Result
<img src=https://hackmd.io/_uploads/SkPJKTiN6.png alt=圖片>
<img src=https://hackmd.io/_uploads/ByKlFaiN6.png alt=圖片>
:::</li><li>接著會進到loc_401AE0，這部分應該是一個function但不知道為甚麼IDA翻譯不出來，不過看了一下source code也是蠻簡單的，就是一直跳到==sub_401220==，這個在動態也可以patch
:::spoiler Patch Anti-Debug Result
<img src=https://hackmd.io/_uploads/r15VqajVa.png alt=圖片>
:::</li><li>==sub_401220==主要是在其他anti debug的部分，具體怎麼做不是很清楚，只知道大概是和exception handler有關係，不過我在開了scylla hide之後沒有出現甚麼特別的事情
<img src=https://hackmd.io/_uploads/rySec6jN6.png alt=圖片></li><li>接著會進到==sub_401170==，這一段蠻重要的，就是處理一些Exception Handler的事情，然後莫名其妙的會進到0x40120F中的==InputFlag_Check==，中間的一些操作可能是被scylla hide擋掉了，不過中間也確實有檢察==IsDebuggerPresent==這東西</li><li>到了這邊就可以大膽猜測一些常見的操作，諸如scanf或是printf的function，接著我們會進到check這個function，也就是實際把我們的輸入，進行cipher操作後和內部的data bytes進行對比的過程</li><li>所以到了這邊一切都很明瞭了，主要的code如下<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>  iv <span style=color:#f92672>=</span> <span style=color:#ae81ff>0xE0C92EAB</span>;
</span></span><span style=display:flex><span>  memset(output, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0x400u</span>);
</span></span><span style=display:flex><span>  block <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> ( len )
</span></span><span style=display:flex><span>  {
</span></span><span style=display:flex><span>    mem_addr_gap <span style=color:#f92672>=</span> input <span style=color:#f92672>-</span> output;              <span style=color:#75715e>// v5代表我們輸入的flag的位址和他memset的位址的差距，從這支檔案為例就是0x418
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    mem_addr_gap_cp <span style=color:#f92672>=</span> input <span style=color:#f92672>-</span> output;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>do</span>
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>      cipher <span style=color:#f92672>=</span> iv <span style=color:#f92672>^</span> output[block <span style=color:#f92672>+</span> mem_addr_gap];
</span></span><span style=display:flex><span>      output[block] <span style=color:#f92672>=</span> cipher;
</span></span><span style=display:flex><span>      iv <span style=color:#f92672>=</span> len <span style=color:#f92672>+</span> (cipher <span style=color:#f92672>^</span> __ROR4__(iv, <span style=color:#ae81ff>3</span>)) <span style=color:#f92672>-</span> block;
</span></span><span style=display:flex><span>      Sleep(<span style=color:#ae81ff>1000u</span>);
</span></span><span style=display:flex><span>      printf(dot, new_line);
</span></span><span style=display:flex><span>      mem_addr_gap <span style=color:#f92672>=</span> mem_addr_gap_cp;
</span></span><span style=display:flex><span>      <span style=color:#f92672>++</span>block;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> ( block <span style=color:#f92672>&lt;</span> len );
</span></span><span style=display:flex><span>  }
</span></span></code></pre></div>其中，<code>output[block + mem_addr_gap]</code>其實就是我們的input，所以exploit的邏輯就是用brute force，把所有可能都丟一遍，然後嘗試去對比有沒有和built-in cipher bytes一樣，BTW，<code>len</code>代表我們輸入的長度，合理猜測和built-in cipher bytes的長度一樣，也就是23個char，中間的sleep在動態也可以patch掉，就看自己方便
:::danger
在寫ROR的實作時有一個非常重要的重點要注意，也就是最後一個右旋的bit如果是0，在下一次右旋時會被忽略，也就是那個bit會消失，被當成0x的一部分，舉例來說，0x111001，右旋兩次後變成0x011110，但是最左邊的0會被當成0x的一部分，所以下一次再右旋兩次的結果會變成0x10111而不是0x100111，所以我的作法是在每次右旋之前都檢查bit length是不是都是32 bits，如果有少就padding 0在最左邊
:::</li></ol><h2 id=exploit>Exploit
<a class=anchor href=#exploit>#</a></h2><p>另外說明一下，z3或angr的解法都沒辦法實作出來，不確定是甚麼原因，但有機會還是會想解看看，所以先放著看看</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>from</span> string <span style=color:#f92672>import</span> <span style=color:#f92672>*</span>
</span></span><span style=display:flex><span><span style=color:#f92672>from</span> tqdm <span style=color:#f92672>import</span> trange
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>ror</span>(n, rotations, width):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> rotations<span style=color:#f92672>.</span>bit_length() <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>32</span>:
</span></span><span style=display:flex><span>        rotations <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;0&#39;</span> <span style=color:#f92672>*</span> (<span style=color:#ae81ff>32</span> <span style=color:#f92672>-</span> rotations<span style=color:#f92672>.</span>bit_length()) <span style=color:#f92672>+</span> bin(rotations)[<span style=color:#ae81ff>2</span>:]
</span></span><span style=display:flex><span>        tmp <span style=color:#f92672>=</span> rotations[<span style=color:#f92672>-</span>width:] <span style=color:#f92672>+</span> rotations[:<span style=color:#f92672>-</span>width]
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> int(tmp, <span style=color:#ae81ff>2</span>)
</span></span><span style=display:flex><span>    tmp <span style=color:#f92672>=</span> int(bin(rotations <span style=color:#f92672>&lt;&lt;</span> (n<span style=color:#f92672>-</span>width))[<span style=color:#f92672>-</span>n:<span style=color:#f92672>-</span>n<span style=color:#f92672>+</span>width] <span style=color:#f92672>+</span> bin(rotations <span style=color:#f92672>&gt;&gt;</span> width)[<span style=color:#ae81ff>2</span>:], <span style=color:#ae81ff>2</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> tmp
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>candidates <span style=color:#f92672>=</span> printable
</span></span><span style=display:flex><span>targets <span style=color:#f92672>=</span> [<span style=color:#ae81ff>0xED</span>, <span style=color:#ae81ff>0x03</span>, <span style=color:#ae81ff>0x81</span>, <span style=color:#ae81ff>0x69</span>, <span style=color:#ae81ff>0x7B</span>, <span style=color:#ae81ff>0x84</span>, <span style=color:#ae81ff>0xA6</span>, <span style=color:#ae81ff>0xA0</span>, <span style=color:#ae81ff>0x5B</span>, <span style=color:#ae81ff>0x2B</span>, <span style=color:#ae81ff>0xB6</span>, <span style=color:#ae81ff>0xE6</span>, <span style=color:#ae81ff>0x5C</span>, <span style=color:#ae81ff>0x57</span>, <span style=color:#ae81ff>0xC9</span>, <span style=color:#ae81ff>0x99</span>, <span style=color:#ae81ff>0xE8</span>, <span style=color:#ae81ff>0xB2</span>, <span style=color:#ae81ff>0x20</span>, <span style=color:#ae81ff>0x72</span>, <span style=color:#ae81ff>0x38</span>, <span style=color:#ae81ff>0xF1</span>, <span style=color:#ae81ff>0x58</span>]
</span></span><span style=display:flex><span>len <span style=color:#f92672>=</span> len(targets)
</span></span><span style=display:flex><span>iv <span style=color:#f92672>=</span> <span style=color:#ae81ff>0xE0C92EAB</span>
</span></span><span style=display:flex><span>flag <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;&#39;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> byte <span style=color:#f92672>in</span> trange(len):
</span></span><span style=display:flex><span>    iv_xor <span style=color:#f92672>=</span> int(hex(iv)[<span style=color:#ae81ff>2</span>:][<span style=color:#f92672>-</span><span style=color:#ae81ff>2</span>:], <span style=color:#ae81ff>16</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> candidate <span style=color:#f92672>in</span> candidates:
</span></span><span style=display:flex><span>        cipher <span style=color:#f92672>=</span> iv_xor <span style=color:#f92672>^</span> ord(candidate)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> cipher <span style=color:#f92672>==</span> targets[byte]:
</span></span><span style=display:flex><span>            flag <span style=color:#f92672>+=</span> candidate
</span></span><span style=display:flex><span>            iv <span style=color:#f92672>=</span> ror(<span style=color:#ae81ff>32</span>, iv, <span style=color:#ae81ff>3</span>)
</span></span><span style=display:flex><span>            iv <span style=color:#f92672>=</span> len <span style=color:#f92672>+</span> (cipher <span style=color:#f92672>^</span> iv) <span style=color:#f92672>-</span> byte
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>break</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># print(flag)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>print(flag)
</span></span></code></pre></div><p>:::spoiler z3 solver</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>from</span> z3 <span style=color:#f92672>import</span> <span style=color:#f92672>*</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>target <span style=color:#f92672>=</span> [<span style=color:#ae81ff>0xED</span>, <span style=color:#ae81ff>0x03</span>, <span style=color:#ae81ff>0x81</span>, <span style=color:#ae81ff>0x69</span>, <span style=color:#ae81ff>0x7B</span>, <span style=color:#ae81ff>0x84</span>, <span style=color:#ae81ff>0xA6</span>, <span style=color:#ae81ff>0xA0</span>, <span style=color:#ae81ff>0x5B</span>, <span style=color:#ae81ff>0x2B</span>, <span style=color:#ae81ff>0xB6</span>, <span style=color:#ae81ff>0xE6</span>, <span style=color:#ae81ff>0x5C</span>, <span style=color:#ae81ff>0x57</span>, <span style=color:#ae81ff>0xC9</span>, <span style=color:#ae81ff>0x99</span>, <span style=color:#ae81ff>0xE8</span>, <span style=color:#ae81ff>0xB2</span>, <span style=color:#ae81ff>0x20</span>, <span style=color:#ae81ff>0x72</span>, <span style=color:#ae81ff>0x38</span>, <span style=color:#ae81ff>0xF1</span>, <span style=color:#ae81ff>0x58</span>]
</span></span><span style=display:flex><span>len <span style=color:#f92672>=</span> len(target)
</span></span><span style=display:flex><span>iv <span style=color:#f92672>=</span> <span style=color:#ae81ff>0xE0C92EAB</span>
</span></span><span style=display:flex><span><span style=color:#75715e># 起手式 - 開一個Solver</span>
</span></span><span style=display:flex><span>s <span style=color:#f92672>=</span> Solver()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 建立符號 - 以此HW來說就是建立23個符號對應每一個flag字元</span>
</span></span><span style=display:flex><span>bvs <span style=color:#f92672>=</span> [BitVec(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#39;bt_</span><span style=color:#e6db74>{</span>i<span style=color:#e6db74>}</span><span style=color:#e6db74>&#39;</span>, <span style=color:#ae81ff>8</span>) <span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> range(len)]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 加上constraint - 以此lab來說每一個flag字元都應該限制在空白到0x7f之間</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> bv <span style=color:#f92672>in</span> bvs:
</span></span><span style=display:flex><span>    s<span style=color:#f92672>.</span>add(And(bv <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>0x20</span>, bv <span style=color:#f92672>&lt;=</span> <span style=color:#ae81ff>0x7f</span>))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> range(len):
</span></span><span style=display:flex><span>    iv <span style=color:#f92672>=</span> <span style=color:#e6db74>f</span><span style=color:#e6db74>&#39;int(hex(iv)[2:][-2:], 16)&#39;</span>
</span></span><span style=display:flex><span>    bvs_formula <span style=color:#f92672>=</span> <span style=color:#e6db74>f</span><span style=color:#e6db74>&#39;((</span><span style=color:#e6db74>{</span>eval(iv)<span style=color:#e6db74>}</span><span style=color:#e6db74>) ^ bvs[</span><span style=color:#e6db74>{</span>i<span style=color:#e6db74>}</span><span style=color:#e6db74>])&#39;</span>
</span></span><span style=display:flex><span>    s<span style=color:#f92672>.</span>add(eval(bvs_formula) <span style=color:#f92672>==</span> target[i])
</span></span><span style=display:flex><span>    RotateRight <span style=color:#f92672>=</span> <span style=color:#e6db74>f</span><span style=color:#e6db74>&#39;int(bin(</span><span style=color:#e6db74>{</span>iv_formula<span style=color:#e6db74>}</span><span style=color:#e6db74> &lt;&lt; (32-3))[-32:-29] + bin(</span><span style=color:#e6db74>{</span>iv_formula<span style=color:#e6db74>}</span><span style=color:#e6db74> &gt;&gt; 3)[2:], 2)&#39;</span>
</span></span><span style=display:flex><span>    iv_formula <span style=color:#f92672>=</span> <span style=color:#e6db74>f</span><span style=color:#e6db74>&#39;</span><span style=color:#e6db74>{</span>int(hex(iv)[<span style=color:#ae81ff>2</span>:][<span style=color:#f92672>-</span><span style=color:#ae81ff>2</span>:], <span style=color:#ae81ff>16</span>)<span style=color:#e6db74>}</span><span style=color:#e6db74>&#39;</span>
</span></span><span style=display:flex><span>    iv_formula <span style=color:#f92672>=</span> <span style=color:#e6db74>f</span><span style=color:#e6db74>&#39;</span><span style=color:#e6db74>{</span>len<span style=color:#e6db74>}</span><span style=color:#e6db74> + (</span><span style=color:#e6db74>{</span>iv_formula<span style=color:#e6db74>}</span><span style=color:#e6db74> ^ </span><span style=color:#e6db74>{</span>iv<span style=color:#e6db74>}</span><span style=color:#e6db74>) - </span><span style=color:#e6db74>{</span>i<span style=color:#e6db74>}</span><span style=color:#e6db74>&#39;</span>
</span></span><span style=display:flex><span>    print(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#39;iv_formula = </span><span style=color:#e6db74>{</span>iv_formula<span style=color:#e6db74>}</span><span style=color:#e6db74>&#39;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 如果有解的話就會做以下操作</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> s<span style=color:#f92672>.</span>check() <span style=color:#f92672>==</span> sat:
</span></span><span style=display:flex><span>    print(<span style=color:#e6db74>&#39;Find ~~~&#39;</span>)
</span></span><span style=display:flex><span>    print(s<span style=color:#f92672>.</span>model())
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    flag <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> bv <span style=color:#f92672>in</span> bvs:
</span></span><span style=display:flex><span>        flag <span style=color:#f92672>+=</span> chr(s<span style=color:#f92672>.</span>model()[bv]<span style=color:#f92672>.</span>as_long())
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    print(flag)
</span></span></code></pre></div><p>:::
:::spoiler angr solver</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>import</span> angr
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> claripy
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 建立一個project</span>
</span></span><span style=display:flex><span>root <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;Reverse/HW3/Evil FlagChecker/&#39;</span>
</span></span><span style=display:flex><span>proj <span style=color:#f92672>=</span> angr<span style=color:#f92672>.</span>Project(root <span style=color:#f92672>+</span> <span style=color:#e6db74>&#39;test.exe&#39;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 建立Claripy Symbol</span>
</span></span><span style=display:flex><span>sym_arg <span style=color:#f92672>=</span> claripy<span style=color:#f92672>.</span>BVS(<span style=color:#e6db74>&#39;sym_arg&#39;</span>, <span style=color:#ae81ff>8</span> <span style=color:#f92672>*</span> <span style=color:#ae81ff>23</span>) <span style=color:#75715e># 就像z3一樣要建立symbol</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 建立初始的state</span>
</span></span><span style=display:flex><span>state <span style=color:#f92672>=</span> proj<span style=color:#f92672>.</span>factory<span style=color:#f92672>.</span>entry_state(stdin<span style=color:#f92672>=</span>sym_arg)
</span></span><span style=display:flex><span>simgr <span style=color:#f92672>=</span> proj<span style=color:#f92672>.</span>factory<span style=color:#f92672>.</span>simulation_manager(state)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 有了proj/symbol/initial state之後就要開始讓他跑起來</span>
</span></span><span style=display:flex><span><span style=color:#75715e># simgr.explore(find = lambda s: b&#39;Good!&#39; in s.posix.dumps(1))</span>
</span></span><span style=display:flex><span>simgr<span style=color:#f92672>.</span>explore(find <span style=color:#f92672>=</span> <span style=color:#66d9ef>lambda</span> s: <span style=color:#e6db74>b</span><span style=color:#e6db74>&#34;Good!&#34;</span> <span style=color:#f92672>in</span> s<span style=color:#f92672>.</span>posix<span style=color:#f92672>.</span>dumps(<span style=color:#ae81ff>1</span>), avoid<span style=color:#f92672>=</span><span style=color:#66d9ef>lambda</span> s: <span style=color:#e6db74>b</span><span style=color:#e6db74>&#34;No no no...&#34;</span> <span style=color:#f92672>in</span> s<span style=color:#f92672>.</span>posix<span style=color:#f92672>.</span>dumps(<span style=color:#ae81ff>1</span>))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> len(simgr<span style=color:#f92672>.</span>found) <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span>:
</span></span><span style=display:flex><span>    print(simgr<span style=color:#f92672>.</span>found[<span style=color:#ae81ff>0</span>]<span style=color:#f92672>.</span>solver<span style=color:#f92672>.</span>eval(sym_arg, cast_to<span style=color:#f92672>=</span>bytes))
</span></span><span style=display:flex><span><span style=color:#66d9ef>else</span>:
</span></span><span style=display:flex><span>    print(<span style=color:#e6db74>&#34;NONONONO&#34;</span>)
</span></span></code></pre></div><p>:::</p><p>Flag: <code>FLAG{jmp1ng_a1l_ar0und}</code></p></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#background>Background</a></li><li><a href=#source-code>Source code</a></li><li><a href=#recon>Recon</a></li><li><a href=#exploit>Exploit</a></li></ul></nav></div></aside></main></body></html>