<!doctype html><html lang=en-us dir=ltr><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content='
  Simple Reverse - 0x20(2023 Lab - WinMalware - Extract Next Stage Payload - 2)
  #


  Background
  #


CreateToolhelp32Snapshot
Process32FirstW
GetCurrentProcess
OpenProcess
EqualSid
Process32NextW
OpenProcessToken
GetTokenInformation


  Source code
  #


sub_1400016B0
:::spoiler IDA Source Code解析前
__int64 returnTargetPid()
{
  DWORD LastError; // eax
  DWORD v2; // eax
  WCHAR *szExeFile; // rax
  signed __int64 v4; // rcx
  WCHAR v5; // dx
  int v6; // eax
  DWORD th32ProcessID; // [rsp+20h] [rbp-288h]
  HANDLE hSnapshot; // [rsp+28h] [rbp-280h]
  HANDLE hObject; // [rsp+30h] [rbp-278h]
  HANDLE CurrentProcess; // [rsp+38h] [rbp-270h]
  PSID pSid1; // [rsp+40h] [rbp-268h] BYREF
  PSID pSid2; // [rsp+48h] [rbp-260h] BYREF
  PROCESSENTRY32W pe; // [rsp+50h] [rbp-258h] BYREF

  hSnapshot = CreateToolhelp32Snapshot(2u, 0);
  if ( hSnapshot == (HANDLE)-1i64 )
  {
    LastError = GetLastError();
    sub_140001260("CreateToolhelp32Snapshot failed with error %lu\n", LastError);
    return 0i64;
  }
  else
  {
    pe.dwSize = 568;
    if ( Process32FirstW(hSnapshot, &amp;pe) )
    {
      pSid2 = malloc(0x44ui64);
      CurrentProcess = GetCurrentProcess();
      sub_140001500(CurrentProcess, &amp;pSid2);
      th32ProcessID = 0;
      do
      {
        pSid1 = malloc(0x44ui64);
        hObject = OpenProcess(0x400u, 0, pe.th32ProcessID);
        if ( hObject )
        {
          if ( (unsigned int)sub_140001500(hObject, &amp;pSid1) )
          {
            if ( EqualSid(pSid1, pSid2) )
            {
              szExeFile = pe.szExeFile;
              v4 = (char *)L"msedge.exe" - (char *)pe.szExeFile;
              while ( 1 )
              {
                v5 = *szExeFile;
                if ( *szExeFile != *(WCHAR *)((char *)szExeFile + v4) )
                  break;
                ++szExeFile;
                if ( !v5 )
                {
                  v6 = 0;
                  goto LABEL_14;
                }
              }
              v6 = v5 < *(WCHAR *)((char *)szExeFile + v4) ? -1 : 1;
LABEL_14:
              if ( !v6 )
                th32ProcessID = pe.th32ProcessID;
            }
            free(pSid1);
          }
          CloseHandle(hObject);
        }
      }
      while ( !th32ProcessID && Process32NextW(hSnapshot, &amp;pe) );
      free(pSid2);
      CloseHandle(hSnapshot);
      return th32ProcessID;
    }
    else
    {
      v2 = GetLastError();
      sub_140001260("Process32First failed with error %lu\n", v2);
      CloseHandle(hSnapshot);
      return 0i64;
    }
  }
}    
:::


  Recon
  #



首先，他先利用CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0)把當前系統中所有的process都snapshot，並回傳指定快照集的開啟控制碼(handle)'><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#343a40"><meta name=color-scheme content="light dark"><meta property="og:url" content="https://bernie6401.github.io/security/course/ntu-cs/reverse/winmalware-lab/simple-reverse---0x202023-lab---winmalware---extract-next-stage-payload---2/"><meta property="og:site_name" content="SBK Hugo Site"><meta property="og:title" content="Simple Reverse - 0x20(2023 Lab - WinMalware - Extract Next Stage Payload - 2)"><meta property="og:description" content='Simple Reverse - 0x20(2023 Lab - WinMalware - Extract Next Stage Payload - 2) # Background # CreateToolhelp32Snapshot Process32FirstW GetCurrentProcess OpenProcess EqualSid Process32NextW OpenProcessToken GetTokenInformation Source code # sub_1400016B0 :::spoiler IDA Source Code解析前 __int64 returnTargetPid() { DWORD LastError; // eax DWORD v2; // eax WCHAR *szExeFile; // rax signed __int64 v4; // rcx WCHAR v5; // dx int v6; // eax DWORD th32ProcessID; // [rsp+20h] [rbp-288h] HANDLE hSnapshot; // [rsp+28h] [rbp-280h] HANDLE hObject; // [rsp+30h] [rbp-278h] HANDLE CurrentProcess; // [rsp+38h] [rbp-270h] PSID pSid1; // [rsp+40h] [rbp-268h] BYREF PSID pSid2; // [rsp+48h] [rbp-260h] BYREF PROCESSENTRY32W pe; // [rsp+50h] [rbp-258h] BYREF hSnapshot = CreateToolhelp32Snapshot(2u, 0); if ( hSnapshot == (HANDLE)-1i64 ) { LastError = GetLastError(); sub_140001260("CreateToolhelp32Snapshot failed with error %lu\n", LastError); return 0i64; } else { pe.dwSize = 568; if ( Process32FirstW(hSnapshot, &amp;pe) ) { pSid2 = malloc(0x44ui64); CurrentProcess = GetCurrentProcess(); sub_140001500(CurrentProcess, &amp;pSid2); th32ProcessID = 0; do { pSid1 = malloc(0x44ui64); hObject = OpenProcess(0x400u, 0, pe.th32ProcessID); if ( hObject ) { if ( (unsigned int)sub_140001500(hObject, &amp;pSid1) ) { if ( EqualSid(pSid1, pSid2) ) { szExeFile = pe.szExeFile; v4 = (char *)L"msedge.exe" - (char *)pe.szExeFile; while ( 1 ) { v5 = *szExeFile; if ( *szExeFile != *(WCHAR *)((char *)szExeFile + v4) ) break; ++szExeFile; if ( !v5 ) { v6 = 0; goto LABEL_14; } } v6 = v5 < *(WCHAR *)((char *)szExeFile + v4) ? -1 : 1; LABEL_14: if ( !v6 ) th32ProcessID = pe.th32ProcessID; } free(pSid1); } CloseHandle(hObject); } } while ( !th32ProcessID && Process32NextW(hSnapshot, &amp;pe) ); free(pSid2); CloseHandle(hSnapshot); return th32ProcessID; } else { v2 = GetLastError(); sub_140001260("Process32First failed with error %lu\n", v2); CloseHandle(hSnapshot); return 0i64; } } } ::: Recon # 首先，他先利用CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0)把當前系統中所有的process都snapshot，並回傳指定快照集的開啟控制碼(handle)'><meta property="og:locale" content="en_us"><meta property="og:type" content="article"><meta property="article:section" content="security"><meta property="article:tag" content="Eductf"><meta property="article:tag" content="CTF"><meta property="article:tag" content="Reverse"><title>Simple Reverse - 0x20(2023 Lab - WinMalware - Extract Next Stage Payload - 2) | SBK Hugo Site</title>
<link rel=icon href=/favicon.png><link rel=manifest href=/manifest.json><link rel=canonical href=https://bernie6401.github.io/security/course/ntu-cs/reverse/winmalware-lab/simple-reverse---0x202023-lab---winmalware---extract-next-stage-payload---2/><link rel=stylesheet href=/book.min.6c8b9d2a1fc95075ed7da46ca81060b39add8fff6741ac51259f768929281e2c.css integrity="sha256-bIudKh/JUHXtfaRsqBBgs5rdj/9nQaxRJZ92iSkoHiw=" crossorigin=anonymous><script defer src=/fuse.min.js></script><script defer src=/en.search.min.acdc41c8d39e6c69d70d8a23779875e0a3733fefead3e428d5344966bb12f562.js integrity="sha256-rNxByNOebGnXDYojd5h14KNzP+/q0+Qo1TRJZrsS9WI=" crossorigin=anonymous></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/><span>SBK Hugo Site</span></a></h2><div class="book-search hidden"><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><script>document.querySelector(".book-search").classList.remove("hidden")</script></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu></label><h3>Simple Reverse - 0x20(2023 Lab - WinMalware - Extract Next Stage Payload - 2)</h3><label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#background>Background</a></li><li><a href=#source-code>Source code</a></li><li><a href=#recon>Recon</a></li></ul></nav></aside></header><article class="markdown book-article"><h1 id=simple-reverse---0x202023-lab---winmalware---extract-next-stage-payload---2>Simple Reverse - 0x20(2023 Lab - WinMalware - Extract Next Stage Payload - 2)
<a class=anchor href=#simple-reverse---0x202023-lab---winmalware---extract-next-stage-payload---2>#</a></h1><h2 id=background>Background
<a class=anchor href=#background>#</a></h2><ul><li><a href=https://learn.microsoft.com/zh-tw/windows/win32/api/tlhelp32/nf-tlhelp32-createtoolhelp32snapshot>CreateToolhelp32Snapshot</a></li><li><a href=https://learn.microsoft.com/zh-tw/windows/win32/api/tlhelp32/nf-tlhelp32-process32firstw>Process32FirstW</a></li><li><a href=https://learn.microsoft.com/zh-tw/windows/win32/api/processthreadsapi/nf-processthreadsapi-getcurrentprocess>GetCurrentProcess</a></li><li><a href=https://learn.microsoft.com/zh-tw/windows/win32/api/processthreadsapi/nf-processthreadsapi-openprocess>OpenProcess</a></li><li><a href=https://learn.microsoft.com/zh-tw/windows/win32/api/securitybaseapi/nf-securitybaseapi-equalsid>EqualSid</a></li><li><a href=https://learn.microsoft.com/zh-tw/windows/win32/api/tlhelp32/nf-tlhelp32-process32nextw>Process32NextW</a></li><li><a href=https://learn.microsoft.com/zh-tw/windows/win32/api/processthreadsapi/nf-processthreadsapi-openprocesstoken>OpenProcessToken</a></li><li><a href=https://learn.microsoft.com/zh-tw/windows/win32/api/securitybaseapi/nf-securitybaseapi-gettokeninformation>GetTokenInformation</a></li></ul><h2 id=source-code>Source code
<a class=anchor href=#source-code>#</a></h2><ul><li>sub_1400016B0
:::spoiler IDA Source Code解析前<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>__int64</span> <span style=color:#a6e22e>returnTargetPid</span>()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  DWORD LastError; <span style=color:#75715e>// eax
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  DWORD v2; <span style=color:#75715e>// eax
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  WCHAR <span style=color:#f92672>*</span>szExeFile; <span style=color:#75715e>// rax
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>signed</span> <span style=color:#66d9ef>__int64</span> v4; <span style=color:#75715e>// rcx
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  WCHAR v5; <span style=color:#75715e>// dx
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>int</span> v6; <span style=color:#75715e>// eax
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  DWORD th32ProcessID; <span style=color:#75715e>// [rsp+20h] [rbp-288h]
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  HANDLE hSnapshot; <span style=color:#75715e>// [rsp+28h] [rbp-280h]
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  HANDLE hObject; <span style=color:#75715e>// [rsp+30h] [rbp-278h]
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  HANDLE CurrentProcess; <span style=color:#75715e>// [rsp+38h] [rbp-270h]
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  PSID pSid1; <span style=color:#75715e>// [rsp+40h] [rbp-268h] BYREF
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  PSID pSid2; <span style=color:#75715e>// [rsp+48h] [rbp-260h] BYREF
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  PROCESSENTRY32W pe; <span style=color:#75715e>// [rsp+50h] [rbp-258h] BYREF
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>  hSnapshot <span style=color:#f92672>=</span> CreateToolhelp32Snapshot(<span style=color:#ae81ff>2u</span>, <span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> ( hSnapshot <span style=color:#f92672>==</span> (HANDLE)<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>i64 )
</span></span><span style=display:flex><span>  {
</span></span><span style=display:flex><span>    LastError <span style=color:#f92672>=</span> GetLastError();
</span></span><span style=display:flex><span>    sub_140001260(<span style=color:#e6db74>&#34;CreateToolhelp32Snapshot failed with error %lu</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, LastError);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>i64;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>  {
</span></span><span style=display:flex><span>    pe.dwSize <span style=color:#f92672>=</span> <span style=color:#ae81ff>568</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> ( Process32FirstW(hSnapshot, <span style=color:#f92672>&amp;</span>pe) )
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>      pSid2 <span style=color:#f92672>=</span> malloc(<span style=color:#ae81ff>0x44u</span>i64);
</span></span><span style=display:flex><span>      CurrentProcess <span style=color:#f92672>=</span> GetCurrentProcess();
</span></span><span style=display:flex><span>      sub_140001500(CurrentProcess, <span style=color:#f92672>&amp;</span>pSid2);
</span></span><span style=display:flex><span>      th32ProcessID <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>do</span>
</span></span><span style=display:flex><span>      {
</span></span><span style=display:flex><span>        pSid1 <span style=color:#f92672>=</span> malloc(<span style=color:#ae81ff>0x44u</span>i64);
</span></span><span style=display:flex><span>        hObject <span style=color:#f92672>=</span> OpenProcess(<span style=color:#ae81ff>0x400u</span>, <span style=color:#ae81ff>0</span>, pe.th32ProcessID);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> ( hObject )
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>          <span style=color:#66d9ef>if</span> ( (<span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>int</span>)sub_140001500(hObject, <span style=color:#f92672>&amp;</span>pSid1) )
</span></span><span style=display:flex><span>          {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> ( EqualSid(pSid1, pSid2) )
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>              szExeFile <span style=color:#f92672>=</span> pe.szExeFile;
</span></span><span style=display:flex><span>              v4 <span style=color:#f92672>=</span> (<span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>)<span style=color:#e6db74>L</span><span style=color:#e6db74>&#34;msedge.exe&#34;</span> <span style=color:#f92672>-</span> (<span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>)pe.szExeFile;
</span></span><span style=display:flex><span>              <span style=color:#66d9ef>while</span> ( <span style=color:#ae81ff>1</span> )
</span></span><span style=display:flex><span>              {
</span></span><span style=display:flex><span>                v5 <span style=color:#f92672>=</span> <span style=color:#f92672>*</span>szExeFile;
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> ( <span style=color:#f92672>*</span>szExeFile <span style=color:#f92672>!=</span> <span style=color:#f92672>*</span>(WCHAR <span style=color:#f92672>*</span>)((<span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>)szExeFile <span style=color:#f92672>+</span> v4) )
</span></span><span style=display:flex><span>                  <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>                <span style=color:#f92672>++</span>szExeFile;
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> ( <span style=color:#f92672>!</span>v5 )
</span></span><span style=display:flex><span>                {
</span></span><span style=display:flex><span>                  v6 <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>                  <span style=color:#66d9ef>goto</span> LABEL_14;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>              }
</span></span><span style=display:flex><span>              v6 <span style=color:#f92672>=</span> v5 <span style=color:#f92672>&lt;</span> <span style=color:#f92672>*</span>(WCHAR <span style=color:#f92672>*</span>)((<span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>)szExeFile <span style=color:#f92672>+</span> v4) <span style=color:#f92672>?</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span> <span style=color:#f92672>:</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>LABEL_14:
</span></span><span style=display:flex><span>              <span style=color:#66d9ef>if</span> ( <span style=color:#f92672>!</span>v6 )
</span></span><span style=display:flex><span>                th32ProcessID <span style=color:#f92672>=</span> pe.th32ProcessID;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            free(pSid1);
</span></span><span style=display:flex><span>          }
</span></span><span style=display:flex><span>          CloseHandle(hObject);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>while</span> ( <span style=color:#f92672>!</span>th32ProcessID <span style=color:#f92672>&amp;&amp;</span> Process32NextW(hSnapshot, <span style=color:#f92672>&amp;</span>pe) );
</span></span><span style=display:flex><span>      free(pSid2);
</span></span><span style=display:flex><span>      CloseHandle(hSnapshot);
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>return</span> th32ProcessID;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>      v2 <span style=color:#f92672>=</span> GetLastError();
</span></span><span style=display:flex><span>      sub_140001260(<span style=color:#e6db74>&#34;Process32First failed with error %lu</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, v2);
</span></span><span style=display:flex><span>      CloseHandle(hSnapshot);
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>i64;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}    
</span></span></code></pre></div>:::</li></ul><h2 id=recon>Recon
<a class=anchor href=#recon>#</a></h2><ol><li><p>首先，他先利用<code>CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0)</code>把當前系統中所有的process都snapshot，並回傳指定快照集的開啟控制碼(handle)</p></li><li><p>在<a href=https://learn.microsoft.com/zh-tw/windows/win32/api/tlhelp32/nf-tlhelp32-createtoolhelp32snapshot#parameters>MSDN</a>中有提到</p><blockquote><p>若要列舉process，請參閱 <a href=https://learn.microsoft.com/zh-tw/windows/win32/api/tlhelp32/nf-tlhelp32-process32firstw>Process32FirstW</a></p></blockquote><p>所以的確，該function底下就有使用到這個API(#27)，主要目的是擷取系統snapshot中所遇到的第一個process相關資訊</p></li><li><p>接著進到<code>sub_140001500</code>中看一下，如果不看其他exception handler的話其實蠻簡單的</p><ol><li>也就是他會先取得<code>currentProcess</code>的token handle(暫時不需要知道handle是啥)，然後再取得儲存資料所需要的buffer size，這邊很tricky的地方是，在#14的地方原本是設定<code>TokenInformationLength = 0</code>，而後面呼叫的<code>GetTokenInformation</code>就一定會報錯，但他只是想知道TokenInformation的length為多少，所以當他執行完#15行之後，<code>&amp;TokenInformationLength</code>會儲存Length，而我可以利用報錯error code(也就是0x7A, <code>ERROR_INSUFFICIENT_BUFFER</code>)，進到if statement中，然後利用得到的length再malloc一個空間，做後續的操作
<img src=https://hackmd.io/_uploads/ByZ4tHpMp.png alt></li><li>再次呼叫GetTokenInformation 取得資料，此時因為我們已經明確知道需要多大的空間了，所以就不會再報錯了，此時才能真正的取得資料
<img src=https://hackmd.io/_uploads/SJoEKSpfT.png alt></li><li>將User SID 複製到a2這個變數
:::spoiler</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>__int64</span> <span style=color:#66d9ef>__fastcall</span> <span style=color:#a6e22e>sub_140001500</span>(<span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>a1, PSID <span style=color:#f92672>*</span>a2)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  DWORD v2; <span style=color:#75715e>// eax
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  DWORD v4; <span style=color:#75715e>// eax
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  DWORD v5; <span style=color:#75715e>// eax
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  DWORD LastError; <span style=color:#75715e>// eax
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  PSID <span style=color:#f92672>*</span>TokenInformation; <span style=color:#75715e>// [rsp+30h] [rbp-28h]
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  DWORD TokenInformationLength; <span style=color:#75715e>// [rsp+38h] [rbp-20h] BYREF
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  HANDLE TokenHandle; <span style=color:#75715e>// [rsp+40h] [rbp-18h] BYREF
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>  TokenHandle <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>i64;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> ( OpenProcessToken(a1, <span style=color:#ae81ff>0x20008u</span>, <span style=color:#f92672>&amp;</span>TokenHandle) )
</span></span><span style=display:flex><span>  {
</span></span><span style=display:flex><span>    TokenInformationLength <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    GetTokenInformation(TokenHandle, TokenUser, <span style=color:#ae81ff>0</span>i64, <span style=color:#ae81ff>0</span>, <span style=color:#f92672>&amp;</span>TokenInformationLength);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> ( GetLastError() <span style=color:#f92672>==</span> <span style=color:#ae81ff>122</span> )
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>      TokenInformation <span style=color:#f92672>=</span> (PSID <span style=color:#f92672>*</span>)malloc(TokenInformationLength);
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>if</span> ( TokenInformation )
</span></span><span style=display:flex><span>      {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> ( GetTokenInformation(
</span></span><span style=display:flex><span>               TokenHandle,
</span></span><span style=display:flex><span>               TokenUser,
</span></span><span style=display:flex><span>               TokenInformation,
</span></span><span style=display:flex><span>               TokenInformationLength,
</span></span><span style=display:flex><span>               <span style=color:#f92672>&amp;</span>TokenInformationLength) )
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>          <span style=color:#66d9ef>if</span> ( CopySid(<span style=color:#ae81ff>0x44u</span>, <span style=color:#f92672>*</span>a2, <span style=color:#f92672>*</span>TokenInformation) )
</span></span><span style=display:flex><span>          {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> ( <span style=color:#f92672>!</span>IsValidSid(<span style=color:#f92672>*</span>a2) )
</span></span><span style=display:flex><span>              sub_140001260(<span style=color:#e6db74>&#34;Sid is invalid</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>            free(TokenInformation);
</span></span><span style=display:flex><span>            CloseHandle(TokenHandle);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>1</span>i64;
</span></span><span style=display:flex><span>          }
</span></span><span style=display:flex><span>          <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>          {
</span></span><span style=display:flex><span>            LastError <span style=color:#f92672>=</span> GetLastError();
</span></span><span style=display:flex><span>            sub_140001260(<span style=color:#e6db74>&#34;CopySid failed, %d</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, LastError);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>i64;
</span></span><span style=display:flex><span>          }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>          v5 <span style=color:#f92672>=</span> GetLastError();
</span></span><span style=display:flex><span>          sub_140001260(<span style=color:#e6db74>&#34;GetTokenInformatoin failed, %d</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, v5);
</span></span><span style=display:flex><span>          CloseHandle(TokenHandle);
</span></span><span style=display:flex><span>          <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>i64;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>      {
</span></span><span style=display:flex><span>        CloseHandle(TokenHandle);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>i64;
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>      v4 <span style=color:#f92672>=</span> GetLastError();
</span></span><span style=display:flex><span>      sub_140001260(<span style=color:#e6db74>&#34;GetTokenInformatoin 1 failed, %d</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, v4);
</span></span><span style=display:flex><span>      CloseHandle(TokenHandle);
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>i64;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>  {
</span></span><span style=display:flex><span>    v2 <span style=color:#f92672>=</span> GetLastError();
</span></span><span style=display:flex><span>    sub_140001260(<span style=color:#e6db74>&#34;OpenProcessToken failed, %d</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, v2);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>i64;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>:::</p></li><li><p>回到<code>sub_1400016B0</code>，可以看到#33~#67是一個do_while loop，該loop就是把現在存取的process再打開(利用PID指定)，並取得他的handle，然後找到該process的User SID，再去比對前一個步驟取得的User SID和現在取得的User SID有沒有一樣，如果一樣就做==#43~#57==(其實就是<code>memcmp("msedge.exe", process’s executable file name)</code>)，他會去比對目前的這一支程式的filename是不是<code>msedge.exe</code>，如果這個Edge Process的User SID和目前的current User SID一樣且<code>memcmp</code>也回傳是，就return PID</p></li></ol><p>:::info
簡略流程如下:</p><ol><li>snapshot目前所有的process</li><li>取得目前執行這支程式(A)的User SID</li><li>遍歷snapshot中所有的process，如果遍歷的process(B)的User SID和剛剛取得的一樣就再memcmp，看目前的這支程式(B)是不是msedge.exe，如果是就回傳PID，若否就再遍歷下一個process(B&rsquo;)
:::</li></ol></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#background>Background</a></li><li><a href=#source-code>Source code</a></li><li><a href=#recon>Recon</a></li></ul></nav></div></aside></main></body></html>