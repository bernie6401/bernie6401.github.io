<!doctype html><html lang=en-us dir=ltr><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content='
  Simple Reverse - 0x19(2023 Lab - WinMalware - Extract Next Stage Payload)
  #


  Description
  #


取出 eductf-lab.exe 中的 next stage payload (embedded PE file)，並計算其 MD5 hash。
Flag format: FLAG{462fe0000&mldr;} (hex character must be lowercase)

  Background
  #


DOS Header

NT Headers - Optional Header



  Source code
  #


sub_140001870
:::spoiler IDA Source Code解析前
__int64 __fastcall sub_140001870(char **pe_file, _QWORD *pe_file_size)
{
  *pe_file = byte_140005040;
  *pe_file_size = 72770i64;                     // 這是個是怎麼判斷成PE size我也不知道
  if ( **pe_file == &#39;ZM&#39; )
  {
    if ( *(sub_1400013D0(*pe_file) + 0x18) == 0x20B )
    {
      return 1i64;
    }
    else
    {
      sub_140001260("remote dll optional header magic check failed\n");
      return 0i64;
    }
  }
  else
  {
    sub_140001260("remote dll magic check failed\n");
    return 0i64;
  }
}
:::


  Recon
  #


進到sub_140001BF0之後可以先觀察sub_140001870，前面有source code可以看到他正在比對byte_140005040的前面兩個字元是不是等於MZ，也就是一支PE file的magic header，並且又比對了後面0x18的位置是不是等於0x20B，也就是另外一個magic header(用來判斷該程式是否可於64-bits運行)，由以上操作幾乎可以確定駭客把真正的程式(可能是惡意的)塞在正常的PE file中
:::info
如果只是要解題的話，到這邊就可以了，只要利用前一題學到的把byte_140005040改變他的type，變成char[72770]，再用Shift+E，把raw data export出來，丟到online md5 checksum，就可以得到這支檔案的hash(462fe0007f86957f59824e113f78947c)


:::
sub_1400013D0仔細看他的操作，其實就是把byte_140005040的地址，加上0x3C，再取值，就是e_lfanew，也就是NT Headers的file offset，這個offset加上原本的原本的140005040就是NT header，所以可以把sub_1400013D0 rename成getNtHdr
__int64 __fastcall getNtHdr(__int64 a1)
{
  return *(a1 + 0x3C) + a1;
}

接下來可以改變這個function的type，按Y，改IMAGE_NT_HEADERS *__fastcall getNtHdr(_QWORD)，就變得非常簡潔好看，另外，要把pe_file的type從_int64改成_QWORD的原因是pe_file存的是byte_140005040的地址，不是數字，雖然代表的byte數一樣，但意義不相同，所以IDA可能會解析不出來


最後就把目前的這個sub function rename成getEmbeddedPE_File就可以了

:::info

:::
:::spoiler 解析後'><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#343a40"><meta name=color-scheme content="light dark"><meta property="og:url" content="https://bernie6401.github.io/security/course/ntu-cs/reverse/winmalware-lab/simple-reverse---0x192023-lab---winmalware---extract-next-stage-payload/"><meta property="og:site_name" content="SBK Hugo Site"><meta property="og:title" content="Simple Reverse - 0x19(2023 Lab - WinMalware - Extract Next Stage Payload)"><meta property="og:description" content='Simple Reverse - 0x19(2023 Lab - WinMalware - Extract Next Stage Payload) # Description # 取出 eductf-lab.exe 中的 next stage payload (embedded PE file)，並計算其 MD5 hash。 Flag format: FLAG{462fe0000…} (hex character must be lowercase)
Background # DOS Header NT Headers - Optional Header Source code # sub_140001870 :::spoiler IDA Source Code解析前 __int64 __fastcall sub_140001870(char **pe_file, _QWORD *pe_file_size) { *pe_file = byte_140005040; *pe_file_size = 72770i64; // 這是個是怎麼判斷成PE size我也不知道 if ( **pe_file == &#39;ZM&#39; ) { if ( *(sub_1400013D0(*pe_file) + 0x18) == 0x20B ) { return 1i64; } else { sub_140001260("remote dll optional header magic check failed\n"); return 0i64; } } else { sub_140001260("remote dll magic check failed\n"); return 0i64; } } ::: Recon # 進到sub_140001BF0之後可以先觀察sub_140001870，前面有source code可以看到他正在比對byte_140005040的前面兩個字元是不是等於MZ，也就是一支PE file的magic header，並且又比對了後面0x18的位置是不是等於0x20B，也就是另外一個magic header(用來判斷該程式是否可於64-bits運行)，由以上操作幾乎可以確定駭客把真正的程式(可能是惡意的)塞在正常的PE file中 :::info 如果只是要解題的話，到這邊就可以了，只要利用前一題學到的把byte_140005040改變他的type，變成char[72770]，再用Shift+E，把raw data export出來，丟到online md5 checksum，就可以得到這支檔案的hash(462fe0007f86957f59824e113f78947c) ::: sub_1400013D0仔細看他的操作，其實就是把byte_140005040的地址，加上0x3C，再取值，就是e_lfanew，也就是NT Headers的file offset，這個offset加上原本的原本的140005040就是NT header，所以可以把sub_1400013D0 rename成getNtHdr __int64 __fastcall getNtHdr(__int64 a1) { return *(a1 + 0x3C) + a1; } 接下來可以改變這個function的type，按Y，改IMAGE_NT_HEADERS *__fastcall getNtHdr(_QWORD)，就變得非常簡潔好看，另外，要把pe_file的type從_int64改成_QWORD的原因是pe_file存的是byte_140005040的地址，不是數字，雖然代表的byte數一樣，但意義不相同，所以IDA可能會解析不出來 最後就把目前的這個sub function rename成getEmbeddedPE_File就可以了 :::info ::: :::spoiler 解析後'><meta property="og:locale" content="en_us"><meta property="og:type" content="article"><meta property="article:section" content="security"><meta property="article:tag" content="Eductf"><meta property="article:tag" content="CTF"><meta property="article:tag" content="Reverse"><title>Simple Reverse - 0x19(2023 Lab - WinMalware - Extract Next Stage Payload) | SBK Hugo Site</title>
<link rel=icon href=/favicon.png><link rel=manifest href=/manifest.json><link rel=canonical href=https://bernie6401.github.io/security/course/ntu-cs/reverse/winmalware-lab/simple-reverse---0x192023-lab---winmalware---extract-next-stage-payload/><link rel=stylesheet href=/book.min.6c8b9d2a1fc95075ed7da46ca81060b39add8fff6741ac51259f768929281e2c.css integrity="sha256-bIudKh/JUHXtfaRsqBBgs5rdj/9nQaxRJZ92iSkoHiw=" crossorigin=anonymous><script defer src=/fuse.min.js></script><script defer src=/en.search.min.acdc41c8d39e6c69d70d8a23779875e0a3733fefead3e428d5344966bb12f562.js integrity="sha256-rNxByNOebGnXDYojd5h14KNzP+/q0+Qo1TRJZrsS9WI=" crossorigin=anonymous></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/><span>SBK Hugo Site</span></a></h2><div class="book-search hidden"><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><script>document.querySelector(".book-search").classList.remove("hidden")</script></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu></label><h3>Simple Reverse - 0x19(2023 Lab - WinMalware - Extract Next Stage Payload)</h3><label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#description>Description</a></li><li><a href=#background>Background</a></li><li><a href=#source-code>Source code</a></li><li><a href=#recon>Recon</a></li></ul></nav></aside></header><article class="markdown book-article"><h1 id=simple-reverse---0x192023-lab---winmalware---extract-next-stage-payload>Simple Reverse - 0x19(2023 Lab - WinMalware - Extract Next Stage Payload)
<a class=anchor href=#simple-reverse---0x192023-lab---winmalware---extract-next-stage-payload>#</a></h1><h2 id=description>Description
<a class=anchor href=#description>#</a></h2><blockquote><p>取出 eductf-lab.exe 中的 next stage payload (embedded PE file)，並計算其 MD5 hash。
Flag format: FLAG{462fe0000&mldr;} (hex character must be lowercase)</p></blockquote><h2 id=background>Background
<a class=anchor href=#background>#</a></h2><ul><li>DOS Header
<img src=https://hackmd.io/_uploads/HJ9P9gpfp.png alt></li><li>NT Headers - Optional Header
<img src=https://hackmd.io/_uploads/SkjNqeazT.png alt></li></ul><h2 id=source-code>Source code
<a class=anchor href=#source-code>#</a></h2><ul><li>sub_140001870
:::spoiler IDA Source Code解析前<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>__int64</span> <span style=color:#66d9ef>__fastcall</span> <span style=color:#a6e22e>sub_140001870</span>(<span style=color:#66d9ef>char</span> <span style=color:#f92672>**</span>pe_file, _QWORD <span style=color:#f92672>*</span>pe_file_size)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#f92672>*</span>pe_file <span style=color:#f92672>=</span> byte_140005040;
</span></span><span style=display:flex><span>  <span style=color:#f92672>*</span>pe_file_size <span style=color:#f92672>=</span> <span style=color:#ae81ff>72770</span>i64;                     <span style=color:#75715e>// 這是個是怎麼判斷成PE size我也不知道
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>if</span> ( <span style=color:#f92672>**</span>pe_file <span style=color:#f92672>==</span> <span style=color:#960050;background-color:#1e0010>&#39;</span>ZM<span style=color:#960050;background-color:#1e0010>&#39;</span> )
</span></span><span style=display:flex><span>  {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> ( <span style=color:#f92672>*</span>(sub_1400013D0(<span style=color:#f92672>*</span>pe_file) <span style=color:#f92672>+</span> <span style=color:#ae81ff>0x18</span>) <span style=color:#f92672>==</span> <span style=color:#ae81ff>0x20B</span> )
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>1</span>i64;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>      sub_140001260(<span style=color:#e6db74>&#34;remote dll optional header magic check failed</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>i64;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>  {
</span></span><span style=display:flex><span>    sub_140001260(<span style=color:#e6db74>&#34;remote dll magic check failed</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>i64;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div>:::</li></ul><h2 id=recon>Recon
<a class=anchor href=#recon>#</a></h2><ol><li>進到<code>sub_140001BF0</code>之後可以先觀察<code>sub_140001870</code>，前面有source code可以看到他正在比對<code>byte_140005040</code>的前面兩個字元是不是等於<code>MZ</code>，也就是一支PE file的magic header，並且又比對了後面0x18的位置是不是等於0x20B，也就是另外一個magic header(用來判斷該程式是否可於64-bits運行)，由以上操作幾乎可以確定駭客把真正的程式(可能是惡意的)塞在正常的PE file中
:::info
如果只是要解題的話，到這邊就可以了，只要利用前一題學到的把<code>byte_140005040</code>改變他的type，變成<code>char[72770]</code>，再用Shift+E，把raw data export出來，丟到<a href=https://emn178.github.io/online-tools/md5_checksum.html>online md5 checksum</a>，就可以得到這支檔案的hash(<code>462fe0007f86957f59824e113f78947c</code>)
<img src=https://hackmd.io/_uploads/SJoeiepGT.png alt>
<img src=https://hackmd.io/_uploads/rk7SigpGp.png alt>
:::</li><li><code>sub_1400013D0</code>仔細看他的操作，其實就是把<code>byte_140005040</code>的地址，加上<code>0x3C</code>，再取值，就是<code>e_lfanew</code>，也就是NT Headers的file offset，這個offset加上原本的原本的<code>140005040</code>就是NT header，所以可以把<code>sub_1400013D0</code> rename成<code>getNtHdr</code><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>__int64</span> <span style=color:#66d9ef>__fastcall</span> <span style=color:#a6e22e>getNtHdr</span>(<span style=color:#66d9ef>__int64</span> a1)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> <span style=color:#f92672>*</span>(a1 <span style=color:#f92672>+</span> <span style=color:#ae81ff>0x3C</span>) <span style=color:#f92672>+</span> a1;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li><li>接下來可以改變這個function的type，按Y，<code>改IMAGE_NT_HEADERS *__fastcall getNtHdr(_QWORD)</code>，就變得非常簡潔好看，另外，要把<code>pe_file</code>的type從<code>_int64</code>改成<code>_QWORD</code>的原因是<code>pe_file</code>存的是<code>byte_140005040</code>的地址，不是數字，雖然代表的byte數一樣，但意義不相同，所以IDA可能會解析不出來
<img src=https://hackmd.io/_uploads/ryHl0gaG6.png alt>
<img src=https://hackmd.io/_uploads/rJniAlaM6.png alt></li><li>最後就把目前的這個sub function rename成<code>getEmbeddedPE_File</code>就可以了</li></ol><p>:::info
<img src=https://hackmd.io/_uploads/HJaNxWpzp.png alt>
:::
:::spoiler 解析後</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>__int64</span> <span style=color:#a6e22e>returnTargetPid</span>()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  DWORD LastError; <span style=color:#75715e>// eax
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  DWORD v2; <span style=color:#75715e>// eax
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  WCHAR <span style=color:#f92672>*</span>szExeFile; <span style=color:#75715e>// rax
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>signed</span> <span style=color:#66d9ef>__int64</span> v4; <span style=color:#75715e>// rcx
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  WCHAR v5; <span style=color:#75715e>// dx
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>int</span> v6; <span style=color:#75715e>// eax
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  DWORD th32ProcessID; <span style=color:#75715e>// [rsp+20h] [rbp-288h]
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  HANDLE hSnapshot; <span style=color:#75715e>// [rsp+28h] [rbp-280h]
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  HANDLE hObject; <span style=color:#75715e>// [rsp+30h] [rbp-278h]
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  HANDLE CurrentProcess; <span style=color:#75715e>// [rsp+38h] [rbp-270h]
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  PSID pSid1; <span style=color:#75715e>// [rsp+40h] [rbp-268h] BYREF
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  PSID pSid2; <span style=color:#75715e>// [rsp+48h] [rbp-260h] BYREF
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  PROCESSENTRY32W pe; <span style=color:#75715e>// [rsp+50h] [rbp-258h] BYREF
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>  hSnapshot <span style=color:#f92672>=</span> CreateToolhelp32Snapshot(<span style=color:#ae81ff>2u</span>, <span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> ( hSnapshot <span style=color:#f92672>==</span> (HANDLE)<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>i64 )
</span></span><span style=display:flex><span>  {
</span></span><span style=display:flex><span>    LastError <span style=color:#f92672>=</span> GetLastError();
</span></span><span style=display:flex><span>    sub_140001260(<span style=color:#e6db74>&#34;CreateToolhelp32Snapshot failed with error %lu</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, LastError);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>i64;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>  {
</span></span><span style=display:flex><span>    pe.dwSize <span style=color:#f92672>=</span> <span style=color:#ae81ff>568</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> ( Process32FirstW(hSnapshot, <span style=color:#f92672>&amp;</span>pe) )
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>      pSid2 <span style=color:#f92672>=</span> malloc(<span style=color:#ae81ff>0x44u</span>i64);
</span></span><span style=display:flex><span>      CurrentProcess <span style=color:#f92672>=</span> GetCurrentProcess();
</span></span><span style=display:flex><span>      sub_140001500(CurrentProcess, <span style=color:#f92672>&amp;</span>pSid2);
</span></span><span style=display:flex><span>      th32ProcessID <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>do</span>
</span></span><span style=display:flex><span>      {
</span></span><span style=display:flex><span>        pSid1 <span style=color:#f92672>=</span> malloc(<span style=color:#ae81ff>0x44u</span>i64);
</span></span><span style=display:flex><span>        hObject <span style=color:#f92672>=</span> OpenProcess(<span style=color:#ae81ff>0x400u</span>, <span style=color:#ae81ff>0</span>, pe.th32ProcessID);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> ( hObject )
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>          <span style=color:#66d9ef>if</span> ( (<span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>int</span>)sub_140001500(hObject, <span style=color:#f92672>&amp;</span>pSid1) )
</span></span><span style=display:flex><span>          {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> ( EqualSid(pSid1, pSid2) )
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>              szExeFile <span style=color:#f92672>=</span> pe.szExeFile;
</span></span><span style=display:flex><span>              v4 <span style=color:#f92672>=</span> (<span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>)<span style=color:#e6db74>L</span><span style=color:#e6db74>&#34;msedge.exe&#34;</span> <span style=color:#f92672>-</span> (<span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>)pe.szExeFile;
</span></span><span style=display:flex><span>              <span style=color:#66d9ef>while</span> ( <span style=color:#ae81ff>1</span> )
</span></span><span style=display:flex><span>              {
</span></span><span style=display:flex><span>                v5 <span style=color:#f92672>=</span> <span style=color:#f92672>*</span>szExeFile;
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> ( <span style=color:#f92672>*</span>szExeFile <span style=color:#f92672>!=</span> <span style=color:#f92672>*</span>(WCHAR <span style=color:#f92672>*</span>)((<span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>)szExeFile <span style=color:#f92672>+</span> v4) )
</span></span><span style=display:flex><span>                  <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>                <span style=color:#f92672>++</span>szExeFile;
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> ( <span style=color:#f92672>!</span>v5 )
</span></span><span style=display:flex><span>                {
</span></span><span style=display:flex><span>                  v6 <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>                  <span style=color:#66d9ef>goto</span> LABEL_14;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>              }
</span></span><span style=display:flex><span>              v6 <span style=color:#f92672>=</span> v5 <span style=color:#f92672>&lt;</span> <span style=color:#f92672>*</span>(WCHAR <span style=color:#f92672>*</span>)((<span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>)szExeFile <span style=color:#f92672>+</span> v4) <span style=color:#f92672>?</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span> <span style=color:#f92672>:</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>LABEL_14:
</span></span><span style=display:flex><span>              <span style=color:#66d9ef>if</span> ( <span style=color:#f92672>!</span>v6 )
</span></span><span style=display:flex><span>                th32ProcessID <span style=color:#f92672>=</span> pe.th32ProcessID;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            free(pSid1);
</span></span><span style=display:flex><span>          }
</span></span><span style=display:flex><span>          CloseHandle(hObject);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>while</span> ( <span style=color:#f92672>!</span>th32ProcessID <span style=color:#f92672>&amp;&amp;</span> Process32NextW(hSnapshot, <span style=color:#f92672>&amp;</span>pe) );
</span></span><span style=display:flex><span>      free(pSid2);
</span></span><span style=display:flex><span>      CloseHandle(hSnapshot);
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>return</span> th32ProcessID;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>      v2 <span style=color:#f92672>=</span> GetLastError();
</span></span><span style=display:flex><span>      sub_140001260(<span style=color:#e6db74>&#34;Process32First failed with error %lu</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, v2);
</span></span><span style=display:flex><span>      CloseHandle(hSnapshot);
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>i64;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>:::
Flag: <code>FLAG{462fe0007f86957f59824e113f78947c}</code></p></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#description>Description</a></li><li><a href=#background>Background</a></li><li><a href=#source-code>Source code</a></li><li><a href=#recon>Recon</a></li></ul></nav></div></aside></main></body></html>