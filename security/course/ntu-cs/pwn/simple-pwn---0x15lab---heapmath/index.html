<!doctype html><html lang=en-us dir=ltr><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content='
  Simple PWN - 0x15(Lab - heapmath)
  #


  tags: CTF PWN eductf
  #

Version: Ubuntu 20.04

  Original Code
  #

:::spoiler code
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <fcntl.h>
#include <time.h>

int main()
{
    setvbuf(stdin, 0, _IONBF, 0);
    setvbuf(stdout, 0, _IONBF, 0);
    srand(time(NULL));

    void *tcache_chk[7]                = {0};
    unsigned char tcachebin[3][7]      = {0}; // 0x20, 0x30, 0x40
    unsigned int tcachebin_counts[4]   = {0};
    unsigned long tcache_size[7]       = {0};
    unsigned long tcache_free_order[7] = {0};

    puts("----------- ** tcache chall ** -----------");
    unsigned long tmp = 0;
    for (int i = 0; i < 7; i++) {
        tmp = (rand() % 0x21) + 0x10; // 0x10 ~ 0x30
        tcache_size[i] = tmp;
    }

    for (int i = 0; i < 7; i++) {
    repeat:
        tmp = rand() % 7;
        for (int j = 0; j < i; j++)
            if (tmp == tcache_free_order[j]) goto repeat;
        tcache_free_order[i] = tmp;
    }

    for (int i = 0; i < 7; i++) {
        tcache_chk[i] = malloc( tcache_size[i] );
        printf("char *%c = (char *) malloc(0x%lx);\n", &#39;A&#39; + i, tcache_size[i]);
    }

    for (int i = 0; i < 7; i++) {
        int idx = tcache_free_order[i];
        free(tcache_chk[ idx ]);
        printf("free(%c);\n", &#39;A&#39; + (unsigned char) idx);

        tmp = tcache_size[ idx ] - 0x8;
        if (tmp % 0x10)
            tmp = (tmp & ~0xf) + 0x20;
        else
            tmp += 0x10;

        unsigned int binidx = ((tmp - 0x20) / 0x10);
        unsigned int bincnt = tcachebin_counts[ binidx ];
        tcachebin[ binidx ][ bincnt ] = &#39;A&#39; + (unsigned char) idx;
        tcachebin_counts[ binidx ]++;
    }

    char tmpbuf[0x100]   = {0};
    char ansbuf[3][0x100] = {0};
    for (int i = 0; i < 3; i++) {
        for (int j = 6; j >= 0; j--)
            if (tcachebin[i][j]) {
                sprintf(tmpbuf, "%c --> ", tcachebin[i][j]);
                strcat(ansbuf[i], tmpbuf);
            }
        strcat(ansbuf[i], "NULL");
    }
    puts("");
    for (int i = 0; i < 3; i++) {
        printf("[chunk size] 0x%x: ", (i+2) * 0x10);
        if (i == 0) {
            printf("%s\t(just send \"%s\")\n", ansbuf[i], ansbuf[i]);
        } else {
            printf("?\n> ");
            fgets(tmpbuf, 0x100, stdin);
            if (!strncmp(tmpbuf, ansbuf[i], strlen(ansbuf[i]))) {
                puts("Correct !");
            } else {
                puts("Wrong !");
                printf("Ans: \"%s\"\n", ansbuf[i]);
                exit(0);
            }
        }
    }

    puts("\n----------- ** address chall ** -----------");
    int cmp1 = 0;
    int cmp2 = 0;
    unsigned long ans_addr = 0;

    cmp1 = rand() % 7;
    while ((cmp2 = rand() % 7) == cmp1);
    if (cmp1 > cmp2) {
        tmp = cmp1;
        cmp1 = cmp2;
        cmp2 = tmp;
    }

    printf("assert( %c == %p );\n", &#39;A&#39; + cmp1, tcache_chk[ cmp1 ]);
    printf("%c == ?\t(send as hex format, e.g. \"%p\")\n> ",
                &#39;A&#39; + cmp2, tcache_chk[ cmp1 ]);
    scanf("%s", tmpbuf);
    ans_addr = strtoul(tmpbuf, NULL, 16);

    if (ans_addr == (unsigned long) tcache_chk[ cmp2 ]) {
        puts("Correct !");
    } else {
        puts("Wrong !");
        printf("Ans: %p\n", tcache_chk[ cmp2 ]);
        exit(0);
    }

    puts("\n----------- ** index chall ** -----------");
    unsigned long *fastbin[2] = {0};
    unsigned long fastbin_size = 0;
    unsigned long secret_idx = 0, result_idx = 0, res = 0;

    fastbin_size = (rand() % 0x31) + 0x40; // 0x40 ~ 0x70
    fastbin_size &= ~0xf;
    fastbin[0] = (unsigned long *) malloc( fastbin_size );
    fastbin[1] = (unsigned long *) malloc( fastbin_size );
    
    printf("unsigned long *%c = (unsigned long *) malloc(0x%lx);\n", &#39;X&#39;, fastbin_size);
    printf("unsigned long *%c = (unsigned long *) malloc(0x%lx);\n", &#39;Y&#39;, fastbin_size);

    secret_idx = rand() % (fastbin_size / 8);
    fastbin[1][ secret_idx ] = 0xdeadbeef;
    result_idx = ((unsigned long)(&amp;fastbin[1][ secret_idx ]) - (unsigned long)(&amp;fastbin[0][0])) / 8;
    
    printf("Y[%lu] = 0xdeadbeef;\n", secret_idx);
    printf("X[?] == 0xdeadbeef\t(just send an integer, e.g. \"8\")\n> ");
    scanf("%lu", &amp;res);

    if (fastbin[0][res] == 0xdeadbeef) {
        puts("Correct !");
    } else {
        puts("Wrong !");
        printf("Ans: %lu\n", result_idx);
        exit(0);
    }

    puts("\n----------- ** tcache fd chall ** -----------");
    free(fastbin[0]);
    free(fastbin[1]);
    printf("free(X);\nfree(Y);\nassert( Y == %p );\n", fastbin[1]);
    printf("fd of Y == ?\t(send as hex format, e.g. \"%p\")\n> ", fastbin[1]);
    scanf("%s", tmpbuf);
    ans_addr = strtoul(tmpbuf, NULL, 16);

    if (ans_addr == *fastbin[1]) {
        puts("Correct !");
    } else {
        puts("Wrong !");
        printf("Ans: 0x%lx\n", *fastbin[1]);
        exit(0);
    }

    puts("\n----------- ** fastbin fd chall (final) ** -----------");
    puts("[*] Restore the chunk to X and Y");
    printf("%c = (unsigned long *) malloc(0x%lx);\n", &#39;Y&#39;, fastbin_size);
    printf("%c = (unsigned long *) malloc(0x%lx);\n", &#39;X&#39;, fastbin_size);
    fastbin[1] = malloc(fastbin_size);
    fastbin[0] = malloc(fastbin_size);
    printf("[*] Do something to fill up 0x%lx tcache\n...\n[*] finish\n", fastbin_size + 0x10);
    void *tmpchk[7];
    for (int i = 0; i < 7; i++)
        tmpchk[i] = malloc(fastbin_size);
    for (int i = 0; i < 7; i++)
        free(tmpchk[i]);
    printf("free(X);\nfree(Y);\nassert( Y == %p );\n", fastbin[1]);
    free(fastbin[0]);
    free(fastbin[1]);
    printf("fd of Y == ?\t(send as hex format, e.g. \"%p\")\n> ", fastbin[1]);
    scanf("%s", tmpbuf);
    ans_addr = strtoul(tmpbuf, NULL, 16);

    if (ans_addr == *fastbin[1]) {
        puts("Correct !");
        memset(tmpbuf, 0, 0x31);
        
        int fd = open("/home/heapmath/flag", O_RDONLY);
        read(fd, tmpbuf, 0x30);
        close(fd);
        printf("Here is your flag: %s\n", tmpbuf);
    } else {
        puts("Wrong !");
        printf("Ans: 0x%lx\n", *fastbin[1]);
        exit(0);
    }
}
:::'><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#343a40"><meta name=color-scheme content="light dark"><meta property="og:url" content="https://bernie6401.github.io/security/course/ntu-cs/pwn/simple-pwn---0x15lab---heapmath/"><meta property="og:site_name" content="SBK Hugo Site"><meta property="og:title" content="Simple PWN - 0x15(Lab - `heapmath`)"><meta property="og:description" content='Simple PWN - 0x15(Lab - heapmath) # tags: CTF PWN eductf # Version: Ubuntu 20.04
Original Code # :::spoiler code
#include <stdio.h> #include <string.h> #include <stdlib.h> #include <unistd.h> #include <fcntl.h> #include <time.h> int main() { setvbuf(stdin, 0, _IONBF, 0); setvbuf(stdout, 0, _IONBF, 0); srand(time(NULL)); void *tcache_chk[7] = {0}; unsigned char tcachebin[3][7] = {0}; // 0x20, 0x30, 0x40 unsigned int tcachebin_counts[4] = {0}; unsigned long tcache_size[7] = {0}; unsigned long tcache_free_order[7] = {0}; puts("----------- ** tcache chall ** -----------"); unsigned long tmp = 0; for (int i = 0; i < 7; i++) { tmp = (rand() % 0x21) + 0x10; // 0x10 ~ 0x30 tcache_size[i] = tmp; } for (int i = 0; i < 7; i++) { repeat: tmp = rand() % 7; for (int j = 0; j < i; j++) if (tmp == tcache_free_order[j]) goto repeat; tcache_free_order[i] = tmp; } for (int i = 0; i < 7; i++) { tcache_chk[i] = malloc( tcache_size[i] ); printf("char *%c = (char *) malloc(0x%lx);\n", &#39;A&#39; + i, tcache_size[i]); } for (int i = 0; i < 7; i++) { int idx = tcache_free_order[i]; free(tcache_chk[ idx ]); printf("free(%c);\n", &#39;A&#39; + (unsigned char) idx); tmp = tcache_size[ idx ] - 0x8; if (tmp % 0x10) tmp = (tmp & ~0xf) + 0x20; else tmp += 0x10; unsigned int binidx = ((tmp - 0x20) / 0x10); unsigned int bincnt = tcachebin_counts[ binidx ]; tcachebin[ binidx ][ bincnt ] = &#39;A&#39; + (unsigned char) idx; tcachebin_counts[ binidx ]++; } char tmpbuf[0x100] = {0}; char ansbuf[3][0x100] = {0}; for (int i = 0; i < 3; i++) { for (int j = 6; j >= 0; j--) if (tcachebin[i][j]) { sprintf(tmpbuf, "%c --> ", tcachebin[i][j]); strcat(ansbuf[i], tmpbuf); } strcat(ansbuf[i], "NULL"); } puts(""); for (int i = 0; i < 3; i++) { printf("[chunk size] 0x%x: ", (i+2) * 0x10); if (i == 0) { printf("%s\t(just send \"%s\")\n", ansbuf[i], ansbuf[i]); } else { printf("?\n> "); fgets(tmpbuf, 0x100, stdin); if (!strncmp(tmpbuf, ansbuf[i], strlen(ansbuf[i]))) { puts("Correct !"); } else { puts("Wrong !"); printf("Ans: \"%s\"\n", ansbuf[i]); exit(0); } } } puts("\n----------- ** address chall ** -----------"); int cmp1 = 0; int cmp2 = 0; unsigned long ans_addr = 0; cmp1 = rand() % 7; while ((cmp2 = rand() % 7) == cmp1); if (cmp1 > cmp2) { tmp = cmp1; cmp1 = cmp2; cmp2 = tmp; } printf("assert( %c == %p );\n", &#39;A&#39; + cmp1, tcache_chk[ cmp1 ]); printf("%c == ?\t(send as hex format, e.g. \"%p\")\n> ", &#39;A&#39; + cmp2, tcache_chk[ cmp1 ]); scanf("%s", tmpbuf); ans_addr = strtoul(tmpbuf, NULL, 16); if (ans_addr == (unsigned long) tcache_chk[ cmp2 ]) { puts("Correct !"); } else { puts("Wrong !"); printf("Ans: %p\n", tcache_chk[ cmp2 ]); exit(0); } puts("\n----------- ** index chall ** -----------"); unsigned long *fastbin[2] = {0}; unsigned long fastbin_size = 0; unsigned long secret_idx = 0, result_idx = 0, res = 0; fastbin_size = (rand() % 0x31) + 0x40; // 0x40 ~ 0x70 fastbin_size &= ~0xf; fastbin[0] = (unsigned long *) malloc( fastbin_size ); fastbin[1] = (unsigned long *) malloc( fastbin_size ); printf("unsigned long *%c = (unsigned long *) malloc(0x%lx);\n", &#39;X&#39;, fastbin_size); printf("unsigned long *%c = (unsigned long *) malloc(0x%lx);\n", &#39;Y&#39;, fastbin_size); secret_idx = rand() % (fastbin_size / 8); fastbin[1][ secret_idx ] = 0xdeadbeef; result_idx = ((unsigned long)(&amp;fastbin[1][ secret_idx ]) - (unsigned long)(&amp;fastbin[0][0])) / 8; printf("Y[%lu] = 0xdeadbeef;\n", secret_idx); printf("X[?] == 0xdeadbeef\t(just send an integer, e.g. \"8\")\n> "); scanf("%lu", &amp;res); if (fastbin[0][res] == 0xdeadbeef) { puts("Correct !"); } else { puts("Wrong !"); printf("Ans: %lu\n", result_idx); exit(0); } puts("\n----------- ** tcache fd chall ** -----------"); free(fastbin[0]); free(fastbin[1]); printf("free(X);\nfree(Y);\nassert( Y == %p );\n", fastbin[1]); printf("fd of Y == ?\t(send as hex format, e.g. \"%p\")\n> ", fastbin[1]); scanf("%s", tmpbuf); ans_addr = strtoul(tmpbuf, NULL, 16); if (ans_addr == *fastbin[1]) { puts("Correct !"); } else { puts("Wrong !"); printf("Ans: 0x%lx\n", *fastbin[1]); exit(0); } puts("\n----------- ** fastbin fd chall (final) ** -----------"); puts("[*] Restore the chunk to X and Y"); printf("%c = (unsigned long *) malloc(0x%lx);\n", &#39;Y&#39;, fastbin_size); printf("%c = (unsigned long *) malloc(0x%lx);\n", &#39;X&#39;, fastbin_size); fastbin[1] = malloc(fastbin_size); fastbin[0] = malloc(fastbin_size); printf("[*] Do something to fill up 0x%lx tcache\n...\n[*] finish\n", fastbin_size + 0x10); void *tmpchk[7]; for (int i = 0; i < 7; i++) tmpchk[i] = malloc(fastbin_size); for (int i = 0; i < 7; i++) free(tmpchk[i]); printf("free(X);\nfree(Y);\nassert( Y == %p );\n", fastbin[1]); free(fastbin[0]); free(fastbin[1]); printf("fd of Y == ?\t(send as hex format, e.g. \"%p\")\n> ", fastbin[1]); scanf("%s", tmpbuf); ans_addr = strtoul(tmpbuf, NULL, 16); if (ans_addr == *fastbin[1]) { puts("Correct !"); memset(tmpbuf, 0, 0x31); int fd = open("/home/heapmath/flag", O_RDONLY); read(fd, tmpbuf, 0x30); close(fd); printf("Here is your flag: %s\n", tmpbuf); } else { puts("Wrong !"); printf("Ans: 0x%lx\n", *fastbin[1]); exit(0); } } :::'><meta property="og:locale" content="en_us"><meta property="og:type" content="article"><meta property="article:section" content="security"><meta property="article:tag" content="CTF"><meta property="article:tag" content="PWN"><meta property="article:tag" content="Eductf"><title>Simple PWN - 0x15(Lab - `heapmath`) | SBK Hugo Site</title>
<link rel=icon href=/favicon.png><link rel=manifest href=/manifest.json><link rel=canonical href=https://bernie6401.github.io/security/course/ntu-cs/pwn/simple-pwn---0x15lab---heapmath/><link rel=stylesheet href=/book.min.6c8b9d2a1fc95075ed7da46ca81060b39add8fff6741ac51259f768929281e2c.css integrity="sha256-bIudKh/JUHXtfaRsqBBgs5rdj/9nQaxRJZ92iSkoHiw=" crossorigin=anonymous><script defer src=/fuse.min.js></script><script defer src=/en.search.min.acdc41c8d39e6c69d70d8a23779875e0a3733fefead3e428d5344966bb12f562.js integrity="sha256-rNxByNOebGnXDYojd5h14KNzP+/q0+Qo1TRJZrsS9WI=" crossorigin=anonymous></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/><span>SBK Hugo Site</span></a></h2><div class="book-search hidden"><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><script>document.querySelector(".book-search").classList.remove("hidden")</script></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu></label><h3>Simple PWN - 0x15(Lab - `heapmath`)</h3><label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><ul><li></li></ul></li><li><a href=#original-code>Original Code</a></li><li><a href=#questions>Questions</a></li><li><a href=#reference>Reference</a></li></ul></nav></aside></header><article class="markdown book-article"><h1 id=simple-pwn---0x15lab---heapmath>Simple PWN - 0x15(Lab - <code>heapmath</code>)
<a class=anchor href=#simple-pwn---0x15lab---heapmath>#</a></h1><h6 id=tags-ctf-pwn-eductf>tags: <code>CTF</code> <code>PWN</code> <code>eductf</code>
<a class=anchor href=#tags-ctf-pwn-eductf>#</a></h6><p>Version: Ubuntu 20.04</p><h2 id=original-code>Original Code
<a class=anchor href=#original-code>#</a></h2><p>:::spoiler code</p><pre tabindex=0><code class="language-cpp!=" data-lang="cpp!=">#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;time.h&gt;

int main()
{
    setvbuf(stdin, 0, _IONBF, 0);
    setvbuf(stdout, 0, _IONBF, 0);
    srand(time(NULL));

    void *tcache_chk[7]                = {0};
    unsigned char tcachebin[3][7]      = {0}; // 0x20, 0x30, 0x40
    unsigned int tcachebin_counts[4]   = {0};
    unsigned long tcache_size[7]       = {0};
    unsigned long tcache_free_order[7] = {0};

    puts(&#34;----------- ** tcache chall ** -----------&#34;);
    unsigned long tmp = 0;
    for (int i = 0; i &lt; 7; i++) {
        tmp = (rand() % 0x21) + 0x10; // 0x10 ~ 0x30
        tcache_size[i] = tmp;
    }

    for (int i = 0; i &lt; 7; i++) {
    repeat:
        tmp = rand() % 7;
        for (int j = 0; j &lt; i; j++)
            if (tmp == tcache_free_order[j]) goto repeat;
        tcache_free_order[i] = tmp;
    }

    for (int i = 0; i &lt; 7; i++) {
        tcache_chk[i] = malloc( tcache_size[i] );
        printf(&#34;char *%c = (char *) malloc(0x%lx);\n&#34;, &#39;A&#39; + i, tcache_size[i]);
    }

    for (int i = 0; i &lt; 7; i++) {
        int idx = tcache_free_order[i];
        free(tcache_chk[ idx ]);
        printf(&#34;free(%c);\n&#34;, &#39;A&#39; + (unsigned char) idx);

        tmp = tcache_size[ idx ] - 0x8;
        if (tmp % 0x10)
            tmp = (tmp &amp; ~0xf) + 0x20;
        else
            tmp += 0x10;

        unsigned int binidx = ((tmp - 0x20) / 0x10);
        unsigned int bincnt = tcachebin_counts[ binidx ];
        tcachebin[ binidx ][ bincnt ] = &#39;A&#39; + (unsigned char) idx;
        tcachebin_counts[ binidx ]++;
    }

    char tmpbuf[0x100]   = {0};
    char ansbuf[3][0x100] = {0};
    for (int i = 0; i &lt; 3; i++) {
        for (int j = 6; j &gt;= 0; j--)
            if (tcachebin[i][j]) {
                sprintf(tmpbuf, &#34;%c --&gt; &#34;, tcachebin[i][j]);
                strcat(ansbuf[i], tmpbuf);
            }
        strcat(ansbuf[i], &#34;NULL&#34;);
    }
    puts(&#34;&#34;);
    for (int i = 0; i &lt; 3; i++) {
        printf(&#34;[chunk size] 0x%x: &#34;, (i+2) * 0x10);
        if (i == 0) {
            printf(&#34;%s\t(just send \&#34;%s\&#34;)\n&#34;, ansbuf[i], ansbuf[i]);
        } else {
            printf(&#34;?\n&gt; &#34;);
            fgets(tmpbuf, 0x100, stdin);
            if (!strncmp(tmpbuf, ansbuf[i], strlen(ansbuf[i]))) {
                puts(&#34;Correct !&#34;);
            } else {
                puts(&#34;Wrong !&#34;);
                printf(&#34;Ans: \&#34;%s\&#34;\n&#34;, ansbuf[i]);
                exit(0);
            }
        }
    }

    puts(&#34;\n----------- ** address chall ** -----------&#34;);
    int cmp1 = 0;
    int cmp2 = 0;
    unsigned long ans_addr = 0;

    cmp1 = rand() % 7;
    while ((cmp2 = rand() % 7) == cmp1);
    if (cmp1 &gt; cmp2) {
        tmp = cmp1;
        cmp1 = cmp2;
        cmp2 = tmp;
    }

    printf(&#34;assert( %c == %p );\n&#34;, &#39;A&#39; + cmp1, tcache_chk[ cmp1 ]);
    printf(&#34;%c == ?\t(send as hex format, e.g. \&#34;%p\&#34;)\n&gt; &#34;,
                &#39;A&#39; + cmp2, tcache_chk[ cmp1 ]);
    scanf(&#34;%s&#34;, tmpbuf);
    ans_addr = strtoul(tmpbuf, NULL, 16);

    if (ans_addr == (unsigned long) tcache_chk[ cmp2 ]) {
        puts(&#34;Correct !&#34;);
    } else {
        puts(&#34;Wrong !&#34;);
        printf(&#34;Ans: %p\n&#34;, tcache_chk[ cmp2 ]);
        exit(0);
    }

    puts(&#34;\n----------- ** index chall ** -----------&#34;);
    unsigned long *fastbin[2] = {0};
    unsigned long fastbin_size = 0;
    unsigned long secret_idx = 0, result_idx = 0, res = 0;

    fastbin_size = (rand() % 0x31) + 0x40; // 0x40 ~ 0x70
    fastbin_size &amp;= ~0xf;
    fastbin[0] = (unsigned long *) malloc( fastbin_size );
    fastbin[1] = (unsigned long *) malloc( fastbin_size );
    
    printf(&#34;unsigned long *%c = (unsigned long *) malloc(0x%lx);\n&#34;, &#39;X&#39;, fastbin_size);
    printf(&#34;unsigned long *%c = (unsigned long *) malloc(0x%lx);\n&#34;, &#39;Y&#39;, fastbin_size);

    secret_idx = rand() % (fastbin_size / 8);
    fastbin[1][ secret_idx ] = 0xdeadbeef;
    result_idx = ((unsigned long)(&amp;fastbin[1][ secret_idx ]) - (unsigned long)(&amp;fastbin[0][0])) / 8;
    
    printf(&#34;Y[%lu] = 0xdeadbeef;\n&#34;, secret_idx);
    printf(&#34;X[?] == 0xdeadbeef\t(just send an integer, e.g. \&#34;8\&#34;)\n&gt; &#34;);
    scanf(&#34;%lu&#34;, &amp;res);

    if (fastbin[0][res] == 0xdeadbeef) {
        puts(&#34;Correct !&#34;);
    } else {
        puts(&#34;Wrong !&#34;);
        printf(&#34;Ans: %lu\n&#34;, result_idx);
        exit(0);
    }

    puts(&#34;\n----------- ** tcache fd chall ** -----------&#34;);
    free(fastbin[0]);
    free(fastbin[1]);
    printf(&#34;free(X);\nfree(Y);\nassert( Y == %p );\n&#34;, fastbin[1]);
    printf(&#34;fd of Y == ?\t(send as hex format, e.g. \&#34;%p\&#34;)\n&gt; &#34;, fastbin[1]);
    scanf(&#34;%s&#34;, tmpbuf);
    ans_addr = strtoul(tmpbuf, NULL, 16);

    if (ans_addr == *fastbin[1]) {
        puts(&#34;Correct !&#34;);
    } else {
        puts(&#34;Wrong !&#34;);
        printf(&#34;Ans: 0x%lx\n&#34;, *fastbin[1]);
        exit(0);
    }

    puts(&#34;\n----------- ** fastbin fd chall (final) ** -----------&#34;);
    puts(&#34;[*] Restore the chunk to X and Y&#34;);
    printf(&#34;%c = (unsigned long *) malloc(0x%lx);\n&#34;, &#39;Y&#39;, fastbin_size);
    printf(&#34;%c = (unsigned long *) malloc(0x%lx);\n&#34;, &#39;X&#39;, fastbin_size);
    fastbin[1] = malloc(fastbin_size);
    fastbin[0] = malloc(fastbin_size);
    printf(&#34;[*] Do something to fill up 0x%lx tcache\n...\n[*] finish\n&#34;, fastbin_size + 0x10);
    void *tmpchk[7];
    for (int i = 0; i &lt; 7; i++)
        tmpchk[i] = malloc(fastbin_size);
    for (int i = 0; i &lt; 7; i++)
        free(tmpchk[i]);
    printf(&#34;free(X);\nfree(Y);\nassert( Y == %p );\n&#34;, fastbin[1]);
    free(fastbin[0]);
    free(fastbin[1]);
    printf(&#34;fd of Y == ?\t(send as hex format, e.g. \&#34;%p\&#34;)\n&gt; &#34;, fastbin[1]);
    scanf(&#34;%s&#34;, tmpbuf);
    ans_addr = strtoul(tmpbuf, NULL, 16);

    if (ans_addr == *fastbin[1]) {
        puts(&#34;Correct !&#34;);
        memset(tmpbuf, 0, 0x31);
        
        int fd = open(&#34;/home/heapmath/flag&#34;, O_RDONLY);
        read(fd, tmpbuf, 0x30);
        close(fd);
        printf(&#34;Here is your flag: %s\n&#34;, tmpbuf);
    } else {
        puts(&#34;Wrong !&#34;);
        printf(&#34;Ans: 0x%lx\n&#34;, *fastbin[1]);
        exit(0);
    }
}
</code></pre><p>:::</p><ul><li>It&rsquo;s a test of <code>tcache and fastbin</code> background, therefore, just execute it directly!!!</li></ul><h2 id=questions>Questions
<a class=anchor href=#questions>#</a></h2><ol><li><pre tabindex=0><code class=language-bash! data-lang=bash!>----------- ** tcache chall ** -----------
char *A = (char *) malloc(0x12);
char *B = (char *) malloc(0x30);
char *C = (char *) malloc(0x13);
char *D = (char *) malloc(0x23);
char *E = (char *) malloc(0x20);
char *F = (char *) malloc(0x28);
char *G = (char *) malloc(0x13);
free(B);
free(A);
free(F);
free(C);
free(D);
free(G);
free(E);

[chunk size] 0x20: G --&gt; C --&gt; A --&gt; NULL       (just send &#34;G --&gt; C --&gt; A --&gt; NULL&#34;)
[chunk size] 0x30: ?
[chunk size] 0x40: ?
</code></pre><p>Sol.
First, try to compute every char malloc size
A → $align(0x12 - 0x8 + 0x10) = 0x20$
B → $align(0x30 - 0x8 + 0x10) = 0x40$
C → $align(0x13 - 0x8 + 0x10) = 0x20$
D → $align(0x23 - 0x8 + 0x10) = 0x30$
E → $align(0x20 - 0x8 + 0x10) = 0x30$
F → $align(0x28 - 0x8 + 0x10) = 0x30$
G → $align(0x13 - 0x8 + 0x10) = 0x20$</p><p>Then, the sequence of the free char is B→A→F→C→D→G→E, according to FILO ruls(stack)
<img src=https://imgur.com/TZhy6b9.png alt>
<font color=FF0000>The sequence of 0x30: E &ndash;> D &ndash;> F &ndash;> NULL
The sequence of 0x30: B &ndash;> NULL</font></p></li><li><pre tabindex=0><code class=language-bash! data-lang=bash!>----------- ** address chall ** -----------
assert( A == 0x563d3e2b72a0 );
F == ?  (send as hex format, e.g. &#34;0x563d3e2b72a0&#34;)
</code></pre><p>Sol. Just accumulate the size
A == 0x563d3e2b72a0
B == A + 0x20 == 0x563d3e2b72c0
C == B + 0x40 == 0x563d3e2b7300
D == C + 0x20 == 0x563d3e2b7320
E == D + 0x30 == 0x563d3e2b7350
<font color=FF0000>F == E + 0x30 == 0x563d3e2b7380</font>
G == F + 0x30 == 0x563d3e2b73b0</p></li><li><pre tabindex=0><code class=language-bash! data-lang=bash!>----------- ** index chall ** -----------
unsigned long *X = (unsigned long *) malloc(0x60);
unsigned long *Y = (unsigned long *) malloc(0x60);
Y[8] = 0xdeadbeef;
X[?] == 0xdeadbeef      (just send an integer, e.g. &#34;8&#34;)
</code></pre><p>Sol.
<code>X</code> has $align(0x60 - 0x8 + 0x10) = 0x70$ size of malloc address
<code>Y</code> has $align(0x60 - 0x8 + 0x10) = 0x70$ size of malloc address
In addition these two memory are connected together
Thus, <code>X</code> has <code>7*2=14</code> 8 bytes and <code>0xdeadbeef</code> is at the 4th position of Y
Therefore, the answer is <font color=FF0000>$14+8=22$</font>
<img src=https://imgur.com/H2gp0r4.png alt></p></li><li><pre tabindex=0><code class=language-bash! data-lang=bash!>----------- ** tcache fd chall ** -----------
free(X);
free(Y);
assert( Y == 0x563d3e2b7440 );
fd of Y == ?    (send as hex format, e.g. &#34;0x563d3e2b7440&#34;)
</code></pre><p>Sol. Just minus the size of Y
From the last question, we can know that the memory space of <code>X</code> and <code>Y</code> are connected together, in addition, the <code>fd</code> of <code>Y</code> point to <code>X's</code> data section
<img src=https://imgur.com/AGYaISV.png alt>
Thus, the answer is <font color=FF0000>$0x563d3e2b7440 - 0x10 - 0x60 = 0x563d3e2b73d0$</font></p></li><li><pre tabindex=0><code class=language-bash! data-lang=bash!>----------- ** fastbin fd chall (final) ** -----------
[*] Restore the chunk to X and Y
Y = (unsigned long *) malloc(0x60);
X = (unsigned long *) malloc(0x60);
[*] Do something to fill up 0x70 tcache
...
[*] finish
free(X);
free(Y);
assert( Y == 0x563d3e2b7440 );
fd of Y == ?    (send as hex format, e.g. &#34;0x563d3e2b7440&#34;)
</code></pre><p>Sol. When <code>tcache</code> is full, the free chunk will be put into other bin, such as <code>fastbin</code>.
According to the lecture description of <code>fastbin</code> structure, the answer is
<font color=FF0000>$0x563d3e2b7440 - 0x10 - 0x70 = 0x563d3e2b73c0$</font>
<img src=https://imgur.com/nykXyGP.png alt></p><p><img src=https://imgur.com/DfWnXT0.png alt></p></li></ol><h2 id=reference>Reference
<a class=anchor href=#reference>#</a></h2><p><a href=https://youtu.be/00IkLtMWGWA>SS111-Pwn2</a></p></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><ul><li></li></ul></li><li><a href=#original-code>Original Code</a></li><li><a href=#questions>Questions</a></li><li><a href=#reference>Reference</a></li></ul></nav></div></aside></main></body></html>