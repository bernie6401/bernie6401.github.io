<!doctype html><html lang=en-us dir=ltr><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="
  Simple Crypto 0x11(2023 HW - invalid_curve_attack)
  #


  Background
  #

pekobot - maple

這邊我會嘗試用簡單的講法把這個攻擊簡述一遍，詳細還是建議 Crypton 或是其他地方的說明。
Invalid Curve Attack 大致上來說利用的是當一個不在原本曲線 $E$ 上的 $P$ 進行 scalar multiplication 的一些特性，使用類似 Pohlig–Hellman algorithm 的辦法在不同的 subgroup 解 DLP 然後用 CRT 解回原本的 private key。
一個 Short Weierstrass curve 長這樣:
$$
y^2 = x^3 + ax + b
$$
而它的 point doubling formula ($R=2P$) 是:
$$
\begin{aligned}
s &= \frac{3x_P^2+a}{2y_P} \
x_R &= s^2 - 2x_P \
y_R &= y_P + s(x_R - x_P)
\end{aligned}
$$"><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#343a40"><meta name=color-scheme content="light dark"><meta property="og:url" content="https://bernie6401.github.io/security/course/ntu-cs/crypto/simple-crypto-0x112023-hw---invalid_curve_attack/"><meta property="og:site_name" content="SBK Hugo Site"><meta property="og:title" content="Simple Crypto 0x11(2023 HW - invalid_curve_attack)"><meta property="og:description" content="Simple Crypto 0x11(2023 HW - invalid_curve_attack) # Background # pekobot - maple
這邊我會嘗試用簡單的講法把這個攻擊簡述一遍，詳細還是建議 Crypton 或是其他地方的說明。
Invalid Curve Attack 大致上來說利用的是當一個不在原本曲線 $E$ 上的 $P$ 進行 scalar multiplication 的一些特性，使用類似 Pohlig–Hellman algorithm 的辦法在不同的 subgroup 解 DLP 然後用 CRT 解回原本的 private key。
一個 Short Weierstrass curve 長這樣:
$$ y^2 = x^3 + ax + b $$
而它的 point doubling formula ($R=2P$) 是:
$$ \begin{aligned} s &= \frac{3x_P^2+a}{2y_P} \ x_R &= s^2 - 2x_P \ y_R &= y_P + s(x_R - x_P) \end{aligned} $$"><meta property="og:locale" content="en_us"><meta property="og:type" content="article"><meta property="article:section" content="security"><meta property="article:tag" content="CTF"><meta property="article:tag" content="Crypto"><meta property="article:tag" content="Eductf"><title>Simple Crypto 0x11(2023 HW - invalid_curve_attack) | SBK Hugo Site</title>
<link rel=icon href=/favicon.png><link rel=manifest href=/manifest.json><link rel=canonical href=https://bernie6401.github.io/security/course/ntu-cs/crypto/simple-crypto-0x112023-hw---invalid_curve_attack/><link rel=stylesheet href=/book.min.6c8b9d2a1fc95075ed7da46ca81060b39add8fff6741ac51259f768929281e2c.css integrity="sha256-bIudKh/JUHXtfaRsqBBgs5rdj/9nQaxRJZ92iSkoHiw=" crossorigin=anonymous><script defer src=/fuse.min.js></script><script defer src=/en.search.min.acdc41c8d39e6c69d70d8a23779875e0a3733fefead3e428d5344966bb12f562.js integrity="sha256-rNxByNOebGnXDYojd5h14KNzP+/q0+Qo1TRJZrsS9WI=" crossorigin=anonymous></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/><span>SBK Hugo Site</span></a></h2><div class="book-search hidden"><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><script>document.querySelector(".book-search").classList.remove("hidden")</script></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu></label><h3>Simple Crypto 0x11(2023 HW - invalid_curve_attack)</h3><label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#background>Background</a></li><li><a href=#source-code>Source code</a></li><li><a href=#recon>Recon</a></li><li><a href=#exploit>Exploit</a></li><li><a href=#reference>Reference</a></li></ul></nav></aside></header><article class="markdown book-article"><h1 id=simple-crypto-0x112023-hw---invalid_curve_attack>Simple Crypto 0x11(2023 HW - invalid_curve_attack)
<a class=anchor href=#simple-crypto-0x112023-hw---invalid_curve_attack>#</a></h1><h2 id=background>Background
<a class=anchor href=#background>#</a></h2><p><a href=https://github.com/maple3142/My-CTF-Challenges/blob/7d9141ac7b61fdbb71f29c07d489018d7c0a0aaa/AIS3%20Pre-exam%202022/pekobot/README.md>pekobot - maple</a></p><blockquote><p>這邊我會嘗試用簡單的講法把這個攻擊簡述一遍，詳細還是建議 <a href=https://github.com/ashutosh1206/Crypton/blob/master/Diffie-Hellman-Key-Exchange/Attack-Invalid-Curve-Point/README.md>Crypton</a> 或是其他地方的說明。</p><p>Invalid Curve Attack 大致上來說利用的是當一個不在原本曲線 $E$ 上的 $P$ 進行 scalar multiplication 的一些特性，使用類似 <a href=https://en.wikipedia.org/wiki/Pohlig%E2%80%93Hellman_algorithm>Pohlig–Hellman algorithm</a> 的辦法在不同的 subgroup 解 <a href=https://en.wikipedia.org/wiki/Discrete_logarithm>DLP</a> 然後用 <a href=https://en.wikipedia.org/wiki/Chinese_remainder_theorem>CRT</a> 解回原本的 private key。</p><p>一個 Short Weierstrass curve 長這樣:</p><p>$$
y^2 = x^3 + ax + b
$$</p><p>而它的 point doubling formula ($R=2P$) 是:</p><p>$$
\begin{aligned}
s &= \frac{3x_P^2+a}{2y_P} \
x_R &= s^2 - 2x_P \
y_R &= y_P + s(x_R - x_P)
\end{aligned}
$$</p><p>由此可見一個 Short Weierstrass curve 在做 scalar multiplication 時並沒有使用到 $b$，
因此對一個 $P \notin E$ 的點做 scalar multiplication 相當於在另一個 $b&rsquo; \neq b$ 的 $E&rsquo;: y^2 = x^3 + ax + b&rsquo;$ 上運算。</p><p>這會帶來的問題是 $E&rsquo;$ 通常和特別選過的 $E$ 不同，它的 curve order $#(E&rsquo;)=n$ 分解後不一定都有個 large prime order subgroup 存在。當 $E&rsquo;$ 上存在一個 order 為 $f$ 的 small subgroup 時，我們可以將原本 $Q=dP$ 的問題轉換成 $(n/f)Q=d((n/f)P)$，然後就能在短時間內解出 $d \bmod{f}$ 的值。</p><p>所以只要有多個夠小的 $f_1, f_2, f_3, \cdots$，利用上面的方法找出 $d_i \equiv d \pmod{f_i}$，然後利用 CRT 就能算出 $d \bmod{\prod_{i=1}^{b} f_i}$ 的結果。因此要得到真正的 $d$ 就得找出足夠多的 $f_i$ 使得 $\prod_{i=1}^{b} f_i > n > d$ 才行。</p><p>當然，一個 $E&rsquo;$ 通常不會提供這麼多的 $f_i$ 能達成這個條件，所以會有多個 $E&rsquo;, E&rsquo;&rsquo;, E&rsquo;&rsquo;&rsquo;, \cdots$ 分別提供不同的 $f_i$，然後用一樣的方法在 subgroup 中解 DLP，最後應用 CRT 即可求出需要的 $d$。</p><p>這題原先的曲線 $E$ 是 NIST P-256，所以我先將 $a$ 固定，然後暴力搜尋其他不同的 $b&rsquo;$ 得到 $E&rsquo;$，把夠小的 $f_i$ 紀錄下來。這部分可以參考 <a href=https://github.com/maple3142/My-CTF-Challenges/blob/7d9141ac7b61fdbb71f29c07d489018d7c0a0aaa/AIS3%20Pre-exam%202022/pekobot/find_curves.sage>find_curves.sage</a>。</p><p>為了減少之後的計算量，我把 $b&rsquo;$, $E&rsquo;$ 上的 generator $G&rsquo;$, $#(E&rsquo;)$ 還有 $f_i$ 都記錄了下來</p><p>剩下就是利用這些預先計算好的參數，將各個 $E&rsquo;$ 的 $G&rsquo;$ 當作 public key $P$ 傳給 oracle，然後得到 $Q=dP$，然後用前面的方法得到 $d \equiv d \pmod{f_i}$ 的值，最後使用 CRT 求回 $d$ 即可。</p></blockquote><h2 id=source-code>Source code
<a class=anchor href=#source-code>#</a></h2><p>:::spoiler Server</p><pre tabindex=0><code class="language-python=" data-lang="python=">from sage.all import *
from elliptic_curve_97cadb52fbd7b2cd import Curve, Point
from Crypto.Util.number import bytes_to_long
from secret import FLAG

# NIST P-256
p = 0xffffffff00000001000000000000000000000000ffffffffffffffffffffffff
a = 0xffffffff00000001000000000000000000000000fffffffffffffffffffffffc
b = 0x5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b
n = 0xffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632551

print(&#34;Give me a G and I will give you the hint.&#34;)
E = Curve(p, a, b)
Gx = int(input(&#34;Gx: &#34;))
Gy = int(input(&#34;Gy: &#34;))
G = Point(E, Gx, Gy)
hint = G * bytes_to_long(FLAG)
print(hint)
</code></pre><p>:::</p><p>:::spoiler Self-Defined Elliptic Curve</p><pre tabindex=0><code class="language-python=" data-lang="python="># Reference: https://github.com/maple3142/My-CTF-Challenges/blob/7d9141ac7b61fdbb71f29c07d489018d7c0a0aaa/AIS3%20Pre-exam%202022/pekobot/README.md
class Curve:
    def __init__(self, p, a, b):
        self.p = p
        self.a = a
        self.b = b

    def __eq__(self, other):
        if isinstance(other, Curve):
            return self.p == other.p and self.a == other.a and self.b == other.b
        return None

    def __str__(self):
        return &#34;y^2 = x^3 + %dx + %d over F_%d&#34; % (self.a, self.b, self.p)


class Point:
    def __init__(self, curve, x, y):
        if curve == None:
            self.curve = self.x = self.y = None
            return
        self.curve = curve
        self.x = x % curve.p
        self.y = y % curve.p

    def __str__(self):
        if self == INFINITY:
            return &#34;INF&#34;
        return &#34;(%d, %d)&#34; % (self.x, self.y)

    def __eq__(self, other):
        if isinstance(other, Point):
            return self.curve == other.curve and self.x == other.x and self.y == other.y
        return None

    def __add__(self, other):
        if not isinstance(other, Point):
            return None
        if other == INFINITY:
            return self
        if self == INFINITY:
            return other
        p = self.curve.p
        if self.x == other.x:
            if (self.y + other.y) % p == 0:
                return INFINITY
            else:
                return self.double()
        p = self.curve.p
        l = ((other.y - self.y) * pow(other.x - self.x, -1, p)) % p
        x3 = (l * l - self.x - other.x) % p
        y3 = (l * (self.x - x3) - self.y) % p
        return Point(self.curve, x3, y3)

    def __neg__(self):
        return Point(self.curve, self.x, self.curve.p - self.y)

    def __mul__(self, e):
        if e == 0:
            return INFINITY
        if self == INFINITY:
            return INFINITY
        if e &lt; 0:
            return (-self) * (-e)
        ret = self * (e // 2)
        ret = ret.double()
        if e % 2 == 1:
            ret = ret + self
        return ret

    def __rmul__(self, other):
        return self * other

    def double(self):
        if self == INFINITY:
            return INFINITY
        p = self.curve.p
        a = self.curve.a
        l = ((3 * self.x * self.x + a) * pow(2 * self.y, -1, p)) % p
        x3 = (l * l - 2 * self.x) % p
        y3 = (l * (self.x - x3) - self.y) % p
        return Point(self.curve, x3, y3)


INFINITY = Point(None, None, None)
</code></pre><p>:::</p><h2 id=recon>Recon
<a class=anchor href=#recon>#</a></h2><ol><li><p>觀察source code會發現maple實作了一個沒有檢查我們傳送的點是否在一開始創的橢圓曲線上的elliptiv curve class，然後他把我們給的point當作參數，創立一個初始點，可以看一下下面裡個範例，如果是maple的實作，給予一個根本不在該Elliptic Curve的點他還是會算一個G+G的點給你，只是該點其實是在別的曲線上的2G這個點，反觀正常的sage中的實作會發現只要給予的點不在該曲線上就會直接報錯
<img src=https://hackmd.io/_uploads/H15TTzBZa.png alt>
:::spoiler maple 實作的Elliptic Curve</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>&gt;&gt;&gt;</span> <span style=color:#f92672>from</span> elliptic_curve_97cadb52fbd7b2cd <span style=color:#f92672>import</span> Curve, Point
</span></span><span style=display:flex><span><span style=color:#f92672>&gt;&gt;&gt;</span> p<span style=color:#f92672>=</span><span style=color:#ae81ff>23</span>
</span></span><span style=display:flex><span><span style=color:#f92672>&gt;&gt;&gt;</span> a<span style=color:#f92672>=</span><span style=color:#ae81ff>5</span>
</span></span><span style=display:flex><span><span style=color:#f92672>&gt;&gt;&gt;</span> b<span style=color:#f92672>=</span><span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span><span style=color:#f92672>&gt;&gt;&gt;</span> E <span style=color:#f92672>=</span> Curve(p, a, b)
</span></span><span style=display:flex><span><span style=color:#f92672>&gt;&gt;&gt;</span> G <span style=color:#f92672>=</span> Point(E, <span style=color:#ae81ff>4</span>, <span style=color:#ae81ff>4</span>)
</span></span><span style=display:flex><span><span style=color:#f92672>&gt;&gt;&gt;</span> print(G)
</span></span><span style=display:flex><span>(<span style=color:#ae81ff>4</span>, <span style=color:#ae81ff>4</span>)
</span></span><span style=display:flex><span><span style=color:#f92672>&gt;&gt;&gt;</span> print(G<span style=color:#f92672>+</span>G)
</span></span><span style=display:flex><span>(<span style=color:#ae81ff>19</span>, <span style=color:#ae81ff>3</span>)
</span></span><span style=display:flex><span><span style=color:#f92672>&gt;&gt;&gt;</span> fake_G <span style=color:#f92672>=</span> Point(E, <span style=color:#ae81ff>4</span>, <span style=color:#ae81ff>3</span>)
</span></span><span style=display:flex><span><span style=color:#f92672>&gt;&gt;&gt;</span> print(fake_G<span style=color:#f92672>+</span>fake_G)
</span></span><span style=display:flex><span>(<span style=color:#ae81ff>17</span>, <span style=color:#ae81ff>1</span>)
</span></span></code></pre></div><p>:::</p><p>:::spoiler 正常的Elliptic Curve</p><pre tabindex=0><code class=language-python! data-lang=python!>&gt;&gt;&gt; from sage.all import *
&gt;&gt;&gt; p=23
&gt;&gt;&gt; a=5
&gt;&gt;&gt; b=1
&gt;&gt;&gt; E = EllipticCurve(Zmod(p), [a, b])
&gt;&gt;&gt; G = E(4, 4)
&gt;&gt;&gt; print(G)
(4 : 4 : 1)
&gt;&gt;&gt; fake_G = E(4, 3)
Traceback (most recent call last):
  File &#34;sage/structure/category_object.pyx&#34;, line 839, in sage.structure.category_object.CategoryObject.getattr_from_category (build/cythonized/sage/structure/category_object.c:7216)
KeyError: &#39;point_homset&#39;

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File &#34;/home/sbk6401/anaconda3/envs/sageenv/lib/python3.11/site-packages/sage/schemes/projective/projective_subscheme.py&#34;, line 122, in point
    return self._point(self.point_homset(), v, check=check)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File &#34;/home/sbk6401/anaconda3/envs/sageenv/lib/python3.11/site-packages/sage/schemes/elliptic_curves/ell_point.py&#34;, line 259, in __init__
    point_homset = curve.point_homset()
                   ^^^^^^^^^^^^^^^^^^
  File &#34;sage/structure/category_object.pyx&#34;, line 833, in sage.structure.category_object.CategoryObject.__getattr__ (build/cythonized/sage/structure/category_object.c:7135)
  File &#34;sage/structure/category_object.pyx&#34;, line 848, in sage.structure.category_object.CategoryObject.getattr_from_category (build/cythonized/sage/structure/category_object.c:7301)
  File &#34;sage/cpython/getattr.pyx&#34;, line 356, in sage.cpython.getattr.getattr_from_other_class (build/cythonized/sage/cpython/getattr.c:2717)
AttributeError: &#39;IntegerModRing_generic_with_category&#39; object has no attribute &#39;__custom_name&#39;

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File &#34;&lt;stdin&gt;&#34;, line 1, in &lt;module&gt;
  File &#34;/home/sbk6401/anaconda3/envs/sageenv/lib/python3.11/site-packages/sage/schemes/elliptic_curves/ell_generic.py&#34;, line 582, in __call__
    return plane_curve.ProjectivePlaneCurve.__call__(self, *args, **kwds)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File &#34;/home/sbk6401/anaconda3/envs/sageenv/lib/python3.11/site-packages/sage/schemes/generic/scheme.py&#34;, line 266, in __call__
    return self.point(args)
           ^^^^^^^^^^^^^^^^
  File &#34;/home/sbk6401/anaconda3/envs/sageenv/lib/python3.11/site-packages/sage/schemes/projective/projective_subscheme.py&#34;, line 124, in point
    return self._point(self, v, check=check)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File &#34;/home/sbk6401/anaconda3/envs/sageenv/lib/python3.11/site-packages/sage/schemes/elliptic_curves/ell_point.py&#34;, line 298, in __init__
    raise TypeError(&#34;Coordinates %s do not define a point on %s&#34; % (list(v), curve))
TypeError: Coordinates [4, 3, 1] do not define a point on Elliptic Curve defined by y^2 = x^3 + 5*x + 1 over Ring of integers modulo 23
</code></pre><p>:::</p></li><li><p>有了這個性質就可以回去參考一下maple在github上的說明，我們要解決的問題是$hint=G<em>flag$中的flag到底是甚麼，如果是像前面舉例的那樣($p=23/a=5/b=1/order=31$)很小的order，其實只要直接算<code>discrete_log(K, G, operation='+')</code>就可以了，範例如下，可以看到我先定義<code>K = E(19, 3)</code>，算出<code>discete log=28</code>，事後驗證也證明$K=28</em>G$。但是，像題目中這樣這麼大的order，如果要計算discrete_log的話會非常非常久的時間，總之我先往smooth order的方向思考，也就是說order被factor後其實是由好幾個小的prime所組成，我是直接調整$b$這個不會被Elliptic Curve Multiplication運算使用到的參數(代表其他參數$p, a$要照舊)，然後factor曲線的order看夠不夠smooth，但這樣找也一樣要非常非常久，或者說找到的$b$所得到的order都不夠smooth，最大的prime都還是超過$2^{65}$(e.g. 範例如下)</p><pre tabindex=0><code class=language-python! data-lang=python!>&gt;&gt;&gt; G = E.gen(0)
&gt;&gt;&gt; print(G)
(15 : 1 : 1)
&gt;&gt;&gt; K = E(19, 3)
&gt;&gt;&gt; discrete_log(K, G, operation=&#39;+&#39;)
28
&gt;&gt;&gt; 28 * G
(19 : 3 : 1)
</code></pre><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sage data-lang=sage><span style=display:flex><span>sage: p <span style=color:#f92672>=</span> <span style=color:#ae81ff>0xffffffff00000001000000000000000000000000ffffffffffffffffffffffff</span>
</span></span><span style=display:flex><span><span style=color:#f92672>....</span>: a <span style=color:#f92672>=</span> <span style=color:#ae81ff>0xffffffff00000001000000000000000000000000fffffffffffffffffffffffc</span>
</span></span><span style=display:flex><span><span style=color:#f92672>....</span>: b <span style=color:#f92672>=</span> <span style=color:#ae81ff>56</span>
</span></span><span style=display:flex><span>sage: E <span style=color:#f92672>=</span> EllipticCurve(Zmod(p), [a, b])
</span></span><span style=display:flex><span>sage: factor(E<span style=color:#f92672>.</span>order())
</span></span><span style=display:flex><span><span style=color:#ae81ff>3</span><span style=color:#f92672>^</span><span style=color:#ae81ff>3</span> <span style=color:#f92672>*</span> <span style=color:#ae81ff>13967</span> <span style=color:#f92672>*</span> <span style=color:#ae81ff>67679</span> <span style=color:#f92672>*</span> <span style=color:#ae81ff>559243</span> <span style=color:#f92672>*</span> <span style=color:#ae81ff>11024719</span> <span style=color:#f92672>*</span> <span style=color:#ae81ff>127273871</span> <span style=color:#f92672>*</span> <span style=color:#ae81ff>1213196727283</span> <span style=color:#f92672>*</span> <span style=color:#ae81ff>171447020014729</span> <span style=color:#f92672>*</span> <span style=color:#ae81ff>27796463802665410393</span>
</span></span><span style=display:flex><span>sage: <span style=color:#ae81ff>27796463802665410393.</span>bit_length()
</span></span><span style=display:flex><span><span style=color:#ae81ff>65</span>
</span></span></code></pre></div></li><li><p>所以我開始朝maple的說明繼續前進，如果有invalid curve的問題就可以考慮用Pohlig–Hellman algorithm的方法求出flag為多少，就如同maple在background中提到的，我們選擇不同的$b$所產生的Elliptic Curve Order被factor後不一定有一個超大prime存在，因此我們就可以把問題簡化($n$就是改變$b$之後取得的Elliptic Curve Order)
$$
hint=flag*G\
\hookrightarrow {n \over prime}hint=flag&rsquo;\times {n\over prime} G\
flag&rsquo;=discrete_log({n \over prime}hint, {n\over prime} G, operation=&rsquo;+&rsquo;)
$$</p></li><li><p>等我們找到很多個$b$就可以找到很多不同的$flag&rsquo;$，最後我們再用CRT找出真正的$flag$為何就可以了，也就是
$$
flag\equiv flag&rsquo;\ (mod\ prime_1)\
flag\equiv flag&rsquo;&rsquo;\ (mod\ prime_2)\
flag\equiv flag&rsquo;&rsquo;&rsquo;\ (mod\ prime_3)\
&mldr;
$$
所以重點在於要找到足夠多的$flag&rsquo;$和$prime_n$組合</p></li></ol><h2 id=exploit>Exploit
<a class=anchor href=#exploit>#</a></h2><p>實作的部分主要是參考<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup>的幫忙，大致上就和上面提到的差不多</p><pre tabindex=0><code class="language-python=" data-lang="python=">from sage.all import *
from Crypto.Util.number import bytes_to_long, getPrime, long_to_bytes
from pwn import *

# NIST P-256
p = 0xffffffff00000001000000000000000000000000ffffffffffffffffffffffff
a = 0xffffffff00000001000000000000000000000000fffffffffffffffffffffffc

def solveDL():
    b = randint(1, p)
    E = EllipticCurve(Zmod(p), [a, b])
    G = E.gen(0)
    order = E.order()
    # print(order)
    factors = prime_factors(order)
    # print(factors)
    valid = []
    for factor in factors:
        if factor &lt;= 2**40:
            valid.append(factor)
    prime = valid[-1]
    new_G = G * int(order / prime)
    tmp_point = new_G.xy()
    tmp_x, tmp_y = str(tmp_point[0]), str(tmp_point[1])

    try:
        r = remote(&#39;10.113.184.121&#39;, 10034)
        r.recvline()
        r.sendlineafter(b&#39;Gx: &#39;, tmp_x.encode())
        r.sendlineafter(b&#39;Gy: &#39;, tmp_y.encode())
        hint = r.recvline().decode().strip()
        ct_x, ct_y = hint.rstrip(&#39;)&#39;).lstrip(&#39;(&#39;).split(&#39;, &#39;)
        r.close()
    except Exception as e:
        r.close()
        print(e)
        return None, None

    # print(f&#39;Position (ct_x, ct_y) = ({ct_x}, {ct_y})&#39;)
    new_hint = E(int(ct_x), int(ct_y))
    aprt_of_flag = discrete_log(new_hint, new_G, operation=&#39;+&#39;)
    print(f&#34;Flag&#39; found: {aprt_of_flag}&#34;)
    return (aprt_of_flag, prime)
    
def getDLs():
    dlogs = []
    primes = []
    for i in range(1, 16):
        log, prime = solveDL()
        if log != None:
            dlogs.append(log)
            primes.append(prime)
        print(f&#34;counter: {i}&#34;)
    return dlogs, primes

dlogs, primes = getDLs()
print(f&#34;dlogs: {dlogs}&#34;)
print(f&#34;primes: {primes}&#34;)
super_secret = CRT_list(dlogs, primes)
print(f&#39;Flag: {long_to_bytes(super_secret).decode()}&#39;)
</code></pre><p>:::spoiler Result</p><pre tabindex=0><code class=language-bash! data-lang=bash!>$ $ python exp.py
[+] Opening connection to 10.113.184.121 on port 10034: Done
[*] Closed connection to 10.113.184.121 port 10034
Flag&#39; found: 27360610332
counter: 1
[+] Opening connection to 10.113.184.121 on port 10034: Done
[*] Closed connection to 10.113.184.121 port 10034
Flag&#39; found: 1023158172
counter: 2
[+] Opening connection to 10.113.184.121 on port 10034: Done
[*] Closed connection to 10.113.184.121 port 10034
Flag&#39; found: 19279
counter: 3
[+] Opening connection to 10.113.184.121 on port 10034: Done
[*] Closed connection to 10.113.184.121 port 10034
Flag&#39; found: 99180577
counter: 4
[+] Opening connection to 10.113.184.121 on port 10034: Done
[*] Closed connection to 10.113.184.121 port 10034
not enough values to unpack (expected 2, got 1)
counter: 5
[+] Opening connection to 10.113.184.121 on port 10034: Done
[*] Closed connection to 10.113.184.121 port 10034
Flag&#39; found: 1431258
counter: 6
[+] Opening connection to 10.113.184.121 on port 10034: Done
[*] Closed connection to 10.113.184.121 port 10034
Flag&#39; found: 152629534
counter: 7
[+] Opening connection to 10.113.184.121 on port 10034: Done
[*] Closed connection to 10.113.184.121 port 10034
Flag&#39; found: 36835
counter: 8
[+] Opening connection to 10.113.184.121 on port 10034: Done
[*] Closed connection to 10.113.184.121 port 10034
Flag&#39; found: 15673959
counter: 9
[+] Opening connection to 10.113.184.121 on port 10034: Done
[*] Closed connection to 10.113.184.121 port 10034
Flag&#39; found: 301945137539
counter: 10
[+] Opening connection to 10.113.184.121 on port 10034: Done
[*] Closed connection to 10.113.184.121 port 10034
Flag&#39; found: 2906
counter: 11
[+] Opening connection to 10.113.184.121 on port 10034: Done
[*] Closed connection to 10.113.184.121 port 10034
Flag&#39; found: 111332288773
counter: 12
[+] Opening connection to 10.113.184.121 on port 10034: Done
[*] Closed connection to 10.113.184.121 port 10034
Flag&#39; found: 245821
counter: 13
[+] Opening connection to 10.113.184.121 on port 10034: Done
[*] Closed connection to 10.113.184.121 port 10034
Flag&#39; found: 7711492
counter: 14
[+] Opening connection to 10.113.184.121 on port 10034: Done
[*] Closed connection to 10.113.184.121 port 10034
not enough values to unpack (expected 2, got 1)
counter: 15
dlogs: [27360610332, 1023158172, 19279, 99180577, 1431258, 152629534, 36835, 15673959, 301945137539, 2906, 111332288773, 245821, 7711492]
primes: [144923720933, 357189282511, 62189, 572762753, 1649429, 172592237, 163171, 34381453, 443616973637, 11159, 568852214543, 371177, 8924527]
Flag: FLAG{YouAreARealECDLPMaster}
</code></pre><p>:::</p><p>Flag: <code>FLAG{YouAreARealECDLPMaster}</code></p><h2 id=reference>Reference
<a class=anchor href=#reference>#</a></h2><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p><a href=https://www.hackthebox.com/blog/business-ctf-2022-400-curves-write-up>Business CTF 2022: Invalid curve attack - 400 Curves</a>&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#background>Background</a></li><li><a href=#source-code>Source code</a></li><li><a href=#recon>Recon</a></li><li><a href=#exploit>Exploit</a></li><li><a href=#reference>Reference</a></li></ul></nav></div></aside></main></body></html>