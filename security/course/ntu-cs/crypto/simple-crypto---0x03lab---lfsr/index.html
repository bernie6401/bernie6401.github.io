<!doctype html><html lang=en-us dir=ltr><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="
  Simple Crypto - 0x03(Lab - LFSR)
  #


  tags: eductf CTF Crypto
  #


  Background
  #

[2022 fall] 0923 Crypto  - LFSR
Crypto I - LFSR

  Source Code
  #

Must read the source code first with some comment I added
:::spoiler source code
import random

# from secret import FLAG

FLAG = b'00001111'

class LFSR:
    def __init__(self, tap, state):
        self._tap = tap
        self._state = state

    def getbit(self):
        # f is the new bit that append in last position
        f = sum([self._state[i] for i in self._tap]) & 1

        # x is the output bit
        x = self._state[0]
        
        # self._state is a new state
        self._state = self._state[1:] + [f]
        return x

class triLFSR:
    def __init__(self, lfsr1, lfsr2, lfsr3):
        self.lfsr1 = lfsr1
        self.lfsr2 = lfsr2
        self.lfsr3 = lfsr3

    def getbit(self):
        x1 = self.lfsr1.getbit()
        x2 = self.lfsr2.getbit()
        x3 = self.lfsr3.getbit()
        return x2 if x1 else x3
# These are the state of lfsr1, lfsr2, and lfsr3
A = [random.randrange(2) for _ in range(27)]
B = [random.randrange(2) for _ in range(23)]
C = [random.randrange(2) for _ in range(25)]
print(A, B, C)

# tap is a filter that decide the last bit is 1 or 0
tap1 = [0, 13, 16, 26]
tap2 = [0, 5, 7, 22]
tap3 = [0, 17, 19, 24]

lfsr1 = LFSR(tap1, A)
lfsr2 = LFSR(tap2, B)
lfsr3 = LFSR(tap3, C)
cipher = triLFSR(lfsr1, lfsr2, lfsr3)

# Transfer the flag to ascii code and expressed in binary
# e.g. FLAG = '00001111' → '3030303031313131' → '001100000011000000110000...00110001'(64 bits)
flag = map(int, ''.join([&#34;{:08b}&#34;.format(c) for c in FLAG]))

output = []

for b in flag:
    # print(b)
    output.append(cipher.getbit() ^ b)

for _ in range(200):
    output.append(cipher.getbit())

# print(output)
:::"><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#343a40"><meta name=color-scheme content="light dark"><meta property="og:url" content="https://bernie6401.github.io/security/course/ntu-cs/crypto/simple-crypto---0x03lab---lfsr/"><meta property="og:site_name" content="SBK Hugo Site"><meta property="og:title" content="Simple Crypto - 0x03(Lab - LFSR)"><meta property="og:description" content="Simple Crypto - 0x03(Lab - LFSR) # tags: eductf CTF Crypto # Background # [2022 fall] 0923 Crypto - LFSR Crypto I - LFSR
Source Code # Must read the source code first with some comment I added :::spoiler source code
import random # from secret import FLAG FLAG = b'00001111' class LFSR: def __init__(self, tap, state): self._tap = tap self._state = state def getbit(self): # f is the new bit that append in last position f = sum([self._state[i] for i in self._tap]) & 1 # x is the output bit x = self._state[0] # self._state is a new state self._state = self._state[1:] + [f] return x class triLFSR: def __init__(self, lfsr1, lfsr2, lfsr3): self.lfsr1 = lfsr1 self.lfsr2 = lfsr2 self.lfsr3 = lfsr3 def getbit(self): x1 = self.lfsr1.getbit() x2 = self.lfsr2.getbit() x3 = self.lfsr3.getbit() return x2 if x1 else x3 # These are the state of lfsr1, lfsr2, and lfsr3 A = [random.randrange(2) for _ in range(27)] B = [random.randrange(2) for _ in range(23)] C = [random.randrange(2) for _ in range(25)] print(A, B, C) # tap is a filter that decide the last bit is 1 or 0 tap1 = [0, 13, 16, 26] tap2 = [0, 5, 7, 22] tap3 = [0, 17, 19, 24] lfsr1 = LFSR(tap1, A) lfsr2 = LFSR(tap2, B) lfsr3 = LFSR(tap3, C) cipher = triLFSR(lfsr1, lfsr2, lfsr3) # Transfer the flag to ascii code and expressed in binary # e.g. FLAG = '00001111' → '3030303031313131' → '001100000011000000110000...00110001'(64 bits) flag = map(int, ''.join([&#34;{:08b}&#34;.format(c) for c in FLAG])) output = [] for b in flag: # print(b) output.append(cipher.getbit() ^ b) for _ in range(200): output.append(cipher.getbit()) # print(output) :::"><meta property="og:locale" content="en_us"><meta property="og:type" content="article"><meta property="article:section" content="security"><meta property="article:tag" content="CTF"><meta property="article:tag" content="Crypto"><meta property="article:tag" content="Eductf"><title>Simple Crypto - 0x03(Lab - LFSR) | SBK Hugo Site</title>
<link rel=icon href=/favicon.png><link rel=manifest href=/manifest.json><link rel=canonical href=https://bernie6401.github.io/security/course/ntu-cs/crypto/simple-crypto---0x03lab---lfsr/><link rel=stylesheet href=/book.min.6c8b9d2a1fc95075ed7da46ca81060b39add8fff6741ac51259f768929281e2c.css integrity="sha256-bIudKh/JUHXtfaRsqBBgs5rdj/9nQaxRJZ92iSkoHiw=" crossorigin=anonymous><script defer src=/fuse.min.js></script><script defer src=/en.search.min.acdc41c8d39e6c69d70d8a23779875e0a3733fefead3e428d5344966bb12f562.js integrity="sha256-rNxByNOebGnXDYojd5h14KNzP+/q0+Qo1TRJZrsS9WI=" crossorigin=anonymous></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/><span>SBK Hugo Site</span></a></h2><div class="book-search hidden"><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><script>document.querySelector(".book-search").classList.remove("hidden")</script></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu></label><h3>Simple Crypto - 0x03(Lab - LFSR)</h3><label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><ul><li></li></ul></li><li><a href=#background>Background</a></li><li><a href=#source-code>Source Code</a></li><li><a href=#exploit---correlation-attackcor-attack>Exploit - Correlation Attack(COR Attack)</a></li><li><a href=#reference>Reference</a></li></ul></nav></aside></header><article class="markdown book-article"><h1 id=simple-crypto---0x03lab---lfsr>Simple Crypto - 0x03(Lab - LFSR)
<a class=anchor href=#simple-crypto---0x03lab---lfsr>#</a></h1><h6 id=tags-eductf-ctf-crypto>tags: <code>eductf</code> <code>CTF</code> <code>Crypto</code>
<a class=anchor href=#tags-eductf-ctf-crypto>#</a></h6><h2 id=background>Background
<a class=anchor href=#background>#</a></h2><p><a href="https://youtu.be/hnXtaiyvQ3s?t=945">[2022 fall] 0923 Crypto - LFSR</a>
<a href="https://youtu.be/dYyNeMeDM20?t=4386">Crypto I - LFSR</a></p><h2 id=source-code>Source Code
<a class=anchor href=#source-code>#</a></h2><p>Must read the source code first with some comment I added
:::spoiler source code</p><pre tabindex=0><code class="language-pytho=" data-lang="pytho=">import random

# from secret import FLAG

FLAG = b&#39;00001111&#39;

class LFSR:
    def __init__(self, tap, state):
        self._tap = tap
        self._state = state

    def getbit(self):
        # f is the new bit that append in last position
        f = sum([self._state[i] for i in self._tap]) &amp; 1

        # x is the output bit
        x = self._state[0]
        
        # self._state is a new state
        self._state = self._state[1:] + [f]
        return x

class triLFSR:
    def __init__(self, lfsr1, lfsr2, lfsr3):
        self.lfsr1 = lfsr1
        self.lfsr2 = lfsr2
        self.lfsr3 = lfsr3

    def getbit(self):
        x1 = self.lfsr1.getbit()
        x2 = self.lfsr2.getbit()
        x3 = self.lfsr3.getbit()
        return x2 if x1 else x3
# These are the state of lfsr1, lfsr2, and lfsr3
A = [random.randrange(2) for _ in range(27)]
B = [random.randrange(2) for _ in range(23)]
C = [random.randrange(2) for _ in range(25)]
print(A, B, C)

# tap is a filter that decide the last bit is 1 or 0
tap1 = [0, 13, 16, 26]
tap2 = [0, 5, 7, 22]
tap3 = [0, 17, 19, 24]

lfsr1 = LFSR(tap1, A)
lfsr2 = LFSR(tap2, B)
lfsr3 = LFSR(tap3, C)
cipher = triLFSR(lfsr1, lfsr2, lfsr3)

# Transfer the flag to ascii code and expressed in binary
# e.g. FLAG = &#39;00001111&#39; → &#39;3030303031313131&#39; → &#39;001100000011000000110000...00110001&#39;(64 bits)
flag = map(int, &#39;&#39;.join([&#34;{:08b}&#34;.format(c) for c in FLAG]))

output = []

for b in flag:
    # print(b)
    output.append(cipher.getbit() ^ b)

for _ in range(200):
    output.append(cipher.getbit())

# print(output)
</code></pre><p>:::</p><h2 id=exploit---correlation-attackcor-attack>Exploit - Correlation Attack(COR Attack)
<a class=anchor href=#exploit---correlation-attackcor-attack>#</a></h2><p>:::spoiler exploit</p><pre tabindex=0><code class="language-python=" data-lang="python=">import random
from tqdm import trange
import base64

def initialize():
    # Import output file(our cipher flag)
    File_path = &#34;//wsl.localhost/Ubuntu-20.04/home/sbk6401/NTUCS/Crypto/Lab/cor_485bab3bb2c51396/output.txt&#34;
    f = open(File_path, &#34;r&#34;)
    f = f.read().split(&#39;,&#39;)

    # The first 232 is flag with encrypted
    cipher_text = []
    cipher_flag = []
    for i in range(len(f)):
        if i &lt; 232:
            cipher_flag.append(int(f[i]))
        else:
            cipher_text.append(int(f[i]))
    # print(cipher_flag, cipher_text)
    return cipher_flag, cipher_text

def cal_correlation(a, b):
    count = 0
    for i in range(200):
        if a[i] == b[i]:
            count += 1
    return count / 200

def decimalToBinary(n):
    return bin(n).replace(&#34;0b&#34;, &#34;&#34;)

class LFSR:
    def __init__(self, tap, state):
        self._tap = tap
        self._state = state

    def getbit(self):
        f = sum([self._state[i] for i in self._tap]) &amp; 1
        x = self._state[0]
        self._state = self._state[1:] + [f]
        return x

class triLFSR:
    def __init__(self, lfsr1, lfsr2, lfsr3):
        self.lfsr1 = lfsr1
        self.lfsr2 = lfsr2
        self.lfsr3 = lfsr3

    def getbit(self):
        x1 = self.lfsr1.getbit()
        x2 = self.lfsr2.getbit()
        x3 = self.lfsr3.getbit()
        return x2 if x1 else x3

def guess_state(state_size_pow, tap, cipher_text):
    guess_state = [0 for _ in range(state_size_pow)]  # Initial guess state
    result = []

    for state in trange(2**state_size_pow):
        guess_text = []
        lfsr = LFSR(tap, guess_state)

        for _ in range(232):
            lfsr.getbit()

        for _ in range(200):
            guess_text.append(lfsr.getbit())
            
        acc = cal_correlation(guess_text, cipher_text)
        if acc &gt;= 0.70:
            # print(guess_state)
            result.append(guess_state)

        tmp = decimalToBinary(state + 1 + 3187671)
        guess_state = [0 for i in range(state_size_pow - len(tmp))] + [int(tmp[i]) for i in range(len(tmp))]

    return result

def final_guess(state_size_pow, tap, cipher_text, b_guess_state, c_guess_state):
    guess_state = [0 for _ in range(state_size_pow)]  # Initial guess state

    for state in trange(2**state_size_pow):
        guess_text = []
        lfsr1 = LFSR(tap[0], guess_state)
        lfsr2 = LFSR(tap[1], b_guess_state)
        lfsr3 = LFSR(tap[2], c_guess_state)
        cipher = triLFSR(lfsr1, lfsr2, lfsr3)

        for _ in range(232):
            cipher.getbit()

        for _ in range(200):
            guess_text.append(cipher.getbit())
            
        acc = cal_correlation(guess_text, cipher_text)
        if acc == 1:
            print(guess_state)
            return guess_state

        tmp = decimalToBinary(state + 1 + 13421773 * 8)
        guess_state = [0 for i in range(state_size_pow - len(tmp))] + [int(tmp[i]) for i in range(len(tmp))]

def binToHexa(n):
    bnum = int(n)
    temp = 0
    mul = 1
     
    # counter to check group of 4
    count = 1
     
    # char array to store hexadecimal number
    hexaDeciNum = [&#39;0&#39;] * 100
     
    # counter for hexadecimal number array
    i = 0
    while bnum != 0:
        rem = bnum % 10
        temp = temp + (rem*mul)
         
        # check if group of 4 completed
        if count % 4 == 0:
           
            # check if temp &lt; 10
            if temp &lt; 10:
                hexaDeciNum[i] = chr(temp+48)
            else:
                hexaDeciNum[i] = chr(temp+55)
            mul = 1
            temp = 0
            count = 1
            i = i+1
             
        # group of 4 is not completed
        else:
            mul = mul*2
            count = count+1
        bnum = int(bnum/10)
         
    # check if at end the group of 4 is not
    # completed
    if count != 1:
        hexaDeciNum[i] = chr(temp+48)
         
    # check at end the group of 4 is completed
    if count == 1:
        i = i-1
         
    # printing hexadecimal number
    # array in reverse order
    # print(&#34;\n Hexadecimal equivalent of {}:  &#34;.format(n), end=&#34;&#34;)
    hex_string = &#39;&#39;
    while i &gt;= 0:
        # print(end=hexaDeciNum[i])
        # print(hexaDeciNum[i])
        hex_string += hexaDeciNum[i]
        # print(base64.b64decode(hexaDeciNum[i]))
        i = i-1
    return hex_string

if __name__ == &#39;__main__&#39;:
    cipher_flag, cipher_text = initialize()

    tap = [[0, 13, 16, 26], [0, 5, 7, 22], [0, 17, 19, 24]]
    B_guess_state = guess_state(23, tap[1], cipher_text)    # [1, 0, 1, 1, 1, 0, 1, 0, 0, 0, 1, 0, 0, 1, 1, 1, 0, 1, 0, 1, 1, 1, 0]
    C_guess_state = guess_state(25, tap[2], cipher_text)  # [0, 1, 1, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 0, 0]
    A_guess_state = final_guess(27, tap, cipher_text, B_guess_state[0], C_guess_state[0]) # [1, 1, 1, 1, 0, 0, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0]
    # B_guess_state = [1, 0, 1, 1, 1, 0, 1, 0, 0, 0, 1, 0, 0, 1, 1, 1, 0, 1, 0, 1, 1, 1, 0]
    # C_guess_state = [0, 1, 1, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 0, 0]
    # A_guess_state = [1, 1, 1, 1, 0, 0, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0]


    lfsr1 = LFSR(tap[0], A_guess_state)
    lfsr2 = LFSR(tap[1], B_guess_state)
    lfsr3 = LFSR(tap[2], C_guess_state)
    cipher = triLFSR(lfsr1, lfsr2, lfsr3)

    output = []
    plaintext_bin = &#39;&#39;
    plaintext_hex = &#39;&#39;

    for i, b in enumerate(cipher_flag):
        plaintext_bin += str(cipher.getbit() ^ b)

        if (i+1) % 8 == 0:
            plaintext_hex += binToHexa(plaintext_bin)
            plaintext_bin = &#39;&#39;
    print(bytes.fromhex(plaintext_hex).decode())
</code></pre><p>:::</p><h2 id=reference>Reference
<a class=anchor href=#reference>#</a></h2><p><a href=https://www.geeksforgeeks.org/python-program-to-convert-binary-to-hexadecimal/>binary to hex</a>
<a href=https://blog.finxter.com/how-to-decode-a-hex-string-in-python/>hex to ascii</a></p></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><ul><li></li></ul></li><li><a href=#background>Background</a></li><li><a href=#source-code>Source Code</a></li><li><a href=#exploit---correlation-attackcor-attack>Exploit - Correlation Attack(COR Attack)</a></li><li><a href=#reference>Reference</a></li></ul></nav></div></aside></main></body></html>