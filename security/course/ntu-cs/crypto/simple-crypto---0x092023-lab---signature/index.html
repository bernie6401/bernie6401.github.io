<!doctype html><html lang=en-us dir=ltr><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="
  Simple Crypto - 0x09(2023 Lab - signature)
  #


  Background
  #

 [edu-ctf 2023] week03 - crypto2 - ECDSA




  Source code
  #

:::spoiler Source Code
from random import randint
from Crypto.Util.number import *
from hashlib import sha256
from ecdsa import SECP256k1
from ecdsa.ecdsa import Public_key, Private_key, Signature
from secret import FLAG

E = SECP256k1
G, n = E.generator, E.order

d = randint(1, n)
k = randint(1, n)
pubkey = Public_key(G, d*G)
prikey = Private_key(pubkey, d)
print(f'P = ({pubkey.point.x()}, {pubkey.point.y()})')

for _ in range(3):
    print('''
1) Request for Signature
2) Check the Permission
3) exit''')
    option = input()
    if option == '1':
        msg = input('What do you want? ')
        if msg == 'Give me the FLAG.':
                print('No way!')
        else:
            h = sha256(msg.encode()).digest()
            # k = k * 1337 % n
            sig = prikey.sign(bytes_to_long(h), k)
            print(f'sig = ({sig.r}, {sig.s})')

    elif option == '2':
        msg = 'Give me the FLAG.'
        r = input('r: ')
        s = input('s: ')
        h = bytes_to_long(sha256(msg.encode()).digest())
        verified = pubkey.verifies(h, Signature(int(r), int(s)))
        if verified:
            print(FLAG)
        else:
            print('Bad signature')
    else:
        print(&#34;bye~&#34;)
        break
:::"><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#343a40"><meta name=color-scheme content="light dark"><meta property="og:url" content="https://bernie6401.github.io/security/course/ntu-cs/crypto/simple-crypto---0x092023-lab---signature/"><meta property="og:site_name" content="SBK Hugo Site"><meta property="og:title" content="Simple Crypto - 0x09(2023 Lab - signature)"><meta property="og:description" content="Simple Crypto - 0x09(2023 Lab - signature) # Background # [edu-ctf 2023] week03 - crypto2 - ECDSA
Source code # :::spoiler Source Code
from random import randint from Crypto.Util.number import * from hashlib import sha256 from ecdsa import SECP256k1 from ecdsa.ecdsa import Public_key, Private_key, Signature from secret import FLAG E = SECP256k1 G, n = E.generator, E.order d = randint(1, n) k = randint(1, n) pubkey = Public_key(G, d*G) prikey = Private_key(pubkey, d) print(f'P = ({pubkey.point.x()}, {pubkey.point.y()})') for _ in range(3): print(''' 1) Request for Signature 2) Check the Permission 3) exit''') option = input() if option == '1': msg = input('What do you want? ') if msg == 'Give me the FLAG.': print('No way!') else: h = sha256(msg.encode()).digest() # k = k * 1337 % n sig = prikey.sign(bytes_to_long(h), k) print(f'sig = ({sig.r}, {sig.s})') elif option == '2': msg = 'Give me the FLAG.' r = input('r: ') s = input('s: ') h = bytes_to_long(sha256(msg.encode()).digest()) verified = pubkey.verifies(h, Signature(int(r), int(s))) if verified: print(FLAG) else: print('Bad signature') else: print(&#34;bye~&#34;) break :::"><meta property="og:locale" content="en_us"><meta property="og:type" content="article"><meta property="article:section" content="security"><meta property="article:tag" content="CTF"><meta property="article:tag" content="Crypto"><meta property="article:tag" content="Eductf"><title>Simple Crypto - 0x09(2023 Lab - signature) | SBK Hugo Site</title>
<link rel=icon href=/favicon.png><link rel=manifest href=/manifest.json><link rel=canonical href=https://bernie6401.github.io/security/course/ntu-cs/crypto/simple-crypto---0x092023-lab---signature/><link rel=stylesheet href=/book.min.6c8b9d2a1fc95075ed7da46ca81060b39add8fff6741ac51259f768929281e2c.css integrity="sha256-bIudKh/JUHXtfaRsqBBgs5rdj/9nQaxRJZ92iSkoHiw=" crossorigin=anonymous><script defer src=/fuse.min.js></script><script defer src=/en.search.min.acdc41c8d39e6c69d70d8a23779875e0a3733fefead3e428d5344966bb12f562.js integrity="sha256-rNxByNOebGnXDYojd5h14KNzP+/q0+Qo1TRJZrsS9WI=" crossorigin=anonymous></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/><span>SBK Hugo Site</span></a></h2><div class="book-search hidden"><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><script>document.querySelector(".book-search").classList.remove("hidden")</script></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu></label><h3>Simple Crypto - 0x09(2023 Lab - signature)</h3><label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#background>Background</a></li><li><a href=#source-code>Source code</a></li><li><a href=#recon>Recon</a></li><li><a href=#exploit>Exploit</a></li></ul></nav></aside></header><article class="markdown book-article"><h1 id=simple-crypto---0x092023-lab---signature>Simple Crypto - 0x09(2023 Lab - signature)
<a class=anchor href=#simple-crypto---0x092023-lab---signature>#</a></h1><h2 id=background>Background
<a class=anchor href=#background>#</a></h2><p><a href="https://www.youtube.com/live/u4ZVc8PuJC0?si=ychlqdZnGVfFYRAV&amp;t=4075">[edu-ctf 2023] week03 - crypto2 - ECDSA</a></p><blockquote><p><img src=https://hackmd.io/_uploads/ryVbmdMWp.png alt></p><p><img src=https://hackmd.io/_uploads/HkJMXOG-T.png alt></p></blockquote><h2 id=source-code>Source code
<a class=anchor href=#source-code>#</a></h2><p>:::spoiler Source Code</p><pre tabindex=0><code class="language-python=" data-lang="python=">from random import randint
from Crypto.Util.number import *
from hashlib import sha256
from ecdsa import SECP256k1
from ecdsa.ecdsa import Public_key, Private_key, Signature
from secret import FLAG

E = SECP256k1
G, n = E.generator, E.order

d = randint(1, n)
k = randint(1, n)
pubkey = Public_key(G, d*G)
prikey = Private_key(pubkey, d)
print(f&#39;P = ({pubkey.point.x()}, {pubkey.point.y()})&#39;)

for _ in range(3):
    print(&#39;&#39;&#39;
1) Request for Signature
2) Check the Permission
3) exit&#39;&#39;&#39;)
    option = input()
    if option == &#39;1&#39;:
        msg = input(&#39;What do you want? &#39;)
        if msg == &#39;Give me the FLAG.&#39;:
                print(&#39;No way!&#39;)
        else:
            h = sha256(msg.encode()).digest()
            # k = k * 1337 % n
            sig = prikey.sign(bytes_to_long(h), k)
            print(f&#39;sig = ({sig.r}, {sig.s})&#39;)

    elif option == &#39;2&#39;:
        msg = &#39;Give me the FLAG.&#39;
        r = input(&#39;r: &#39;)
        s = input(&#39;s: &#39;)
        h = bytes_to_long(sha256(msg.encode()).digest())
        verified = pubkey.verifies(h, Signature(int(r), int(s)))
        if verified:
            print(FLAG)
        else:
            print(&#39;Bad signature&#39;)
    else:
        print(&#34;bye~&#34;)
        break
</code></pre><p>:::</p><h2 id=recon>Recon
<a class=anchor href=#recon>#</a></h2><p>這一題主要就是利用上課提到的nonce $k$不隨機的問題，因為$k$只能用一次，也就代表他需要夠隨機，如果像LCG這樣的psudo random generator產生的話，一但被compromise，就會被推導出private key $d$，而這個lab就是有這樣的問題</p><ol><li>觀察source code會發現不同的nonce $k$之間會產生一個1337倍數的關係，然後如果request <code>Give me the FLAG.</code>的signature會被拒絕，所以只能自己產生<code>Give me the FLAG.</code>的signature再丟給server檢查，如果過了就可以拿到flag，但重點是要怎麼偽造signature假裝是server簽的?就是要想辦法拿到server產生的private key $d$，可以詳細看一下source code中提到，通常public key都一樣，所以重點是$d$才能產生private key，然後用private key簽署message<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>E <span style=color:#f92672>=</span> SECP256k1
</span></span><span style=display:flex><span>G, n <span style=color:#f92672>=</span> E<span style=color:#f92672>.</span>generator, E<span style=color:#f92672>.</span>order
</span></span><span style=display:flex><span>d <span style=color:#f92672>=</span> randint(<span style=color:#ae81ff>1</span>, n)
</span></span><span style=display:flex><span>pubkey <span style=color:#f92672>=</span> Public_key(G, d<span style=color:#f92672>*</span>G)
</span></span><span style=display:flex><span>prikey <span style=color:#f92672>=</span> Private_key(pubkey, d)
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>↓</span>
</span></span><span style=display:flex><span>sig <span style=color:#f92672>=</span> prikey<span style=color:#f92672>.</span>sign(bytes_to_long(h), k)
</span></span></code></pre></div></li><li>已知(題目給的部分)
只要我們給兩次要簽章的message，總共可以得到以下資訊
$$
coordinate\ (x_0,\ y_0),\
hash\ H_1,\ hash\ H_2,\
signature\ (s_1,\ r_1),\ (s_2,\ r_2)
$$</li><li>推導
假設$msg=b&rsquo;a&rsquo;$
$$
H_1 = H_2 = sha256(msg)\
\begin{aligned}
k_1 &= {s_1}^{-1} \cdot (H_1 + d\cdot r_1)={s_1}^{-1} \cdot H_1 + d\cdot r_1 \cdot {s_1}^{-1}\
k_2 &= {s_2}^{-1} \cdot (H_2 + d\cdot r_2) = 1337\times k_1=\
&= {s_2}^{-1} \cdot H_2 + {s_2}^{-1}\cdot d\cdot r_2\
&= 1337 \cdot {s_1}^{-1} \cdot H_1 + 1337 \cdot d\cdot r_1 \cdot {s_1}^{-1}
\end{aligned}\
\downarrow \
d\cdot (H_2\cdot {s_2}^{-1} - 1337\cdot H_1\cdot {s_1}^{-1})=1337\cdot r_1\cdot {s_1}^{-1}-r_2\cdot {s_2}^{-1}\
\hookrightarrow d = {1337\cdot r_1\cdot {s_1}^{-1}-r_2\cdot {s_2}^{-1} \over H_2\cdot {s_2}^{-1} - 1337\cdot H_1\cdot {s_1}^{-1}}
$$</li><li>得到原本的private key $d$之後就可以直接選一個亂數nonce $k$，然後重新自己簽署<code>Give me the FLAG.</code>的signature</li></ol><h2 id=exploit>Exploit
<a class=anchor href=#exploit>#</a></h2><p>:::spoiler Whole Exploit</p><pre tabindex=0><code class="language-python=" data-lang="python=">from pwn import *
from Crypto.Util.number import *
from hashlib import sha256
from ecdsa import SECP256k1
from ecdsa.ecdsa import Public_key, Private_key, Signature

# r = process([&#34;python&#34;, &#34;./signature_416666d57b34123f.py&#34;])
r = remote(&#39;10.113.184.121&#39;, 10033)

# Receive Some Info from Server
msg = &#39;a&#39;
E = SECP256k1
G, n = E.generator, E.order
r.recvuntil(b&#39;P = (&#39;)
x, y = r.recvline().decode().strip().rstrip(&#39;)&#39;).split(&#39;, &#39;)
r.recvlines(3)
r.sendline(b&#39;1&#39;)
r.sendlineafter(b&#39;What do you want?&#39;, msg.encode())
r.recvuntil(b&#39;sig = (&#39;)
r1, s1 = r.recvline().decode().strip().rstrip(&#39;)&#39;).split(&#39;, &#39;)
r.recvlines(3)
r.sendline(b&#39;1&#39;)
r.sendlineafter(b&#39;What do you want?&#39;, msg.encode())
r.recvuntil(b&#39;sig = (&#39;)
r2, s2 = r.recvline().decode().strip().rstrip(&#39;)&#39;).split(&#39;, &#39;)

log.info(f&#39;x = {x}\ny = {y}&#39;)
log.info(f&#39;r1 = {r1}\ns1 = {s1}&#39;)
log.info(f&#39;r2 = {r2}\ns2 = {s2}&#39;)

# Calculte Private Key - d
hash_msg = sha256(msg.encode()).digest()
inv_s1 = inverse(int(s1), n)
inv_s2 = inverse(int(s2), n)
hash_msg_decimal = bytes_to_long(hash_msg)
r1 = int(r1)
r2 = int(r2)
d = inverse(1337 * r1 * inv_s1 - r2 * inv_s2, n) * (hash_msg_decimal * inv_s2 - 1337 * hash_msg_decimal * inv_s1)
k1 = inv_s1 * (hash_msg_decimal + d * r1)
k2 = inv_s2 * (hash_msg_decimal + d * r2)
assert k2 % n == k1 * 1337 % n

# Forgery Signature &amp; Send it
k = randint(1, n)
pubkey = Public_key(G, d*G)
prikey = Private_key(pubkey, d)
flag_msg = &#39;Give me the FLAG.&#39;
flag_msg_h = sha256(flag_msg.encode()).digest()
sig = prikey.sign(bytes_to_long(flag_msg_h), k)
r.recvlines(3)
r.sendline(b&#39;2&#39;)
r.sendlineafter(b&#39;r: &#39;, sig.r.digits().encode())
r.sendlineafter(b&#39;s: &#39;, sig.s.digits().encode())
flag = r.recvline().strip().decode()

log.info(f&#39;Flag: {flag}&#39;)

r.close()
:::

```bash
$ python exp.py
[+] Opening connection to 10.113.184.121 on port 10033: Done
[*] x = 80833128996081892656118221427167942614367970190999112028100047868271602908158
    y = 7692760766381285656486680270900861598977131934640663688795645395086394523342
[*] r1 = 57205296794452689467192257573140114834242454684651993799259557149551452463654
    s1 = 46076932900642565773729561332617152693574412598169577544559584675273278539735
[*] r2 = 32274988576741840972950688950377038880296385056439434547263507357520953909449
    s2 = 38964710627625045025023640822136515580011444306594995093726779755542228691436
[*] Flag: b&#39;FLAG{EphemeralKeyShouldBeRandom}&#39;
[*] Closed connection to 10.113.184.121 port 10033
</code></pre><p>Flag: <code>FLAG{EphemeralKeyShouldBeRandom}</code></p></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#background>Background</a></li><li><a href=#source-code>Source code</a></li><li><a href=#recon>Recon</a></li><li><a href=#exploit>Exploit</a></li></ul></nav></div></aside></main></body></html>