<!doctype html><html lang=en-us dir=ltr><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content='
  Lecture 8
  #


  tags: Data Structure NYCU
  #


  Reference & Background
  #

Lec08 資料結構 第五週課程
C語言: 超好懂的指標，初學者請進～

  Note
  #


  Rewind
  #


Array
之前提到Array的結構，其缺點是大小是固定的，但有時候需要儲存的東西可能是動態改變的，且沒有用到的空間就會變成一種浪費
Solution
此時就可能可以考慮用Link-List的結構處理這樣的資料


  Link-List
  #



主要結構
每一個Element都會有兩個儲存單位，一個是儲存資料本體，另一個是儲存pointer，指向下一個Element的位置



Insert GAT
Create新的node，儲存GAT，並改變前後的指標，原本FAT的指標要assign給GAT的pointer，然後GAT的位址也要assign給FAT



Delete GAT
把HAT的位址assign給FAT


缺點：如果要delete某一個Element就需要"先找到該Element的位置在哪裡"，如果Link-List 很長，則要做到這件事情的Overhead就會很高
Solution: Double-Link-List，可以從前後同時找要刪除的Element，這樣的話就會比較快




  Implement
  #

:::spoiler Source Code - Composite Classes
class ThreeLetterList; // forward delcanon 
class ThreeLetterNode {
    friend class ThreeLetterList; 
    private 
    char data[3]; // 每一個Elment就是只有儲存三個字元
    ThreeLetterNode *link;
};

class ThreeLetterList{ 
    public: 
        // List Manipulat10n operabons 
    private:
        ThreeLetterNode *first;
};
:::'><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#343a40"><meta name=color-scheme content="light dark"><meta property="og:url" content="https://bernie6401.github.io/data-structure/lecture-8/"><meta property="og:site_name" content="SBK Hugo Site"><meta property="og:title" content="Lecture 8"><meta property="og:description" content='Lecture 8 # tags: Data Structure NYCU # Reference & Background # Lec08 資料結構 第五週課程 C語言: 超好懂的指標，初學者請進～
Note # Rewind # Array 之前提到Array的結構，其缺點是大小是固定的，但有時候需要儲存的東西可能是動態改變的，且沒有用到的空間就會變成一種浪費 Solution 此時就可能可以考慮用Link-List的結構處理這樣的資料 Link-List # 主要結構 每一個Element都會有兩個儲存單位，一個是儲存資料本體，另一個是儲存pointer，指向下一個Element的位置 Insert GAT Create新的node，儲存GAT，並改變前後的指標，原本FAT的指標要assign給GAT的pointer，然後GAT的位址也要assign給FAT Delete GAT 把HAT的位址assign給FAT 缺點：如果要delete某一個Element就需要"先找到該Element的位置在哪裡"，如果Link-List 很長，則要做到這件事情的Overhead就會很高 Solution: Double-Link-List，可以從前後同時找要刪除的Element，這樣的話就會比較快 Implement # :::spoiler Source Code - Composite Classes
class ThreeLetterList; // forward delcanon class ThreeLetterNode { friend class ThreeLetterList; private char data[3]; // 每一個Elment就是只有儲存三個字元 ThreeLetterNode *link; }; class ThreeLetterList{ public: // List Manipulat10n operabons private: ThreeLetterNode *first; }; :::'><meta property="og:locale" content="en_us"><meta property="og:type" content="article"><meta property="article:section" content="data-structure"><meta property="article:tag" content="Data Structure"><meta property="article:tag" content="NYCU"><title>Lecture 8 | SBK Hugo Site</title>
<link rel=icon href=/favicon.png><link rel=manifest href=/manifest.json><link rel=canonical href=https://bernie6401.github.io/data-structure/lecture-8/><link rel=stylesheet href=/book.min.6c8b9d2a1fc95075ed7da46ca81060b39add8fff6741ac51259f768929281e2c.css integrity="sha256-bIudKh/JUHXtfaRsqBBgs5rdj/9nQaxRJZ92iSkoHiw=" crossorigin=anonymous><script defer src=/fuse.min.js></script><script defer src=/en.search.min.acdc41c8d39e6c69d70d8a23779875e0a3733fefead3e428d5344966bb12f562.js integrity="sha256-rNxByNOebGnXDYojd5h14KNzP+/q0+Qo1TRJZrsS9WI=" crossorigin=anonymous></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/><span>SBK Hugo Site</span></a></h2><div class="book-search hidden"><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><script>document.querySelector(".book-search").classList.remove("hidden")</script></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu></label><h3>Lecture 8</h3><label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><ul><li></li></ul></li><li><a href=#reference--background>Reference & Background</a></li><li><a href=#note>Note</a><ul><li><a href=#rewind>Rewind</a></li><li><a href=#link-list>Link-List</a></li></ul></li></ul></nav></aside></header><article class="markdown book-article"><h1 id=lecture-8>Lecture 8
<a class=anchor href=#lecture-8>#</a></h1><h6 id=tags-data-structure-nycu>tags: <code>Data Structure</code> <code>NYCU</code>
<a class=anchor href=#tags-data-structure-nycu>#</a></h6><h2 id=reference--background>Reference & Background
<a class=anchor href=#reference--background>#</a></h2><p><a href=https://youtu.be/lhXHk8IuFeQ>Lec08 資料結構 第五週課程</a>
<a href=https://kopu.chat/c%E8%AA%9E%E8%A8%80-%E8%B6%85%E5%A5%BD%E6%87%82%E7%9A%84%E6%8C%87%E6%A8%99%EF%BC%8C%E5%88%9D%E5%AD%B8%E8%80%85%E8%AB%8B%E9%80%B2%EF%BD%9E/>C語言: 超好懂的指標，初學者請進～</a></p><h2 id=note>Note
<a class=anchor href=#note>#</a></h2><h3 id=rewind>Rewind
<a class=anchor href=#rewind>#</a></h3><ul><li>Array
之前提到Array的結構，其缺點是大小是固定的，但有時候需要儲存的東西可能是動態改變的，且沒有用到的空間就會變成一種浪費</li><li>Solution
此時就可能可以考慮用Link-List的結構處理這樣的資料</li></ul><h3 id=link-list>Link-List
<a class=anchor href=#link-list>#</a></h3><ul><li><p>主要結構
每一個Element都會有兩個儲存單位，一個是儲存資料本體，另一個是儲存pointer，指向下一個Element的位置
<img src=https://hackmd.io/_uploads/SJ0yRNXH3.png alt></p></li><li><p>Insert <code>GAT</code>
Create新的node，儲存<code>GAT</code>，並改變前後的指標，原本<code>FAT</code>的指標要assign給<code>GAT</code>的pointer，然後<code>GAT</code>的位址也要assign給<code>FAT</code>
<img src=https://hackmd.io/_uploads/H1JrREXBh.png alt></p></li><li><p>Delete <code>GAT</code>
把<code>HAT</code>的位址assign給<code>FAT</code>
<img src=https://hackmd.io/_uploads/SJ2zkr7B3.png alt></p><ul><li>缺點：如果要delete某一個Element就需要"先找到該Element的位置在哪裡"，如果Link-List 很長，則要做到這件事情的Overhead就會很高</li><li>Solution: Double-Link-List，可以從前後同時找要刪除的Element，這樣的話就會比較快</li></ul></li></ul><h4 id=implement>Implement
<a class=anchor href=#implement>#</a></h4><p>:::spoiler Source Code - Composite Classes</p><pre tabindex=0><code class=language-cpp! data-lang=cpp!>class ThreeLetterList; // forward delcanon 
class ThreeLetterNode {
    friend class ThreeLetterList; 
    private 
    char data[3]; // 每一個Elment就是只有儲存三個字元
    ThreeLetterNode *link;
};

class ThreeLetterList{ 
    public: 
        // List Manipulat10n operabons 
    private:
        ThreeLetterNode *first;
};
</code></pre><p>:::</p><p>:::spoiler Another Implementation - Nested Classes</p><pre tabindex=0><code class=language-cpp! data-lang=cpp!>class ThreeLetterList{
    public:
    // List ManipuIation operatlons 
    private:
        class ThreeLetterNode{ // nested class 
        public:
            char data[3]; 
            ThreeLetterNode *link;
        };
        ThreeLetterNode *first;
};
</code></pre><p>:::</p><ul><li><p>How to create 2 link-list element
:::spoiler Example Code</p><pre tabindex=0><code class=language-cpp! data-lang=cpp!>void List::Create2()
{
    /* create a linked list with two nodes */ 
    first = new ListNode(10); 
    first-&gt;link = new ListNode(20); 
}
ListNode::ListNode(int element=0)
{
    data = element; 
    link = 0;
}
</code></pre><p>:::
<img src=https://hackmd.io/_uploads/By5RniQSh.png alt></p></li><li><p>How to insert 50 in a existed link-list
:::spoiler Example Code</p><pre tabindex=0><code class=language-cpp! data-lang=cpp!>void List::Insert50 (ListNode *x)
{
    /* insert a new node with data=50 into the list* */ 
    ListNode *t = new ListNode(50); 
    if (!first) 
    {
        first = t; 
        return;
    }
    //insert after x 
    t-&gt;link = x-&gt;link; 
    x-&gt;link = t;
}
</code></pre><p>:::
<img src=https://hackmd.io/_uploads/B1nW2imHh.png alt></p></li></ul></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><ul><li></li></ul></li><li><a href=#reference--background>Reference & Background</a></li><li><a href=#note>Note</a><ul><li><a href=#rewind>Rewind</a></li><li><a href=#link-list>Link-List</a></li></ul></li></ul></nav></div></aside></main></body></html>