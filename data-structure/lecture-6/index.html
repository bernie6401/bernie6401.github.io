<!doctype html><html lang=en-us dir=ltr><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="
  Lecture 6
  #


  tags: Data Structure NYCU
  #

[TOC]

  Reference
  #

Lec06 資料結構 第四週課程
[C/C++] C/C++ 箭頭(->) 、點(.)、雙冒號(::) 用法

  Rewind
  #


  String Matching Task
  #

最笨的作法是一個字元依依比對



  KMP Algorithm
  #



有沒有可能一次不要只移動一個字元，



又充分利用已經比對過的資訊進行位移




  原理
  #

運用到的就是建立一個Failure Function，如下圖為例，在index=5的地方failure function是3，代表從index=5往回看3個字元，會和整個字串的開頭往後看3個字元會相等

這樣的話就可以快速的移動比對的字串，例如下圖，index i和j不相等，則可以往回看j-1的failure function儲存的相等字元有多少，如果是3代表可以直接移動到P到相等字元的地方(也就是p[3+1]的地方開始比對)，也就是粉紅色的地方對齊，這樣的話就可以移動不只一個字元


  Implementation
  #

:::info
Prefix (Failure) Function can refer to 1:05:00
KMP Matcher can refer to orignal video at timestamp 1:14:00
實際操作：1:14:10
:::"><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#343a40"><meta name=color-scheme content="light dark"><meta property="og:url" content="https://bernie6401.github.io/data-structure/lecture-6/"><meta property="og:site_name" content="SBK Hugo Site"><meta property="og:title" content="Lecture 6"><meta property="og:description" content="Lecture 6 # tags: Data Structure NYCU # [TOC]
Reference # Lec06 資料結構 第四週課程 [C/C++] C/C++ 箭頭(->) 、點(.)、雙冒號(::) 用法
Rewind # String Matching Task # 最笨的作法是一個字元依依比對 KMP Algorithm # 有沒有可能一次不要只移動一個字元， 又充分利用已經比對過的資訊進行位移 原理 # 運用到的就是建立一個Failure Function，如下圖為例，在index=5的地方failure function是3，代表從index=5往回看3個字元，會和整個字串的開頭往後看3個字元會相等 這樣的話就可以快速的移動比對的字串，例如下圖，index i和j不相等，則可以往回看j-1的failure function儲存的相等字元有多少，如果是3代表可以直接移動到P到相等字元的地方(也就是p[3+1]的地方開始比對)，也就是粉紅色的地方對齊，這樣的話就可以移動不只一個字元 Implementation # :::info Prefix (Failure) Function can refer to 1:05:00 KMP Matcher can refer to orignal video at timestamp 1:14:00 實際操作：1:14:10 :::"><meta property="og:locale" content="en_us"><meta property="og:type" content="article"><meta property="article:section" content="data-structure"><meta property="article:tag" content="Data Structure"><meta property="article:tag" content="NYCU"><title>Lecture 6 | SBK Hugo Site</title>
<link rel=icon href=/favicon.png><link rel=manifest href=/manifest.json><link rel=canonical href=https://bernie6401.github.io/data-structure/lecture-6/><link rel=stylesheet href=/book.min.6c8b9d2a1fc95075ed7da46ca81060b39add8fff6741ac51259f768929281e2c.css integrity="sha256-bIudKh/JUHXtfaRsqBBgs5rdj/9nQaxRJZ92iSkoHiw=" crossorigin=anonymous><script defer src=/fuse.min.js></script><script defer src=/en.search.min.acdc41c8d39e6c69d70d8a23779875e0a3733fefead3e428d5344966bb12f562.js integrity="sha256-rNxByNOebGnXDYojd5h14KNzP+/q0+Qo1TRJZrsS9WI=" crossorigin=anonymous></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/><span>SBK Hugo Site</span></a></h2><div class="book-search hidden"><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><script>document.querySelector(".book-search").classList.remove("hidden")</script></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu></label><h3>Lecture 6</h3><label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><ul><li></li></ul></li><li><a href=#reference>Reference</a></li><li><a href=#rewind>Rewind</a><ul><li><a href=#string-matching-task>String Matching Task</a></li><li><a href=#kmp-algorithm>KMP Algorithm</a></li><li><a href=#原理>原理</a></li><li><a href=#implementation>Implementation</a></li><li><a href=#order>Order</a></li></ul></li><li><a href=#note>Note</a><ul><li><a href=#stack>Stack</a></li><li><a href=#queue>Queue</a></li></ul></li></ul></nav></aside></header><article class="markdown book-article"><h1 id=lecture-6>Lecture 6
<a class=anchor href=#lecture-6>#</a></h1><h6 id=tags-data-structure-nycu>tags: <code>Data Structure</code> <code>NYCU</code>
<a class=anchor href=#tags-data-structure-nycu>#</a></h6><p>[TOC]</p><h2 id=reference>Reference
<a class=anchor href=#reference>#</a></h2><p><a href=https://youtu.be/5HBMYNYYGZU>Lec06 資料結構 第四週課程</a>
<a href=https://gist.github.com/LeeKLTW/e5004f2d7046d43676d0891af8a13ef7>[C/C++] C/C++ 箭頭(->) 、點(.)、雙冒號(::) 用法</a></p><h2 id=rewind>Rewind
<a class=anchor href=#rewind>#</a></h2><h3 id=string-matching-task>String Matching Task
<a class=anchor href=#string-matching-task>#</a></h3><p>最笨的作法是一個字元依依比對
<img src=https://i.imgur.com/qwCSoNe.png alt></p><hr><h3 id=kmp-algorithm>KMP Algorithm
<a class=anchor href=#kmp-algorithm>#</a></h3><ul><li><p>有沒有可能一次不要只移動一個字元，
<img src=https://i.imgur.com/zNhwzCt.png alt></p></li><li><p>又充分利用已經比對過的資訊進行位移
<img src=https://i.imgur.com/7uvOfzP.png alt></p></li></ul><h3 id=原理>原理
<a class=anchor href=#%e5%8e%9f%e7%90%86>#</a></h3><p>運用到的就是建立一個Failure Function，如下圖為例，在index=5的地方failure function是3，代表從index=5往回看3個字元，會和整個字串的開頭往後看3個字元會相等
<img src=https://i.imgur.com/k8auhgP.png alt></p><p>這樣的話就可以快速的移動比對的字串，例如下圖，index i和j不相等，則可以往回看j-1的failure function儲存的相等字元有多少，如果是3代表可以直接移動到P到相等字元的地方(也就是p[3+1]的地方開始比對)，也就是粉紅色的地方對齊，這樣的話就可以移動不只一個字元
<img src=https://i.imgur.com/vrO4YnO.png alt></p><h3 id=implementation>Implementation
<a class=anchor href=#implementation>#</a></h3><p>:::info
Prefix (Failure) Function can refer to <code>1:05:00</code>
KMP Matcher can refer to orignal video at timestamp <code>1:14:00</code>
實際操作：<code>1:14:10</code>
:::</p><h3 id=order>Order
<a class=anchor href=#order>#</a></h3><p>此演算法有分兩個phase，前一個是要計算failure function $O(m)$，後一個phase是matching $O(n)$
所以總共是：$O(m+n)$</p><h2 id=note>Note
<a class=anchor href=#note>#</a></h2><h3 id=stack>Stack
<a class=anchor href=#stack>#</a></h3><ul><li><p>Last In First Out
Top Pointer永遠指向最後進來的element
<img src=https://i.imgur.com/wFZMQXA.png alt></p></li><li><p>Application</p><ul><li>Function Call的Return Address或是其他Passing Parameters都會儲存在Stack中
<img src=https://i.imgur.com/mvfzAgR.png alt></li></ul></li><li><p>Implementation
:::info
How to implement? Array Or Link List
:::
:::spoiler Structure</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span>Template <span style=color:#f92672>&lt;</span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>KeyType</span><span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Stack</span>
</span></span><span style=display:flex><span>{<span style=color:#75715e>// objects: A finite ordered list with zero or more elements
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>        Stack (<span style=color:#66d9ef>int</span> MaxStackSize <span style=color:#f92672>=</span> DefaultSize);
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Create an empty stack whose maximum size is MarStackSize
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        Boolean <span style=color:#a6e22e>IsFull</span>();
</span></span><span style=display:flex><span>        <span style=color:#75715e>// if number of elements in the stack is equal to the maximum size
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// of the stack, return TRUE(1) else return FALSE(0)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>Add</span>(<span style=color:#66d9ef>const</span> KeyType<span style=color:#f92672>&amp;</span> item);
</span></span><span style=display:flex><span>        <span style=color:#75715e>// if IsFull(), then StackFull(); else insert item into the top of the stack.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        Boolean <span style=color:#a6e22e>IsEmpty</span>();
</span></span><span style=display:flex><span>        <span style=color:#75715e>// if number of elements in the stack is 0, return TRUE(1) else return FALSE(0)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        KeyType<span style=color:#f92672>*</span> <span style=color:#a6e22e>Delete</span>(KeyType<span style=color:#f92672>&amp;</span>);
</span></span><span style=display:flex><span>        <span style=color:#75715e>// if IsEmpty(), then StackEmpty() and return O;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// else remove and return a pointer to the top element of the stack.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>private</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> top;
</span></span><span style=display:flex><span>        KeyType <span style=color:#f92672>*</span>stack;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> MaxSize,
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>template</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>KeyType</span><span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span>        Stack<span style=color:#f92672>&lt;</span>KeyType<span style=color:#f92672>&gt;::</span>Stack(<span style=color:#66d9ef>int</span> MaxStackSize)<span style=color:#f92672>:</span>MaxSize(Max.StackSize)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            stack<span style=color:#f92672>=</span><span style=color:#66d9ef>new</span> KeyType(MaxSize),
</span></span><span style=display:flex><span>            top<span style=color:#f92672>=-</span><span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>template</span><span style=color:#f92672>&lt;</span>classs KeyType<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>inline</span> Boolean Stack<span style=color:#f92672>&lt;</span>KeyType<span style=color:#f92672>&gt;::</span>IsFul1()
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (top<span style=color:#f92672>==</span>MarSize<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>) <span style=color:#66d9ef>return</span> TRUE,
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>return</span> FALSE;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>template</span><span style=color:#f92672>&lt;</span>classs KeyType<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>inline</span> Boolean Stack<span style=color:#f92672>&lt;</span>KeyType<span style=color:#f92672>&gt;::</span>IsEmpty()
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (top<span style=color:#f92672>==-</span><span style=color:#ae81ff>1</span>)<span style=color:#66d9ef>return</span> TRUE;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>return</span> FALSE;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>:::</p><p>:::spoiler Add to a stack</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span>Template <span style=color:#f92672>&lt;</span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>KeyType</span><span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> Stack<span style=color:#f92672>&lt;</span>Key Type<span style=color:#f92672>&gt;::</span>Add(<span style=color:#66d9ef>const</span> KeyType<span style=color:#f92672>&amp;</span> x)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* add an item to the global stack */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (IsFull())
</span></span><span style=display:flex><span>        stack_full( );
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>        stack[<span style=color:#f92672>++</span>top]<span style=color:#f92672>-</span>x;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>:::</p><p>:::spoiler Delete from a stack</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span>Template <span style=color:#f92672>&lt;</span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Key</span> Type<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span>KeyType<span style=color:#f92672>*</span>Stack<span style=color:#f92672>&lt;</span>KeyType<span style=color:#f92672>&gt;::</span>Delete(KeyType<span style=color:#f92672>&amp;</span>x)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* return the top element from the stack */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (IsEmpty())
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        stack_empty( ); <span style=color:#75715e>/* returns and error key
</span></span></span><span style=display:flex><span><span style=color:#75715e>        return 0;
</span></span></span><span style=display:flex><span><span style=color:#75715e>    }
</span></span></span><span style=display:flex><span><span style=color:#75715e>    x=stack[top--];
</span></span></span><span style=display:flex><span><span style=color:#75715e>    return &amp;x;
</span></span></span><span style=display:flex><span><span style=color:#75715e>}
</span></span></span></code></pre></div><p>:::</p></li></ul><h3 id=queue>Queue
<a class=anchor href=#queue>#</a></h3><ul><li><p>First In First Out
<img src=https://i.imgur.com/MmC6x23.png alt></p></li><li><p>Application</p><ul><li>在OS中的Job Scheduling的其中一種方式，誰先進入這個Queue，OS就先服務誰，但這個方式很不好，如果第一個Job的工作量很大，則後面其他Job的waiting time就會很長，所以另外一種方式是利用Priority Queue的方式</li></ul></li><li><p>Implementation
:::spoiler Abstract Data Type of Queue</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span>Template <span style=color:#f92672>&lt;</span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>KeyType</span><span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Queue</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#75715e>// objects: A finite ordered list with zero or more elements
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>        Queue(<span style=color:#66d9ef>int</span> MaxQueueSize <span style=color:#f92672>=</span> DefaultSize);
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Create an empty queue whose maximum size is MaxQueueSize
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        Boolean <span style=color:#a6e22e>IsFull</span>();
</span></span><span style=display:flex><span>        <span style=color:#75715e>// if number of elements in the queue is equal to the maximum size of
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// the queue, return TRUE(1); otherwise, return FALSE(0)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>Add</span>(<span style=color:#66d9ef>const</span> KeyType<span style=color:#f92672>&amp;</span> item);
</span></span><span style=display:flex><span>        <span style=color:#75715e>// if IsFull(), then QueueFull(); else insert item at rear of the queue
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        Boolean IsEmptyO;
</span></span><span style=display:flex><span>        l<span style=color:#f92672>/</span> <span style=color:#66d9ef>if</span> number of elements in the queue is equal to O, <span style=color:#66d9ef>return</span> TRUE(<span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>        l<span style=color:#f92672>/</span> <span style=color:#66d9ef>else</span> retur FALSE(<span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>        KeyType<span style=color:#f92672>*</span> Delete(KeyType<span style=color:#f92672>&amp;</span>);
</span></span><span style=display:flex><span>        <span style=color:#75715e>// if IsEmptyO, then QueueEmpty() and return O;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// else remove the item at the front of the queue and return a pointer to it
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><p>:::</p></li></ul></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><ul><li></li></ul></li><li><a href=#reference>Reference</a></li><li><a href=#rewind>Rewind</a><ul><li><a href=#string-matching-task>String Matching Task</a></li><li><a href=#kmp-algorithm>KMP Algorithm</a></li><li><a href=#原理>原理</a></li><li><a href=#implementation>Implementation</a></li><li><a href=#order>Order</a></li></ul></li><li><a href=#note>Note</a><ul><li><a href=#stack>Stack</a></li><li><a href=#queue>Queue</a></li></ul></li></ul></nav></div></aside></main></body></html>