<!doctype html><html lang=en-us dir=ltr><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="
  Lecture 10
  #


  tags: Data Structure NYCU
  #


  Reference
  #

Lec10 資料結構 第六週課程

  Rewind
  #


Stack / Queue也可以用link-list實作，所以兩者不能和array畫上等號，只能說兩者都是一種data structure，只是用不同方式implement而已
:::spoiler Implementation Example

:::
之前提到的多項式也可以用link-list實作，同樣也可以解決sparse的問題
:::spoiler Implementation Example

:::
Free pool的概念就是像glibc中那樣的回收場(Fast bin/Small bin/Large bin/Unsorted bin)


  Equivalence Relations
  #



A relation over a set, S, is said to be an equivalence relations over S iff it is symmetric, reflexive, and transitive over S.

reflexive, x=x
symmetric, if x=y, then y=x
transitive, if x=y and y=z, then x=z



Example"><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#343a40"><meta name=color-scheme content="light dark"><meta property="og:url" content="https://bernie6401.github.io/data-structure/lecture-10/"><meta property="og:site_name" content="SBK Hugo Site"><meta property="og:title" content="Lecture 10"><meta property="og:description" content="Lecture 10 # tags: Data Structure NYCU # Reference # Lec10 資料結構 第六週課程
Rewind # Stack / Queue也可以用link-list實作，所以兩者不能和array畫上等號，只能說兩者都是一種data structure，只是用不同方式implement而已 :::spoiler Implementation Example ::: 之前提到的多項式也可以用link-list實作，同樣也可以解決sparse的問題 :::spoiler Implementation Example ::: Free pool的概念就是像glibc中那樣的回收場(Fast bin/Small bin/Large bin/Unsorted bin) Equivalence Relations # A relation over a set, S, is said to be an equivalence relations over S iff it is symmetric, reflexive, and transitive over S.
reflexive, x=x symmetric, if x=y, then y=x transitive, if x=y and y=z, then x=z Example"><meta property="og:locale" content="en_us"><meta property="og:type" content="article"><meta property="article:section" content="data-structure"><meta property="article:tag" content="Data Structure"><meta property="article:tag" content="NYCU"><title>Lecture 10 | SBK Hugo Site</title>
<link rel=icon href=/favicon.png><link rel=manifest href=/manifest.json><link rel=canonical href=https://bernie6401.github.io/data-structure/lecture-10/><link rel=stylesheet href=/book.min.6c8b9d2a1fc95075ed7da46ca81060b39add8fff6741ac51259f768929281e2c.css integrity="sha256-bIudKh/JUHXtfaRsqBBgs5rdj/9nQaxRJZ92iSkoHiw=" crossorigin=anonymous><script defer src=/fuse.min.js></script><script defer src=/en.search.min.acdc41c8d39e6c69d70d8a23779875e0a3733fefead3e428d5344966bb12f562.js integrity="sha256-rNxByNOebGnXDYojd5h14KNzP+/q0+Qo1TRJZrsS9WI=" crossorigin=anonymous></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/><span>SBK Hugo Site</span></a></h2><div class="book-search hidden"><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><script>document.querySelector(".book-search").classList.remove("hidden")</script></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu></label><h3>Lecture 10</h3><label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><ul><li></li></ul></li><li><a href=#reference>Reference</a></li><li><a href=#rewind>Rewind</a><ul><li><a href=#equivalence-relations>Equivalence Relations</a></li></ul></li><li><a href=#note>Note</a></li></ul></nav></aside></header><article class="markdown book-article"><h1 id=lecture-10>Lecture 10
<a class=anchor href=#lecture-10>#</a></h1><h6 id=tags-data-structure-nycu>tags: <code>Data Structure</code> <code>NYCU</code>
<a class=anchor href=#tags-data-structure-nycu>#</a></h6><h2 id=reference>Reference
<a class=anchor href=#reference>#</a></h2><p><a href=https://youtu.be/zLuuRC56uvI>Lec10 資料結構 第六週課程</a></p><h2 id=rewind>Rewind
<a class=anchor href=#rewind>#</a></h2><ul><li>Stack / Queue也可以用link-list實作，所以兩者不能和array畫上等號，只能說兩者都是一種data structure，只是用不同方式implement而已
:::spoiler Implementation Example
<img src=https://hackmd.io/_uploads/HkkCaFyUn.png alt>
:::</li><li>之前提到的多項式也可以用link-list實作，同樣也可以解決sparse的問題
:::spoiler Implementation Example
<img src=https://hackmd.io/_uploads/r15haYyL2.png alt>
:::</li><li>Free pool的概念就是像glibc中那樣的回收場(Fast bin/Small bin/Large bin/Unsorted bin)</li></ul><h3 id=equivalence-relations>Equivalence Relations
<a class=anchor href=#equivalence-relations>#</a></h3><ul><li><p>A relation over a set, S, is said to be an equivalence relations over S iff it is symmetric, reflexive, and transitive over S.</p><ul><li>reflexive, x=x</li><li>symmetric, if x=y, then y=x</li><li>transitive, if x=y and y=z, then x=z</li></ul></li><li><p>Example</p><ul><li>Input: pairs of numbers
<code>0=4,3=1,6=10,8=9,7=4,6=8,3=5,2=11,11=0</code></li><li>Output: equivalent sets
three equivalent classes
{0, 2, 4, 7, 11};{1, 3, 5};{6, 8, 9, 10}</li></ul></li><li><p>How to implement?
<img src=https://hackmd.io/_uploads/BJMpI5yIn.png alt></p><ul><li>Phase 1: 先看過所有的組合然後用link-list的方式建一個表格，如上圖，就可以知道誰和誰有關係</li><li>Phase 2: 最後印出來，簡單來說就是從頭開始檢查，如果印出來後，專門儲存的array會把相對應的index設定成false，例如：0和11還有4有關係(print 0 and 11 and 4)，而11和0,2有關係(print 2 only)，接著2又和11有關係，此時因為11已經被設定成false，這樣的話就結束這個round，換下一個數值(4)繼續挖掘，4和7, 0有關係(print 7 only)而7又和4有關係，此時繞回來了，這樣就接著往下看, so on and so on until print all of the value or the final index.</li></ul><pre tabindex=0><code class="language-cpp=" data-lang="cpp=">void equivalence()
// Input the equivalence pairs and output the equivalence classes
{
    ifstream inFile(&#34;equiv.in&#34;, ios::in);    //&#34;equiv.in&#34; is the input file
    if(!inFile)
    {
        cerr &lt;&lt; &#34;Cannot open input file&#34; &lt;&lt; endl;
        return ;
    }
    int i, j, n;
    inFile &gt;&gt; n; // read number of objects

    // initialize seq and out
    ListNodePtr *seq = new ListNodePtr[n];
    Boolean *out = new Boolean[n];
    for (i=0; i&lt;n; i++)
    {
        seq[i] = 0;
        out[i] = False;
    }
}

// Phase 1: input equivalence pairs
inFile &gt;&gt; i &gt;&gt; j;
while(inFile.good())
{    // check end of file
    ListNode *x = new ListNode(j);
    x-&gt;link = seq[i];
    seq[i] = x; // add j to seq[i]
    ListNode *y = new ListNode(i);
    y-&gt;link = seq[j];
    seq[j] = y; // add j to seq[j]
    inFile &gt;&gt; i &gt;&gt; j;
}

// Phase 2: output equivalence classes
for (i=0; i&lt;n; i++)
{
    if (out[i] == False)
    {
        cout &lt;&lt; endl &lt;&lt; &#34;A new classes: &#34; &lt;&lt; i; // for example, i = 0, Output: 0
        out[i] = True;
        ListNode *x = seq[i];
        ListNode *top = o; // init stack
        while (1)
        {    // find rest of class
            while(x)
            {    // process the list
                j = x -&gt; data; // when i=0, j=11
                if (out[j] == False)
                {
                    cout &lt;&lt; &#34;, &#34; &lt;&lt; j;
                    out[j] = True;
                    ListNode *j = x-&gt;link; // when  i = 0 in the first round, y = 4
                    x-&gt;link = top;
                    top = x; // in stack, top point to node 11
                    x = y;
                }
                else x = x-&gt;link;
            } // end of while(x)
            if (!top) break;
            else
            {
                x = seq[top-&gt;data];
                top = top-&gt;link; //unstack
            }
        } // end of while(1)
    } // end of if(out[i] == False)
}
</code></pre></li></ul><h2 id=note>Note
<a class=anchor href=#note>#</a></h2><ul><li><p>Link-list也可以解決sparse matrix(用環狀的link-list)
<img src=https://hackmd.io/_uploads/H1BTViJUn.png alt>
每一個row / column都有自己的Link-list
<img src=https://hackmd.io/_uploads/rJELBjkI2.png alt></p><p>黃色的head node看起來有8個但其實只有四個，只是為了表示方便所以畫起來長這樣
<img src=https://hackmd.io/_uploads/r1UGHikL3.png alt></p></li><li><p>How to implement?</p><pre tabindex=0><code class="language-cpp=" data-lang="cpp=">enum Boolean {False, True};
struct Triple {int value, row, col;};
class Matrix; // forward declaration
class MatrixNode
{
    friend class Matrix;
    // for reading in a matrix
    friend istream&amp; operation &gt;&gt; (istream&amp;, Matrix&amp;);
    private:
        MatrixNode *down, *right;
        Boolean head;
        union
        {
            // anonymous union
            MatrixNode *next;
            Triple triple;
        };
    MatrixNode(Boolean, Triple *); // constrctor
};
MatrixNode::MatrixNode(Boolean b, Triple *t) // constructor
{
    head = b;
    if (b){right = next = down = this;} // row/column head node
    else triple = *t; // head node for list of headnodes OR element
    // node
}
typedef MatrixNode * MatrixNodePtr;
// to allow subsequent creation of array of pointers
</code></pre><pre tabindex=0><code class="language-cpp=" data-lang="cpp=">class Matrix
{
    friend istream&amp; operator &gt;&gt; (istream&amp;, Matrix&amp;);
    public:
        ~Matrix(); // destructor
    private:
        MatrixNode *headnode;
}
</code></pre></li></ul></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><ul><li></li></ul></li><li><a href=#reference>Reference</a></li><li><a href=#rewind>Rewind</a><ul><li><a href=#equivalence-relations>Equivalence Relations</a></li></ul></li><li><a href=#note>Note</a></li></ul></nav></div></aside></main></body></html>